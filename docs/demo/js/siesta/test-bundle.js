(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @module siesta
 */

var collection = require('./src/collection');
var util = require('./src/util');

var CollectionRegistry = require('./src/collectionRegistry').CollectionRegistry,
    Collection = collection.Collection,
    cache = require('./src/cache'),
    Mapping = require('./src/mapping').Mapping,
    notificationCentre = require('./src/notificationCentre').notificationCentre,
    Operation = require('./vendor/operations.js/src/operation').Operation,
    OperationQueue = require('./vendor/operations.js/src/queue').OperationQueue,
    RelationshipType = require('./src/relationship').RelationshipType,
    log = require('./vendor/operations.js/src/log'),
    q = require('q'),
    _ = util._;


Operation.logLevel = log.Level.warn;
OperationQueue.logLevel = log.Level.warn;


var siesta;
if (typeof module != 'undefined') {
    siesta = module.exports;
} else {
    siesta = {};
}

// siesta.save = function save(callback) {
//     var deferred = q.defer();
//     callback = util.constructCallbackAndPromiseHandler(callback, deferred);
//     if (siesta.ext.storageEnabled) {
//         util.next(function() {
//             var mergeChanges = siesta.ext.storage.changes.mergeChanges;
//             mergeChanges(callback);
//         });
//     } else {
//         callback('Storage module not installed');
//     }
//     return deferred.promise;
// };

/**
 * Wipe everything!
 */
siesta.reset = function() {
    cache.reset();
    CollectionRegistry.reset();
    siesta.ext.http.DescriptorRegistry.reset();
    //noinspection JSAccessibilityCheck
};


/**
 * Listen to notificatons.
 * @param {String} notificationName
 * @param {Function} handler
 */
siesta.on = _.bind(notificationCentre.on, notificationCentre);

/**
 * Listen to notificatons.
 * @param {String} notificationName
 * @param {Function} handler
 */
siesta.addListener = siesta.on;

/**
 * Stop listening to a particular notification
 * 
 * @param {String} notificationName
 * @param {Function} handler
 */
siesta.off = _.bind(notificationCentre.removeListener, notificationCentre);

/**
 * Stop listening to a particular notification
 * 
 * @param {String} notificationName
 * @param {Function} handler
 */
siesta.removeListener = siesta.off;

/**
 * Listen to one and only one notification.
 * 
 * @param {String} notificationName
 * @param {Function} handler
 */
siesta.once = _.bind(notificationCentre.once, notificationCentre);

/**
 * Removes all listeners.
 */
siesta.removeAllListeners = _.bind(notificationCentre.removeAllListeners, notificationCentre);

siesta.Collection = Collection;
siesta.RelationshipType = RelationshipType;

// Used by modules.
var coreChanges = require('./src/changes');

// Make available modules to extensions.
siesta._internal = {
    log: log,
    Mapping: Mapping,
    mapping: require('./src/mapping'),
    error: require('./src/error'),
    ChangeType: coreChanges.ChangeType,
    object: require('./src/object'),
    extend: require('extend'),
    notificationCentre: require('./src/notificationCentre'),
    cache: require('./src/cache'),
    misc: require('./src/misc'),
    Operation: Operation,
    OperationQueue: OperationQueue,
    coreChanges: coreChanges,
    CollectionRegistry: require('./src/collectionRegistry').CollectionRegistry,
    Collection: collection.Collection,
    collection: collection,
    utils: util,
    util: util,
    _: util._,
    query: require('./src/query'),
    store: require('./src/store'),
    q: require('q')
};

siesta.performanceMonitoringEnabled = false;
siesta.httpEnabled = false;
siesta.storageEnabled = false;

siesta.ext = {};

// Object.defineProperty(siesta, 'setPouch', {
//     get: function() {
//         if (siesta.ext.storageEnabled) {
//             return siesta.ext.storage.pouch.setPouch;
//         }
//         return null;
//     }
// });

// Object.defineProperty(siesta.ext, 'storageEnabled', {
//     get: function() {
//         if (siesta.ext._storageEnabled !== undefined) {
//             return siesta.ext._storageEnabled;
//         }
//         return !!siesta.ext.storage;
//     },
//     set: function(v) {
//         siesta.ext._storageEnabled = v;
//     }
// });

/**
 * True if siesta.http.js is installed correctly (or siesta.bundle.js is being used instead).
 */
Object.defineProperty(siesta.ext, 'httpEnabled', {
    get: function() {
        if (siesta.ext._httpEnabled !== undefined) {
            return siesta.ext._httpEnabled;
        }
        return !!siesta.ext.http;
    },
    set: function(v) {
        siesta.ext._httpEnabled = v;
    }
});

/**
 * Creates and registers a new Collection.
 * @param  {[type]} name
 * @param  {[type]} opts
 * @return {Collection}
 */
siesta.collection = function(name, opts) {
    return new Collection(name, opts);
};

/**
 * Sets the ajax function to use e.g. $.ajax
 * @param {Function} ajax
 * @example
 * // Use zepto instead of jQuery for http ajax requests.
 * siesta.setAjax(zepto.ajax);
 */
siesta.setAjax = function(ajax) {
    if (siesta.ext.httpEnabled) {
        siesta.ext.http.ajax = ajax;
    } else {
        throw new Error('http module not installed correctly (have you included siesta.http.js?)');
    }
};

/**
 * Returns the ajax function being used.
 * @return {Function}
 */
siesta.getAjax = function() {
    return siesta.ext.http.ajax;
};

siesta.notify = util.next;

/**
 * Returns an object whos keys map onto string constants used for log levels.
 * @type {Object}
 */
siesta.LogLevel = log.Level;

/**
 * Sets the log level for the named logger
 * @param {String} loggerName
 * @param {String} level
 *
 * @example
 * // Logger used by HTTP request/response descriptors.
 * siesta.setLogLevel('Descriptor', siesta.LogLevel.trace);
 * // Logger used by request descriptors specifically.
 * siesta.setLogLevel('RequestDescriptor', siesta.LogLevel.trace);
 * // Logger used by response descriptors specifically.
 * siesta.setLogLevel('ResponseDescriptor', siesta.LogLevel.trace);
 * // All descriptors are registered in the DescriptorRegistry.
 * siesta.setLogLevel('DescriptorRegistry', siesta.LogLevel.trace);
 * // Logger used by HTTP requests/responses.
 * siesta.setLogLevel('HTTP', siesta.LogLevel.trace);
 * // Objects are cached by local id (_id) or their remote id. This logger is used by the local object cache.
 * siesta.setLogLevel('LocalCache', siesta.LogLevel.trace);
 * // Objects are cached by local id (_id) or their remote id. This logger is used by the remote object cache.
 * siesta.setLogLevel('RemoteCache', siesta.LogLevel.trace);
 * // The logger used by change notifications.
 * siesta.setLogLevel('changes', siesta.LogLevel.trace);
 * // The logger used by the Collection class, which is used to describe a set of mappings.
 * siesta.setLogLevel('Collection', siesta.LogLevel.trace);
 * // The logger used by the Mapping class.
 * siesta.setLogLevel('Mapping', siesta.LogLevel.trace);
 * // The logger used during mapping operations, i.e. mapping data onto the object graph.
 * siesta.setLogLevel('MappingOperation', siesta.LogLevel.trace);
 * // The logger used by the SiestaModel class, which makes up the individual nodes of the object graph.
 * siesta.setLogLevel('SiestaModel', siesta.LogLevel.trace);
 * // The logger used by the performance monitoring extension (siesta.perf.js)
 * siesta.setLogLevel('Performance', siesta.LogLevel.trace);
 * // The logger used during local queries against the object graph.
 * siesta.setLogLevel('Query', siesta.LogLevel.trace);
 * siesta.setLogLevel('Store', siesta.LogLevel.trace);
 * // Much logic in Siesta is tied up in 'Operations'.
 * siesta.setLogLevel('Operation', siesta.LogLevel.trace);
 * // Siesta makes use of queues of operations for managing concurrency and concurrent operation limits.
 * siesta.setLogLevel('OperationQueue', siesta.LogLevel.trace);
 */
siesta.setLogLevel = function(loggerName, level) {
    var Logger = log.loggerWithName(loggerName);
    Logger.setLevel(level);
};



siesta.serialisers = {};
siesta.serializers = siesta.serialisers;

Object.defineProperty(siesta.serialisers, 'id', {
    get: function() {
        if (siesta.ext.httpEnabled) {
            return siesta.ext.http.Serialiser.idSerialiser;
        }
        return null;
    }
});

Object.defineProperty(siesta.serialisers, 'depth', {
    get: function() {
        if (siesta.ext.httpEnabled) {
            return siesta.ext.http.Serialiser.depthSerializer;
        }
        return null;
    }
});

// * `siesta.map` is equivalent to [_.map](http://underscorejs.org/#map)
// * `siesta.each` is equivalent to [_.each](http://underscorejs.org/#each)
// * `siesta.partial` is equivalent to [_.partial](http://underscorejs.org/#partial)
// * `siesta.bind` is equivalent to [_.bind](http://underscorejs.org/#bind)
// * `siesta.pluck` is equivalent to [_.pluck](http://underscorejs.org/#pluck)
// * `siesta.property` is equivalent to [_.property](http://underscorejs.org/#property)
// * `siesta.sortBy` is equivalent to [_.sortBy](http://underscorejs.org/#sortBy)
// * `siesta.parallel` is equivalent to [async.parallel](https://github.com/caolan/async#parallel)
// * `siesta.series` is equivalent to [async.series](https://github.com/caolan/async#series)
// * `siesta.q` is the entire [q promises library](https://github.com/kriskowal/q)

siesta.map = util._.map;
siesta.each = util._.each;
siesta.partial = util._.partial;
siesta.bind = util._.bind;
siesta.pluck = util._.pluck;
siesta.property = util._.pluck;
siesta.sortBy = util._.sortBy;
siesta.series = util.series;
siesta.parallel = util.parallel;
siesta.q = q;

// Object.defineProperty(siesta, 'isDirty', {
//     get: function() {
//         return Collection.isDirty
//     },
//     configurable: true,
//     enumerable: true
// });

if (typeof window != 'undefined') {
    window.siesta = siesta;
}

exports.siesta = siesta;
},{"./src/cache":43,"./src/changes":44,"./src/collection":45,"./src/collectionRegistry":46,"./src/error":47,"./src/mapping":49,"./src/misc":51,"./src/notificationCentre":52,"./src/object":53,"./src/query":57,"./src/relationship":58,"./src/store":59,"./src/util":60,"./vendor/operations.js/src/log":107,"./vendor/operations.js/src/operation":108,"./vendor/operations.js/src/queue":109,"extend":41,"q":42}],2:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":8}],3:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":4,"ieee754":5,"is-array":6}],4:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],5:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],6:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],9:[function(require,module,exports){
module.exports = require('./lib/chai');

},{"./lib/chai":10}],10:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var used = []
  , exports = module.exports = {};

/*!
 * Chai version
 */

exports.version = '1.9.2';

/*!
 * Assertion Error
 */

exports.AssertionError = require('assertion-error');

/*!
 * Utils for plugins (not exported)
 */

var util = require('./chai/utils');

/**
 * # .use(function)
 *
 * Provides a way to extend the internals of Chai
 *
 * @param {Function}
 * @returns {this} for chaining
 * @api public
 */

exports.use = function (fn) {
  if (!~used.indexOf(fn)) {
    fn(this, util);
    used.push(fn);
  }

  return this;
};

/*!
 * Configuration
 */

var config = require('./chai/config');
exports.config = config;

/*!
 * Primary `Assertion` prototype
 */

var assertion = require('./chai/assertion');
exports.use(assertion);

/*!
 * Core Assertions
 */

var core = require('./chai/core/assertions');
exports.use(core);

/*!
 * Expect interface
 */

var expect = require('./chai/interface/expect');
exports.use(expect);

/*!
 * Should interface
 */

var should = require('./chai/interface/should');
exports.use(should);

/*!
 * Assert interface
 */

var assert = require('./chai/interface/assert');
exports.use(assert);

},{"./chai/assertion":11,"./chai/config":12,"./chai/core/assertions":13,"./chai/interface/assert":14,"./chai/interface/expect":15,"./chai/interface/should":16,"./chai/utils":27,"assertion-error":36}],11:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('./config');

module.exports = function (_chai, util) {
  /*!
   * Module dependencies.
   */

  var AssertionError = _chai.AssertionError
    , flag = util.flag;

  /*!
   * Module export.
   */

  _chai.Assertion = Assertion;

  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * @api private
   */

  function Assertion (obj, msg, stack) {
    flag(this, 'ssfi', stack || arguments.callee);
    flag(this, 'object', obj);
    flag(this, 'message', msg);
  }

  Object.defineProperty(Assertion, 'includeStack', {
    get: function() {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      return config.includeStack;
    },
    set: function(value) {
      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');
      config.includeStack = value;
    }
  });

  Object.defineProperty(Assertion, 'showDiff', {
    get: function() {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      return config.showDiff;
    },
    set: function(value) {
      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');
      config.showDiff = value;
    }
  });

  Assertion.addProperty = function (name, fn) {
    util.addProperty(this.prototype, name, fn);
  };

  Assertion.addMethod = function (name, fn) {
    util.addMethod(this.prototype, name, fn);
  };

  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {
    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  Assertion.overwriteProperty = function (name, fn) {
    util.overwriteProperty(this.prototype, name, fn);
  };

  Assertion.overwriteMethod = function (name, fn) {
    util.overwriteMethod(this.prototype, name, fn);
  };

  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {
    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);
  };

  /*!
   * ### .assert(expression, message, negateMessage, expected, actual)
   *
   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.
   *
   * @name assert
   * @param {Philosophical} expression to be tested
   * @param {String or Function} message or function that returns message to display if fails
   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails
   * @param {Mixed} expected value (remember to check for negation)
   * @param {Mixed} actual (optional) will default to `this.obj`
   * @api private
   */

  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {
    var ok = util.test(this, arguments);
    if (true !== showDiff) showDiff = false;
    if (true !== config.showDiff) showDiff = false;

    if (!ok) {
      var msg = util.getMessage(this, arguments)
        , actual = util.getActual(this, arguments);
      throw new AssertionError(msg, {
          actual: actual
        , expected: expected
        , showDiff: showDiff
      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));
    }
  };

  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */

  Object.defineProperty(Assertion.prototype, '_obj',
    { get: function () {
        return flag(this, 'object');
      }
    , set: function (val) {
        flag(this, 'object', val);
      }
  });
};

},{"./config":12}],12:[function(require,module,exports){
module.exports = {

  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */

   includeStack: false,

  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */

  showDiff: true,

  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded,
   * the value is truncated.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */

  truncateThreshold: 40

};

},{}],13:[function(require,module,exports){
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, _) {
  var Assertion = chai.Assertion
    , toString = Object.prototype.toString
    , flag = _.flag;

  /**
   * ### Language Chains
   *
   * The following are provided as chainable getters to
   * improve the readability of your assertions. They
   * do not provide testing capabilities unless they
   * have been overwritten by a plugin.
   *
   * **Chains**
   *
   * - to
   * - be
   * - been
   * - is
   * - that
   * - and
   * - has
   * - have
   * - with
   * - at
   * - of
   * - same
   *
   * @name language chains
   * @api public
   */

  [ 'to', 'be', 'been'
  , 'is', 'and', 'has', 'have'
  , 'with', 'that', 'at'
  , 'of', 'same' ].forEach(function (chain) {
    Assertion.addProperty(chain, function () {
      return this;
    });
  });

  /**
   * ### .not
   *
   * Negates any of assertions following in the chain.
   *
   *     expect(foo).to.not.equal('bar');
   *     expect(goodFn).to.not.throw(Error);
   *     expect({ foo: 'baz' }).to.have.property('foo')
   *       .and.not.equal('bar');
   *
   * @name not
   * @api public
   */

  Assertion.addProperty('not', function () {
    flag(this, 'negate', true);
  });

  /**
   * ### .deep
   *
   * Sets the `deep` flag, later used by the `equal` and
   * `property` assertions.
   *
   *     expect(foo).to.deep.equal({ bar: 'baz' });
   *     expect({ foo: { bar: { baz: 'quux' } } })
   *       .to.have.deep.property('foo.bar.baz', 'quux');
   *
   * @name deep
   * @api public
   */

  Assertion.addProperty('deep', function () {
    flag(this, 'deep', true);
  });

  /**
   * ### .a(type)
   *
   * The `a` and `an` assertions are aliases that can be
   * used either as language chains or to assert a value's
   * type.
   *
   *     // typeof
   *     expect('test').to.be.a('string');
   *     expect({ foo: 'bar' }).to.be.an('object');
   *     expect(null).to.be.a('null');
   *     expect(undefined).to.be.an('undefined');
   *
   *     // language chain
   *     expect(foo).to.be.an.instanceof(Foo);
   *
   * @name a
   * @alias an
   * @param {String} type
   * @param {String} message _optional_
   * @api public
   */

  function an (type, msg) {
    if (msg) flag(this, 'message', msg);
    type = type.toLowerCase();
    var obj = flag(this, 'object')
      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';

    this.assert(
        type === _.type(obj)
      , 'expected #{this} to be ' + article + type
      , 'expected #{this} not to be ' + article + type
    );
  }

  Assertion.addChainableMethod('an', an);
  Assertion.addChainableMethod('a', an);

  /**
   * ### .include(value)
   *
   * The `include` and `contain` assertions can be used as either property
   * based language chains or as methods to assert the inclusion of an object
   * in an array or a substring in a string. When used as language chains,
   * they toggle the `contain` flag for the `keys` assertion.
   *
   *     expect([1,2,3]).to.include(2);
   *     expect('foobar').to.contain('foo');
   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');
   *
   * @name include
   * @alias contain
   * @param {Object|String|Number} obj
   * @param {String} message _optional_
   * @api public
   */

  function includeChainingBehavior () {
    flag(this, 'contains', true);
  }

  function include (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var expected = false;
    if (_.type(obj) === 'array' && _.type(val) === 'object') {
      for (var i in obj) {
        if (_.eql(obj[i], val)) {
          expected = true;
          break;
        }
      }
    } else if (_.type(val) === 'object') {
      if (!flag(this, 'negate')) {
        for (var k in val) new Assertion(obj).property(k, val[k]);
        return;
      }
      var subset = {}
      for (var k in val) subset[k] = obj[k]
      expected = _.eql(subset, val);
    } else {
      expected = obj && ~obj.indexOf(val)
    }
    this.assert(
        expected
      , 'expected #{this} to include ' + _.inspect(val)
      , 'expected #{this} to not include ' + _.inspect(val));
  }

  Assertion.addChainableMethod('include', include, includeChainingBehavior);
  Assertion.addChainableMethod('contain', include, includeChainingBehavior);

  /**
   * ### .ok
   *
   * Asserts that the target is truthy.
   *
   *     expect('everthing').to.be.ok;
   *     expect(1).to.be.ok;
   *     expect(false).to.not.be.ok;
   *     expect(undefined).to.not.be.ok;
   *     expect(null).to.not.be.ok;
   *
   * @name ok
   * @api public
   */

  Assertion.addProperty('ok', function () {
    this.assert(
        flag(this, 'object')
      , 'expected #{this} to be truthy'
      , 'expected #{this} to be falsy');
  });

  /**
   * ### .true
   *
   * Asserts that the target is `true`.
   *
   *     expect(true).to.be.true;
   *     expect(1).to.not.be.true;
   *
   * @name true
   * @api public
   */

  Assertion.addProperty('true', function () {
    this.assert(
        true === flag(this, 'object')
      , 'expected #{this} to be true'
      , 'expected #{this} to be false'
      , this.negate ? false : true
    );
  });

  /**
   * ### .false
   *
   * Asserts that the target is `false`.
   *
   *     expect(false).to.be.false;
   *     expect(0).to.not.be.false;
   *
   * @name false
   * @api public
   */

  Assertion.addProperty('false', function () {
    this.assert(
        false === flag(this, 'object')
      , 'expected #{this} to be false'
      , 'expected #{this} to be true'
      , this.negate ? true : false
    );
  });

  /**
   * ### .null
   *
   * Asserts that the target is `null`.
   *
   *     expect(null).to.be.null;
   *     expect(undefined).not.to.be.null;
   *
   * @name null
   * @api public
   */

  Assertion.addProperty('null', function () {
    this.assert(
        null === flag(this, 'object')
      , 'expected #{this} to be null'
      , 'expected #{this} not to be null'
    );
  });

  /**
   * ### .undefined
   *
   * Asserts that the target is `undefined`.
   *
   *     expect(undefined).to.be.undefined;
   *     expect(null).to.not.be.undefined;
   *
   * @name undefined
   * @api public
   */

  Assertion.addProperty('undefined', function () {
    this.assert(
        undefined === flag(this, 'object')
      , 'expected #{this} to be undefined'
      , 'expected #{this} not to be undefined'
    );
  });

  /**
   * ### .exist
   *
   * Asserts that the target is neither `null` nor `undefined`.
   *
   *     var foo = 'hi'
   *       , bar = null
   *       , baz;
   *
   *     expect(foo).to.exist;
   *     expect(bar).to.not.exist;
   *     expect(baz).to.not.exist;
   *
   * @name exist
   * @api public
   */

  Assertion.addProperty('exist', function () {
    this.assert(
        null != flag(this, 'object')
      , 'expected #{this} to exist'
      , 'expected #{this} to not exist'
    );
  });


  /**
   * ### .empty
   *
   * Asserts that the target's length is `0`. For arrays, it checks
   * the `length` property. For objects, it gets the count of
   * enumerable keys.
   *
   *     expect([]).to.be.empty;
   *     expect('').to.be.empty;
   *     expect({}).to.be.empty;
   *
   * @name empty
   * @api public
   */

  Assertion.addProperty('empty', function () {
    var obj = flag(this, 'object')
      , expected = obj;

    if (Array.isArray(obj) || 'string' === typeof object) {
      expected = obj.length;
    } else if (typeof obj === 'object') {
      expected = Object.keys(obj).length;
    }

    this.assert(
        !expected
      , 'expected #{this} to be empty'
      , 'expected #{this} not to be empty'
    );
  });

  /**
   * ### .arguments
   *
   * Asserts that the target is an arguments object.
   *
   *     function test () {
   *       expect(arguments).to.be.arguments;
   *     }
   *
   * @name arguments
   * @alias Arguments
   * @api public
   */

  function checkArguments () {
    var obj = flag(this, 'object')
      , type = Object.prototype.toString.call(obj);
    this.assert(
        '[object Arguments]' === type
      , 'expected #{this} to be arguments but got ' + type
      , 'expected #{this} to not be arguments'
    );
  }

  Assertion.addProperty('arguments', checkArguments);
  Assertion.addProperty('Arguments', checkArguments);

  /**
   * ### .equal(value)
   *
   * Asserts that the target is strictly equal (`===`) to `value`.
   * Alternately, if the `deep` flag is set, asserts that
   * the target is deeply equal to `value`.
   *
   *     expect('hello').to.equal('hello');
   *     expect(42).to.equal(42);
   *     expect(1).to.not.equal(true);
   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });
   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
   *
   * @name equal
   * @alias equals
   * @alias eq
   * @alias deep.equal
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEqual (val, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'deep')) {
      return this.eql(val);
    } else {
      this.assert(
          val === obj
        , 'expected #{this} to equal #{exp}'
        , 'expected #{this} to not equal #{exp}'
        , val
        , this._obj
        , true
      );
    }
  }

  Assertion.addMethod('equal', assertEqual);
  Assertion.addMethod('equals', assertEqual);
  Assertion.addMethod('eq', assertEqual);

  /**
   * ### .eql(value)
   *
   * Asserts that the target is deeply equal to `value`.
   *
   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });
   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);
   *
   * @name eql
   * @alias eqls
   * @param {Mixed} value
   * @param {String} message _optional_
   * @api public
   */

  function assertEql(obj, msg) {
    if (msg) flag(this, 'message', msg);
    this.assert(
        _.eql(obj, flag(this, 'object'))
      , 'expected #{this} to deeply equal #{exp}'
      , 'expected #{this} to not deeply equal #{exp}'
      , obj
      , this._obj
      , true
    );
  }

  Assertion.addMethod('eql', assertEql);
  Assertion.addMethod('eqls', assertEql);

  /**
   * ### .above(value)
   *
   * Asserts that the target is greater than `value`.
   *
   *     expect(10).to.be.above(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *
   * @name above
   * @alias gt
   * @alias greaterThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertAbove (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len > n
        , 'expected #{this} to have a length above #{exp} but got #{act}'
        , 'expected #{this} to not have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj > n
        , 'expected #{this} to be above ' + n
        , 'expected #{this} to be at most ' + n
      );
    }
  }

  Assertion.addMethod('above', assertAbove);
  Assertion.addMethod('gt', assertAbove);
  Assertion.addMethod('greaterThan', assertAbove);

  /**
   * ### .least(value)
   *
   * Asserts that the target is greater than or equal to `value`.
   *
   *     expect(10).to.be.at.least(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a minimum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.least(2);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);
   *
   * @name least
   * @alias gte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertLeast (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= n
        , 'expected #{this} to have a length at least #{exp} but got #{act}'
        , 'expected #{this} to have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj >= n
        , 'expected #{this} to be at least ' + n
        , 'expected #{this} to be below ' + n
      );
    }
  }

  Assertion.addMethod('least', assertLeast);
  Assertion.addMethod('gte', assertLeast);

  /**
   * ### .below(value)
   *
   * Asserts that the target is less than `value`.
   *
   *     expect(5).to.be.below(10);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *
   * @name below
   * @alias lt
   * @alias lessThan
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertBelow (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len < n
        , 'expected #{this} to have a length below #{exp} but got #{act}'
        , 'expected #{this} to not have a length below #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj < n
        , 'expected #{this} to be below ' + n
        , 'expected #{this} to be at least ' + n
      );
    }
  }

  Assertion.addMethod('below', assertBelow);
  Assertion.addMethod('lt', assertBelow);
  Assertion.addMethod('lessThan', assertBelow);

  /**
   * ### .most(value)
   *
   * Asserts that the target is less than or equal to `value`.
   *
   *     expect(5).to.be.at.most(5);
   *
   * Can also be used in conjunction with `length` to
   * assert a maximum length. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.of.at.most(4);
   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);
   *
   * @name most
   * @alias lte
   * @param {Number} value
   * @param {String} message _optional_
   * @api public
   */

  function assertMost (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len <= n
        , 'expected #{this} to have a length at most #{exp} but got #{act}'
        , 'expected #{this} to have a length above #{exp}'
        , n
        , len
      );
    } else {
      this.assert(
          obj <= n
        , 'expected #{this} to be at most ' + n
        , 'expected #{this} to be above ' + n
      );
    }
  }

  Assertion.addMethod('most', assertMost);
  Assertion.addMethod('lte', assertMost);

  /**
   * ### .within(start, finish)
   *
   * Asserts that the target is within a range.
   *
   *     expect(7).to.be.within(5,10);
   *
   * Can also be used in conjunction with `length` to
   * assert a length range. The benefit being a
   * more informative error message than if the length
   * was supplied directly.
   *
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name within
   * @param {Number} start lowerbound inclusive
   * @param {Number} finish upperbound inclusive
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('within', function (start, finish, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , range = start + '..' + finish;
    if (flag(this, 'doLength')) {
      new Assertion(obj, msg).to.have.property('length');
      var len = obj.length;
      this.assert(
          len >= start && len <= finish
        , 'expected #{this} to have a length within ' + range
        , 'expected #{this} to not have a length within ' + range
      );
    } else {
      this.assert(
          obj >= start && obj <= finish
        , 'expected #{this} to be within ' + range
        , 'expected #{this} to not be within ' + range
      );
    }
  });

  /**
   * ### .instanceof(constructor)
   *
   * Asserts that the target is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , Chai = new Tea('chai');
   *
   *     expect(Chai).to.be.an.instanceof(Tea);
   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);
   *
   * @name instanceof
   * @param {Constructor} constructor
   * @param {String} message _optional_
   * @alias instanceOf
   * @api public
   */

  function assertInstanceOf (constructor, msg) {
    if (msg) flag(this, 'message', msg);
    var name = _.getName(constructor);
    this.assert(
        flag(this, 'object') instanceof constructor
      , 'expected #{this} to be an instance of ' + name
      , 'expected #{this} to not be an instance of ' + name
    );
  };

  Assertion.addMethod('instanceof', assertInstanceOf);
  Assertion.addMethod('instanceOf', assertInstanceOf);

  /**
   * ### .property(name, [value])
   *
   * Asserts that the target has a property `name`, optionally asserting that
   * the value of that property is strictly equal to  `value`.
   * If the `deep` flag is set, you can use dot- and bracket-notation for deep
   * references into objects and arrays.
   *
   *     // simple referencing
   *     var obj = { foo: 'bar' };
   *     expect(obj).to.have.property('foo');
   *     expect(obj).to.have.property('foo', 'bar');
   *
   *     // deep referencing
   *     var deepObj = {
   *         green: { tea: 'matcha' }
   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]
   *     };

   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');
   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');
   *
   * You can also use an array as the starting point of a `deep.property`
   * assertion, or traverse nested arrays.
   *
   *     var arr = [
   *         [ 'chai', 'matcha', 'konacha' ]
   *       , [ { tea: 'chai' }
   *         , { tea: 'matcha' }
   *         , { tea: 'konacha' } ]
   *     ];
   *
   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');
   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');
   *
   * Furthermore, `property` changes the subject of the assertion
   * to be the value of that property from the original object. This
   * permits for further chainable assertions on that property.
   *
   *     expect(obj).to.have.property('foo')
   *       .that.is.a('string');
   *     expect(deepObj).to.have.property('green')
   *       .that.is.an('object')
   *       .that.deep.equals({ tea: 'matcha' });
   *     expect(deepObj).to.have.property('teas')
   *       .that.is.an('array')
   *       .with.deep.property('[2]')
   *         .that.deep.equals({ tea: 'konacha' });
   *
   * @name property
   * @alias deep.property
   * @param {String} name
   * @param {Mixed} value (optional)
   * @param {String} message _optional_
   * @returns value of property for chaining
   * @api public
   */

  Assertion.addMethod('property', function (name, val, msg) {
    if (msg) flag(this, 'message', msg);

    var descriptor = flag(this, 'deep') ? 'deep property ' : 'property '
      , negate = flag(this, 'negate')
      , obj = flag(this, 'object')
      , value = flag(this, 'deep')
        ? _.getPathValue(name, obj)
        : obj[name];

    if (negate && undefined !== val) {
      if (undefined === value) {
        msg = (msg != null) ? msg + ': ' : '';
        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));
      }
    } else {
      this.assert(
          undefined !== value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name)
        , 'expected #{this} to not have ' + descriptor + _.inspect(name));
    }

    if (undefined !== val) {
      this.assert(
          val === value
        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'
        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'
        , val
        , value
      );
    }

    flag(this, 'object', value);
  });


  /**
   * ### .ownProperty(name)
   *
   * Asserts that the target has an own property `name`.
   *
   *     expect('test').to.have.ownProperty('length');
   *
   * @name ownProperty
   * @alias haveOwnProperty
   * @param {String} name
   * @param {String} message _optional_
   * @api public
   */

  function assertOwnProperty (name, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        obj.hasOwnProperty(name)
      , 'expected #{this} to have own property ' + _.inspect(name)
      , 'expected #{this} to not have own property ' + _.inspect(name)
    );
  }

  Assertion.addMethod('ownProperty', assertOwnProperty);
  Assertion.addMethod('haveOwnProperty', assertOwnProperty);

  /**
   * ### .length(value)
   *
   * Asserts that the target's `length` property has
   * the expected value.
   *
   *     expect([ 1, 2, 3]).to.have.length(3);
   *     expect('foobar').to.have.length(6);
   *
   * Can also be used as a chain precursor to a value
   * comparison for the length property.
   *
   *     expect('foo').to.have.length.above(2);
   *     expect([ 1, 2, 3 ]).to.have.length.above(2);
   *     expect('foo').to.have.length.below(4);
   *     expect([ 1, 2, 3 ]).to.have.length.below(4);
   *     expect('foo').to.have.length.within(2,4);
   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);
   *
   * @name length
   * @alias lengthOf
   * @param {Number} length
   * @param {String} message _optional_
   * @api public
   */

  function assertLengthChain () {
    flag(this, 'doLength', true);
  }

  function assertLength (n, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).to.have.property('length');
    var len = obj.length;

    this.assert(
        len == n
      , 'expected #{this} to have a length of #{exp} but got #{act}'
      , 'expected #{this} to not have a length of #{act}'
      , n
      , len
    );
  }

  Assertion.addChainableMethod('length', assertLength, assertLengthChain);
  Assertion.addMethod('lengthOf', assertLength);

  /**
   * ### .match(regexp)
   *
   * Asserts that the target matches a regular expression.
   *
   *     expect('foobar').to.match(/^foo/);
   *
   * @name match
   * @param {RegExp} RegularExpression
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('match', function (re, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    this.assert(
        re.exec(obj)
      , 'expected #{this} to match ' + re
      , 'expected #{this} not to match ' + re
    );
  });

  /**
   * ### .string(string)
   *
   * Asserts that the string target contains another string.
   *
   *     expect('foobar').to.have.string('bar');
   *
   * @name string
   * @param {String} string
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('string', function (str, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('string');

    this.assert(
        ~obj.indexOf(str)
      , 'expected #{this} to contain ' + _.inspect(str)
      , 'expected #{this} to not contain ' + _.inspect(str)
    );
  });


  /**
   * ### .keys(key1, [key2], [...])
   *
   * Asserts that the target has exactly the given keys, or
   * asserts the inclusion of some keys when using the
   * `include` or `contain` modifiers.
   *
   *     expect({ foo: 1, bar: 2 }).to.have.keys(['foo', 'bar']);
   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.keys('foo', 'bar');
   *
   * @name keys
   * @alias key
   * @param {String...|Array} keys
   * @api public
   */

  function assertKeys (keys) {
    var obj = flag(this, 'object')
      , str
      , ok = true;

    keys = keys instanceof Array
      ? keys
      : Array.prototype.slice.call(arguments);

    if (!keys.length) throw new Error('keys required');

    var actual = Object.keys(obj)
      , expected = keys
      , len = keys.length;

    // Inclusion
    ok = keys.every(function(key){
      return ~actual.indexOf(key);
    });

    // Strict
    if (!flag(this, 'negate') && !flag(this, 'contains')) {
      ok = ok && keys.length == actual.length;
    }

    // Key string
    if (len > 1) {
      keys = keys.map(function(key){
        return _.inspect(key);
      });
      var last = keys.pop();
      str = keys.join(', ') + ', and ' + last;
    } else {
      str = _.inspect(keys[0]);
    }

    // Form
    str = (len > 1 ? 'keys ' : 'key ') + str;

    // Have / include
    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;

    // Assertion
    this.assert(
        ok
      , 'expected #{this} to ' + str
      , 'expected #{this} to not ' + str
      , expected.sort()
      , actual.sort()
      , true
    );
  }

  Assertion.addMethod('keys', assertKeys);
  Assertion.addMethod('key', assertKeys);

  /**
   * ### .throw(constructor)
   *
   * Asserts that the function target will throw a specific error, or specific type of error
   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test
   * for the error's message.
   *
   *     var err = new ReferenceError('This is a bad function.');
   *     var fn = function () { throw err; }
   *     expect(fn).to.throw(ReferenceError);
   *     expect(fn).to.throw(Error);
   *     expect(fn).to.throw(/bad function/);
   *     expect(fn).to.not.throw('good function');
   *     expect(fn).to.throw(ReferenceError, /bad function/);
   *     expect(fn).to.throw(err);
   *     expect(fn).to.not.throw(new RangeError('Out of range.'));
   *
   * Please note that when a throw expectation is negated, it will check each
   * parameter independently, starting with error constructor type. The appropriate way
   * to check for the existence of a type of error but for a message that does not match
   * is to use `and`.
   *
   *     expect(fn).to.throw(ReferenceError)
   *        .and.not.throw(/good function/);
   *
   * @name throw
   * @alias throws
   * @alias Throw
   * @param {ErrorConstructor} constructor
   * @param {String|RegExp} expected error message
   * @param {String} message _optional_
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @returns error for chaining (null if no error)
   * @api public
   */

  function assertThrows (constructor, errMsg, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    new Assertion(obj, msg).is.a('function');

    var thrown = false
      , desiredError = null
      , name = null
      , thrownError = null;

    if (arguments.length === 0) {
      errMsg = null;
      constructor = null;
    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {
      errMsg = constructor;
      constructor = null;
    } else if (constructor && constructor instanceof Error) {
      desiredError = constructor;
      constructor = null;
      errMsg = null;
    } else if (typeof constructor === 'function') {
      name = constructor.prototype.name || constructor.name;
      if (name === 'Error' && constructor !== Error) {
        name = (new constructor()).name;
      }
    } else {
      constructor = null;
    }

    try {
      obj();
    } catch (err) {
      // first, check desired error
      if (desiredError) {
        this.assert(
            err === desiredError
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp}'
          , (desiredError instanceof Error ? desiredError.toString() : desiredError)
          , (err instanceof Error ? err.toString() : err)
        );

        flag(this, 'object', err);
        return this;
      }

      // next, check constructor
      if (constructor) {
        this.assert(
            err instanceof constructor
          , 'expected #{this} to throw #{exp} but #{act} was thrown'
          , 'expected #{this} to not throw #{exp} but #{act} was thrown'
          , name
          , (err instanceof Error ? err.toString() : err)
        );

        if (!errMsg) {
          flag(this, 'object', err);
          return this;
        }
      }

      // next, check message
      var message = 'object' === _.type(err) && "message" in err
        ? err.message
        : '' + err;

      if ((message != null) && errMsg && errMsg instanceof RegExp) {
        this.assert(
            errMsg.exec(message)
          , 'expected #{this} to throw error matching #{exp} but got #{act}'
          , 'expected #{this} to throw error not matching #{exp}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {
        this.assert(
            ~message.indexOf(errMsg)
          , 'expected #{this} to throw error including #{exp} but got #{act}'
          , 'expected #{this} to throw error not including #{act}'
          , errMsg
          , message
        );

        flag(this, 'object', err);
        return this;
      } else {
        thrown = true;
        thrownError = err;
      }
    }

    var actuallyGot = ''
      , expectedThrown = name !== null
        ? name
        : desiredError
          ? '#{exp}' //_.inspect(desiredError)
          : 'an error';

    if (thrown) {
      actuallyGot = ' but #{act} was thrown'
    }

    this.assert(
        thrown === true
      , 'expected #{this} to throw ' + expectedThrown + actuallyGot
      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot
      , (desiredError instanceof Error ? desiredError.toString() : desiredError)
      , (thrownError instanceof Error ? thrownError.toString() : thrownError)
    );

    flag(this, 'object', thrownError);
  };

  Assertion.addMethod('throw', assertThrows);
  Assertion.addMethod('throws', assertThrows);
  Assertion.addMethod('Throw', assertThrows);

  /**
   * ### .respondTo(method)
   *
   * Asserts that the object or class target will respond to a method.
   *
   *     Klass.prototype.bar = function(){};
   *     expect(Klass).to.respondTo('bar');
   *     expect(obj).to.respondTo('bar');
   *
   * To check if a constructor will respond to a static function,
   * set the `itself` flag.
   *
   *     Klass.baz = function(){};
   *     expect(Klass).itself.to.respondTo('baz');
   *
   * @name respondTo
   * @param {String} method
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('respondTo', function (method, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object')
      , itself = flag(this, 'itself')
      , context = ('function' === _.type(obj) && !itself)
        ? obj.prototype[method]
        : obj[method];

    this.assert(
        'function' === typeof context
      , 'expected #{this} to respond to ' + _.inspect(method)
      , 'expected #{this} to not respond to ' + _.inspect(method)
    );
  });

  /**
   * ### .itself
   *
   * Sets the `itself` flag, later used by the `respondTo` assertion.
   *
   *     function Foo() {}
   *     Foo.bar = function() {}
   *     Foo.prototype.baz = function() {}
   *
   *     expect(Foo).itself.to.respondTo('bar');
   *     expect(Foo).itself.not.to.respondTo('baz');
   *
   * @name itself
   * @api public
   */

  Assertion.addProperty('itself', function () {
    flag(this, 'itself', true);
  });

  /**
   * ### .satisfy(method)
   *
   * Asserts that the target passes a given truth test.
   *
   *     expect(1).to.satisfy(function(num) { return num > 0; });
   *
   * @name satisfy
   * @param {Function} matcher
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('satisfy', function (matcher, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');
    var result = matcher(obj);
    this.assert(
        result
      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)
      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)
      , this.negate ? false : true
      , result
    );
  });

  /**
   * ### .closeTo(expected, delta)
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     expect(1.5).to.be.closeTo(1, 0.5);
   *
   * @name closeTo
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('closeTo', function (expected, delta, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj, msg).is.a('number');
    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {
      throw new Error('the arguments to closeTo must be numbers');
    }

    this.assert(
        Math.abs(obj - expected) <= delta
      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta
      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta
    );
  });

  function isSubsetOf(subset, superset, cmp) {
    return subset.every(function(elem) {
      if (!cmp) return superset.indexOf(elem) !== -1;

      return superset.some(function(elem2) {
        return cmp(elem, elem2);
      });
    })
  }

  /**
   * ### .members(set)
   *
   * Asserts that the target is a superset of `set`,
   * or that the target and `set` have the same strictly-equal (===) members.
   * Alternately, if the `deep` flag is set, set members are compared for deep
   * equality.
   *
   *     expect([1, 2, 3]).to.include.members([3, 2]);
   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);
   *
   *     expect([4, 2]).to.have.members([2, 4]);
   *     expect([5, 2]).to.not.have.members([5, 2, 1]);
   *
   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);
   *
   * @name members
   * @param {Array} set
   * @param {String} message _optional_
   * @api public
   */

  Assertion.addMethod('members', function (subset, msg) {
    if (msg) flag(this, 'message', msg);
    var obj = flag(this, 'object');

    new Assertion(obj).to.be.an('array');
    new Assertion(subset).to.be.an('array');

    var cmp = flag(this, 'deep') ? _.eql : undefined;

    if (flag(this, 'contains')) {
      return this.assert(
          isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to be a superset of #{act}'
        , 'expected #{this} to not be a superset of #{act}'
        , obj
        , subset
      );
    }

    this.assert(
        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)
        , 'expected #{this} to have the same members as #{act}'
        , 'expected #{this} to not have the same members as #{act}'
        , obj
        , subset
    );
  });
};

},{}],14:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */


module.exports = function (chai, util) {

  /*!
   * Chai dependencies.
   */

  var Assertion = chai.Assertion
    , flag = util.flag;

  /*!
   * Module export.
   */

  /**
   * ### assert(expression, message)
   *
   * Write your own test expressions.
   *
   *     assert('foo' !== 'bar', 'foo is not bar');
   *     assert(Array.isArray([]), 'empty arrays are arrays');
   *
   * @param {Mixed} expression to test for truthiness
   * @param {String} message to display on error
   * @name assert
   * @api public
   */

  var assert = chai.assert = function (express, errmsg) {
    var test = new Assertion(null, null, chai.assert);
    test.assert(
        express
      , errmsg
      , '[ negation message unavailable ]'
    );
  };

  /**
   * ### .fail(actual, expected, [message], [operator])
   *
   * Throw a failure. Node.js `assert` module-compatible.
   *
   * @name fail
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @param {String} operator
   * @api public
   */

  assert.fail = function (actual, expected, message, operator) {
    message = message || 'assert.fail()';
    throw new chai.AssertionError(message, {
        actual: actual
      , expected: expected
      , operator: operator
    }, assert.fail);
  };

  /**
   * ### .ok(object, [message])
   *
   * Asserts that `object` is truthy.
   *
   *     assert.ok('everything', 'everything is ok');
   *     assert.ok(false, 'this will fail');
   *
   * @name ok
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.ok = function (val, msg) {
    new Assertion(val, msg).is.ok;
  };

  /**
   * ### .notOk(object, [message])
   *
   * Asserts that `object` is falsy.
   *
   *     assert.notOk('everything', 'this will fail');
   *     assert.notOk(false, 'this will pass');
   *
   * @name notOk
   * @param {Mixed} object to test
   * @param {String} message
   * @api public
   */

  assert.notOk = function (val, msg) {
    new Assertion(val, msg).is.not.ok;
  };

  /**
   * ### .equal(actual, expected, [message])
   *
   * Asserts non-strict equality (`==`) of `actual` and `expected`.
   *
   *     assert.equal(3, '3', '== coerces values to strings');
   *
   * @name equal
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.equal = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.equal);

    test.assert(
        exp == flag(test, 'object')
      , 'expected #{this} to equal #{exp}'
      , 'expected #{this} to not equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .notEqual(actual, expected, [message])
   *
   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.
   *
   *     assert.notEqual(3, 4, 'these numbers are not equal');
   *
   * @name notEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notEqual = function (act, exp, msg) {
    var test = new Assertion(act, msg, assert.notEqual);

    test.assert(
        exp != flag(test, 'object')
      , 'expected #{this} to not equal #{exp}'
      , 'expected #{this} to equal #{act}'
      , exp
      , act
    );
  };

  /**
   * ### .strictEqual(actual, expected, [message])
   *
   * Asserts strict equality (`===`) of `actual` and `expected`.
   *
   *     assert.strictEqual(true, true, 'these booleans are strictly equal');
   *
   * @name strictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.strictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.equal(exp);
  };

  /**
   * ### .notStrictEqual(actual, expected, [message])
   *
   * Asserts strict inequality (`!==`) of `actual` and `expected`.
   *
   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');
   *
   * @name notStrictEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notStrictEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.equal(exp);
  };

  /**
   * ### .deepEqual(actual, expected, [message])
   *
   * Asserts that `actual` is deeply equal to `expected`.
   *
   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });
   *
   * @name deepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.deepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.eql(exp);
  };

  /**
   * ### .notDeepEqual(actual, expected, [message])
   *
   * Assert that `actual` is not deeply equal to `expected`.
   *
   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });
   *
   * @name notDeepEqual
   * @param {Mixed} actual
   * @param {Mixed} expected
   * @param {String} message
   * @api public
   */

  assert.notDeepEqual = function (act, exp, msg) {
    new Assertion(act, msg).to.not.eql(exp);
  };

  /**
   * ### .isTrue(value, [message])
   *
   * Asserts that `value` is true.
   *
   *     var teaServed = true;
   *     assert.isTrue(teaServed, 'the tea has been served');
   *
   * @name isTrue
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isTrue = function (val, msg) {
    new Assertion(val, msg).is['true'];
  };

  /**
   * ### .isFalse(value, [message])
   *
   * Asserts that `value` is false.
   *
   *     var teaServed = false;
   *     assert.isFalse(teaServed, 'no tea yet? hmm...');
   *
   * @name isFalse
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFalse = function (val, msg) {
    new Assertion(val, msg).is['false'];
  };

  /**
   * ### .isNull(value, [message])
   *
   * Asserts that `value` is null.
   *
   *     assert.isNull(err, 'there was no error');
   *
   * @name isNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNull = function (val, msg) {
    new Assertion(val, msg).to.equal(null);
  };

  /**
   * ### .isNotNull(value, [message])
   *
   * Asserts that `value` is not null.
   *
   *     var tea = 'tasty chai';
   *     assert.isNotNull(tea, 'great, time for tea!');
   *
   * @name isNotNull
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNull = function (val, msg) {
    new Assertion(val, msg).to.not.equal(null);
  };

  /**
   * ### .isUndefined(value, [message])
   *
   * Asserts that `value` is `undefined`.
   *
   *     var tea;
   *     assert.isUndefined(tea, 'no tea defined');
   *
   * @name isUndefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isUndefined = function (val, msg) {
    new Assertion(val, msg).to.equal(undefined);
  };

  /**
   * ### .isDefined(value, [message])
   *
   * Asserts that `value` is not `undefined`.
   *
   *     var tea = 'cup of chai';
   *     assert.isDefined(tea, 'tea has been defined');
   *
   * @name isDefined
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isDefined = function (val, msg) {
    new Assertion(val, msg).to.not.equal(undefined);
  };

  /**
   * ### .isFunction(value, [message])
   *
   * Asserts that `value` is a function.
   *
   *     function serveTea() { return 'cup of tea'; };
   *     assert.isFunction(serveTea, 'great, we can have tea now');
   *
   * @name isFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isFunction = function (val, msg) {
    new Assertion(val, msg).to.be.a('function');
  };

  /**
   * ### .isNotFunction(value, [message])
   *
   * Asserts that `value` is _not_ a function.
   *
   *     var serveTea = [ 'heat', 'pour', 'sip' ];
   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');
   *
   * @name isNotFunction
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotFunction = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('function');
  };

  /**
   * ### .isObject(value, [message])
   *
   * Asserts that `value` is an object (as revealed by
   * `Object.prototype.toString`).
   *
   *     var selection = { name: 'Chai', serve: 'with spices' };
   *     assert.isObject(selection, 'tea selection is an object');
   *
   * @name isObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isObject = function (val, msg) {
    new Assertion(val, msg).to.be.a('object');
  };

  /**
   * ### .isNotObject(value, [message])
   *
   * Asserts that `value` is _not_ an object.
   *
   *     var selection = 'chai'
   *     assert.isNotObject(selection, 'tea selection is not an object');
   *     assert.isNotObject(null, 'null is not an object');
   *
   * @name isNotObject
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotObject = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('object');
  };

  /**
   * ### .isArray(value, [message])
   *
   * Asserts that `value` is an array.
   *
   *     var menu = [ 'green', 'chai', 'oolong' ];
   *     assert.isArray(menu, 'what kind of tea do we want?');
   *
   * @name isArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isArray = function (val, msg) {
    new Assertion(val, msg).to.be.an('array');
  };

  /**
   * ### .isNotArray(value, [message])
   *
   * Asserts that `value` is _not_ an array.
   *
   *     var menu = 'green|chai|oolong';
   *     assert.isNotArray(menu, 'what kind of tea do we want?');
   *
   * @name isNotArray
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotArray = function (val, msg) {
    new Assertion(val, msg).to.not.be.an('array');
  };

  /**
   * ### .isString(value, [message])
   *
   * Asserts that `value` is a string.
   *
   *     var teaOrder = 'chai';
   *     assert.isString(teaOrder, 'order placed');
   *
   * @name isString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isString = function (val, msg) {
    new Assertion(val, msg).to.be.a('string');
  };

  /**
   * ### .isNotString(value, [message])
   *
   * Asserts that `value` is _not_ a string.
   *
   *     var teaOrder = 4;
   *     assert.isNotString(teaOrder, 'order placed');
   *
   * @name isNotString
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotString = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('string');
  };

  /**
   * ### .isNumber(value, [message])
   *
   * Asserts that `value` is a number.
   *
   *     var cups = 2;
   *     assert.isNumber(cups, 'how many cups');
   *
   * @name isNumber
   * @param {Number} value
   * @param {String} message
   * @api public
   */

  assert.isNumber = function (val, msg) {
    new Assertion(val, msg).to.be.a('number');
  };

  /**
   * ### .isNotNumber(value, [message])
   *
   * Asserts that `value` is _not_ a number.
   *
   *     var cups = '2 cups please';
   *     assert.isNotNumber(cups, 'how many cups');
   *
   * @name isNotNumber
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotNumber = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('number');
  };

  /**
   * ### .isBoolean(value, [message])
   *
   * Asserts that `value` is a boolean.
   *
   *     var teaReady = true
   *       , teaServed = false;
   *
   *     assert.isBoolean(teaReady, 'is the tea ready');
   *     assert.isBoolean(teaServed, 'has tea been served');
   *
   * @name isBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isBoolean = function (val, msg) {
    new Assertion(val, msg).to.be.a('boolean');
  };

  /**
   * ### .isNotBoolean(value, [message])
   *
   * Asserts that `value` is _not_ a boolean.
   *
   *     var teaReady = 'yep'
   *       , teaServed = 'nope';
   *
   *     assert.isNotBoolean(teaReady, 'is the tea ready');
   *     assert.isNotBoolean(teaServed, 'has tea been served');
   *
   * @name isNotBoolean
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.isNotBoolean = function (val, msg) {
    new Assertion(val, msg).to.not.be.a('boolean');
  };

  /**
   * ### .typeOf(value, name, [message])
   *
   * Asserts that `value`'s type is `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');
   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');
   *     assert.typeOf('tea', 'string', 'we have a string');
   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');
   *     assert.typeOf(null, 'null', 'we have a null');
   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');
   *
   * @name typeOf
   * @param {Mixed} value
   * @param {String} name
   * @param {String} message
   * @api public
   */

  assert.typeOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.a(type);
  };

  /**
   * ### .notTypeOf(value, name, [message])
   *
   * Asserts that `value`'s type is _not_ `name`, as determined by
   * `Object.prototype.toString`.
   *
   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');
   *
   * @name notTypeOf
   * @param {Mixed} value
   * @param {String} typeof name
   * @param {String} message
   * @api public
   */

  assert.notTypeOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.a(type);
  };

  /**
   * ### .instanceOf(object, constructor, [message])
   *
   * Asserts that `value` is an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new Tea('chai');
   *
   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');
   *
   * @name instanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.instanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.be.instanceOf(type);
  };

  /**
   * ### .notInstanceOf(object, constructor, [message])
   *
   * Asserts `value` is not an instance of `constructor`.
   *
   *     var Tea = function (name) { this.name = name; }
   *       , chai = new String('chai');
   *
   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');
   *
   * @name notInstanceOf
   * @param {Object} object
   * @param {Constructor} constructor
   * @param {String} message
   * @api public
   */

  assert.notInstanceOf = function (val, type, msg) {
    new Assertion(val, msg).to.not.be.instanceOf(type);
  };

  /**
   * ### .include(haystack, needle, [message])
   *
   * Asserts that `haystack` includes `needle`. Works
   * for strings and arrays.
   *
   *     assert.include('foobar', 'bar', 'foobar contains string "bar"');
   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');
   *
   * @name include
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.include = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.include).include(inc);
  };

  /**
   * ### .notInclude(haystack, needle, [message])
   *
   * Asserts that `haystack` does not include `needle`. Works
   * for strings and arrays.
   *i
   *     assert.notInclude('foobar', 'baz', 'string not include substring');
   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');
   *
   * @name notInclude
   * @param {Array|String} haystack
   * @param {Mixed} needle
   * @param {String} message
   * @api public
   */

  assert.notInclude = function (exp, inc, msg) {
    new Assertion(exp, msg, assert.notInclude).not.include(inc);
  };

  /**
   * ### .match(value, regexp, [message])
   *
   * Asserts that `value` matches the regular expression `regexp`.
   *
   *     assert.match('foobar', /^foo/, 'regexp matches');
   *
   * @name match
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.match = function (exp, re, msg) {
    new Assertion(exp, msg).to.match(re);
  };

  /**
   * ### .notMatch(value, regexp, [message])
   *
   * Asserts that `value` does not match the regular expression `regexp`.
   *
   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');
   *
   * @name notMatch
   * @param {Mixed} value
   * @param {RegExp} regexp
   * @param {String} message
   * @api public
   */

  assert.notMatch = function (exp, re, msg) {
    new Assertion(exp, msg).to.not.match(re);
  };

  /**
   * ### .property(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`.
   *
   *     assert.property({ tea: { green: 'matcha' }}, 'tea');
   *
   * @name property
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.property = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.property(prop);
  };

  /**
   * ### .notProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`.
   *
   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');
   *
   * @name notProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.property(prop);
  };

  /**
   * ### .deepProperty(object, property, [message])
   *
   * Asserts that `object` has a property named by `property`, which can be a
   * string using dot- and bracket-notation for deep reference.
   *
   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');
   *
   * @name deepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.deepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop);
  };

  /**
   * ### .notDeepProperty(object, property, [message])
   *
   * Asserts that `object` does _not_ have a property named by `property`, which
   * can be a string using dot- and bracket-notation for deep reference.
   *
   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');
   *
   * @name notDeepProperty
   * @param {Object} object
   * @param {String} property
   * @param {String} message
   * @api public
   */

  assert.notDeepProperty = function (obj, prop, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop);
  };

  /**
   * ### .propertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`.
   *
   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');
   *
   * @name propertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.property(prop, val);
  };

  /**
   * ### .propertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`.
   *
   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');
   *
   * @name propertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.propertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.property(prop, val);
  };

  /**
   * ### .deepPropertyVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property` with value given
   * by `value`. `property` can use dot- and bracket-notation for deep
   * reference.
   *
   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');
   *
   * @name deepPropertyVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.have.deep.property(prop, val);
  };

  /**
   * ### .deepPropertyNotVal(object, property, value, [message])
   *
   * Asserts that `object` has a property named by `property`, but with a value
   * different from that given by `value`. `property` can use dot- and
   * bracket-notation for deep reference.
   *
   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');
   *
   * @name deepPropertyNotVal
   * @param {Object} object
   * @param {String} property
   * @param {Mixed} value
   * @param {String} message
   * @api public
   */

  assert.deepPropertyNotVal = function (obj, prop, val, msg) {
    new Assertion(obj, msg).to.not.have.deep.property(prop, val);
  };

  /**
   * ### .lengthOf(object, length, [message])
   *
   * Asserts that `object` has a `length` property with the expected value.
   *
   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');
   *     assert.lengthOf('foobar', 5, 'string has length of 6');
   *
   * @name lengthOf
   * @param {Mixed} object
   * @param {Number} length
   * @param {String} message
   * @api public
   */

  assert.lengthOf = function (exp, len, msg) {
    new Assertion(exp, msg).to.have.length(len);
  };

  /**
   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])
   *
   * Asserts that `function` will throw an error that is an instance of
   * `constructor`, or alternately that it will throw an error with message
   * matching `regexp`.
   *
   *     assert.throw(fn, 'function throws a reference error');
   *     assert.throw(fn, /function throws a reference error/);
   *     assert.throw(fn, ReferenceError);
   *     assert.throw(fn, ReferenceError, 'function throws a reference error');
   *     assert.throw(fn, ReferenceError, /function throws a reference error/);
   *
   * @name throws
   * @alias throw
   * @alias Throw
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.Throw = function (fn, errt, errs, msg) {
    if ('string' === typeof errt || errt instanceof RegExp) {
      errs = errt;
      errt = null;
    }

    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);
    return flag(assertErr, 'object');
  };

  /**
   * ### .doesNotThrow(function, [constructor/regexp], [message])
   *
   * Asserts that `function` will _not_ throw an error that is an instance of
   * `constructor`, or alternately that it will not throw an error with message
   * matching `regexp`.
   *
   *     assert.doesNotThrow(fn, Error, 'function does not throw');
   *
   * @name doesNotThrow
   * @param {Function} function
   * @param {ErrorConstructor} constructor
   * @param {RegExp} regexp
   * @param {String} message
   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types
   * @api public
   */

  assert.doesNotThrow = function (fn, type, msg) {
    if ('string' === typeof type) {
      msg = type;
      type = null;
    }

    new Assertion(fn, msg).to.not.Throw(type);
  };

  /**
   * ### .operator(val1, operator, val2, [message])
   *
   * Compares two values using `operator`.
   *
   *     assert.operator(1, '<', 2, 'everything is ok');
   *     assert.operator(1, '>', 2, 'this will fail');
   *
   * @name operator
   * @param {Mixed} val1
   * @param {String} operator
   * @param {Mixed} val2
   * @param {String} message
   * @api public
   */

  assert.operator = function (val, operator, val2, msg) {
    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {
      throw new Error('Invalid operator "' + operator + '"');
    }
    var test = new Assertion(eval(val + operator + val2), msg);
    test.assert(
        true === flag(test, 'object')
      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)
      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );
  };

  /**
   * ### .closeTo(actual, expected, delta, [message])
   *
   * Asserts that the target is equal `expected`, to within a +/- `delta` range.
   *
   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');
   *
   * @name closeTo
   * @param {Number} actual
   * @param {Number} expected
   * @param {Number} delta
   * @param {String} message
   * @api public
   */

  assert.closeTo = function (act, exp, delta, msg) {
    new Assertion(act, msg).to.be.closeTo(exp, delta);
  };

  /**
   * ### .sameMembers(set1, set2, [message])
   *
   * Asserts that `set1` and `set2` have the same members.
   * Order is not taken into account.
   *
   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');
   *
   * @name sameMembers
   * @param {Array} set1
   * @param {Array} set2
   * @param {String} message
   * @api public
   */

  assert.sameMembers = function (set1, set2, msg) {
    new Assertion(set1, msg).to.have.same.members(set2);
  }

  /**
   * ### .includeMembers(superset, subset, [message])
   *
   * Asserts that `subset` is included in `superset`.
   * Order is not taken into account.
   *
   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');
   *
   * @name includeMembers
   * @param {Array} superset
   * @param {Array} subset
   * @param {String} message
   * @api public
   */

  assert.includeMembers = function (superset, subset, msg) {
    new Assertion(superset, msg).to.include.members(subset);
  }

  /*!
   * Undocumented / untested
   */

  assert.ifError = function (val, msg) {
    new Assertion(val, msg).to.not.be.ok;
  };

  /*!
   * Aliases.
   */

  (function alias(name, as){
    assert[as] = assert[name];
    return alias;
  })
  ('Throw', 'throw')
  ('Throw', 'throws');
};

},{}],15:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  chai.expect = function (val, message) {
    return new chai.Assertion(val, message);
  };
};


},{}],16:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

module.exports = function (chai, util) {
  var Assertion = chai.Assertion;

  function loadShould () {
    // explicitly define this method as function as to have it's name to include as `ssfi`
    function shouldGetter() {
      if (this instanceof String || this instanceof Number) {
        return new Assertion(this.constructor(this), null, shouldGetter);
      } else if (this instanceof Boolean) {
        return new Assertion(this == true, null, shouldGetter);
      }
      return new Assertion(this, null, shouldGetter);
    }
    function shouldSetter(value) {
      // See https://github.com/chaijs/chai/issues/86: this makes
      // `whatever.should = someValue` actually set `someValue`, which is
      // especially useful for `global.should = require('chai').should()`.
      //
      // Note that we have to use [[DefineProperty]] instead of [[Put]]
      // since otherwise we would trigger this very setter!
      Object.defineProperty(this, 'should', {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    }
    // modify Object.prototype to have `should`
    Object.defineProperty(Object.prototype, 'should', {
      set: shouldSetter
      , get: shouldGetter
      , configurable: true
    });

    var should = {};

    should.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.equal(val2);
    };

    should.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.Throw(errt, errs);
    };

    should.exist = function (val, msg) {
      new Assertion(val, msg).to.exist;
    }

    // negation
    should.not = {}

    should.not.equal = function (val1, val2, msg) {
      new Assertion(val1, msg).to.not.equal(val2);
    };

    should.not.Throw = function (fn, errt, errs, msg) {
      new Assertion(fn, msg).to.not.Throw(errt, errs);
    };

    should.not.exist = function (val, msg) {
      new Assertion(val, msg).to.not.exist;
    }

    should['throw'] = should['Throw'];
    should.not['throw'] = should.not['Throw'];

    return should;
  };

  chai.should = loadShould;
  chai.Should = loadShould;
};

},{}],17:[function(require,module,exports){
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var transferFlags = require('./transferFlags');
var flag = require('./flag');
var config = require('../config');

/*!
 * Module variables
 */

// Check whether `__proto__` is supported
var hasProtoSupport = '__proto__' in Object;

// Without `__proto__` support, this module will need to add properties to a function.
// However, some Function.prototype methods cannot be overwritten,
// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).
var excludeNames = /^(?:length|name|arguments|caller)$/;

// Cache `Function` properties
var call  = Function.prototype.call,
    apply = Function.prototype.apply;

/**
 * ### addChainableMethod (ctx, name, method, chainingBehavior)
 *
 * Adds a method to an object, such that the method can also be chained.
 *
 *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);
 *
 * The result can then be used as both a method assertion, executing both `method` and
 * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.
 *
 *     expect(fooStr).to.be.foo('bar');
 *     expect(fooStr).to.be.foo.equal('foo');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for `name`, when called
 * @param {Function} chainingBehavior function to be called every time the property is accessed
 * @name addChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  if (typeof chainingBehavior !== 'function') {
    chainingBehavior = function () { };
  }

  var chainableBehavior = {
      method: method
    , chainingBehavior: chainingBehavior
  };

  // save the methods so we can overwrite them later, if we need to.
  if (!ctx.__methods) {
    ctx.__methods = {};
  }
  ctx.__methods[name] = chainableBehavior;

  Object.defineProperty(ctx, name,
    { get: function () {
        chainableBehavior.chainingBehavior.call(this);

        var assert = function assert() {
          var old_ssfi = flag(this, 'ssfi');
          if (old_ssfi && config.includeStack === false)
            flag(this, 'ssfi', assert);
          var result = chainableBehavior.method.apply(this, arguments);
          return result === undefined ? this : result;
        };

        // Use `__proto__` if available
        if (hasProtoSupport) {
          // Inherit all properties from the object by replacing the `Function` prototype
          var prototype = assert.__proto__ = Object.create(this);
          // Restore the `call` and `apply` methods from `Function`
          prototype.call = call;
          prototype.apply = apply;
        }
        // Otherwise, redefine all properties (slow!)
        else {
          var asserterNames = Object.getOwnPropertyNames(ctx);
          asserterNames.forEach(function (asserterName) {
            if (!excludeNames.test(asserterName)) {
              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);
              Object.defineProperty(assert, asserterName, pd);
            }
          });
        }

        transferFlags(this, assert);
        return assert;
      }
    , configurable: true
  });
};

},{"../config":12,"./flag":20,"./transferFlags":34}],18:[function(require,module,exports){
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

var config = require('../config');

/**
 * ### .addMethod (ctx, name, method)
 *
 * Adds a method to the prototype of an object.
 *
 *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.equal(str);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(fooStr).to.be.foo('bar');
 *
 * @param {Object} ctx object to which the method is added
 * @param {String} name of method to add
 * @param {Function} method function to be used for name
 * @name addMethod
 * @api public
 */
var flag = require('./flag');

module.exports = function (ctx, name, method) {
  ctx[name] = function () {
    var old_ssfi = flag(this, 'ssfi');
    if (old_ssfi && config.includeStack === false)
      flag(this, 'ssfi', ctx[name]);
    var result = method.apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{"../config":12,"./flag":20}],19:[function(require,module,exports){
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### addProperty (ctx, name, getter)
 *
 * Adds a property to the prototype of an object.
 *
 *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {
 *       var obj = utils.flag(this, 'object');
 *       new chai.Assertion(obj).to.be.instanceof(Foo);
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.addProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.foo;
 *
 * @param {Object} ctx object to which the property is added
 * @param {String} name of property to add
 * @param {Function} getter function to be used for name
 * @name addProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter.call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],20:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### flag(object ,key, [value])
 *
 * Get or set a flag value on an object. If a
 * value is provided it will be set, else it will
 * return the currently set value or `undefined` if
 * the value is not set.
 *
 *     utils.flag(this, 'foo', 'bar'); // setter
 *     utils.flag(this, 'foo'); // getter, returns `bar`
 *
 * @param {Object} object (constructed Assertion
 * @param {String} key
 * @param {Mixed} value (optional)
 * @name flag
 * @api private
 */

module.exports = function (obj, key, value) {
  var flags = obj.__flags || (obj.__flags = Object.create(null));
  if (arguments.length === 3) {
    flags[key] = value;
  } else {
    return flags[key];
  }
};

},{}],21:[function(require,module,exports){
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getActual(object, [actual])
 *
 * Returns the `actual` value for an Assertion
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  return args.length > 4 ? args[4] : obj._obj;
};

},{}],22:[function(require,module,exports){
/*!
 * Chai - getEnumerableProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getEnumerableProperties(object)
 *
 * This allows the retrieval of enumerable property names of an object,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getEnumerableProperties
 * @api public
 */

module.exports = function getEnumerableProperties(object) {
  var result = [];
  for (var name in object) {
    result.push(name);
  }
  return result;
};

},{}],23:[function(require,module,exports){
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag')
  , getActual = require('./getActual')
  , inspect = require('./inspect')
  , objDisplay = require('./objDisplay');

/**
 * ### .getMessage(object, message, negateMessage)
 *
 * Construct the error message based on flags
 * and template tags. Template tags will return
 * a stringified inspection of the object referenced.
 *
 * Message template tags:
 * - `#{this}` current asserted object
 * - `#{act}` actual value
 * - `#{exp}` expected value
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 * @name getMessage
 * @api public
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , val = flag(obj, 'object')
    , expected = args[3]
    , actual = getActual(obj, args)
    , msg = negate ? args[2] : args[1]
    , flagMsg = flag(obj, 'message');

  if(typeof msg === "function") msg = msg();
  msg = msg || '';
  msg = msg
    .replace(/#{this}/g, objDisplay(val))
    .replace(/#{act}/g, objDisplay(actual))
    .replace(/#{exp}/g, objDisplay(expected));

  return flagMsg ? flagMsg + ': ' + msg : msg;
};

},{"./flag":20,"./getActual":21,"./inspect":28,"./objDisplay":29}],24:[function(require,module,exports){
/*!
 * Chai - getName utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * # getName(func)
 *
 * Gets the name of a function, in a cross-browser way.
 *
 * @param {Function} a function (usually a constructor)
 */

module.exports = function (func) {
  if (func.name) return func.name;

  var match = /^\s?function ([^(]*)\(/.exec(func);
  return match && match[1] ? match[1] : "";
};

},{}],25:[function(require,module,exports){
/*!
 * Chai - getPathValue utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */

/**
 * ### .getPathValue(path, object)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue('prop1.str', obj); // Hello
 *     getPathValue('prop1.att[2]', obj); // b
 *     getPathValue('prop2.arr[0].nested', obj); // Universe
 *
 * @param {String} path
 * @param {Object} object
 * @returns {Object} value or `undefined`
 * @name getPathValue
 * @api public
 */

var getPathValue = module.exports = function (path, obj) {
  var parsed = parsePath(path);
  return _getPathValue(parsed, obj);
};

/*!
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `_getPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be as near infinitely deep and nested
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */

function parsePath (path) {
  var str = path.replace(/\[/g, '.[')
    , parts = str.match(/(\\\.|[^.]+?)+/g);
  return parts.map(function (value) {
    var re = /\[(\d+)\]$/
      , mArr = re.exec(value)
    if (mArr) return { i: parseFloat(mArr[1]) };
    else return { p: value };
  });
};

/*!
 * ## _getPathValue(parsed, obj)
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(parsed, obj);
 *
 * @param {Object} parsed definition from `parsePath`.
 * @param {Object} object to search against
 * @returns {Object|Undefined} value
 * @api private
 */

function _getPathValue (parsed, obj) {
  var tmp = obj
    , res;
  for (var i = 0, l = parsed.length; i < l; i++) {
    var part = parsed[i];
    if (tmp) {
      if ('undefined' !== typeof part.p)
        tmp = tmp[part.p];
      else if ('undefined' !== typeof part.i)
        tmp = tmp[part.i];
      if (i == (l - 1)) res = tmp;
    } else {
      res = undefined;
    }
  }
  return res;
};

},{}],26:[function(require,module,exports){
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### .getProperties(object)
 *
 * This allows the retrieval of property names of an object, enumerable or not,
 * inherited or not.
 *
 * @param {Object} object
 * @returns {Array}
 * @name getProperties
 * @api public
 */

module.exports = function getProperties(object) {
  var result = Object.getOwnPropertyNames(subject);

  function addProperty(property) {
    if (result.indexOf(property) === -1) {
      result.push(property);
    }
  }

  var proto = Object.getPrototypeOf(subject);
  while (proto !== null) {
    Object.getOwnPropertyNames(proto).forEach(addProperty);
    proto = Object.getPrototypeOf(proto);
  }

  return result;
};

},{}],27:[function(require,module,exports){
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main exports
 */

var exports = module.exports = {};

/*!
 * test utility
 */

exports.test = require('./test');

/*!
 * type utility
 */

exports.type = require('./type');

/*!
 * message utility
 */

exports.getMessage = require('./getMessage');

/*!
 * actual utility
 */

exports.getActual = require('./getActual');

/*!
 * Inspect util
 */

exports.inspect = require('./inspect');

/*!
 * Object Display util
 */

exports.objDisplay = require('./objDisplay');

/*!
 * Flag utility
 */

exports.flag = require('./flag');

/*!
 * Flag transferring utility
 */

exports.transferFlags = require('./transferFlags');

/*!
 * Deep equal utility
 */

exports.eql = require('deep-eql');

/*!
 * Deep path value
 */

exports.getPathValue = require('./getPathValue');

/*!
 * Function name
 */

exports.getName = require('./getName');

/*!
 * add Property
 */

exports.addProperty = require('./addProperty');

/*!
 * add Method
 */

exports.addMethod = require('./addMethod');

/*!
 * overwrite Property
 */

exports.overwriteProperty = require('./overwriteProperty');

/*!
 * overwrite Method
 */

exports.overwriteMethod = require('./overwriteMethod');

/*!
 * Add a chainable method
 */

exports.addChainableMethod = require('./addChainableMethod');

/*!
 * Overwrite chainable method
 */

exports.overwriteChainableMethod = require('./overwriteChainableMethod');


},{"./addChainableMethod":17,"./addMethod":18,"./addProperty":19,"./flag":20,"./getActual":21,"./getMessage":23,"./getName":24,"./getPathValue":25,"./inspect":28,"./objDisplay":29,"./overwriteChainableMethod":30,"./overwriteMethod":31,"./overwriteProperty":32,"./test":33,"./transferFlags":34,"./type":35,"deep-eql":37}],28:[function(require,module,exports){
// This is (almost) directly from Node.js utils
// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js

var getName = require('./getName');
var getProperties = require('./getProperties');
var getEnumerableProperties = require('./getEnumerableProperties');

module.exports = inspect;

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Boolean} showHidden Flag that shows hidden (not enumerable)
 *    properties of objects.
 * @param {Number} depth Depth in which to descend in object. Default is 2.
 * @param {Boolean} colors Flag to turn on ANSI escape codes to color the
 *    output. Default is false (no coloring).
 */
function inspect(obj, showHidden, depth, colors) {
  var ctx = {
    showHidden: showHidden,
    seen: [],
    stylize: function (str) { return str; }
  };
  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));
}

// Returns true if object is a DOM element.
var isDOMElement = function (object) {
  if (typeof HTMLElement === 'object') {
    return object instanceof HTMLElement;
  } else {
    return object &&
      typeof object === 'object' &&
      object.nodeType === 1 &&
      typeof object.nodeName === 'string';
  }
};

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (value && typeof value.inspect === 'function' &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (typeof ret !== 'string') {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // If this is a DOM element, try to get the outer HTML.
  if (isDOMElement(value)) {
    if ('outerHTML' in value) {
      return value.outerHTML;
      // This value does not have an outerHTML attribute,
      //   it could still be an XML element
    } else {
      // Attempt to serialize it
      try {
        if (document.xmlVersion) {
          var xmlSerializer = new XMLSerializer();
          return xmlSerializer.serializeToString(value);
        } else {
          // Firefox 11- do not support outerHTML
          //   It does, however, support innerHTML
          //   Use the following to render the element
          var ns = "http://www.w3.org/1999/xhtml";
          var container = document.createElementNS(ns, '_');

          container.appendChild(value.cloneNode(false));
          html = container.innerHTML
            .replace('><', '>' + value.innerHTML + '<');
          container.innerHTML = '';
          return html;
        }
      } catch (err) {
        // This could be a non-native DOM implementation,
        //   continue with the normal flow:
        //   printing the element as if it is an object.
      }
    }
  }

  // Look up the keys of the object.
  var visibleKeys = getEnumerableProperties(value);
  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;

  // Some type of object without properties can be shortcutted.
  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,
  // a `stack` plus `description` property; ignore those for consistency.
  if (keys.length === 0 || (isError(value) && (
      (keys.length === 1 && keys[0] === 'stack') ||
      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')
     ))) {
    if (typeof value === 'function') {
      var name = getName(value);
      var nameSuffix = name ? ': ' + name : '';
      return ctx.stylize('[Function' + nameSuffix + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var name = getName(value);
    var nameSuffix = name ? ': ' + name : '';
    base = ' [Function' + nameSuffix + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    return formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  switch (typeof value) {
    case 'undefined':
      return ctx.stylize('undefined', 'undefined');

    case 'string':
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');

    case 'number':
      return ctx.stylize('' + value, 'number');

    case 'boolean':
      return ctx.stylize('' + value, 'boolean');
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return ctx.stylize('null', 'null');
  }
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (Object.prototype.hasOwnProperty.call(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str;
  if (value.__lookupGetter__) {
    if (value.__lookupGetter__(key)) {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (value.__lookupSetter__(key)) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
  }
  if (visibleKeys.indexOf(key) < 0) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(value[key]) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, value[key], null);
      } else {
        str = formatValue(ctx, value[key], recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (typeof name === 'undefined') {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function isArray(ar) {
  return Array.isArray(ar) ||
         (typeof ar === 'object' && objectToString(ar) === '[object Array]');
}

function isRegExp(re) {
  return typeof re === 'object' && objectToString(re) === '[object RegExp]';
}

function isDate(d) {
  return typeof d === 'object' && objectToString(d) === '[object Date]';
}

function isError(e) {
  return typeof e === 'object' && objectToString(e) === '[object Error]';
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"./getEnumerableProperties":22,"./getName":24,"./getProperties":26}],29:[function(require,module,exports){
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var inspect = require('./inspect');
var config = require('../config');

/**
 * ### .objDisplay (object)
 *
 * Determines if an object or an array matches
 * criteria to be inspected in-line for error
 * messages or should be truncated.
 *
 * @param {Mixed} javascript object to inspect
 * @name objDisplay
 * @api public
 */

module.exports = function (obj) {
  var str = inspect(obj)
    , type = Object.prototype.toString.call(obj);

  if (config.truncateThreshold && str.length >= config.truncateThreshold) {
    if (type === '[object Function]') {
      return !obj.name || obj.name === ''
        ? '[Function]'
        : '[Function: ' + obj.name + ']';
    } else if (type === '[object Array]') {
      return '[ Array(' + obj.length + ') ]';
    } else if (type === '[object Object]') {
      var keys = Object.keys(obj)
        , kstr = keys.length > 2
          ? keys.splice(0, 2).join(', ') + ', ...'
          : keys.join(', ');
      return '{ Object (' + kstr + ') }';
    } else {
      return str;
    }
  } else {
    return str;
  }
};

},{"../config":12,"./inspect":28}],30:[function(require,module,exports){
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteChainableMethod (ctx, name, fn)
 *
 * Overwites an already existing chainable method
 * and provides access to the previous function or
 * property.  Must return functions to be used for
 * name.
 *
 *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',
 *       function (_super) {
 *       }
 *     , function (_super) {
 *       }
 *     );
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.have.length(3);
 *     expect(myFoo).to.have.length.above(3);
 *
 * @param {Object} ctx object whose method / property is to be overwritten
 * @param {String} name of method / property to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @param {Function} chainingBehavior function that returns a function to be used for property
 * @name overwriteChainableMethod
 * @api public
 */

module.exports = function (ctx, name, method, chainingBehavior) {
  var chainableBehavior = ctx.__methods[name];

  var _chainingBehavior = chainableBehavior.chainingBehavior;
  chainableBehavior.chainingBehavior = function () {
    var result = chainingBehavior(_chainingBehavior).call(this);
    return result === undefined ? this : result;
  };

  var _method = chainableBehavior.method;
  chainableBehavior.method = function () {
    var result = method(_method).apply(this, arguments);
    return result === undefined ? this : result;
  };
};

},{}],31:[function(require,module,exports){
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteMethod (ctx, name, fn)
 *
 * Overwites an already existing method and provides
 * access to previous function. Must return function
 * to be used for name.
 *
 *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {
 *       return function (str) {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.value).to.equal(str);
 *         } else {
 *           _super.apply(this, arguments);
 *         }
 *       }
 *     });
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteMethod('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.equal('bar');
 *
 * @param {Object} ctx object whose method is to be overwritten
 * @param {String} name of method to overwrite
 * @param {Function} method function that returns a function to be used for name
 * @name overwriteMethod
 * @api public
 */

module.exports = function (ctx, name, method) {
  var _method = ctx[name]
    , _super = function () { return this; };

  if (_method && 'function' === typeof _method)
    _super = _method;

  ctx[name] = function () {
    var result = method(_super).apply(this, arguments);
    return result === undefined ? this : result;
  }
};

},{}],32:[function(require,module,exports){
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### overwriteProperty (ctx, name, fn)
 *
 * Overwites an already existing property getter and provides
 * access to previous value. Must return function to use as getter.
 *
 *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {
 *       return function () {
 *         var obj = utils.flag(this, 'object');
 *         if (obj instanceof Foo) {
 *           new chai.Assertion(obj.name).to.equal('bar');
 *         } else {
 *           _super.call(this);
 *         }
 *       }
 *     });
 *
 *
 * Can also be accessed directly from `chai.Assertion`.
 *
 *     chai.Assertion.overwriteProperty('foo', fn);
 *
 * Then can be used as any other assertion.
 *
 *     expect(myFoo).to.be.ok;
 *
 * @param {Object} ctx object whose property is to be overwritten
 * @param {String} name of property to overwrite
 * @param {Function} getter function that returns a getter function to be used for name
 * @name overwriteProperty
 * @api public
 */

module.exports = function (ctx, name, getter) {
  var _get = Object.getOwnPropertyDescriptor(ctx, name)
    , _super = function () {};

  if (_get && 'function' === typeof _get.get)
    _super = _get.get

  Object.defineProperty(ctx, name,
    { get: function () {
        var result = getter(_super).call(this);
        return result === undefined ? this : result;
      }
    , configurable: true
  });
};

},{}],33:[function(require,module,exports){
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependancies
 */

var flag = require('./flag');

/**
 * # test(object, expression)
 *
 * Test and object for expression.
 *
 * @param {Object} object (constructed Assertion)
 * @param {Arguments} chai.Assertion.prototype.assert arguments
 */

module.exports = function (obj, args) {
  var negate = flag(obj, 'negate')
    , expr = args[0];
  return negate ? !expr : expr;
};

},{"./flag":20}],34:[function(require,module,exports){
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/**
 * ### transferFlags(assertion, object, includeAll = true)
 *
 * Transfer all the flags for `assertion` to `object`. If
 * `includeAll` is set to `false`, then the base Chai
 * assertion flags (namely `object`, `ssfi`, and `message`)
 * will not be transferred.
 *
 *
 *     var newAssertion = new Assertion();
 *     utils.transferFlags(assertion, newAssertion);
 *
 *     var anotherAsseriton = new Assertion(myObj);
 *     utils.transferFlags(assertion, anotherAssertion, false);
 *
 * @param {Assertion} assertion the assertion to transfer the flags from
 * @param {Object} object the object to transfer the flags too; usually a new assertion
 * @param {Boolean} includeAll
 * @name getAllFlags
 * @api private
 */

module.exports = function (assertion, object, includeAll) {
  var flags = assertion.__flags || (assertion.__flags = Object.create(null));

  if (!object.__flags) {
    object.__flags = Object.create(null);
  }

  includeAll = arguments.length === 3 ? includeAll : true;

  for (var flag in flags) {
    if (includeAll ||
        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {
      object.__flags[flag] = flags[flag];
    }
  }
};

},{}],35:[function(require,module,exports){
/*!
 * Chai - type utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Arguments]': 'arguments'
  , '[object Array]': 'array'
  , '[object Date]': 'date'
  , '[object Function]': 'function'
  , '[object Number]': 'number'
  , '[object RegExp]': 'regexp'
  , '[object String]': 'string'
};

/**
 * ### type(object)
 *
 * Better implementation of `typeof` detection that can
 * be used cross-browser. Handles the inconsistencies of
 * Array, `null`, and `undefined` detection.
 *
 *     utils.type({}) // 'object'
 *     utils.type(null) // `null'
 *     utils.type(undefined) // `undefined`
 *     utils.type([]) // `array`
 *
 * @param {Mixed} object to detect type of
 * @name type
 * @api private
 */

module.exports = function (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
};

},{}],36:[function(require,module,exports){
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */

function exclude () {
  var excludes = [].slice.call(arguments);

  function excludeProps (res, obj) {
    Object.keys(obj).forEach(function (key) {
      if (!~excludes.indexOf(key)) res[key] = obj[key];
    });
  }

  return function extendExclude () {
    var args = [].slice.call(arguments)
      , i = 0
      , res = {};

    for (; i < args.length; i++) {
      excludeProps(res, args[i]);
    }

    return res;
  };
};

/*!
 * Primary Exports
 */

module.exports = AssertionError;

/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */

function AssertionError (message, _props, ssf) {
  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')
    , props = extend(_props || {});

  // default values
  this.message = message || 'Unspecified AssertionError';
  this.showDiff = false;

  // copy from properties
  for (var key in props) {
    this[key] = props[key];
  }

  // capture stack trace
  ssf = ssf || arguments.callee;
  if (ssf && Error.captureStackTrace) {
    Error.captureStackTrace(this, ssf);
  }
}

/*!
 * Inherit from Error.prototype
 */

AssertionError.prototype = Object.create(Error.prototype);

/*!
 * Statically set name
 */

AssertionError.prototype.name = 'AssertionError';

/*!
 * Ensure correct constructor
 */

AssertionError.prototype.constructor = AssertionError;

/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */

AssertionError.prototype.toJSON = function (stack) {
  var extend = exclude('constructor', 'toJSON', 'stack')
    , props = extend({ name: this.name }, this);

  // include stack if exists and not turned off
  if (false !== stack && this.stack) {
    props.stack = this.stack;
  }

  return props;
};

},{}],37:[function(require,module,exports){
module.exports = require('./lib/eql');

},{"./lib/eql":38}],38:[function(require,module,exports){
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Module dependencies
 */

var type = require('type-detect');

/*!
 * Buffer.isBuffer browser shim
 */

var Buffer;
try { Buffer = require('buffer').Buffer; }
catch(ex) {
  Buffer = {};
  Buffer.isBuffer = function() { return false; }
}

/*!
 * Primary Export
 */

module.exports = deepEqual;

/**
 * Assert super-strict (egal) equality between
 * two objects of any type.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @param {Array} memoised (optional)
 * @return {Boolean} equal match
 */

function deepEqual(a, b, m) {
  if (sameValue(a, b)) {
    return true;
  } else if ('date' === type(a)) {
    return dateEqual(a, b);
  } else if ('regexp' === type(a)) {
    return regexpEqual(a, b);
  } else if (Buffer.isBuffer(a)) {
    return bufferEqual(a, b);
  } else if ('arguments' === type(a)) {
    return argumentsEqual(a, b, m);
  } else if (!typeEqual(a, b)) {
    return false;
  } else if (('object' !== type(a) && 'object' !== type(b))
  && ('array' !== type(a) && 'array' !== type(b))) {
    return sameValue(a, b);
  } else {
    return objectEqual(a, b, m);
  }
}

/*!
 * Strict (egal) equality test. Ensures that NaN always
 * equals NaN and `-0` does not equal `+0`.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} equal match
 */

function sameValue(a, b) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  return a !== a && b !== b;
}

/*!
 * Compare the types of two given objects and
 * return if they are equal. Note that an Array
 * has a type of `array` (not `object`) and arguments
 * have a type of `arguments` (not `array`/`object`).
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function typeEqual(a, b) {
  return type(a) === type(b);
}

/*!
 * Compare two Date objects by asserting that
 * the time values are equal using `saveValue`.
 *
 * @param {Date} a
 * @param {Date} b
 * @return {Boolean} result
 */

function dateEqual(a, b) {
  if ('date' !== type(b)) return false;
  return sameValue(a.getTime(), b.getTime());
}

/*!
 * Compare two regular expressions by converting them
 * to string and checking for `sameValue`.
 *
 * @param {RegExp} a
 * @param {RegExp} b
 * @return {Boolean} result
 */

function regexpEqual(a, b) {
  if ('regexp' !== type(b)) return false;
  return sameValue(a.toString(), b.toString());
}

/*!
 * Assert deep equality of two `arguments` objects.
 * Unfortunately, these must be sliced to arrays
 * prior to test to ensure no bad behavior.
 *
 * @param {Arguments} a
 * @param {Arguments} b
 * @param {Array} memoize (optional)
 * @return {Boolean} result
 */

function argumentsEqual(a, b, m) {
  if ('arguments' !== type(b)) return false;
  a = [].slice.call(a);
  b = [].slice.call(b);
  return deepEqual(a, b, m);
}

/*!
 * Get enumerable properties of a given object.
 *
 * @param {Object} a
 * @return {Array} property names
 */

function enumerable(a) {
  var res = [];
  for (var key in a) res.push(key);
  return res;
}

/*!
 * Simple equality for flat iterable objects
 * such as Arrays or Node.js buffers.
 *
 * @param {Iterable} a
 * @param {Iterable} b
 * @return {Boolean} result
 */

function iterableEqual(a, b) {
  if (a.length !==  b.length) return false;

  var i = 0;
  var match = true;

  for (; i < a.length; i++) {
    if (a[i] !== b[i]) {
      match = false;
      break;
    }
  }

  return match;
}

/*!
 * Extension to `iterableEqual` specifically
 * for Node.js Buffers.
 *
 * @param {Buffer} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function bufferEqual(a, b) {
  if (!Buffer.isBuffer(b)) return false;
  return iterableEqual(a, b);
}

/*!
 * Block for `objectEqual` ensuring non-existing
 * values don't get in.
 *
 * @param {Mixed} object
 * @return {Boolean} result
 */

function isValue(a) {
  return a !== null && a !== undefined;
}

/*!
 * Recursively check the equality of two objects.
 * Once basic sameness has been established it will
 * defer to `deepEqual` for each enumerable key
 * in the object.
 *
 * @param {Mixed} a
 * @param {Mixed} b
 * @return {Boolean} result
 */

function objectEqual(a, b, m) {
  if (!isValue(a) || !isValue(b)) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  var i;
  if (m) {
    for (i = 0; i < m.length; i++) {
      if ((m[i][0] === a && m[i][1] === b)
      ||  (m[i][0] === b && m[i][1] === a)) {
        return true;
      }
    }
  } else {
    m = [];
  }

  try {
    var ka = enumerable(a);
    var kb = enumerable(b);
  } catch (ex) {
    return false;
  }

  ka.sort();
  kb.sort();

  if (!iterableEqual(ka, kb)) {
    return false;
  }

  m.push([ a, b ]);

  var key;
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], m)) {
      return false;
    }
  }

  return true;
}

},{"buffer":3,"type-detect":39}],39:[function(require,module,exports){
module.exports = require('./lib/type');

},{"./lib/type":40}],40:[function(require,module,exports){
/*!
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Primary Exports
 */

var exports = module.exports = getType;

/*!
 * Detectable javascript natives
 */

var natives = {
    '[object Array]': 'array'
  , '[object RegExp]': 'regexp'
  , '[object Function]': 'function'
  , '[object Arguments]': 'arguments'
  , '[object Date]': 'date'
};

/**
 * ### typeOf (obj)
 *
 * Use several different techniques to determine
 * the type of object being tested.
 *
 *
 * @param {Mixed} object
 * @return {String} object type
 * @api public
 */

function getType (obj) {
  var str = Object.prototype.toString.call(obj);
  if (natives[str]) return natives[str];
  if (obj === null) return 'null';
  if (obj === undefined) return 'undefined';
  if (obj === Object(obj)) return 'object';
  return typeof obj;
}

exports.Library = Library;

/**
 * ### Library
 *
 * Create a repository for custom type detection.
 *
 * ```js
 * var lib = new type.Library;
 * ```
 *
 */

function Library () {
  this.tests = {};
}

/**
 * #### .of (obj)
 *
 * Expose replacement `typeof` detection to the library.
 *
 * ```js
 * if ('string' === lib.of('hello world')) {
 *   // ...
 * }
 * ```
 *
 * @param {Mixed} object to test
 * @return {String} type
 */

Library.prototype.of = getType;

/**
 * #### .define (type, test)
 *
 * Add a test to for the `.test()` assertion.
 *
 * Can be defined as a regular expression:
 *
 * ```js
 * lib.define('int', /^[0-9]+$/);
 * ```
 *
 * ... or as a function:
 *
 * ```js
 * lib.define('bln', function (obj) {
 *   if ('boolean' === lib.of(obj)) return true;
 *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];
 *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();
 *   return !! ~blns.indexOf(obj);
 * });
 * ```
 *
 * @param {String} type
 * @param {RegExp|Function} test
 * @api public
 */

Library.prototype.define = function (type, test) {
  if (arguments.length === 1) return this.tests[type];
  this.tests[type] = test;
  return this;
};

/**
 * #### .test (obj, test)
 *
 * Assert that an object is of type. Will first
 * check natives, and if that does not pass it will
 * use the user defined custom tests.
 *
 * ```js
 * assert(lib.test('1', 'int'));
 * assert(lib.test('yes', 'bln'));
 * ```
 *
 * @param {Mixed} object
 * @param {String} type
 * @return {Boolean} result
 * @api public
 */

Library.prototype.test = function (obj, type) {
  if (type === getType(obj)) return true;
  var test = this.tests[type];

  if (test && 'regexp' === getType(test)) {
    return test.test(obj);
  } else if (test && 'function' === getType(test)) {
    return test(obj);
  } else {
    throw new ReferenceError('Type test "' + type + '" not defined or invalid.');
  }
};

},{}],41:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var undefined;

var isPlainObject = function isPlainObject(obj) {
	"use strict";
	if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval) {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	"use strict";
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === "boolean") {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if (typeof target !== "object" && typeof target !== "function" || target == undefined) {
			target = {};
	}

	for (; i < length; ++i) {
		// Only deal with non-null/undefined values
		if ((options = arguments[i]) != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],42:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    // Turn off strict mode for this function so we can assign to global.Q
    /* jshint strict: false */

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else {
        Q = definition();
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;

    function flush() {
        /* jshint loopfunc: true */

        while (head.next) {
            head = head.next;
            var task = head.task;
            head.task = void 0;
            var domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }

            try {
                task();

            } catch (e) {
                if (isNodeJS) {
                    // In node, uncaught exceptions are considered fatal errors.
                    // Re-throw them synchronously to interrupt flushing!

                    // Ensure continuation if the uncaught exception is suppressed
                    // listening "uncaughtException" events (as domains does).
                    // Continue in next event to avoid tick recursion.
                    if (domain) {
                        domain.exit();
                    }
                    setTimeout(flush, 0);
                    if (domain) {
                        domain.enter();
                    }

                    throw e;

                } else {
                    // In browsers, uncaught exceptions are not fatal.
                    // Re-throw them asynchronously to avoid slow-downs.
                    setTimeout(function() {
                       throw e;
                    }, 0);
                }
            }

            if (domain) {
                domain.exit();
            }
        }

        flushing = false;
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process !== "undefined" && process.nextTick) {
        // Node.js before 0.9. Note that some fake-Node environments, like the
        // Mocha test runner, introduce a `process` global without a `nextTick`.
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }

    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (isPromise(value)) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become fulfilled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be fulfilled
 */
Q.race = race;
function race(answerPs) {
    return promise(function(resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function(answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return isObject(object) &&
        typeof object.promiseDispatch === "function" &&
        typeof object.inspect === "function";
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return result.value;
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return exception.value;
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var countDown = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++countDown;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--countDown === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (countDown === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {String} custom error message (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, message) {
    return Q(object).timeout(ms, message);
};

Promise.prototype.timeout = function (ms, message) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        deferred.reject(new Error(message || "Timed out after " + ms + " ms"));
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))
},{"_process":8}],43:[function(require,module,exports){
/**
 * This is an in-memory cache for models. Models are cached by local id (_id) and remote id (defined by the mapping).
 * Lookups are performed against the cache when mapping.
 * @module cache
 */
var log = require('../vendor/operations.js/src/log');
var LocalCacheLogger = log.loggerWithName('LocalCache');
LocalCacheLogger.setLevel(log.Level.warn);
var RemoteCacheLogger = log.loggerWithName('RemoteCache');
RemoteCacheLogger.setLevel(log.Level.warn);
var InternalSiestaError = require('./error').InternalSiestaError;
var util = require('./util');


var localCacheById = {};
var localCache = {};


var remoteCache = {};

function reset() {
    remoteCache = {};
    localCacheById = {};
    localCache = {};
}

reset();

/**
 * Return the object in the cache given a local id (_id)
 * @param  {String} localId
 * @return {SiestaModel}
 */
function getViaLocalId(localId) {
    var obj = localCacheById[localId];
    if (obj) {
        if (LocalCacheLogger.debug.isEnabled)
            LocalCacheLogger.debug('Local cache hit: ' + obj._dump(true));
    } else {
        if (LocalCacheLogger.debug.isEnabled)
            LocalCacheLogger.debug('Local cache miss: ' + localId);
    }
    return obj;
}

/**
 * Return the singleton object given a singleton mapping.
 * @param  {Mapping} mapping
 * @return {SiestaModel}
 */
function getSingleton(mapping) {
    var mappingName = mapping.type;
    var collectionName = mapping.collection;
    var collectionCache = localCache[collectionName];
    if (collectionCache) {
        var typeCache = collectionCache[mappingName];
        if (typeCache) {
            var objs = [];
            for (var prop in typeCache) {
                if (typeCache.hasOwnProperty(prop)) {
                    objs.push(typeCache[prop]);
                }
            }
            if (objs.length > 1) {
                throw new InternalSiestaError('A singleton mapping has more than 1 object in the cache! This is a serious error. ' +
                    'Either a mapping has been modified after objects have already been created, or something has gone' +
                    'very wrong. Please file a bug report if the latter.');
            } else if (objs.length) {
                return objs[0];
            }
        }
    }
    return null;
}

/**
 * Given a remote identifier and an options object that describes mapping/collection,
 * return the model if cached.
 * @param  {String} remoteId
 * @param  {Object} opts
 * @return {SiestaModel}
 */
function getViaRemoteId(remoteId, opts) {
    var type = opts.mapping.type;
    var collection = opts.mapping.collection;
    var collectionCache = remoteCache[collection];
    if (collectionCache) {
        var typeCache = remoteCache[collection][type];
        if (typeCache) {
            var obj = typeCache[remoteId];
            if (obj) {
                if (RemoteCacheLogger.debug.isEnabled)
                    RemoteCacheLogger.debug('Remote cache hit: ' + obj._dump(true));
            } else {
                if (RemoteCacheLogger.debug.isEnabled)
                    RemoteCacheLogger.debug('Remote cache miss: ' + remoteId);
            }
            return obj;
        }
    }
    if (RemoteCacheLogger.debug.isEnabled)
        RemoteCacheLogger.debug('Remote cache miss: ' + remoteId);
    return null;
}

/**
 * Insert an objet into the cache using a remote identifier defined by the mapping.
 * @param  {SiestaModel} obj
 * @param  {String} remoteId
 * @param  {String} previousRemoteId If remote id has been changed, this is the old remote identifier
 */
function remoteInsert(obj, remoteId, previousRemoteId) {
    if (obj) {
        var collection = obj.mapping.collection;
        if (collection) {
            if (!remoteCache[collection]) {
                remoteCache[collection] = {};
            }
            var type = obj.mapping.type;
            if (type) {
                if (!remoteCache[collection][type]) {
                    remoteCache[collection][type] = {};
                }
                if (previousRemoteId) {
                    remoteCache[collection][type][previousRemoteId] = null;
                }
                var cachedObject = remoteCache[collection][type][remoteId];
                if (!cachedObject) {
                    remoteCache[collection][type][remoteId] = obj;
                    if (RemoteCacheLogger.debug.isEnabled)
                        RemoteCacheLogger.debug('Remote cache insert: ' + obj._dump(true));
                    if (RemoteCacheLogger.trace.isEnabled)
                        RemoteCacheLogger.trace('Remote cache now looks like: ' + remoteDump(true))
                } else {
                    // Something has gone really wrong. Only one object for a particular collection/type/remoteid combo
                    // should ever exist.
                    if (obj != cachedObject) {
                        var message = 'Object ' + collection.toString() + ':' + type.toString() + '[' + obj.mapping.id + '="' + remoteId + '"] already exists in the cache.' +
                            ' This is a serious error, please file a bug report if you are experiencing this out in the wild';
                        RemoteCacheLogger.error(message, {
                            obj: obj,
                            cachedObject: cachedObject
                        });
                        util.printStackTrace();
                        throw new InternalSiestaError(message);
                    } else {
                        if (RemoteCacheLogger.debug.isEnabled)
                            RemoteCacheLogger.debug('Object has already been inserted: ' + obj._dump(true));
                    }

                }
            } else {
                throw new InternalSiestaError('Mapping has no type', {
                    mapping: obj.mapping,
                    obj: obj
                });
            }
        } else {
            throw new InternalSiestaError('Mapping has no collection', {
                mapping: obj.mapping,
                obj: obj
            });
        }
    } else {
        var msg = 'Must pass an object when inserting to cache';
        RemoteCacheLogger.error(msg);
        throw new InternalSiestaError(msg);
    }
}

/**
 * Dump the remote id cache
 * @param  {boolean} asJson Whether or not to apply JSON.stringify
 * @return {String|Object}
 */
function remoteDump(asJson) {
    var dumpedRestCache = {};
    for (var coll in remoteCache) {
        if (remoteCache.hasOwnProperty(coll)) {
            var dumpedCollCache = {};
            dumpedRestCache[coll] = dumpedCollCache;
            var collCache = remoteCache[coll];
            for (var mapping in collCache) {
                if (collCache.hasOwnProperty(mapping)) {
                    var dumpedMappingCache = {};
                    dumpedCollCache[mapping] = dumpedMappingCache;
                    var mappingCache = collCache[mapping];
                    for (var remoteId in mappingCache) {
                        if (mappingCache.hasOwnProperty(remoteId)) {
                            if (mappingCache[remoteId]) {
                                dumpedMappingCache[remoteId] = mappingCache[remoteId]._dump();
                            }
                        }
                    }
                }
            }
        }
    }
    return asJson ? JSON.stringify(dumpedRestCache, null, 4) : dumpedRestCache;

}

/**
 * Dump the local id (_id) cache
 * @param  {boolean} asJson Whether or not to apply JSON.stringify
 * @return {String|Object}
 */
function localDump(asJson) {
    var dumpedIdCache = {};
    for (var id in localCacheById) {
        if (localCacheById.hasOwnProperty(id)) {
            dumpedIdCache[id] = localCacheById[id]._dump()
        }
    }
    return asJson ? JSON.stringify(dumpedIdCache, null, 4) : dumpedIdCache;
}

/**
 * Dump to the cache.
 * @param  {boolean} asJson Whether or not to apply JSON.stringify
 * @return {String|Object}
 */
function dump(asJson) {
    var dumped = {
        localCache: localDump(),
        remoteCache: remoteDump()
    };
    return asJson ? JSON.stringify(dumped, null, 4) : dumped;
}

function _remoteCache() {
    return remoteCache
}

function _localCache() {
    return localCacheById;
}

/**
 * Query the cache
 * @param  {Object} opts Object describing the query
 * @return {SiestaModel}
 * @example
 * ```js
 * cache.get({_id: '5'}); // Query by local id
 * cache.get({remoteId: '5', mapping: myMapping}); // Query by remote id
 * ```
 */
function get(opts) {
    if (LocalCacheLogger.debug.isEnabled) LocalCacheLogger.debug('get', opts);
    var obj, idField, remoteId;
    var localId = opts._id;
    if (localId) {
        obj = getViaLocalId(localId);
        if (obj) {
            return obj;
        } else {
            if (opts.mapping) {
                idField = opts.mapping.id;
                remoteId = opts[idField];
                if (LocalCacheLogger.debug.isEnabled) LocalCacheLogger.debug(idField + '=' + remoteId);
                return getViaRemoteId(remoteId, opts);
            } else {
                return null;
            }
        }
    } else if (opts.mapping) {
        idField = opts.mapping.id;
        remoteId = opts[idField];
        if (remoteId) {
            return getViaRemoteId(remoteId, opts);
        } else if (opts.mapping.singleton) {
            return getSingleton(opts.mapping);
        }
    } else {
        LocalCacheLogger.warn('Invalid opts to cache', {
            opts: opts
        });
    }
    return null;
}

/**
 * Insert an objet into the cache.
 * @param  {SiestaModel} obj
 * @throws {InternalSiestaError} An object with _id/remoteId already exists. Not thrown if same obhect.
 */
function insert(obj) {
    var localId = obj._id;
    if (localId) {
        var collectionName = obj.mapping.collection;
        var mappingName = obj.mapping.type;
        if (!localCacheById[localId]) {
            if (LocalCacheLogger.debug.isEnabled)
                LocalCacheLogger.debug('Local cache insert: ' + obj._dump(true));
            localCacheById[localId] = obj;
            if (LocalCacheLogger.trace.isEnabled)
                LocalCacheLogger.trace('Local cache now looks like: ' + localDump(true));
            if (!localCache[collectionName]) localCache[collectionName] = {};
            if (!localCache[collectionName][mappingName]) localCache[collectionName][mappingName] = {};
            localCache[collectionName][obj.type][localId] = obj;
        } else {
            // Something has gone badly wrong here. Two objects should never exist with the same _id
            if (localCacheById[localId] != obj) {
                var message = 'Object with _id="' + localId.toString() + '" is already in the cache. ' +
                    'This is a serious error. Please file a bug report if you are experiencing this out in the wild';
                LocalCacheLogger.error(message);
                throw new InternalSiestaError(message);
            }
        }
    }
    var idField = obj.idField;
    var remoteId = obj[idField];
    if (remoteId) {
        remoteInsert(obj, remoteId);
    } else {
        if (RemoteCacheLogger.debug.isEnabled)
            RemoteCacheLogger.debug('No remote id ("' + idField + '") so wont be placing in the remote cache', obj);
    }
}

/**
 * Returns true if object is in the cache
 * @param  {SiestaModel} obj
 * @return {boolean}
 */
function contains(obj) {
    var q = {
        _id: obj._id
    };
    var mapping = obj.mapping;
    if (mapping.id) {
        if (obj[mapping.id]) {
            q.mapping = mapping;
            q[mapping.id] = obj[mapping.id];
        }
    }
    return !!get(q);
}

/**
 * Removes the object from the cache (if it's actually in the cache) otherwises throws an error.
 * @param  {SiestaModel} obj
 * @throws {InternalSiestaError} If object already in the cache.
 */
function remove(obj) {
    if (contains(obj)) {
        var collectionName = obj.mapping.collection;
        var mappingName = obj.mapping.type;
        var _id = obj._id;
        if (!mappingName) throw InternalSiestaError('No mapping name');
        if (!collectionName) throw InternalSiestaError('No collection name');
        if (!_id) throw InternalSiestaError('No _id');
        delete localCache[collectionName][mappingName][_id];
        delete localCacheById[_id];
        if (obj.mapping.id) {
            var remoteId = obj[obj.mapping.id];
            delete remoteCache[collectionName][mappingName][remoteId];
        }
    } else {
        throw new InternalSiestaError('Object was not in cache.');
    }
}


function dump(asJson) {
    var dumped = {
        localCache: localDump(),
        remoteCache: remoteDump()
    };
    return asJson ? JSON.stringify(dumped, null, 4) : dumped;
}

exports._remoteCache = _remoteCache;
exports._localCache = _localCache;
Object.defineProperty(exports, '_localCacheByType', {
    get: function() {
        return localCache;
    }
});
exports.get = get;
exports.insert = insert;
exports.remoteInsert = remoteInsert;
exports.reset = reset;
exports._dump = dump;
exports.contains = contains;
exports.remove = remove;
},{"../vendor/operations.js/src/log":107,"./error":47,"./util":60}],44:[function(require,module,exports){
/**
 * The changes module deals with changes to SiestaModel instances. In the in-memory case this 
 * just means that notifications are sent on any change. If the storage module is being used,
 * the changes module is extended to deal with merging changes into whatever persistant storage
 * method is being used.
 * @module changes
 */

var defineSubProperty = require('./misc').defineSubProperty;
var notificationCentre = require('./notificationCentre').notificationCentre;
var InternalSiestaError = require('./error').InternalSiestaError;
var log = require('../vendor/operations.js/src/log');
var collectionRegistry = require('./collectionRegistry').CollectionRegistry;

var Logger = log.loggerWithName('changes');
Logger.setLevel(log.Level.warn);

/**
 * Constants that describe change events.
 * Set => A new value is assigned to an attribute/relationship
 * Splice => All javascript array operations are described as splices.
 * Delete => Used in the case where objects are removed from an array, but array order is not known in advance.
 * Remove => Object deletion events
 * New => Object creation events
 * @type {Object}
 */
var ChangeType = {
    Set: 'Set',
    Splice: 'Splice',
    Delete: 'Delete',
    New: 'New',
    Remove: 'Remove'
};

/**
 * Represents an individual change.
 * @param opts
 * @constructor
 */
function Change(opts) {
    this._opts = opts;
    if (!this._opts) {
        this._opts = {};
    }
    defineSubProperty.call(this, 'collection', this._opts);
    defineSubProperty.call(this, 'mapping', this._opts);
    defineSubProperty.call(this, '_id', this._opts);
    defineSubProperty.call(this, 'field', this._opts);
    defineSubProperty.call(this, 'type', this._opts);
    defineSubProperty.call(this, 'index', this._opts);
    defineSubProperty.call(this, 'added', this._opts);
    defineSubProperty.call(this, 'addedId', this._opts);
    defineSubProperty.call(this, 'removed', this._opts);
    defineSubProperty.call(this, 'removedId', this._opts);
    defineSubProperty.call(this, 'new', this._opts);
    defineSubProperty.call(this, 'newId', this._opts);
    defineSubProperty.call(this, 'old', this._opts);
    defineSubProperty.call(this, 'oldId', this._opts);
    defineSubProperty.call(this, 'obj', this._opts);
}

Change.prototype._dump = function (json) {
    var dumped = {};
    dumped.collection = (typeof this.collection) == 'string' ? this.collection : this.collection._dump();
    dumped.mapping = (typeof this.mapping) == 'string' ? this.mapping : this.mapping.type;
    dumped._id = this._id;
    dumped.field = this.field;
    dumped.type = this.type;
    if (this.index) dumped.index = this.index;
    if (this.added) dumped.added = _.map(this.added, function (x) {return x._dump()});
    if (this.removed) dumped.removed = _.map(this.removed, function (x) {return x._dump()});
    if (this.old) dumped.old = this.old;
    if (this.new) dumped.new = this.new;
    return json ? JSON.stringify(dumped, null, 4) : dumped;
};

/**
 * Broadcas
 * @param  {String} collectionName
 * @param  {String} mappingName
 * @param  {Object} c an options dictionary representing the change
 * @return {[type]}
 */
function broadcast(collectionName, mappingName, c) {
    if (Logger.trace.isEnabled) Logger.trace('Sending notification "' + collectionName + '" of type ' + c.type);
    notificationCentre.emit(collectionName, c);
    var mappingNotif = collectionName + ':' + mappingName;
    if (Logger.trace.isEnabled) Logger.trace('Sending notification "' + mappingNotif + '" of type ' + c.type);
    notificationCentre.emit(mappingNotif, c);
    var genericNotif = 'Siesta';
    if (Logger.trace.isEnabled) Logger.trace('Sending notification "' + genericNotif + '" of type ' + c.type);
    notificationCentre.emit(genericNotif, c);
    var localIdNotif = c._id;
    if (Logger.trace.isEnabled) Logger.trace('Sending notification "' + localIdNotif + '" of type ' + c.type);
    notificationCentre.emit(localIdNotif, c);
    var collection = collectionRegistry[collectionName];
    if (!collection) {
        var err = 'No such collection "' + collectionName + '"';
        Logger.error(err, collectionRegistry);
        throw new InternalSiestaError(err);
    }
    var mapping = collection[mappingName];
    if (!mapping) {
        var err = 'No such mapping "' + mappingName + '"';
        Logger.error(err, collectionRegistry);
        throw new InternalSiestaError(err);
    }
    if (mapping.id && c.obj[mapping.id]) {
        var remoteIdNotif = collectionName + ':' + mappingName + ':' + c.obj[mapping.id];
        if (Logger.trace.isEnabled) Logger.trace('Sending notification "' + remoteIdNotif + '" of type ' + c.type);
        notificationCentre.emit(remoteIdNotif, c);
    }
}

/**
 * Throw an error if the change is incorrect.
 * @param changeOpts
 * @throws {InternalSiestaError} If change options are invalid
 */
function validateChange(changeOpts) {
    if (!changeOpts.mapping) throw new InternalSiestaError('Must pass a mapping');
    if (!changeOpts.collection) throw new InternalSiestaError('Must pass a collection');
    if (!changeOpts._id) throw new InternalSiestaError('Must pass a local identifier');
    if (!changeOpts.obj) throw new InternalSiestaError('Must pass the object');
}

/**
 * Register that a change has been made.
 * @param opts
 * @return {Change} The constructed change
 */
function registerChange(opts) {
    validateChange(opts);
    var collection = opts.collection;
    var mapping = opts.mapping;
    var c = new Change(opts);
    broadcast(collection, mapping, c);
    return c;
}

exports.Change = Change;
exports.registerChange = registerChange;
exports.validateChange = validateChange;
exports.ChangeType = ChangeType;
},{"../vendor/operations.js/src/log":107,"./collectionRegistry":46,"./error":47,"./misc":51,"./notificationCentre":52}],45:[function(require,module,exports){
/**
 * @module collection
 */

var log = require('../vendor/operations.js/src/log');
var Logger = log.loggerWithName('Collection');
Logger.setLevel(log.Level.warn);

var CollectionRegistry = require('./collectionRegistry').CollectionRegistry;
var Operation = require('../vendor/operations.js/src/operation').Operation;
var InternalSiestaError = require('./error').InternalSiestaError;
var Mapping = require('./mapping').Mapping;
var extend = require('extend');
var observe = require('../vendor/observe-js/src/observe').Platform;

var util = require('./util');
var _ = util._;

var q = require('q');

var cache = require('./cache');

var SAFE_METHODS = ['GET', 'HEAD', 'TRACE', 'OPTIONS', 'CONNECT'];
var UNSAFE_METHODS = ['PUT', 'PATCH', 'POST', 'DELETE'];

/**
 * A collection describes a set of models and optionally a REST API which we would
 * like to model.
 *
 * @param name
 * @constructor
 *
 *
 * @example
 * ```js
 * var GitHub = new siesta.Collection('GitHub')
 * // ... configure mappings, descriptors etc ...
 * GitHub.install(function () {
 *     // ... carry on.
 * });
 * ```
 */
function Collection(name) {
    var self = this;
    if (!this) return new Collection(name);
    if (!name) throw new InternalSiestaError('Collection must have a name');
    this._name = name;
    this._docId = 'Collection_' + this._name;
    this._rawMappings = {};
    this._mappings = {};
    /**
     * The URL of the API e.g. http://api.github.com
     * @type {string}
     */
    this.baseURL = '';

    /**
     * Set to true if installation has succeeded. You cannot use the collectio
     * @type {boolean}
     */
    this.installed = false;
    CollectionRegistry.register(this);

    /**
     *
     * @type {string}
     */
    Object.defineProperty(this, 'name', {
        get: function() {
            return self._name;
        }
    });
}

/**
 * Ensure mappings are installed.
 * @param callback
 */
Collection.prototype.install = function(callback) {
    var deferred = q.defer();
    var self = this;
    if (!this.installed) {
        var mappingsToInstall = [];
        for (var name in this._mappings) {
            if (this._mappings.hasOwnProperty(name)) {
                var mapping = this._mappings[name];
                mappingsToInstall.push(mapping);
            }
        }
        if (Logger.info.isEnabled)
            Logger.info('There are ' + mappingsToInstall.length.toString() + ' mappings to install');
        if (mappingsToInstall.length) {
            var operations = _.map(mappingsToInstall, function(m) {
                return new Operation('Install Mapping', _.bind(m.install, m));
            });
            var op = new Operation('Install Mappings', operations);
            op.completion = function() {
                if (op.failed) {
                    Logger.error('Failed to install collection', op.error);
                    self._finaliseInstallation(op.error, callback);
                } else {
                    self.installed = true;
                    var errors = [];
                    _.each(mappingsToInstall, function(m) {
                        if (Logger.info.isEnabled)
                            Logger.info('Installing relationships for mapping with name "' + m.type + '"');
                        var err = m.installRelationships();
                        if (err) errors.push(err);
                    });
                    if (!errors.length) {
                        _.each(mappingsToInstall, function(m) {
                            if (Logger.info.isEnabled)
                                Logger.info('Installing reverse relationships for mapping with name "' + m.type + '"');
                            var err = m.installReverseRelationships();
                            if (err) errors.push(err);
                        });
                    }
                    var err;
                    if (errors.length == 1) {
                        err = errors[0];
                    } else if (errors.length) {
                        err = errors;
                    }
                    self._finaliseInstallation(err, callback);
                }
            };
            op.start();
        } else {
            self._finaliseInstallation(null, callback);
        }
    } else {
        var err = new InternalSiestaError('Collection "' + this._name + '" has already been installed');
        self._finaliseInstallation(err, callback);
    }
    return deferred.promise;
};

/**
 * Mark this collection as installed, and place the collection on the global Siesta object.
 * @param  {Object}   err
 * @param  {Function} callback
 */
Collection.prototype._finaliseInstallation = function(err, callback) {
    if (!err) {
        this.installed = true;
        var index = require('../index');
        index[this._name] = this;
    }
    if (callback) callback(err);
};

/**
 * Given the name of a mapping and an options object describing the mapping, creating a Mapping
 * object, install it and return it.
 * @param  {String} name
 * @param  {Object} mapping
 * @return {Mapping}
 */
Collection.prototype._mapping = function(name, opts) {
    if (name) {
        this._rawMappings[name] = opts;
        var opts = extend(true, {}, opts);
        opts.type = name;
        opts.collection = this._name;
        var mappingObject = new Mapping(opts);
        this._mappings[name] = mappingObject;
        this[name] = mappingObject;
        return mappingObject;
    } else {
        throw new InternalSiestaError('No name specified when creating mapping');
    }
};

/**
 * Registers a mapping with this collection.
 * @param {String|Object} optsOrName An options object or the name of the mapping. Must pass options as second param if specify name.
 * @param {Object} opts Options if name already specified.
 * @return {Mapping}
 */
Collection.prototype.mapping = function() {
    var self = this;
    if (arguments.length) {
        if (arguments.length == 1) {
            if (util.isArray(arguments[0])) {
                return _.map(arguments[0], function(m) {
                    return self._mapping(m.name, m);
                });
            } else {
                return this._mapping(arguments[0].name, arguments[0]);
            }
        } else {
            if (typeof arguments[0] == 'string') {
                return this._mapping(arguments[0], arguments[1]);
            } else {
                return _.map(arguments, function(m) {
                    return self._mapping(m.name, m);
                });
            }
        }
    }
    return null;
};

Collection.prototype.descriptor = function(opts) {
    var descriptors = [];
    if (siesta.ext.httpEnabled) {
        var methods = siesta.ext.http._resolveMethod(opts.method);
        var unsafe = [];
        var safe = [];
        for (var i = 0; i < methods.length; i++) {
            var m = methods[i];
            if (UNSAFE_METHODS.indexOf(m) > -1) {
                unsafe.push(m);
            } else {
                safe.push(m);
            }
        }
        if (unsafe.length) {
            var requestDescriptor = extend({}, opts);
            requestDescriptor.method = unsafe;
            requestDescriptor = new siesta.ext.http.RequestDescriptor(requestDescriptor);
            siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(requestDescriptor);
            descriptors.push(requestDescriptor);
        }
        if (safe.length) {
            var responseDescriptor = extend({}, opts);
            responseDescriptor.method = safe;
            responseDescriptor = new siesta.ext.http.ResponseDescriptor(responseDescriptor);
            siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(responseDescriptor);
            descriptors.push(responseDescriptor);
        }
    } else {
        throw new InternalSiestaError('HTTP module not installed');
    }
    return descriptors;
};

/**
 * Dump this collection as JSON
 * @param  {Boolean} asJson Whether or not to apply JSON.stringify
 * @return {String|Object}
 */
Collection.prototype._dump = function(asJson) {
    var obj = {};
    obj.installed = this.installed;
    obj.docId = this._docId;
    obj.name = this._name;
    obj.baseURL = this.baseURL;
    return asJson ? JSON.stringify(obj, null, 4) : obj;
};


// /**
//  * Persist all changes to PouchDB.
//  * Note: Storage extension must be installed.
//  * @param callback
//  * @returns {Promise}
//  */
// Collection.prototype.save = function(callback) {
//     var deferred = q.defer();
//     callback = util.constructCallbackAndPromiseHandler(callback, deferred);
//     if (siesta.ext.storageEnabled) {
//         util.next(function() {
//             var mergeChanges = siesta.ext.storage.changes.mergeChanges;
//             mergeChanges(callback);
//         });
//     } else {
//         callback('Storage module not installed');
//     }
//     return deferred.promise;
// };


Collection.prototype._http = function(method) {
    if (siesta.ext.httpEnabled) {
        var args = Array.prototype.slice.call(arguments, 1);
        args.unshift(this);
        var f = siesta.ext.http[method];
        f.apply(f, args);
    } else {
        throw InternalSiestaError('HTTP module not enabled');
    }
}

/**
 * Send a GET request
 * @param {String} path The path to the resource we want to GET
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @package HTTP
 * @returns {Promise}
 */
Collection.prototype.GET = function() {
    _.partial(this._http, 'GET').apply(this, arguments);
};

/**
 * Send a OPTIONS request
 * @param {String} path The path to the resource to which we want to send an OPTIONS request
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.OPTIONS = function() {
    _.partial(this._http, 'OPTIONS').apply(this, arguments);
};

/**
 * Send a TRACE request
 * @param {path} path The path to the resource to which we want to send a TRACE request
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.TRACE = function() {
    _.partial(this._http, 'TRACE').apply(this, arguments);
};

/**
 * Send a HEAD request
 * @param {String} path The path to the resource to which we want to send a HEAD request
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.HEAD = function() {
    _.partial(this._http, 'HEAD').apply(this, arguments);
};

/**
 * Send a POST request
 * @param {String} path The path to the resource to which we want to send a POST request
 * @param {SiestaModel} model The model that we would like to POST
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.POST = function() {
    _.partial(this._http, 'POST').apply(this, arguments);
};

/**
 * Send a PUT request
 * @param {String} path The path to the resource to which we want to send a PUT request
 * @param {SiestaModel} model The model that we would like to PUT
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.PUT = function() {
    _.partial(this._http, 'PUT').apply(this, arguments);
};

/**
 * Send a PATCH request
 * @param {String} path The path to the resource to which we want to send a PATCH request
 * @param {SiestaModel} model The model that we would like to PATCH
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.PATCH = function() {
    _.partial(this._http, 'PATCH').apply(this, arguments);
};

/**
 * Send a DELETE request. Also removes the object.
 * @param {String} path The path to the resource to which we want to DELETE
 * @param {SiestaModel} model The model that we would like to PATCH
 * @param {Object|Function} optsOrCallback Either an options object or a callback if can use defaults
 * @param {Function} callback Callback if opts specified.
 * @returns {Promise}
 */
Collection.prototype.DELETE = function(path, object) {
    _.partial(this._http, 'DELETE').apply(this, arguments);
};

/**
 * Returns the number of objects in this collection.
 *
 * @param callback
 * @returns {Promise}
 */
Collection.prototype.count = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var tasks = _.map(this._mappings, function(m) {
        return _.bind(m.count, m);
    });
    util.parallel(tasks, function(err, ns) {
        var n;
        if (!err) {
            n = _.reduce(ns, function(m, r) {
                return m + r
            }, 0);
        }
        callback(err, n);
    });
    return deferred.promise;
};

exports.Collection = Collection;
},{"../index":1,"../vendor/observe-js/src/observe":106,"../vendor/operations.js/src/log":107,"../vendor/operations.js/src/operation":108,"./cache":43,"./collectionRegistry":46,"./error":47,"./mapping":49,"./util":60,"extend":41,"q":42}],46:[function(require,module,exports){
/**
 * @module collection 
 */
var _ = require('./util')._;

function CollectionRegistry() {
    if (!this) return new CollectionRegistry();
    this.collectionNames = [];
}

CollectionRegistry.prototype.register = function (collection) {
    var name = collection._name;
    this[name] = collection;
    this.collectionNames.push(name);
};

CollectionRegistry.prototype.reset = function () {
    var self = this;
    _.each(this.collectionNames, function (name) {
        delete self[name];
    });
    this.collectionNames = [];
};

exports.CollectionRegistry = new CollectionRegistry();
},{"./util":60}],47:[function(require,module,exports){
/**
 * @module error
 */

function InternalSiestaError(message, context, ssf) {
    this.message = message;
    this.context = context;
    // capture stack trace
    ssf = ssf || arguments.callee;
    if (ssf && Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
    }
}

InternalSiestaError.prototype = Object.create(Error.prototype);
InternalSiestaError.prototype.name = 'InternalSiestaError';
InternalSiestaError.prototype.constructor = InternalSiestaError;

exports.InternalSiestaError = InternalSiestaError;

},{}],48:[function(require,module,exports){
/**
 * @module relationships
 */

var proxy = require('./proxy')
    , RelationshipProxy = proxy.RelationshipProxy
    , Store = require('./store')
    , util = require('./util')
    , _ = util._
    , InternalSiestaError = require('./error').InternalSiestaError
    , coreChanges = require('./changes')
    , notificationCentre = require('./notificationCentre')
    , wrapArrayForAttributes = notificationCentre.wrapArray
    , SiestaModel = require('./object').SiestaModel
    , ArrayObserver = require('../vendor/observe-js/src/observe').ArrayObserver
    , ChangeType = require('./changes').ChangeType
    , q = require('q')
;

/**
 * [ManyToManyProxy description]
 * @param {Object} opts
 */
function ManyToManyProxy(opts) {
    RelationshipProxy.call(this, opts);
    var self = this;
    Object.defineProperty(this, 'isFault', {
        get: function () {
            if (self._id) {
                return !self.related;
            }
            return true;
        },
        set: function (v) {
            if (v) {
                self._id = undefined;
                self.related = null;
            }
            else {
                if (!self._id) {
                    self._id = [];
                    self.related = [];
                    wrapArray.call(self, self.related);
                }
            }
        }
    });
    this._reverseIsArray = true;
}


function clearReverse(removed) {
    var self = this;
    _.each(removed, function (removedObject) {
        var reverseProxy = proxy.getReverseProxyForObject.call(self, removedObject);
        var idx = reverseProxy._id.indexOf(self.object._id);
        proxy.makeChangesToRelatedWithoutObservations.call(reverseProxy, function (){
            proxy.splice.call(reverseProxy, idx, 1);
        });
    });
}

function setReverse(added) {
    var self = this;
    _.each(added, function (addedObject) {
        var reverseProxy = proxy.getReverseProxyForObject.call(self, addedObject);
        proxy.makeChangesToRelatedWithoutObservations.call(reverseProxy, function (){
            proxy.splice.call(reverseProxy, 0, 0, self.object);
        });
    });
}

function wrapArray(arr) {
    var self = this;
    wrapArrayForAttributes(arr, this.reverseName, this.object);
    if (!arr.oneToManyObserver) {
        arr.oneToManyObserver = new ArrayObserver(arr);
        var observerFunction = function (splices) {
            splices.forEach(function (splice) {
                var added = splice.addedCount ? arr.slice(splice.index, splice.index + splice.addedCount) : [];
                var removed = splice.removed;
                clearReverse.call(self, removed);
                setReverse.call(self, added);
                var mapping = proxy.getForwardMapping.call(self);
                coreChanges.registerChange({
                    collection: mapping.collection,
                    mapping: mapping.type,
                    _id: self.object._id,
                    field: proxy.getForwardName.call(self),
                    removed: removed,
                    added: added,
                    removedId: _.pluck(removed, '_id'),
                    addedId: _.pluck(added, '_id'),
                    type: ChangeType.Splice,
                    index: splice.index,
                    obj: self.object
                });
            });
        };
        arr.oneToManyObserver.open(observerFunction);
    }
}

ManyToManyProxy.prototype = Object.create(RelationshipProxy.prototype);

ManyToManyProxy.prototype.get = function (callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var self = this;
    if (this.isFault) {
        Store.get({_id: this._id}, function (err, stored) {
            if (err) {
                if (callback) callback(err);
            }
            else {
                self.related = stored;
                if (callback) callback(null, stored);
            }
        })
    }
    else {
        if (callback) callback(null, this.related);
    }
    return deferred.promise;
};

function validate(obj) {
    if (Object.prototype.toString.call(obj) != '[object Array]') {
            return 'Cannot assign scalar to many to many';
        }
    return null;
}

ManyToManyProxy.prototype.set = function (obj) {
    proxy.checkInstalled.call(this);
    var self = this;
    if (obj) {
        var errorMessage;
        if (errorMessage = validate.call(this, obj)) {
            return errorMessage;
        }
        else {
            proxy.clearReverseRelated.call(this);
            proxy.set.call(self, obj);
            wrapArray.call(self, obj);
            proxy.setReverse.call(self, obj);
        }
    }
    else {
        proxy.clearReverseRelated.call(this);
        proxy.set.call(self, obj);
    }
};

ManyToManyProxy.prototype.install = function (obj) {
    RelationshipProxy.prototype.install.call(this, obj);
    obj[ ('splice' + util.capitaliseFirstLetter(this.reverseName))] = _.bind(proxy.splice, this);
};

exports.ManyToManyProxy = ManyToManyProxy;
},{"../vendor/observe-js/src/observe":106,"./changes":44,"./error":47,"./notificationCentre":52,"./object":53,"./proxy":56,"./store":59,"./util":60,"q":42}],49:[function(require,module,exports){
/**
 * @module mapping
 */

var log = require('../vendor/operations.js/src/log');
var Logger = log.loggerWithName('Mapping');
Logger.setLevel(log.Level.warn);

var defineSubProperty = require('./misc').defineSubProperty;
var CollectionRegistry = require('./collectionRegistry').CollectionRegistry;
var InternalSiestaError = require('./error').InternalSiestaError;
var relationship = require('./relationship');
var RelationshipType = relationship.RelationshipType;
var Query = require('./query').Query;
var Operation = require('../vendor/operations.js/src/operation').Operation;
var BulkMappingOperation = require('./mappingOperation').BulkMappingOperation;
var SiestaModel = require('./object').SiestaModel;
var guid = require('./misc').guid;
var cache = require('./cache');
var store = require('./store');
var extend = require('extend');

var coreChanges = require('./changes');
var ChangeType = coreChanges.ChangeType;
var wrapArray = require('./notificationCentre').wrapArray;

var OneToManyProxy = require('./oneToManyProxy').OneToManyProxy;
var OneToOneProxy = require('./oneToOneProxy').OneToOneProxy;
var ManyToManyProxy = require('./manyToManyProxy').ManyToManyProxy;

var util = require('./util');
var _ = util._;
var q = require('q');

/**
 * 
 * @param {Object} opts
 */
function Mapping(opts) {
    var self = this;
    this._opts = opts;

    Object.defineProperty(this, '_fields', {
        get: function() {
            var fields = [];
            if (self._opts.id) {
                fields.push(self._opts.id);
            }
            if (self._opts.attributes) {
                _.each(self._opts.attributes, function(x) {
                    fields.push(x)
                });
            }
            return fields;
        },
        enumerable: true,
        configurable: true
    });

    /**
     * @name type
     * @type {String}
     */
    defineSubProperty.call(this, 'type', self._opts);

    /**
     * @name id
     * @type {String}
     */
    defineSubProperty.call(this, 'id', self._opts);
    defineSubProperty.call(this, 'collection', self._opts);
    defineSubProperty.call(this, 'attributes', self._opts);
    defineSubProperty.call(this, 'relationships', self._opts);
    defineSubProperty.call(this, 'indexes', self._opts);
    defineSubProperty.call(this, 'subclass', self._opts);
    defineSubProperty.call(this, 'singleton', self._opts);

    if (!this.relationships) {
        this.relationships = [];
    }

    if (!this.indexes) {
        this.indexes = [];
    }

    this._validateSubclass();

    this._installed = false;
    this._relationshipsInstalled = false;
    this._reverseRelationshipsInstalled = false;

    Object.defineProperty(this, 'installed', {
        get: function() {
            return self._installed && self._relationshipsInstalled && self._reverseRelationshipsInstalled;
        },
        enumerable: true,
        configurable: true
    });

}

/**
 * Ensure that any subclasses passed to the mapping are valid and working correctly.
 * @private
 */
Mapping.prototype._validateSubclass = function() {
    if (this.subclass && this.subclass !== SiestaModel) {
        var obj = new this.subclass(this);
        if (!obj.mapping) {
            throw new InternalSiestaError('Subclass for mapping "' + this.type + '" has not been configured correctly. ' +
                'Did you call super?');
        }
        if (this.subclass.prototype == SiestaModel.prototype) {
            throw new InternalSiestaError('Subclass for mapping "' + this.type + '" has not been configured correctly. ' +
                'You should use Object.create on SiestaModel prototype.');
        }
    }
};


Mapping.prototype.installRelationships = function() {
    if (!this._relationshipsInstalled) {
        var self = this;
        self._relationships = [];
        if (self._opts.relationships) {
            for (var name in self._opts.relationships) {
                if (Logger.debug.isEnabled)
                    Logger.debug(self.type + ': configuring relationship ' + name);
                if (self._opts.relationships.hasOwnProperty(name)) {
                    var relationship = self._opts.relationships[name];
                    if (relationship.type == RelationshipType.OneToMany ||
                        relationship.type == RelationshipType.OneToOne ||
                        relationship.type == RelationshipType.ManyToMany) {
                        var mappingName = relationship.mapping;
                        if (Logger.debug.isEnabled)
                            Logger.debug('reverseMappingName', mappingName);
                        if (!self.collection) throw new InternalSiestaError('Mapping must have collection');
                        var collection = CollectionRegistry[self.collection];
                        if (!collection) {
                            throw new InternalSiestaError('Collection ' + self.collection + ' not registered');
                        }
                        var reverseMapping = collection[mappingName];
                        if (!reverseMapping) {
                            var arr = mappingName.split('.');
                            if (arr.length == 2) {
                                var collectionName = arr[0];
                                mappingName = arr[1];
                                var otherCollection = CollectionRegistry[collectionName];
                                if (!otherCollection) {
                                    var err = 'Collection with name "' + collectionName + '" does not exist.';
                                    console.error(err, {
                                        registry: CollectionRegistry
                                    });
                                    return err;
                                }
                                reverseMapping = otherCollection[mappingName];
                            }
                        }
                        if (Logger.debug.isEnabled)
                            Logger.debug('reverseMapping', reverseMapping);
                        if (reverseMapping) {
                            relationship.reverseMapping = reverseMapping;
                            relationship.forwardMapping = this;
                            relationship.forwardName = name;
                            relationship.reverseName = relationship.reverse;
                            relationship.isReverse = false;
                        } else {
                            return 'Mapping with name "' + mappingName.toString() + '" does not exist';
                        }
                    } else {
                        return 'Relationship type ' + relationship.type + ' does not exist';
                    }
                }
            }
        }
        this._relationshipsInstalled = true;
    } else {
        throw new InternalSiestaError('Relationships for "' + this.type + '" have already been installed');
    }
    return null;
};

Mapping.prototype.installReverseRelationships = function() {
    if (!this._reverseRelationshipsInstalled) {
        for (var forwardName in this.relationships) {
            if (this.relationships.hasOwnProperty(forwardName)) {
                var relationship = this.relationships[forwardName];
                relationship = extend(true, {}, relationship);
                relationship.isReverse = true;
                var reverseMapping = relationship.reverseMapping;
                var reverseName = relationship.reverseName;
                if (Logger.debug.isEnabled)
                    Logger.debug(self.type + ': configuring  reverse relationship ' + name);
                reverseMapping.relationships[reverseName] = relationship;
            }
        }
        this._reverseRelationshipsInstalled = true;
    } else {
        throw new InternalSiestaError('Reverse relationships for "' + this.type + '" have already been installed.');
    }
};

Mapping.prototype.query = function(query, callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var _query = new Query(this, query);
    _query.execute(callback);
    return deferred.promise;
};

Mapping.prototype.get = function(idOrCallback, callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);

    function finish(err, res) {
        if (callback) callback(err, res);
    }

    if (this.singleton) {
        if (typeof idOrCallback == 'function') {
            callback = idOrCallback;
        }
        this.all(function(err, objs) {
            if (err) finish(err);
            if (objs.length > 1) {
                throw new InternalSiestaError('Somehow more than one object has been created for a singleton mapping! ' +
                    'This is a serious error, please file a bug report.');
            } else if (objs.length) {
                finish(null, objs[0]);
            } else {
                finish(null, objs[0]);
            }
        });
    } else {
        var opts = {};
        opts[this.id] = idOrCallback;
        opts.mapping = this;
        var obj = cache.get(opts);
        if (obj) {
            finish(null, obj);
        } else {
            delete opts.mapping;
            var query = new Query(this, opts);
            query.execute(function(err, rows) {
                var obj = null;
                if (!err && rows.length) {
                    if (rows.length > 1) {
                        err = 'More than one object with id=' + idOrCallback.toString();
                    } else {
                        obj = rows[0];
                    }
                }
                finish(err, obj);
            });
        }

    }
    return deferred.promise;
};

Mapping.prototype.all = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var query = new Query(this, {});
    query.execute(callback);
    return deferred.promise;
};

Mapping.prototype.install = function(callback) {
    if (Logger.info.isEnabled) Logger.info('Installing mapping ' + this.type);
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    if (!this._installed) {
        var errors = this._validate();
        this._installed = true;
        if (Logger.info.isEnabled) {
            if (errors.length) Logger.error('Errors installing mapping ' + this.type + ': ' + errors);
            else Logger.info('Installed mapping ' + this.type);
        }
        if (callback) callback(errors.length ? errors : null);
    } else {
        throw new InternalSiestaError('Mapping "' + this.type + '" has already been installed');
    }
    return deferred.promise;
};

Mapping.prototype._validate = function() {
    var errors = [];
    if (!this.type) {
        errors.push('Must specify a type');
    }
    if (!this.collection) {
        errors.push('A mapping must belong to an collection');
    }
    return errors;
};


/**
 * Map data into Siesta.
 *
 * @param data Raw data received remotely or otherwise
 * @param callback Called once pouch persistence returns.
 * @param override Force mapping to this object
 */
Mapping.prototype.map = function(data, callback, override) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    if (this.installed) {
        if (util.isArray(data)) {
            this._mapBulk(data, callback, override);
        } else {
            this._mapBulk([data], function(err, objects) {
                if (callback) {
                    var obj;
                    if (objects) {
                        if (objects.length) {
                            obj = objects[0];
                        }
                    }
                    callback(err ? err[0] : null, obj);
                }
            }, override ? [override] : undefined);
        }
    } else {
        throw new InternalSiestaError('Mapping must be fully installed before creating any models');
    }
    return deferred.promise;
};

Mapping.prototype._mapBulk = function(data, callback, override) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var opts = {
        mapping: this,
        data: data
    };
    if (override) opts.objects = override;
    var op = new BulkMappingOperation(opts);
    op.onCompletion(function() {
        var err = op.error;
        if (err) {
            if (callback) callback(err);
        } else {
            var objects = op.result;
            callback(null, objects);
        }
    });
    op.start();
    return deferred.promise;
};

function _countCache() {
    var collCache = cache._localCacheByType[this.collection] || {};
    var mappingCache = collCache[this.type] || {};
    return _.reduce(Object.keys(mappingCache), function(m, _id) {
        m[_id] = {};
        return m;
    }, {});
}

Mapping.prototype.count = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var hash = _countCache.call(this);
    if (siesta.ext.storageEnabled) {
        var pouch = siesta.ext.storage.Pouch.getPouch();
        var indexName = (new siesta.ext.storage.Index(this.collection, this.type))._getName() + '_';
        pouch.query(indexName, {
            include_docs: false
        }, function(err, resp) {
            var n;
            if (!err) {
                _.each(_.pluck(resp.rows, 'id'), function(id) {
                    hash[id] = {};
                });
                n = Object.keys(hash).length;
            }
            callback(err, n);
        });
    } else {
        callback(null, Object.keys(hash).length)
    }
    return deferred.promise;
};

/**
 * Convert raw data into a SiestaModel
 * @returns {SiestaModel}
 * @private
 */
Mapping.prototype._new = function(data) {
    if (this.installed) {
        var self = this;
        var _id;
        if (data) {
            _id = data._id ? data._id : guid();
        } else {
            _id = guid();
        }
        var newModel;
        if (this.subclass) {
            newModel = new this.subclass(this);
        } else {
            newModel = new SiestaModel(this);
        }
        if (Logger.info.isEnabled)
            Logger.info('New object created _id="' + _id.toString() + '", type=' + this.type, data);
        newModel._id = _id;
        // Place attributes on the object.
        newModel.__values = data || {};
        var fields = this._fields;
        var idx = fields.indexOf(this.id);
        if (idx > -1) {
            fields.splice(idx, 1);
        }
        _.each(fields, function(field) {
            Object.defineProperty(newModel, field, {
                get: function() {
                    return newModel.__values[field] || null;
                },
                set: function(v) {
                    var old = newModel.__values[field];
                    newModel.__values[field] = v;
                    coreChanges.registerChange({
                        collection: self.collection,
                        mapping: self.type,
                        _id: newModel._id,
                        new: v,
                        old: old,
                        type: ChangeType.Set,
                        field: field,
                        obj: newModel
                    });
                    if (util.isArray(v)) {
                        wrapArray(v, field, newModel);
                    }
                },
                enumerable: true,
                configurable: true
            });
        });

        Object.defineProperty(newModel, this.id, {
            get: function() {
                return newModel.__values[self.id] || null;
            },
            set: function(v) {
                var old = newModel[self.id];
                newModel.__values[self.id] = v;
                coreChanges.registerChange({
                    collection: self.collection,
                    mapping: self.type,
                    _id: newModel._id,
                    new: v,
                    old: old,
                    type: ChangeType.Set,
                    field: self.id,
                    obj: newModel
                });
                cache.remoteInsert(newModel, v, old);
            },
            enumerable: true,
            configurable: true
        });


        for (var name in this.relationships) {
            var proxy;
            if (this.relationships.hasOwnProperty(name)) {
                var relationship = this.relationships[name];
                if (relationship.type == RelationshipType.OneToMany) {
                    proxy = new OneToManyProxy(relationship);
                } else if (relationship.type == RelationshipType.OneToOne) {
                    proxy = new OneToOneProxy(relationship);
                } else if (relationship.type == RelationshipType.ManyToMany) {
                    proxy = new ManyToManyProxy(relationship);
                } else {
                    throw new InternalSiestaError('No such relationship type: ' + relationship.type);
                }
            }
            proxy.install(newModel);
            proxy.isFault = false;
        }
        cache.insert(newModel);
        coreChanges.registerChange({
            collection: this.collection,
            mapping: this.type,
            _id: newModel._id,
            newId: newModel._id,
            new: newModel,
            type: ChangeType.New,
            obj: newModel
        });
        return newModel;
    } else {
        util.printStackTrace();
        throw new InternalSiestaError('Mapping must be fully installed before creating any models');
    }

};

Mapping.prototype._dump = function(asJSON) {
    var dumped = {};
    dumped.name = this.type;
    dumped.attributes = this.attributes;
    dumped.id = this.id;
    dumped.collection = this.collection;
    dumped.relationships = _.map(this.relationships, function(r) {
        return r.isForward ? r.forwardName : r.reverseName;
    });
    return asJSON ? JSON.stringify(dumped, null, 4) : dumped;
};

Mapping.prototype.toString = function() {
    return 'Mapping[' + this.type + ']';
};

/**
 * A subclass of InternalSiestaError specifcally for errors that occur during mapping.
 * @param message
 * @param context
 * @param ssf
 * @returns {MappingError}
 * @constructor
 */
function MappingError(message, context, ssf) {
    if (!this) {
        return new MappingError(message, context);
    }

    this.message = message;

    this.context = context;
    // capture stack trace
    ssf = ssf || arguments.callee;
    if (ssf && InternalSiestaError.captureStackTrace) {
        InternalSiestaError.captureStackTrace(this, ssf);
    }
}

MappingError.prototype = Object.create(InternalSiestaError.prototype);
MappingError.prototype.name = 'MappingError';
MappingError.prototype.constructor = MappingError;

function arrayAsString(arr) {
    var arrContents = _.reduce(arr, function(memo, f) {
        return memo + '"' + f + '",'
    }, '');
    arrContents = arrContents.substring(0, arrContents.length - 1);
    return '[' + arrContents + ']';
}


function constructMapFunction(collection, type, fields) {
    var mapFunc;
    var onlyEmptyFieldSetSpecified = (fields.length == 1 && !fields[0].length);
    var noFieldSetsSpecified = !fields.length || onlyEmptyFieldSetSpecified;

    var arr = arrayAsString(fields);
    if (noFieldSetsSpecified) {
        mapFunc = function(doc) {
            var type = "$2";
            var collection = "$3";
            if (doc.type == type && doc.collection == collection) {
                emit(doc.type, doc);
            }
        }.toString();
    } else {
        mapFunc = function(doc) {
            var type = "$2";
            var collection = "$3";
            if (doc.type == type && doc.collection == collection) {
                //noinspection JSUnresolvedVariable
                var fields = $1;
                var aggField = '';
                for (var idx in fields) {
                    //noinspection JSUnfilteredForInLoop
                    var field = fields[idx];
                    var value = doc[field];
                    if (value !== null && value !== undefined) {
                        aggField += value.toString() + '_';
                    } else if (value === null) {
                        aggField += 'null_';
                    } else {
                        aggField += 'undefined_';
                    }
                }
                aggField = aggField.substring(0, aggField.length - 1);
                emit(aggField, doc);
            }
        }.toString();
        mapFunc = mapFunc.replace('$1', arr);
    }
    mapFunc = mapFunc.replace('$2', type);
    mapFunc = mapFunc.replace('$3', collection);
    return mapFunc;
}


function constructMapFunction2(collection, type, fields) {
    var mapFunc;
    var onlyEmptyFieldSetSpecified = (fields.length == 1 && !fields[0].length);
    var noFieldSetsSpecified = !fields.length || onlyEmptyFieldSetSpecified;

    if (noFieldSetsSpecified) {
        mapFunc = function(doc) {
            if (doc.type == type && doc.collection == collection) {
                emit(doc.type, doc);
            }
        };
    } else {
        mapFunc = function(doc) {
            if (doc.type == type && doc.collection == collection) {
                var aggField = '';
                for (var idx in fields) {
                    //noinspection JSUnfilteredForInLoop
                    var field = fields[idx];
                    var value = doc[field];
                    if (value !== null && value !== undefined) {
                        aggField += value.toString() + '_';
                    } else if (value === null) {
                        aggField += 'null_';
                    } else {
                        aggField += 'undefined_';
                    }
                }
                aggField = aggField.substring(0, aggField.length - 1);
                emit(aggField, doc);
            }
        };
    }
    return mapFunc;
}

exports.Mapping = Mapping;
exports.MappingError = MappingError;
exports.constructMapFunction2 = constructMapFunction2;
exports.constructMapFunction = constructMapFunction;
},{"../vendor/operations.js/src/log":107,"../vendor/operations.js/src/operation":108,"./cache":43,"./changes":44,"./collectionRegistry":46,"./error":47,"./manyToManyProxy":48,"./mappingOperation":50,"./misc":51,"./notificationCentre":52,"./object":53,"./oneToManyProxy":54,"./oneToOneProxy":55,"./query":57,"./relationship":58,"./store":59,"./util":60,"extend":41,"q":42}],50:[function(require,module,exports){
/**
 * @module mapping
 */

var Store = require('./store');
var SiestaModel = require('./object').SiestaModel;
var log = require('../vendor/operations.js/src/log');
var Operation = require('../vendor/operations.js/src/operation').Operation;
var InternalSiestaError = require('../src/error').InternalSiestaError;
var Query = require('./query').Query;

var Logger = log.loggerWithName('MappingOperation');
Logger.setLevel(log.Level.warn);

var cache = require('./cache');
var util = require('./util');
var _ = util._;
var defineSubProperty = require('./misc').defineSubProperty;
var ChangeType = require('./changes').ChangeType;
var q = require('q');

function flattenArray(arr) {
    return _.reduce(arr, function(memo, e) {
        if (util.isArray(e)) {
            memo = memo.concat(e);
        } else {
            memo.push(e);
        }
        return memo;
    }, []);
}

function unflattenArray(arr, modelArr) {
    var n = 0;
    var unflattened = [];
    for (var i = 0; i < modelArr.length; i++) {
        if (util.isArray(modelArr[i])) {
            var newArr = [];
            unflattened[i] = newArr;
            for (var j = 0; j < modelArr[i].length; j++) {
                newArr.push(arr[n]);
                n++;
            }
        } else {
            unflattened[i] = arr[n];
            n++;
        }
    }
    return unflattened;
}

/**
 * Defines an encapsulated mapping operation where opts takes a mappin
 * @param {Objects} opts
 */
function BulkMappingOperation(opts) {
    Operation.call(this);

    this._opts = opts;

    /**
     * @name mapping
     * @type {Mapping}
     */
    defineSubProperty.call(this, 'mapping', this._opts);

    /**
     * @name data
     * @type {Array}
     */
    defineSubProperty.call(this, 'data', this._opts);

    /**
     * @name objects
     * @type {Array}
     */
    defineSubProperty.call(this, 'objects', this._opts);

    if (!this.objects) this.objects = [];

    /**
     * Array of errors where indexes map onto same index as the datum that caused an error.
     * @type {Array}
     */
    this.errors = [];

    this.name = 'Mapping Operation';
    this.work = _.bind(this._start, this);
    this.subOps = {};
}

BulkMappingOperation.prototype = Object.create(Operation.prototype);

function mapAttributes() {
    for (var i = 0; i < this.data.length; i++) {
        var datum = this.data[i];
        var object = this.objects[i];
        // No point mapping object onto itself. This happens if a SiestaModel is passed as a relationship.
        if (datum != object) {
            if (object) { // If object is falsy, then there was an error looking up that object/creating it.
                var fields = this.mapping._fields;
                _.each(fields, function(f) {
                    if (datum[f] !== undefined) { // null is fine
                        object[f] = datum[f];
                    }
                });
            }
        }
    }
}


BulkMappingOperation.prototype._map = function() {
    var self = this;
    var numHits = mapAttributes.call(this);
    var relationshipFields = _.keys(self.subOps);
    _.each(relationshipFields, function(f) {
        var op = self.subOps[f].op;
        var indexes = self.subOps[f].indexes;
        var relatedData = getRelatedData.call(self, f).relatedData;
        var unflattenedObjects = unflattenArray(op.objects, relatedData);
        for (var i = 0; i < unflattenedObjects.length; i++) {
            var idx = indexes[i];
            // Errors are plucked from the suboperations.
            var error = self.errors[idx];
            var err = error ? error[f] : null;
            if (!err) {
                var related = unflattenedObjects[i]; // Can be array or scalar.
                var object = self.objects[idx];
                if (object) {
                    var err = object[f + 'Proxy'].set(related);
                    if (err) {
                        if (!self.errors[idx]) self.errors[idx] = {};
                        self.errors[idx][f] = err;
                    }
                }
            }
        }
    });
};

/**
 * For indices where no object is present, perform lookups, creating a new object if necessary.
 * @private
 */
BulkMappingOperation.prototype._lookup = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var self = this;
    var remoteLookups = [];
    var localLookups = [];
    for (var i = 0; i < this.data.length; i++) {
        if (!this.objects[i]) {
            var lookup;
            var datum = this.data[i];
            var isScalar = typeof datum == 'string' || typeof datum == 'number' || datum instanceof String;
            if (datum) {
                if (isScalar) {
                    lookup = {
                        index: i,
                        datum: {}
                    };
                    lookup.datum[self.mapping.id] = datum;
                    remoteLookups.push(lookup);
                } else if (datum instanceof SiestaModel) { // We won't need to perform any mapping.
                    this.objects[i] = datum;
                } else if (datum._id) {
                    localLookups.push({
                        index: i,
                        datum: datum
                    });
                } else if (datum[self.mapping.id]) {
                    remoteLookups.push({
                        index: i,
                        datum: datum
                    });
                } else {
                    // Create a new object if and only if the data has any fields that will actually
                    var datumFields = Object.keys(datum);
                    var objectFields = _.reduce(Object.keys(self.mapping.relationships).concat(self.mapping._fields), function(m, x) {
                        m[x] = {};
                        return m;
                    }, {});
                    var shouldCreateNewObject = false;
                    for (var j = 0; j < datumFields.length; j++) {
                        if (objectFields[datumFields[j]]) {
                            shouldCreateNewObject = true;
                            break;
                        }
                    }
                    if (shouldCreateNewObject) {
                        this.objects[i] = self.mapping._new();
                    }
                }
            } else {
                this.objects[i] = null;
            }
        }
    }
    util.parallel([
            function(callback) {
                var localIdentifiers = _.pluck(_.pluck(localLookups, 'datum'), '_id');
                if (localIdentifiers.length) {
                    Store.getMultipleLocal(localIdentifiers, function(err, objects) {
                        if (!err) {
                            for (var i = 0; i < localIdentifiers.length; i++) {
                                var obj = objects[i];
                                var _id = localIdentifiers[i];
                                var lookup = localLookups[i];
                                if (!obj) {
                                    self.errors[lookup.index] = {
                                        _id: 'No object with _id="' + _id.toString() + '"'
                                    };
                                } else {
                                    self.objects[lookup.index] = obj;
                                }
                            }
                        }
                        callback(err);
                    });
                } else {
                    callback();
                }
            },
            function(callback) {
                var remoteIdentifiers = _.pluck(_.pluck(remoteLookups, 'datum'), self.mapping.id);
                if (remoteIdentifiers.length) {
                    if (Logger.trace.isEnabled)
                        Logger.trace('Looking up remoteIdentifiers: ' + JSON.stringify(remoteIdentifiers, null, 4));
                    Store.getMultipleRemote(remoteIdentifiers, self.mapping, function(err, objects) {
                        if (!err) {
                            if (Logger.trace.isEnabled) {
                                var results = {};
                                for (i = 0; i < objects.length; i++) {
                                    results[remoteIdentifiers[i]] = objects[i] ? objects[i]._id : null;
                                }
                                Logger.trace('Results for remoteIdentifiers: ' + JSON.stringify(results, null, 4));
                            }
                            for (i = 0; i < objects.length; i++) {
                                var obj = objects[i];
                                var lookup = remoteLookups[i];
                                if (obj) {
                                    self.objects[lookup.index] = obj;
                                } else {
                                    var data = {};
                                    var remoteId = remoteIdentifiers[i];
                                    data[self.mapping.id] = remoteId;
                                    var cacheQuery = {
                                        mapping: self.mapping
                                    };
                                    cacheQuery[self.mapping.id] = remoteId;
                                    var cached = cache.get(cacheQuery);
                                    if (cached) {
                                        self.objects[lookup.index] = cached;
                                    } else {
                                        self.objects[lookup.index] = self.mapping._new();
                                        // It's important that we map the remote identifier here to ensure that it ends
                                        // up in the cache.
                                        self.objects[lookup.index][self.mapping.id] = remoteId;
                                    }
                                }
                            }
                        }
                        callback(err);
                    });
                } else {
                    callback();
                }
            }
        ],
        callback);
    return deferred.promise;
};

BulkMappingOperation.prototype._lookupSingleton = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var self = this;
    var cachedSingleton = cache.get({
        mapping: this.mapping
    });
    if (!cachedSingleton) {
        var query = new Query(this.mapping);
        query.execute(function(err, objs) {
            if (!err) {
                var obj;
                if (objs.length) {
                    if (objs.length == 1) {
                        obj = objs[0];
                    } else {
                        throw new InternalSiestaError();
                    }
                } else {
                    obj = self.mapping._new();
                }
                for (var i = 0; i < self.data.length; i++) {
                    self.objects[i] = obj;
                }
            }
            callback(err);
        });
    } else {
        for (var i = 0; i < self.data.length; i++) {
            self.objects[i] = cachedSingleton;
        }
        callback();
    }
    return deferred.promise;
};

BulkMappingOperation.prototype._start = function(done) {
    if (this.data.length) {
        var self = this;
        var tasks = [];
        var lookupFunc = this.mapping.singleton ? this._lookupSingleton : this._lookup;
        tasks.push(_.bind(lookupFunc, this));
        tasks.push(_.bind(this._executeSubOperations, this));
        util.parallel(tasks, function() {
            self._map();
            done(self.errors.length ? self.errors : null, self.objects);
        });
    } else {
        done(null, []);
    }
};

function getRelatedData(name) {
    var indexes = [];
    var relatedData = [];
    for (var i = 0; i < this.data.length; i++) {
        var datum = this.data[i];
        if (datum) {
            if (datum[name]) {
                indexes.push(i);
                relatedData.push(datum[name]);
            }
        }
    }
    return {
        indexes: indexes,
        relatedData: relatedData
    };
}

BulkMappingOperation.prototype._constructSubOperations = function() {
    var subOps = this.subOps;
    var relationships = this.mapping.relationships;
    for (var name in relationships) {
        if (relationships.hasOwnProperty(name)) {
            var relationship = relationships[name];
            var reverseMapping = relationship.forwardName == name ? relationship.reverseMapping : relationship.forwardMapping;
            var __ret = getRelatedData.call(this, name);
            var indexes = __ret.indexes;
            var relatedData = __ret.relatedData;
            if (relatedData.length) {
                var flatRelatedData = flattenArray(relatedData);
                var op = new BulkMappingOperation({
                    mapping: reverseMapping,
                    data: flatRelatedData
                });
                op.__relationshipName = name;
                subOps[name] = {
                    op: op,
                    indexes: indexes
                };
            }
        }
    }
};

function gatherErrorsFromSubOperations() {
    var self = this;
    var relationshipNames = _.keys(this.subOps);
    _.each(relationshipNames, function(name) {
        var op = self.subOps[name].op;
        var indexes = self.subOps[name].indexes;
        var errors = op.errors;
        if (errors.length) {
            var relatedData = getRelatedData.call(self, name).relatedData;
            var unflattenedErrors = unflattenArray(errors, relatedData);
            for (var i = 0; i < unflattenedErrors.length; i++) {
                var idx = indexes[i];
                var err = unflattenedErrors[i];
                var isError = err;
                if (util.isArray(err)) isError = _.reduce(err, function(memo, x) {
                    return memo || x
                }, false);
                if (isError) {
                    if (!self.errors[idx]) self.errors[idx] = {};
                    self.errors[idx][name] = err;
                }
            }
        }
    });
}

BulkMappingOperation.prototype._executeSubOperations = function(callback) {
    var self = this;
    this._constructSubOperations();
    var relationshipNames = _.keys(this.subOps);
    if (relationshipNames.length) {
        var subOperations = _.map(relationshipNames, function(k) {
            return self.subOps[k].op
        });
        var compositeOperation = new Operation(subOperations);
        compositeOperation.onCompletion(function() {
            gatherErrorsFromSubOperations.call(self, relationshipNames);
            callback();
        });
        compositeOperation.start();
    } else {
        callback();
    }
};

exports.BulkMappingOperation = BulkMappingOperation;
exports.flattenArray = flattenArray;
exports.unflattenArray = unflattenArray;
},{"../src/error":47,"../vendor/operations.js/src/log":107,"../vendor/operations.js/src/operation":108,"./cache":43,"./changes":44,"./misc":51,"./object":53,"./query":57,"./store":59,"./util":60,"q":42}],51:[function(require,module,exports){
var InternalSiestaError = require('./error').InternalSiestaError;

function assert(condition, message, context) {
    if (!condition) {
        message = message || "Assertion failed";
        context = context || {};
        throw new InternalSiestaError(message, context);
    }
}

function defineSubProperty (property, subObj, innerProperty) {
    return Object.defineProperty(this, property, {
        get: function () {
            if (innerProperty) {
                return subObj[innerProperty];
            }
            else {
                return subObj[property];
            }
        },
        set: function (value) {
            if (innerProperty) {
                subObj[innerProperty] = value;
            }
            else {
                subObj[property] = value;
            }
        },
        enumerable: true,
        configurable: true
    });
}

var guid = (function () {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }

    return function () {
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    };
})();

function wrappedCallback (callback) {
    return function (err, res) {
        if (callback) callback(err, res);
    }
}

exports.assert = assert;
exports.defineSubProperty = defineSubProperty;
exports.guid = guid;
exports.wrappedCallback = wrappedCallback;
},{"./error":47}],52:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var notificationCentre = new EventEmitter();
notificationCentre.setMaxListeners(100);
var ArrayObserver = require('../vendor/observe-js/src/observe').ArrayObserver;
var coreChanges = require('./changes');
var ChangeType = coreChanges.ChangeType;
var log = require('../vendor/operations.js/src/log');

/**
* Wraps the methods of a javascript array object so that notifications are sent
* on calls.
*
* @param array the array we have wrapping
* @param field name of the field
* @param restObject the object to which this array is a property
*/
function wrapArray(array, field, siestaModel) {
    if (!array.observer) {
        array.observer = new ArrayObserver(array);
        array.observer.open(function (splices) {
            var fieldIsAttribute = siestaModel._fields.indexOf(field) > -1;
            if (fieldIsAttribute) {
                splices.forEach(function (splice) {
                    coreChanges.registerChange({
                        collection: siestaModel.collection,
                        mapping: siestaModel.mapping.type,
                        _id: siestaModel._id,
                        index: splice.index,
                        removed: splice.removed,
                        added: splice.addedCount ? array.slice(splice.index, splice.index+splice.addedCount) : [],
                        type: coreChanges.ChangeType.Splice,
                        field: field,
                        obj: siestaModel
                    });
                });
            }
        });
        array.isFault = false;
    }
}

exports.notificationCentre = notificationCentre;
exports.wrapArray = wrapArray;
},{"../vendor/observe-js/src/observe":106,"../vendor/operations.js/src/log":107,"./changes":44,"events":7}],53:[function(require,module,exports){
var log = require('../vendor/operations.js/src/log');
var Logger = log.loggerWithName('SiestaModel');
Logger.setLevel(log.Level.warn);

var defineSubProperty = require('./misc').defineSubProperty;
//var OperationQueue = require('../vendor/operations.js/src/queue').OperationQueue;
var util = require('./util');
var _ = util._;
var error = require('./error');
var InternalSiestaError = error.InternalSiestaError;
var coreChanges = require('./changes');

var q = require('q');

var cache = require('./cache');

//var queues = {};

function SiestaModel(mapping) {

    if (!this) {
        return new SiestaModel(mapping);
    }
    var self = this;
    this.mapping = mapping;
    Object.defineProperty(this, 'idField', {
        get: function() {
            return self.mapping.id ? self.mapping.id : 'id';
        },
        enumerable: true,
        configurable: true
    });
    defineSubProperty.call(this, 'type', this.mapping);
    defineSubProperty.call(this, 'collection', this.mapping);
    defineSubProperty.call(this, '_fields', this.mapping);
    Object.defineProperty(this, '_relationshipFields', {
        get: function() {
            return _.map(self._proxies, function(p) {
                if (p.isForward) {
                    return p.forwardName;
                } else {
                    return p.reverseName;
                }
            });
        },
        enumerable: true,
        configurable: true
    });


    this.isFault = false;

    Object.defineProperty(this, 'isSaved', {
        get: function() {
            return !!self._rev;
        },
        enumerable: true,
        configurable: true
    });

    this._rev = null;

    this.removed = false;
}

/**
 * Human readable dump of this object
 * @returns {*}
 * @private
 */
SiestaModel.prototype._dump = function(asJson) {
    var self = this;
    var cleanObj = {};
    cleanObj.mapping = this.mapping.type;
    cleanObj.collection = this.collection;
    cleanObj._id = this._id;
    cleanObj = _.reduce(this._fields, function(memo, f) {
        if (self[f]) {
            memo[f] = self[f];
        }
        return memo;
    }, cleanObj);
    cleanObj = _.reduce(this._relationshipFields, function(memo, f) {
        if (self[f + 'Proxy']) {
            if (self[f + 'Proxy'].hasOwnProperty('_id')) {
                if (util.isArray(self[f + 'Proxy']._id)) {
                    if (self[f].length) {
                        memo[f] = self[f + 'Proxy']._id;
                    }
                } else if (self[f + 'Proxy']._id) {
                    memo[f] = self[f + 'Proxy']._id;
                }
            } else {
                memo[f] = self[f];
            }
        }
        return memo;
    }, cleanObj);

    return asJson ? JSON.stringify(cleanObj, null, 4) : cleanObj;
};


SiestaModel.prototype.get = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    callback(null, this);
    return deferred.promise;
};

SiestaModel.prototype.remove = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    cache.remove(this);
    this.removed = true;
    coreChanges.registerChange({
        collection: this.collection,
        mapping: this.mapping.type,
        _id: this._id,
        oldId: this._id,
        old: this,
        type: coreChanges.ChangeType.Remove,
        obj: this
    });
    callback(null, this);
    return deferred.promise;
}

SiestaModel.prototype.restore = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    if (this.removed) {
        cache.insert(this);
        this.removed = false;
    }
    coreChanges.registerChange({
        collection: this.collection,
        mapping: this.mapping.type,
        _id: this._id,
        newId: this._id,
        new: this,
        type: coreChanges.ChangeType.New,
        obj: this
    });
    callback(null, this);
    return deferred.promise;
}

exports.SiestaModel = SiestaModel;
exports.dumpSaveQueues = function() {
    var dumped = {};
    for (var id in queues) {
        if (queues.hasOwnProperty(id)) {
            var queue = queues[id];
            dumped[id] = {
                numRunning: queue.numRunningOperations,
                queued: queue._queuedOperations.length
            };
        }
    }
    return dumped;
};
},{"../vendor/operations.js/src/log":107,"./cache":43,"./changes":44,"./error":47,"./misc":51,"./util":60,"q":42}],54:[function(require,module,exports){
/**
 * @module relationships
 */

var proxy = require('./proxy')
    , RelationshipProxy = proxy.RelationshipProxy
    , Store = require('./store')
    , util = require('./util')
    , _ = util._
    , InternalSiestaError = require('./error').InternalSiestaError
    , coreChanges = require('./changes')
    , SiestaModel = require('./object').SiestaModel
    , notificationCentre = require('./notificationCentre')
    , wrapArrayForAttributes = notificationCentre.wrapArray
    , ArrayObserver = require('../vendor/observe-js/src/observe').ArrayObserver
    , ChangeType = require('./changes').ChangeType
    , q = require('q')
    ;

/**
 * @class  [OneToManyProxy description]
 * @constructor
 * @param {[type]} opts
 */
function OneToManyProxy(opts) {
    RelationshipProxy.call(this, opts);

    var self = this;
    Object.defineProperty(this, 'isFault', {
        get: function () {
            if (self.isForward) {
                if (self._id) {
                    return !self.related;
                }
                else if (self._id === null) {
                    return false;
                }
                return true;
            }
            else {
                if (self._id) {
                    if (self.related) {
                        if (self._id.length != self.related.length) {
                            validateRelated.call(this);
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    return true;
                }
                return true;
            }
        },
        set: function (v) {
            if (v) {
                self._id = undefined;
                self.related = null;
            }
            else {
                if (!self._id) {
                    if (self.isForward) {
                        self._id = null;
                    }
                    else {
                        self._id = [];
                        self.related = [];
                        wrapArray.call(self, self.related);
                    }
                }
            }
        }
    });
    this._reverseIsArray = true;
    this._forwardIsArray = false;
}

OneToManyProxy.prototype = Object.create(RelationshipProxy.prototype);


function clearReverse(removed) {
    var self = this;
    _.each(removed, function (removedObject) {
        var reverseProxy = proxy.getReverseProxyForObject.call(self, removedObject);
        proxy.set.call(reverseProxy, null);
    });
}

function setReverse(added) {
    var self = this;
    _.each(added, function (added) {
        var forwardProxy = proxy.getReverseProxyForObject.call(self, added);
        proxy.set.call(forwardProxy, self.object);
    });
}

function wrapArray(arr) {
    var self = this;
    wrapArrayForAttributes(arr, this.reverseName, this.object);
    if (!arr.oneToManyObserver) {
        arr.oneToManyObserver = new ArrayObserver(arr);
        var observerFunction = function (splices) {
            splices.forEach(function (splice) {
                var added = splice.addedCount ? arr.slice(splice.index, splice.index + splice.addedCount) : [];
                var removed = splice.removed;
                clearReverse.call(self, removed);
                setReverse.call(self, added);
                var mapping = proxy.getForwardMapping.call(self);
                coreChanges.registerChange({
                    collection: mapping.collection,
                    mapping: mapping.type,
                    _id: self.object._id,
                    field: proxy.getForwardName.call(self),
                    removed: removed,
                    added: added,
                    removedId: _.pluck(removed, '_id'),
                    addedId: _.pluck(added, '_id'),
                    type: ChangeType.Splice,
                    index: splice.index,
                    obj: self.object
                });
            });
        };
        arr.oneToManyObserver.open(observerFunction);
    }
}


OneToManyProxy.prototype.get = function (callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var self = this;
    if (this.isFault) {
        if (this._id.length) {
            var storeOpts = {_id: this._id};
            Store.get(storeOpts, function (err, stored) {
                if (err) {
                    if (callback) callback(err);
                }
                else {
                    self.related = stored;
                    if (callback) callback(null, stored);
                }
            });
        }
        else if (callback) {
            callback(null, this.related);
        }
    }
    else {
        if (callback) callback(null, this.related);
    }
    return deferred.promise;
};

/**
 * Validate the object that we're setting
 * @param obj
 * @returns {string|null} An error message or null
 */
function validate(obj) {
    var str = Object.prototype.toString.call(obj);
    if (this.isForward) {
        if (str == '[object Array]') {
            return 'Cannot assign array forward oneToMany (' + str + '): ' + this.forwardName;
        }
    }
    else {
        if (str != '[object Array]') {
            return 'Cannot scalar to reverse oneToMany (' + str + '): ' + this.reverseName;
        }
    }
    return null;
}

function validateRelated() {
    var self = this;
    if (self._id) {
        if (self.related) {
            if (self._id.length != self.related.length) {
                if (self.related.length > 0) {
                    throw new InternalSiestaError('_id and related are somehow out of sync');
                }
            }
        }
    }
}

OneToManyProxy.prototype.set = function (obj) {
    proxy.checkInstalled.call(this);
    var self = this;
    if (obj) {
        var errorMessage;
        if (errorMessage = validate.call(this, obj)) {
            return errorMessage;
        }
        else {
            proxy.clearReverseRelated.call(this);
            proxy.set.call(self, obj);
            if (self.isReverse) {
                wrapArray.call(this, self.related);
            }
            proxy.setReverse.call(self, obj);
        }
    }
    else {
        proxy.clearReverseRelated.call(this);
        proxy.set.call(self, obj);
    }
};

OneToManyProxy.prototype.install = function (obj) {
    RelationshipProxy.prototype.install.call(this, obj);
    if (this.isReverse) {
        obj[ ('splice' + util.capitaliseFirstLetter(this.reverseName))] = _.bind(proxy.splice, this);
    }
};


exports.OneToManyProxy = OneToManyProxy;
},{"../vendor/observe-js/src/observe":106,"./changes":44,"./error":47,"./notificationCentre":52,"./object":53,"./proxy":56,"./store":59,"./util":60,"q":42}],55:[function(require,module,exports){
/**
 * @module relationships
 */

var proxy = require('./proxy')
    , RelationshipProxy = proxy.RelationshipProxy
    , Store = require('./store')
    , util = require('./util')
    , InternalSiestaError = require('./error').InternalSiestaError
    , q = require('q')
    , SiestaModel = require('./object').SiestaModel;

/**
 * [OneToOneProxy description]
 * @param {Object} opts
 */
function OneToOneProxy(opts) {
    RelationshipProxy.call(this, opts);
    this._reverseIsArray = false;
    this._forwardIsArray = false;
}

OneToOneProxy.prototype = Object.create(RelationshipProxy.prototype);

/**
 * Validate the object that we're setting
 * @param obj
 * @returns {string|null} An error message or null
 */
function validate(obj) {
    if (Object.prototype.toString.call(obj) == '[object Array]') {
        return 'Cannot assign array to one to one relationship';
    }
    else if ((!obj instanceof SiestaModel)) {

    }
    return null;
}

OneToOneProxy.prototype.set = function (obj) {
    proxy.checkInstalled.call(this);
    var self = this;
    if (obj) {
        var errorMessage;
        if (errorMessage = validate(obj)) {
            return errorMessage;
        }
        else {
            proxy.clearReverseRelated.call(this);
            proxy.set.call(self, obj);
            proxy.setReverse.call(self, obj);
        }
    }
    else {
        proxy.clearReverseRelated.call(this);
        proxy.set.call(self, obj);
    }
};

OneToOneProxy.prototype.get = function (callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var self = this;
    if (this._id) {
        Store.get({_id: this._id}, function (err, stored) {
            if (err) {
                if (callback) callback(err);
            }
            else {
                self.related = stored;
                if (callback) callback(null, stored);
            }
        })
    }
    return deferred.promise;
};

exports.OneToOneProxy = OneToOneProxy;
},{"./error":47,"./object":53,"./proxy":56,"./store":59,"./util":60,"q":42}],56:[function(require,module,exports){
/**
 * @module relationships
 */

var InternalSiestaError = require('./error').InternalSiestaError,
    Store = require('./store'),
    defineSubProperty = require('./misc').defineSubProperty,
    Operation = require('../vendor/operations.js/src/operation').Operation,
    util = require('./util'),
    _ = util._,
    Query = require('./query').Query,
    log = require('../vendor/operations.js/src/log'),
    notificationCentre = require('./notificationCentre'),
    wrapArrayForAttributes = notificationCentre.wrapArray,
    ArrayObserver = require('../vendor/observe-js/src/observe').ArrayObserver,
    coreChanges = require('./changes'),
    ChangeType = coreChanges.ChangeType;

/**
 * @class  [Fault description]
 * @param {RelationshipProxy} proxy
 * @constructor
 */
function Fault(proxy) {
    var self = this;
    this.proxy = proxy;
    Object.defineProperty(this, 'isFault', {
        get: function() {
            return self.proxy.isFault;
        },
        enumerable: true,
        configurable: true
    });
}

Fault.prototype.get = function() {
    this.proxy.get.apply(this.proxy, arguments);
};

Fault.prototype.set = function() {
    this.proxy.set.apply(this.proxy, arguments);
};

/**
 * @class  [RelationshipProxy description]
 * @param {Object} opts
 * @constructor
 */
function RelationshipProxy(opts) {
    this._opts = opts;
    if (!this) return new RelationshipProxy(opts);
    var self = this;
    this.fault = new Fault(this);
    this.object = null;
    this._id = undefined;
    this.related = null;
    Object.defineProperty(this, 'isFault', {
        get: function() {
            if (self._id) {
                return !self.related;
            } else if (self._id === null) {
                return false;
            }
            return true;
        },
        set: function(v) {
            if (v) {
                self._id = undefined;
                self.related = null;
            } else {
                if (!self._id) {
                    self._id = null;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    defineSubProperty.call(this, 'reverseMapping', this._opts);
    defineSubProperty.call(this, 'forwardMapping', this._opts);
    defineSubProperty.call(this, 'forwardName', this._opts);
    defineSubProperty.call(this, 'reverseName', this._opts);
    defineSubProperty.call(this, 'isReverse', this._opts);
    Object.defineProperty(this, 'isForward', {
        get: function() {
            return !self.isReverse;
        },
        set: function (v) {
            self.isReverse = !v;
        },
        enumerable: true,
        configurable: true
    });
    if (this._opts.isReverse === undefined && this._opts.isForward !== undefined) {
        this.isReverse = !this._opts.isForward;
    }
    else if (this._opts.isReverse === undefined && this._opts.isForward === undefined) {
        throw InternalSiestaError('Must specify either isReverse or isForward when configuring relationship proxy.');
    }
 }

RelationshipProxy.prototype._dump = function(asJson) {
    var dumped = {};
};

RelationshipProxy.prototype.install = function(obj) {
    if (obj) {
        if (!this.object) {
            this.object = obj;
            var self = this;
            var name = getForwardName.call(this);
            Object.defineProperty(obj, name, {
                get: function() {
                    if (self.isFault) {
                        return self.fault;
                    } else {
                        return self.related;
                    }
                },
                set: function(v) {
                    self.set(v);
                },
                configurable: true,
                enumerable: true
            });
            obj[('get' + util.capitaliseFirstLetter(name))] = _.bind(this.get, this);
            obj[('set' + util.capitaliseFirstLetter(name))] = _.bind(this.set, this);
            obj[name + 'Proxy'] = this;
            if (!obj._proxies) {
                obj._proxies = [];
            }
            obj._proxies.push(this);
        } else {
            throw new InternalSiestaError('Already installed.');
        }
    } else {
        throw new InternalSiestaError('No object passed to relationship install');
    }
};

RelationshipProxy.prototype.set = function(obj) {
    throw new InternalSiestaError('Must subclass RelationshipProxy');
};

RelationshipProxy.prototype.get = function(callback) {
    throw new InternalSiestaError('Must subclass RelationshipProxy');
};

function verifyMapping(obj, mapping) {
    if (obj.mapping != mapping) {
        var err = 'Mapping does not match. Expected ' + mapping.type + ' but got ' + obj.mapping.type;
        throw new InternalSiestaError(err);
    }
}

// TODO: Share code between getReverseProxyForObject and getForwardProxyForObject

function getReverseProxyForObject(obj) {
    var reverseName = getReverseName.call(this);
    var proxyName = (reverseName + 'Proxy');
    var reverseMapping = this.reverseMapping;
    // This should never happen. Should g   et caught in the mapping operation?
    if (util.isArray(obj)) {
        // _.each(obj, function(o) {
        //     verifyMapping(o, this.forwardMapping);
        // });
        return _.pluck(obj, proxyName);
    } else {
        // verifyMapping(obj, this.forwardMapping);
        var proxy = obj[proxyName];
        if (!proxy) {
            var err = 'No proxy with name "' + proxyName + '" on mapping ' + reverseMapping.type;
            throw new InternalSiestaError(err);
        }
        return proxy;
    }
}

function getForwardProxyForObject(obj) {
    var forwardName = getForwardName.call(this);
    var proxyName = forwardName + 'Proxy';
    var forwardMapping = this.forwardMapping;
    if (util.isArray(obj)) {
        // _.each(obj, function(o) {
        //     verifyMapping(o, this.reverseMapping);
        // });
        return _.pluck(obj, proxyName);
    } else {
        // verifyMapping(obj, this.reverseMapping);
        var proxy = obj[proxyName];
        if (!proxy) {
            var err = 'No proxy with name "' + proxyName + '" on mapping ' + forwardMapping.type;
            throw new InternalSiestaError(err);
        }
        return proxy;
    }
}

function getReverseName() {
    return this.isForward ? this.reverseName : this.forwardName;
}

function getForwardName() {
    return this.isForward ? this.forwardName : this.reverseName;
}

function getReverseMapping() {
    return this.isForward ? this.reverseMapping : this.forwardMapping;
}

function getForwardMapping() {
    return this.isForward ? this.forwardMapping : this.reverseMapping;
}

function checkInstalled() {
    if (!this.object) {
        throw new InternalSiestaError('Proxy must be installed on an object before can use it.');
    }
}

/**
 * Configure _id and related with the new related object.
 * @param obj
 */
function set(obj) {
    registerSetChange.call(this, obj);
    if (obj) {
        if (util.isArray(obj)) {
            this._id = _.pluck(obj, '_id');
            this.related = obj;
        } else {
            this._id = obj._id;
            this.related = obj;
        }
    } else {
        this._id = null;
        this.related = null;
    }
}

function splice(idx, numRemove) {
    registerSpliceChange.apply(this, arguments);
    var add = Array.prototype.slice.call(arguments, 2);
    var returnValue = _.partial(this._id.splice, idx, numRemove).apply(this._id, _.pluck(add, '_id'));
    if (this.related) {
        _.partial(this.related.splice, idx, numRemove).apply(this.related, add);
    }
    return returnValue;
}

function objAsString(obj) {
    function _objAsString(obj) {
        if (obj) {
            var mapping = obj.mapping;
            var mappingName = mapping.type;
            var ident = obj._id;
            if (typeof ident == 'string') {
                ident = '"' + ident + '"';
            }
            return mappingName + '[_id=' + ident + ']';
        } else if (obj === undefined) {
            return 'undefined';
        } else if (obj === null) {
            return 'null';
        }
    }

    if (util.isArray(obj)) return _.map(_objAsString, obj).join(', ');
    return _objAsString(obj);
}

function clearReverseRelated() {
    var self = this;
    if (!self.isFault) {
        if (this.related) {
            var reverseProxy = getReverseProxyForObject.call(this, this.related);
            var reverseProxies = util.isArray(reverseProxy) ? reverseProxy : [reverseProxy];
            _.each(reverseProxies, function(p) {
                if (util.isArray(p._id)) {
                    var idx = p._id.indexOf(self.object._id);
                    makeChangesToRelatedWithoutObservations.call(p, function() {
                        splice.call(p, idx, 1);
                    });
                } else {
                    set.call(p, null);
                }
            });
        }
    } else {
        if (self._id) {
            var reverseName = getReverseName.call(this);
            var reverseMapping = getReverseMapping.call(this);
            var identifiers = util.isArray(self._id) ? self._id : [self._id];
            if (this._reverseIsArray) {
                _.each(identifiers, function(_id) {
                    coreChanges.registerChange({
                        collection: reverseMapping.collection,
                        mapping: reverseMapping.type,
                        _id: _id,
                        field: reverseName,
                        removedId: [self.object._id],
                        removed: [self.object],
                        type: ChangeType.Delete,
                        obj: self.object
                    });
                });
            } else {
                _.each(identifiers, function(_id) {
                    coreChanges.registerChange({
                        collection: reverseMapping.collection,
                        mapping: reverseMapping.type,
                        _id: _id,
                        field: reverseName,
                        new: null,
                        newId: null,
                        oldId: self.object._id,
                        old: self.object,
                        type: ChangeType.Set,
                        obj: self.object
                    });
                });
            }

        } else {
            throw new Error(getForwardName.call(this) + ' has no _id');
        }
    }
}

function makeChangesToRelatedWithoutObservations(f) {
    if (this.related) {
        this.related.oneToManyObserver.close();
        this.related.oneToManyObserver = null;
        f();
        wrapArray.call(this, this.related);
    } else {
        // If there's a fault we can make changes anyway.
        f();
    }
}

function setReverse(obj) {
    var self = this;
    var reverseProxy = getReverseProxyForObject.call(this, obj);
    var reverseProxies = util.isArray(reverseProxy) ? reverseProxy : [reverseProxy];
    _.each(reverseProxies, function(p) {
        if (util.isArray(p._id)) {
            makeChangesToRelatedWithoutObservations.call(p, function() {
                splice.call(p, p._id.length, 0, self.object);
            });
        } else {
            clearReverseRelated.call(p);
            set.call(p, self.object);
        }
    });
}

function registerSetChange(obj) {
    var proxyObject = this.object;
    if (!proxyObject) throw new InternalSiestaError('Proxy must have an object associated');
    var mapping = proxyObject.mapping.type;
    var coll = proxyObject.collection;
    var newId;
    if (util.isArray(obj)) {
        newId = _.pluck(obj, '_id');
    } else {
        newId = obj ? obj._id : obj;
    }
    // We take [] == null == undefined in the case of relationships.
    var oldId = this._id;
    if (util.isArray(oldId) && !oldId.length) {
        oldId = null;
    }
    var old = this.related;
    if (util.isArray(old) && !old.length) {
        old = null;
    }
    coreChanges.registerChange({
        collection: coll,
        mapping: mapping,
        _id: proxyObject._id,
        field: getForwardName.call(this),
        newId: newId,
        oldId: oldId,
        old: old,
        new: obj,
        type: ChangeType.Set,
        obj: proxyObject
    });
}

function registerSpliceChange(idx, numRemove) {
    var add = Array.prototype.slice.call(arguments, 2);
    var mapping = this.object.mapping.type;
    var coll = this.object.collection;
    coreChanges.registerChange({
        collection: coll,
        mapping: mapping,
        _id: this.object._id,
        field: getForwardName.call(this),
        index: idx,
        removedId: this._id.slice(idx, idx + numRemove),
        removed: this.related ? this.related.slice(idx, idx + numRemove) : null,
        addedId: add.length ? _.pluck(add, '_id') : [],
        added: add.length ? add : [],
        type: ChangeType.Splice,
        obj: this.object
    });
}


function wrapArray(arr) {
    var self = this;
    wrapArrayForAttributes(arr, this.reverseName, this.object);
    if (!arr.oneToManyObserver) {
        arr.oneToManyObserver = new ArrayObserver(arr);
        var observerFunction = function(splices) {
            splices.forEach(function(splice) {
                var added = splice.addedCount ? arr.slice(splice.index, splice.index + splice.addedCount) : [];
                var mapping = getForwardMapping.call(self);
                coreChanges.registerChange({
                    collection: mapping.collection,
                    mapping: mapping.type,
                    _id: self.object._id,
                    field: getForwardName.call(self),
                    removed: splice.removed,
                    added: added,
                    removedId: _.pluck(splice.removed, '_id'),
                    addedId: _.pluck(splice.added, '_id'),
                    type: ChangeType.Splice,
                    obj: self.object
                });
            });
        };
        arr.oneToManyObserver.open(observerFunction);
    }
}

exports.RelationshipProxy = RelationshipProxy;
exports.Fault = Fault;
exports.getReverseProxyForObject = getReverseProxyForObject;
exports.getForwardProxyForObject = getForwardProxyForObject;
exports.getReverseName = getReverseName;
exports.getForwardName = getForwardName;
exports.getReverseMapping = getReverseMapping;
exports.getForwardMapping = getForwardMapping;
exports.checkInstalled = checkInstalled;
exports.set = set;
exports.registerSetChange = registerSetChange;
exports.splice = splice;
exports.clearReverseRelated = clearReverseRelated;
exports.setReverse = setReverse;
exports.objAsString = objAsString;
exports.wrapArray = wrapArray;
exports.registerSpliceChange = registerSpliceChange;
exports.makeChangesToRelatedWithoutObservations = makeChangesToRelatedWithoutObservations;
},{"../vendor/observe-js/src/observe":106,"../vendor/operations.js/src/log":107,"../vendor/operations.js/src/operation":108,"./changes":44,"./error":47,"./misc":51,"./notificationCentre":52,"./query":57,"./store":59,"./util":60}],57:[function(require,module,exports){
/**
 * @module query
 */

var log = require('../vendor/operations.js/src/log');
var cache = require('./cache');
var Logger = log.loggerWithName('Query');
var q = require('q');
var util = require('./util');
Logger.setLevel(log.Level.warn);

/**
 * @class  [Query description]
 * @param {Mapping} mapping
 * @param {Object} opts
 */
function Query(mapping, opts) {
    this.mapping = mapping;
    this.query = opts;
}

/**
 * If the storage extension is enabled, objects may be faulted and so we need to query via PouchDB. The storage
 * extension provides the RawQuery class to enable this.
 * @param callback
 * @private
 */
function _executeUsingStorageExtension(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var storageExtension = siesta.ext.storage;
    var RawQuery = storageExtension.RawQuery;
    var Pouch = storageExtension.Pouch;
    var rawQuery = new RawQuery(this.mapping.collection, this.mapping.type, this.query);
    rawQuery.execute(function(err, results) {
        if (err) {
            callback(err);
        } else {
            if (Logger.debug.isEnabled)
                Logger.debug('got results', results);
            if (callback) callback(null, Pouch.toSiesta(results));
        }
    });
    return deferred.promise;
}

/**
 * Returns true if the given object matches the query.
 * @param {SiestaModel} obj
 * @returns {boolean}
 */
function objectMatchesQuery(obj) {
    var fields = Object.keys(this.query);
    for (var i = 0; i < fields.length; i++) {
        var origField = fields[i];
        var splt = origField.split('__');
        var op = 'e';
        var field;
        if (splt.length == 2) {
            field = splt[0]
            op = splt[1];
        } else {
            field = origField;
        }
        var queryObj = this.query[origField];
        var val = obj[field];
        if (op == 'e') {
            if (val != queryObj) {
                return false;
            }
        } else if (op == 'lt') {
            if (val >= queryObj) {
                return false;
            }
        } else if (op == 'lte') {
            if (val > queryObj) {
                return false;
            }
        } else if (op == 'gt') {
            if (val <= queryObj) {
                return false;
            }
        } else if (op == 'gte') {
            if (val < queryObj) {
                return false;
            }
        } else {
            return 'Query operator "' + op + '"' + ' does not exist';
        }
    }
    return true;
}

/**
 * If the storage extension is not enabled, we simply cycle through all objects of the type requested in memory.
 * @param callback
 * @private
 */
function _executeInMemory(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var cacheByType = cache._localCacheByType;
    var mappingName = this.mapping.type;
    var collectionName = this.mapping.collection;
    var cacheByMapping = cacheByType[collectionName];
    var cacheByLocalId;
    if (cacheByMapping) {
        cacheByLocalId = cacheByMapping[mappingName];
    }
    if (cacheByLocalId) {
        var keys = Object.keys(cacheByLocalId);
        var self = this;
        var res = [];
        var err;
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            var obj = cacheByLocalId[k];
            var matches = objectMatchesQuery.call(self, obj);
            if (typeof(matches) == 'string') {
                err = matches;
                break;
            } else {
                if (matches) res.push(obj);
            }
        }
        callback(err, err ? null : res);
    } else if (callback) {
        callback(null, []);
    }
    return deferred.promise;
}

Query.prototype.execute = function(callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    // if (siesta.ext.storageEnabled) {
    //     _executeUsingStorageExtension.call(this, callback);
    // }
    // else {
    _executeInMemory.call(this, callback);
    // }
    return deferred.promise;
};

Query.prototype._dump = function(asJson) {
    // TODO
    return asJson ? '{}' : {};
};

exports.Query = Query;
},{"../vendor/operations.js/src/log":107,"./cache":43,"./util":60,"q":42}],58:[function(require,module,exports){
/**
 * @module relationship
 */

/**
 * Constants that describe relationships for mappings.
 * @type {Object}
 */
RelationshipType = {
    OneToMany: 'OneToMany',
    OneToOne: 'OneToOne',
    ManyToMany: 'ManyToMany'
};

exports.RelationshipType = RelationshipType;
},{}],59:[function(require,module,exports){
/**
 * The "store" is responsible for mediating between the in-memory cache and any persistent storage.
 * Note that persistent storage has not been properly implemented yet and so this is pretty useless.
 * All queries will go straight to the cache instead.
 * @module store
 */

var wrappedCallback = require('./misc').wrappedCallback;
var InternalSiestaError = require('./error').InternalSiestaError;
var log = require('../vendor/operations.js/src/log');
var Logger = log.loggerWithName('Store');
Logger.setLevel(log.Level.warn);

var util = require('./util');
var _ = util._;
var cache = require('./cache');
var q = require('q');


/**
 * [get description]
 * @param  {Object}   opts
 * @param  {Function} callback
 * @return {Promise}
 * @example
 * ```js
 * var xyz = 'afsdf';
 * ```
 * @example
 * ```js
 * var abc = 'asdsd';
 * ```
 */
function get(opts, callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    if (Logger.debug.isEnabled)
        Logger.debug('get', opts);
    var siestaModel;
    if (opts._id) {
        if (util.isArray(opts._id)) {
            // Proxy onto getMultiple instead.
            getMultiple(_.map(opts._id, function(id) {
                return {
                    _id: id
                }
            }), callback);
        } else {
            siestaModel = cache.get(opts);
            if (siestaModel) {
                if (Logger.debug.isEnabled)
                    Logger.debug('Had cached object', {
                        opts: opts,
                        obj: siestaModel
                    });
                wrappedCallback(callback)(null, siestaModel);
            } else {
                if (util.isArray(opts._id)) {
                    // Proxy onto getMultiple instead.
                    getMultiple(_.map(opts._id, function(id) {
                        return {
                            _id: id
                        }
                    }), callback);
                } else if (callback) {
                    var storage = siesta.ext.storage;
                    if (storage) {
                        storage.store.getFromPouch(opts, callback);
                    } else {
                        throw 'Storage module not installed'
                    }
                }
            }
        }
    } else if (opts.mapping) {
        if (util.isArray(opts[opts.mapping.id])) {
            // Proxy onto getMultiple instead.
            getMultiple(_.map(opts[opts.mapping.id], function(id) {
                var o = {};
                o[opts.mapping.id] = id;
                o.mapping = opts.mapping;
                return o
            }), callback);
        } else {
            siestaModel = cache.get(opts);
            if (siestaModel) {
                if (Logger.debug.isEnabled)
                    Logger.debug('Had cached object', {
                        opts: opts,
                        obj: siestaModel
                    });
                wrappedCallback(callback)(null, siestaModel);
            } else {
                var mapping = opts.mapping;
                if (mapping.singleton) {
                    mapping.get(callback);
                } else {
                    var idField = mapping.id;
                    var id = opts[idField];
                    if (id) {
                        mapping.get(id, function(err, obj) {
                            if (!err) {
                                if (obj) {
                                    callback(null, obj);
                                } else {
                                    callback(null, null);
                                }
                            } else {
                                callback(err);
                            }
                        });
                    } else {
                        wrappedCallback(callback)(new InternalSiestaError('Invalid options given to store. Missing "' + idField.toString() + '."', {
                            opts: opts
                        }));
                    }
                }

            }
        }
    } else {
        // No way in which to find an object locally.
        var context = {
            opts: opts
        };
        var msg = 'Invalid options given to store';
        Logger.error(msg, context);
        wrappedCallback(callback)(new InternalSiestaError(msg, context));
    }
    return deferred.promise;
}

function getMultiple(optsArray, callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var docs = [];
    var errors = [];
    _.each(optsArray, function(opts) {
        get(opts, function(err, doc) {
            if (err) {
                errors.push(err);
            } else {
                docs.push(doc);
            }
            if (docs.length + errors.length == optsArray.length) {
                if (callback) {
                    if (errors.length) {
                        callback(errors);
                    } else {
                        callback(null, docs);
                    }
                }
            }
        });
    });
    return deferred.promise;
}
/**
 * Uses pouch bulk fetch API. Much faster than getMultiple.
 * @param localIdentifiers
 * @param callback
 */
function getMultipleLocal(localIdentifiers, callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var results = _.reduce(localIdentifiers, function(memo, _id) {
        var obj = cache.get({
            _id: _id
        });
        if (obj) {
            memo.cached[_id] = obj;
        } else {
            memo.notCached.push(_id);
        }
        return memo;
    }, {
        cached: {},
        notCached: []
    });

    function finish(err) {
        if (callback) {
            if (err) {
                callback(err);
            } else {
                callback(null, _.map(localIdentifiers, function(_id) {
                    return results.cached[_id];
                }));
            }
        }
    }
    if (siesta.ext.storageEnabled && results.notCached.length) {
        siesta.ext.storage.store.getMultipleLocalFromCouch(results, finish);
    } else {
        finish();
    }
    return deferred.promise;
}

function getMultipleRemote(remoteIdentifiers, mapping, callback) {
    var deferred = q.defer();
    callback = util.constructCallbackAndPromiseHandler(callback, deferred);
    var results = _.reduce(remoteIdentifiers, function(memo, id) {
        var cacheQuery = {
            mapping: mapping
        };
        cacheQuery[mapping.id] = id;
        var obj = cache.get(cacheQuery);
        if (obj) {
            memo.cached[id] = obj;
        } else {
            memo.notCached.push(id);
        }
        return memo;
    }, {
        cached: {},
        notCached: []
    });

    function finish(err) {
        if (callback) {
            if (err) {
                callback(err);
            } else {
                callback(null, _.map(remoteIdentifiers, function(id) {
                    return results.cached[id];
                }));
            }
        }
    }

    if (siesta.ext.storageEnabled && results.notCached.length) {
        siesta.ext.storage.store.getMultipleRemoteFrompouch(mapping, remoteIdentifiers, results, finish);
    } else {
        finish();
    }
    return deferred.promise;
}

exports.get = get;
exports.getMultiple = getMultiple;
exports.getMultipleLocal = getMultipleLocal;
exports.getMultipleRemote = getMultipleRemote;
},{"../vendor/operations.js/src/log":107,"./cache":43,"./error":47,"./misc":51,"./util":60,"q":42}],60:[function(require,module,exports){
/*
 * This is a collection of utilities taken from libraries such as async.js, underscore.js etc.
 * @module util
 */

function printStackTrace() {
    var e = new Error('printStackTrace');
    var stack = e.stack;
    console.log(stack);
}

function capitaliseFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

exports.printStackTrace = printStackTrace;
exports.capitaliseFirstLetter = capitaliseFirstLetter;

var root = {};
// START async.js //

var isArray = Array.isArray || function(obj) {
    return _toString.call(obj) === '[object Array]';
};

function doParallel(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments);
        return fn.apply(null, [each].concat(args));
    };
}

var map = doParallel(_asyncMap);

function _map(arr, iterator) {
    if (arr.map) {
        return arr.map(iterator);
    }
    var results = [];
    each(arr, function(x, i, a) {
        results.push(iterator(x, i, a));
    });
    return results;
}

function _asyncMap(eachfn, arr, iterator, callback) {
    arr = _map(arr, function(x, i) {
        return {
            index: i,
            value: x
        };
    });
    if (!callback) {
        eachfn(arr, function(x, callback) {
            iterator(x.value, function(err) {
                callback(err);
            });
        });
    } else {
        var results = [];
        eachfn(arr, function(x, callback) {
            iterator(x.value, function(err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function(err) {
            callback(err, results);
        });
    }
}

var mapSeries = doSeries(_asyncMap);

function doSeries(fn) {
    return function() {
        var args = Array.prototype.slice.call(arguments);
        return fn.apply(null, [eachSeries].concat(args));
    };
}



function eachSeries(arr, iterator, callback) {
    callback = callback || function() {};
    if (!arr.length) {
        return callback();
    }
    var completed = 0;
    var iterate = function() {
        iterator(arr[completed], function(err) {
            if (err) {
                callback(err);
                callback = function() {};
            } else {
                completed += 1;
                if (completed >= arr.length) {
                    callback();
                } else {
                    iterate();
                }
            }
        });
    };
    iterate();
}




function _each(arr, iterator) {
    if (arr.forEach) {
        return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
        iterator(arr[i], i, arr);
    }
}

function each(arr, iterator, callback) {
    callback = callback || function() {};
    if (!arr.length) {
        return callback();
    }
    var completed = 0;
    _each(arr, function(x) {
        iterator(x, only_once(done));
    });

    function done(err) {
        if (err) {
            callback(err);
            callback = function() {};
        } else {
            completed += 1;
            if (completed >= arr.length) {
                callback();
            }
        }
    }
}

function keys(obj) {
    if (Object.keys) {
        return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
        if (obj.hasOwnProperty(k)) {
            keys.push(k);
        }
    }
    return keys;
}


var _parallel = function(eachfn, tasks, callback) {
    callback = callback || function() {};
    if (isArray(tasks)) {
        eachfn.map(tasks, function(fn, callback) {
            if (fn) {
                fn(function(err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    callback.call(null, err, args);
                });
            }
        }, callback);
    } else {
        var results = {};
        eachfn.each(keys(tasks), function(k, callback) {
            tasks[k](function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                results[k] = args;
                callback(err);
            });
        }, function(err) {
            callback(err, results);
        });
    }
};

function series(tasks, callback) {
    callback = callback || function() {};
    if (_isArray(tasks)) {
        mapSeries(tasks, function(fn, callback) {
            if (fn) {
                fn(function(err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    callback.call(null, err, args);
                });
            }
        }, callback);
    } else {
        var results = {};
        eachSeries(_keys(tasks), function(k, callback) {
            tasks[k](function(err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                results[k] = args;
                callback(err);
            });
        }, function(err) {
            callback(err, results);
        });
    }
}

function only_once(fn) {
    var called = false;
    return function() {
        if (called) throw new Error("Callback was already called.");
        called = true;
        fn.apply(root, arguments);
    }
}

function parallel(tasks, callback) {
    _parallel({
        map: map,
        each: each
    }, tasks, callback);
}

exports.series = series;
exports.parallel = parallel;
exports.isArray = isArray;

// END async.js //

// START underscore.js //

var _ = {};
var ArrayProto = Array.prototype;
var FuncProto = Function.prototype;

var nativeForEach = ArrayProto.forEach;
var nativeMap = ArrayProto.map;
var nativeReduce = ArrayProto.reduce;
var nativeBind = FuncProto.bind;
var slice = ArrayProto.slice;
var breaker = {};

_.keys = keys;

_.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
        }
    } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
            if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        }
    }
    return obj;
};

// Return the results of applying the iterator to each element.
// Delegates to **ECMAScript 5**'s native `map` if available.
_.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    _.each(obj, function(value, index, list) {
        results.push(iterator.call(context, value, index, list));
    });
    return results;
};

// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. _ acts
// as a placeholder, allowing any combination of arguments to be pre-filled.
_.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
        var position = 0;
        var args = boundArgs.slice();
        for (var i = 0, length = args.length; i < length; i++) {
            if (args[i] === _) args[i] = arguments[position++];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return func.apply(this, args);
    };
};

// Convenience version of a common use case of `map`: fetching a property.
_.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
};

var reduceError = 'Reduce of empty array with no initial value';

// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
        if (context) iterator = _.bind(iterator, context);
        return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    _.each(obj, function(value, index, list) {
        if (!initial) {
            memo = value;
            initial = true;
        } else {
            memo = iterator.call(context, memo, value, index, list);
        }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
};

_.property = function(key) {
    return function(obj) {
        return obj[key];
    };
};

// Optimize `isFunction` if appropriate.
if (typeof(/./) !== 'function') {
    _.isFunction = function(obj) {
        return typeof obj === 'function';
    };
}

// An internal function to generate lookup iterators.
var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
};

// Sort the object's values by a criterion produced by an iterator.
_.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
        return {
            value: value,
            index: index,
            criteria: iterator.call(context, value, index, list)
        };
    }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
            if (a > b || a === void 0) return 1;
            if (a < b || b === void 0) return -1;
        }
        return left.index - right.index;
    }), 'value');
};

var ctor = function() {};

// Create a function bound to a given object (assigning `this`, and arguments,
// optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
// available.
_.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
        if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
        ctor.prototype = func.prototype;
        var self = new ctor;
        ctor.prototype = null;
        var result = func.apply(self, args.concat(slice.call(arguments)));
        if (Object(result) === result) return result;
        return self;
    };
};


// END underscore.js //

exports._ = _;
var observe = require('../vendor/observe-js/src/observe').Platform;

function next(callback) {
    observe.performMicrotaskCheckpoint();
    setTimeout(callback);
}


/**
 * Performs dirty check/Object.observe callbacks depending on the browser.
 *
 * If Object.observe is present,
 * @param callback
 */
exports.next = next;

/**
 * Returns a handler that acts upon a callback or a promise depending on the result of a different callback.
 * @param callback
 * @param [promise]
 * @returns {Function}
 */
exports.constructCallbackAndPromiseHandler = function(callback, promise) {
    return function(err) {
        if (callback) callback.apply(callback, arguments);
        if (promise) {
            if (err) promise.reject(err);
            else promise.resolve.apply(promise, Array.prototype.slice.call(arguments, 1));
        }
    };
};
},{"../vendor/observe-js/src/observe":106}],61:[function(require,module,exports){
var chai = require('chai');
var s = require('../index'),
    assert = chai.assert;

var mappingOperation = require('../src/mappingOperation');
var BulkMappingOperation = mappingOperation.BulkMappingOperation;
var util = require('../src/util');
var RelationshipType = require('../src/relationship').RelationshipType;
var Collection = require('../src/collection').Collection;
var cache = require('../src/cache');
var collection;
var Repo, User;

assert.arrEqual = function(arr1, arr2) {
    if (!util.isArray(arr1)) throw new chai.AssertionError(arr1.toString() + ' is not an array');
    if (!util.isArray(arr2)) throw new chai.AssertionError(arr2.toString() + ' is not an array');
    _.chain(arr1).zip(arr2).each(function(x) {
        if (util.isArray(x[0]) && util.isArray(x[1])) {
            assert.arrEqual(x[0], x[1]);
        } else if (x[0] != x[1]) {
            throw new chai.AssertionError(arr1.toString() + ' != ' + arr2.toString());
        }
    });
};

describe('array flattening', function() {
    describe('flatten', function() {
        it('mixture', function() {
            var flattened = mappingOperation.flattenArray(['1', ['2', '3'],
                ['4'], '5'
            ]);
            assert.arrEqual(['1', '2', '3', '4', '5'], flattened);
        });

        it('all arrays', function() {
            var flattened = mappingOperation.flattenArray([
                ['1'],
                ['2', '3'],
                ['4'],
                ['5']
            ]);
            assert.arrEqual(['1', '2', '3', '4', '5'], flattened);
        });

        it('no arrays', function() {
            var flattened = mappingOperation.flattenArray(['1', '2', '3', '4', '5']);
            assert.arrEqual(['1', '2', '3', '4', '5'], flattened);
        });
    });
    describe('unflatten', function() {
        it('mixture', function() {
            var unflattened = mappingOperation.unflattenArray(['a', 'b', 'c', 'd', 'e'], ['1', ['2', '3'],
                ['4'], '5'
            ]);
            assert.arrEqual(['a', ['b', 'c'],
                ['d'], 'e'
            ], unflattened);
        });
    });
});

describe('bulk mapping operation', function() {
    describe('general', function() {
        beforeEach(function(done) {
            s.reset(true);

            collection = new Collection('MyCollection');
            collection.baseURL = 'https://api.github.com';
            Repo = collection.mapping('Repo', {
                id: 'id',
                attributes: ['name', 'full_name', 'description'],
                relationships: {
                    owner: {
                        mapping: 'User',
                        type: RelationshipType.OneToMany,
                        reverse: 'repositories'
                    }
                }
            });
            User = collection.mapping('User', {
                id: 'id',
                attributes: ['login']
            });
            collection.install(done);
        });

        describe('errors', function() {

            describe('simple', function() {
                var op;

                beforeEach(function(done) {
                    var data = [{
                        login: 'mike',
                        id: '123',
                        repositories: 5 // Invalid
                    }, {
                        login: 'mike2',
                        id: '122315634',
                        repositories: [ // Valid
                            {
                                name: 'Repo'
                            }
                        ]
                    }, {
                        login: 'mike4',
                        id: '123124',
                        repositories: 'asdas' // Invalid
                    }, {
                        login: 'mike3',
                        id: '12324',
                        repositories: [ // Invalid
                            {
                                _id: 'nosuchlocalid'
                            }
                        ]
                    }];
                    op = new BulkMappingOperation({
                        mapping: User,
                        data: data
                    });
                    op.onCompletion(function() {
                        done();
                    });
                    op.start();

                });

                it('scalar int', function() {
                    assert.ok(op.error[0]);
                    assert.ok(op.error[0].repositories);
                });

                it('valid', function() {
                    assert.notOk(op.error[1]);
                });

                it('scalar string', function() {
                    assert.ok(op.error[2]);
                    assert.ok(op.error[2].repositories);
                });

                it('invalid _id', function() {
                    assert.ok(op.error[3]);
                    assert.ok(op.error[3].repositories);
                });

            });

            it('non-existent _id', function(done) {
                var data = [{
                    _id: 'nonexistant'
                }];

                var op = new BulkMappingOperation({
                    mapping: User,
                    data: data
                });
                op.onCompletion(function() {
                    assert.ok(op.error);
                    done();
                });
                op.start();
            });

            it('array to scalar', function(done) {
                var data = [{
                    owner: [5, 6]
                }];

                var op = new BulkMappingOperation({
                    mapping: Repo,
                    data: data
                });
                op.onCompletion(function() {
                    assert.ok(op.error);
                    done();
                });
                op.start();
            });

            it('scalar to array', function(done) {
                var data = [{
                    login: 'mike4',
                    id: '123124',
                    repositories: 5
                }];
                var op = new BulkMappingOperation({
                    mapping: User,
                    data: data
                });
                op.onCompletion(function() {
                    assert.ok(op.error);
                    done();
                });
                op.start();
            });


        });

        describe('new', function() {

            describe('foreign key', function() {

                describe('forward', function() {
                    it('sub operations', function() {
                        var owner = {
                            id: 6,
                            login: 'mike'
                        };
                        var data = [{
                            name: 'Repo',
                            full_name: 'A Big Repo',
                            description: 'Blah',
                            _id: 'sdfsd'
                        }, {
                            name: 'Repo2',
                            full_name: 'Another Big Repo',
                            description: 'Blsdah',
                            id: 'sdfsd',
                            owner: 5
                        }, {
                            name: 'Repo3',
                            full_name: 'Yet Another Big Repo',
                            description: 'Blahasdasd',
                            owner: owner
                        }];
                        var op = new BulkMappingOperation({
                            mapping: Repo,
                            data: data
                        });
                        op._constructSubOperations();
                        var ownerSubOperation = op.subOps.owner.op;
                        var ownerIndexes = op.subOps.owner.indexes;
                        assert.equal(ownerIndexes.length, 2);
                        assert.include(ownerIndexes, 1);
                        assert.include(ownerIndexes, 2);
                        assert.equal(ownerSubOperation.mapping, User);
                        assert.equal(ownerSubOperation.data[0], 5);
                        assert.equal(ownerSubOperation.data[1], owner);
                    });

                    it('none existing', function(done) {
                        var owner = {
                            id: 5,
                            login: 'mike'
                        };
                        var data = [{
                            name: 'Repo',
                            full_name: 'A Big Repo',
                            description: 'Blah',
                            id: 'remoteId1'
                        }, {
                            name: 'Repo2',
                            full_name: 'Another Big Repo',
                            description: 'Blsdah',
                            id: 'remoteId2',
                            owner: 5
                        }, {
                            name: 'Repo3',
                            full_name: 'Yet Another Big Repo',
                            description: 'Blahasdasd',
                            id: 'remoteId3',
                            owner: owner
                        }];
                        var op = new BulkMappingOperation({
                            mapping: Repo,
                            data: data
                        });
                        op.onCompletion(function() {
                            var err = op.error;
                            if (err) {
                                done(err);
                            }
                            var objects = this.objects;
                            var repo = objects[0];
                            var repo2 = objects[1];
                            var repo3 = objects[2];
                            // Check attributes have been mapped correctly.
                            assert.equal(repo.id, 'remoteId1');
                            assert.equal(repo.description, 'Blah');
                            assert.equal(repo.full_name, 'A Big Repo');
                            assert.equal(repo.name, 'Repo');
                            assert.equal(repo2.id, 'remoteId2');
                            assert.equal(repo2.description, 'Blsdah');
                            assert.equal(repo2.full_name, 'Another Big Repo');
                            assert.equal(repo2.name, 'Repo2');
                            assert.equal(repo3.id, 'remoteId3');
                            assert.equal(repo3.description, 'Blahasdasd');
                            assert.equal(repo3.full_name, 'Yet Another Big Repo');
                            assert.equal(repo3.name, 'Repo3');
                            // Check relationships have been mapped correctly.
                            assert.equal(repo2.owner, repo3.owner);
                            done();
                        });
                        op.start();
                    });

                });

                describe('reverse', function() {
                    it('none existing', function(done) {
                        var data = [{
                            login: 'mike',
                            id: '123',
                            repositories: [{
                                id: 5,
                                name: 'Repo',
                                full_name: 'A Big Repo'
                            }]
                        }];
                        var op = new BulkMappingOperation({
                            mapping: User,
                            data: data
                        });
                        op.onCompletion(function() {
                            if (op.error) {
                                console.error(JSON.stringify(op.error, null, 4));
                                done(op.error);
                            }
                            var objects = op.result;
                            assert.equal(objects.length, 1);
                            var obj = objects[0];
                            assert.equal(obj.login, 'mike');
                            assert.equal(obj.id, '123');
                            assert.equal(obj.repositories.length, 1);
                            var repo = obj.repositories[0];
                            assert.equal(repo.id, 5);
                            assert.equal(repo.name, 'Repo');
                            assert.equal(repo.full_name, 'A Big Repo');
                            assert.equal(repo.owner, obj);
                            done();
                        });
                        op.start();
                    });

                    it('existing', function(done) {
                        var repo = Repo._new({
                            id: '5',
                            name: 'Old Name',
                            full_name: 'Old Full Name',
                            collection: 'MyCollection',
                            type: 'Repo'
                        });
                        cache.insert(repo);
                        var data = [{
                            login: 'mike',
                            id: '123',
                            repositories: [{
                                id: '5',
                                name: 'Repo',
                                full_name: 'A Big Repo'
                            }]
                        }];
                        var op = new BulkMappingOperation({
                            mapping: User,
                            data: data
                        });
                        op.onCompletion(function() {
                            if (op.error) {
                                done(op.error);
                            } else {
                                var objects = op.result;
                                try {
                                    assert.equal(objects.length, 1);
                                    var obj = objects[0];
                                    assert.equal(obj.login, 'mike');
                                    assert.equal(obj.id, '123');
                                    assert.equal(obj.repositories.length, 1);
                                    var repo = obj.repositories[0];
                                    assert.equal(repo.id, 5);
                                    assert.equal(repo.name, 'Repo');
                                    assert.equal(repo.full_name, 'A Big Repo');
                                    assert.equal(repo.owner, obj);
                                    done();
                                } catch (err) {
                                    done(err);
                                }
                            }
                        });
                        op.start();

                    })
                });

            });

            describe('no relationships', function() {
                var op;

                describe('none existing', function() {
                    beforeEach(function() {
                        var data = [{
                            login: 'mike',
                            id: '123'
                        }, {
                            login: 'bob',
                            id: '1234'
                        }];
                        op = new BulkMappingOperation({
                            mapping: User,
                            data: data
                        });
                    });

                    it('lookup', function(done) {
                        op._lookup(function() {
                            assert.equal(op.objects.length, 2);
                            assert.notOk(op.objects[0].login);
                            assert.notOk(op.objects[1].login);
                            done();
                        });
                    });

                    it('completion', function(done) {
                        op.onCompletion(function() {
                            var objects = op.result;
                            assert.equal(objects.length, 2);
                            var mike = objects[0];
                            var bob = objects[1];
                            assert.equal(mike.login, 'mike');
                            assert.equal(mike.id, '123');
                            assert.equal(bob.login, 'bob');
                            assert.equal(bob.id, '1234');
                            done();
                        });
                        op.start();
                    });

                });


            });
        });
    });

    describe('singleton...', function() {
        var op;

        beforeEach(function(done) {
            s.reset(true);

            collection = new Collection('MyCollection');
            collection.baseURL = 'https://api.github.com';
            Repo = collection.mapping('Repo', {
                id: 'id',
                attributes: ['name', 'full_name', 'description'],
                relationships: {
                    owner: {
                        mapping: 'User',
                        type: RelationshipType.OneToMany,
                        reverse: 'repositories'
                    }
                }
            });
            User = collection.mapping('User', {
                id: 'id',
                attributes: ['login'],
                singleton: true
            });
            collection.install(done);
        });

        describe('new', function() {
            beforeEach(function() {
                var data = [{
                    login: 'mike',
                    id: '123'
                }, {
                    login: 'bob',
                    id: '1234'
                }];
                op = new BulkMappingOperation({
                    mapping: User,
                    data: data
                });
            });

            it('lookupSingleton', function(done) {
                op._lookupSingleton(function(err) {
                    if (!err) {
                        assert.equal(op.objects.length, 2);
                        assert.equal(op.objects[0], op.objects[1]);
                    }
                    done(err);
                });
            });

            it('map', function(done) {
                op.onCompletion(function() {
                    var err = op.error;
                    if (!err) {
                        assert.equal(op.objects.length, 2);
                        assert.equal(op.objects[0], op.objects[1]);
                        assert.equal(op.objects[0].login, 'bob');
                        assert.equal(op.objects[0].id, '1234');
                    }
                    done(err);
                });
                op.start();
            });
        });

        describe('existing, cached', function() {
            var obj;

            beforeEach(function() {
                obj = User._new({
                    id: '567'
                });
                var data = [{
                    login: 'mike',
                    id: '123'
                }, {
                    login: 'bob',
                    id: '1234'
                }];
                op = new BulkMappingOperation({
                    mapping: User,
                    data: data
                });
            });

            it('lookupSingleton', function(done) {
                op._lookupSingleton(function(err) {
                    if (!err) {
                        assert.equal(op.objects.length, 2);
                        assert.equal(op.objects[0], obj);
                        assert.equal(op.objects[0], op.objects[1]);
                    }
                    done(err);
                });
            });

            it('map', function(done) {
                op.onCompletion(function() {
                    var err = op.error;
                    if (!err) {
                        assert.equal(op.objects.length, 2);
                        assert.equal(op.objects[0], obj);
                        assert.equal(op.objects[0], op.objects[1]);
                        assert.equal(op.objects[0].login, 'bob');
                        assert.equal(op.objects[0].id, '1234');
                    }
                    done(err);
                });
                op.start();
            });
        });

    });

});

describe('bug', function() {

    var coll, Car;

    beforeEach(function(done) {
        siesta.reset(true);
        coll = new Collection('myCollection');
        Car = coll.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name']

        });
        coll.install(done);
    });

    it('multiple objects', function(done) {
        var data = [{
            colour: 'red',
            name: 'Aston Martin',
            id: '1'
        }, {
            colour: 'blue',
            name: 'Bentley',
            id: '2'
        }, {
            colour: 'green',
            name: 'Lambo',
            id: '3'
        }];
        Car.map(data, function(err) {
            if (err) done(err);
            Car.map(data, function(err) {
                if (err) done(err);
                // TODO
                done();
            });
        });
    });
});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/mappingOperation":50,"../src/relationship":58,"../src/util":60,"chai":9}],62:[function(require,module,exports){
var siesta = require('../index');
var assert = require('chai').assert;

describe('cache...', function() {
    var mapping;

    var SiestaModel = require('../src/object').SiestaModel;
    var Collection = require('../src/collection').Collection;
    var RelationshipType = require('../src/relationship').RelationshipType;
    var cache = require('../src/cache');

    beforeEach(function(done) {
        siesta.reset(true); 
        var coll = new Collection('myCollection');
        mapping = coll.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name']
        });
        coll.install(done);  
    });

    describe('insertion', function() {
        it('by pouch id', function() {
            var r = new SiestaModel(mapping);
            r._id = 'dsfsd';
            cache.insert(r);
            assert.equal(r, cache._localCache()[r._id]);
            assert.equal(r, cache._localCacheByType[r.mapping.collection][r.type][r._id], r);
        });

        it('by default id', function() {
            var r = new SiestaModel(mapping);
            r.id = 'dsfsd';
            cache.insert(r);

            var remoteCache = cache._remoteCache();
            assert.equal(r, remoteCache[r.collection][r.type][r.id]);
        });

        it('by custom id', function() {
            var m = mapping;
            m.id = 'customId';
            var r = new SiestaModel(m);
            r.customId = 'dsfsd';
            cache.insert(r);
            var remoteCache = cache._remoteCache();
            assert.equal(r, remoteCache[r.collection][r.type][r.customId]);
        });

    });

    describe('get', function() {
        it('by pouch id', function() {
            var r = new SiestaModel(mapping);
            r.id = 'dsfsd';
            cache.insert(r);
            var returned = cache.get({
                mapping: mapping,
                id: 'dsfsd'
            });
            assert.equal(returned, r);
        });
        it('by rest id', function() {
            var model = new SiestaModel(mapping);
            model.id = 'dsfsd';
            model._id = 'xyz';
            cache.insert(model);
            var returned = cache.get({
                mapping: mapping,
                id: 'dsfsd'
            });
            assert.equal(returned, model);
        });
    });

    describe('full test', function() {
        var collection, carMapping, personMapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        mapping: 'Person',
                        type: RelationshipType.OneToMany,
                        reverse: 'cars'
                    }
                }
            });
            collection.baseURL = 'http://mywebsite.co.uk/';
            var desc = new siesta.ext.http.ResponseDescriptor({
                method: 'GET',
                mapping: carMapping,
                path: '/cars/(?<id>[0-9])/?'
            });
            siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(desc);
            collection.install(done);
        });

        describe('errors', function() {
            it('ignore duplicate inserts if is the same object', function() {
                var person = personMapping._new({
                    name: 'Michael Ford',
                    age: 23,
                    id: 'xyz'
                });
                cache.insert(person);
                cache.insert(person); // Should be fine as is the exact same object.
            });

            it('cant insert object with same _id', function() {
                var person = personMapping._new({
                    name: 'Michael Ford',
                    age: 23,
                    id: 'xyz'
                });
                cache.insert(person);
                var duplicateObject = new SiestaModel();
                duplicateObject._id = person._id;
                assert.throws(function() {
                    cache.insert(duplicateObject);
                }, siesta.InternalSiestaError);
            });

            it('cant insert object with same id', function() {
                var person = personMapping._new({
                    name: 'Michael Ford',
                    age: 23,
                    id: 'xyz'
                });
                cache.insert(person);

                assert.throws(function() {
                    cache.insert(personMapping._new({
                        name: 'Michael Ford',
                        age: 23,
                        id: 'xyz'
                    }));
                }, siesta.InternalSiestaError);
            });
        });

    });

    describe('deletion', function () {
        it('xyz', function () {
            
        });
    });

});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/object":53,"../src/relationship":58,"chai":9}],63:[function(require,module,exports){
var s = require('../index')
    , assert = require('chai').assert;

describe('change identifiers', function () {

    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');
    var collection, carMapping;

    var car;

    beforeEach(function (done) {
        s.reset(true);
        collection = new Collection('myCollection');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name']
        });
        collection.install(function (err) {
            if (err) done(err);
            carMapping.map({id: 'xyz', colour: 'red', name: 'ford'}, function (err, _car) {
                if (err) done(err);
                car = _car;
                done();
            })
        });
    });

    it('xyz', function (done) {
        assert.equal(cache.get({id: 'xyz', mapping: carMapping}), car);
        car.id = 'abc';
        assert.notOk(cache.get({id: 'xyz', mapping: carMapping}), car);
        assert.equal(cache.get({id: 'abc', mapping: carMapping}), car);
        done();
    });

});
},{"../index":1,"../src/cache":43,"../src/collection":45,"chai":9}],64:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;


describe('http!', function() {

    var Collection = require('../src/collection').Collection;
    var RelationshipType = require('../src/relationship').RelationshipType;
    var SiestaModel = require('../src/object').SiestaModel;
    var InternalSiestaError = require('../src/error').InternalSiestaError;

    var collection, carMapping, personMapping, vitalSignsMapping;

    var server;

    beforeEach(function() {
        s.reset(true);
        server = sinon.fakeServer.create();
    });

    function configureCollection(callback) {
        collection = new Collection('myCollection');
        personMapping = collection.mapping('Person', {
            id: 'id',
            attributes: ['name', 'age']
        });
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            relationships: {
                owner: {
                    mapping: 'Person',
                    type: RelationshipType.OneToMany,
                    reverse: 'cars'
                }
            }
        });
        vitalSignsMapping = collection.mapping('VitalSigns', {
            id: 'id',
            attributes: ['heartRate', 'bloodPressure'],
            relationships: {
                owner: {
                    mapping: 'Person',
                    type: RelationshipType.OneToOne,
                    reverse: 'vitalSigns'
                }
            }
        });
        collection.baseURL = 'http://mywebsite.co.uk/';
        collection.install(callback);
    }

    afterEach(function() {
        // Restore original server implementation.
        server.restore();
    });


    describe('path regex', function() {


        describe('check', function() {

            beforeEach(function(done) {
                configureCollection(done);
                siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                    method: 'GET',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/(?<colour>[a-zA-Z0-9]+)/?'
                }));
                siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                    method: 'GET',
                    mapping: carMapping,
                    path: '/cars/(?<colour>[a-zA-Z0-9]+)/?'
                }));
            });

            describe('singular', function() {
                var err, obj, resp;

                beforeEach(function(done) {
                    var raw = {
                        colour: 'red',
                        name: 'Aston Martin',
                        owner: '093hodhfno',
                        id: '5'
                    };
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/cars/9/purple/";
                    var method = "GET";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    collection.GET('cars/9/purple/', function(_err, _obj, _resp) {
                        err = _err;
                        obj = _obj;
                        resp = _resp;
                        done();
                    });
                    server.respond();
                });

                it('should map regex matches onto the object', function() {
                    assert.instanceOf(obj, SiestaModel);
                    assert.equal(obj.colour, 'purple');
                    assert.equal(obj.name, 'Aston Martin');
                    assert.equal(obj.id, '9');
                });
            });

            describe('multiple', function() {
                var err, objs, resp;

                beforeEach(function(done) {
                    var raw = [{
                        colour: 'red',
                        name: 'Aston Martin',
                        owner: '093hodhfno',
                        id: '5'
                    }, {
                        colour: 'green',
                        name: 'Aston Martin',
                        owner: '093hodhfno',
                        id: '2'
                    }, {
                        colour: 'orange',
                        name: 'Aston Martin',
                        owner: '093hodhfno',
                        id: '1'
                    }];
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/cars/purple/";
                    var method = "GET";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    collection.GET('cars/purple/', function(_err, _objs, _resp) {
                        err = _err;
                        objs = _objs;
                        resp = _resp;
                        done();
                    });
                    server.respond();
                });

                it('should map regex matches onto the object', function() {
                    assert.notOk(err);
                    assert.ok(objs.length);
                    _.each(objs, function(obj) {
                        assert.equal(obj.colour, 'purple');
                        assert.equal(obj.name, 'Aston Martin');
                    });

                });
            });


        });
    });

    describe('verbs', function() {

        describe('GET', function() {

            beforeEach(function(done) {

                configureCollection(done);

            });

            describe('success', function() {
                var err, obj, resp;

                describe('single', function() {
                    beforeEach(function(done) {
                        siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                            method: 'GET',
                            mapping: carMapping,
                            path: '/cars/(?<id>[0-9])/?'
                        }));
                        var raw = {
                            colour: 'red',
                            name: 'Aston Martin',
                            owner: '093hodhfno',
                            id: '5'
                        };
                        var headers = {
                            "Content-Type": "application/json"
                        };
                        var path = "http://mywebsite.co.uk/cars/5/";
                        var method = "GET";
                        var status = 200;
                        server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                        collection.GET('cars/5/', function(_err, _obj, _resp) {
                            err = _err;
                            obj = _obj;
                            resp = _resp;
                            done();
                        });
                        server.respond();
                    });

                    it('no error', function() {
                        assert.notOk(err);
                    });

                    it('returns data', function() {
                        assert.equal(resp.data.colour, 'red');
                        assert.equal(resp.data.name, 'Aston Martin');
                        assert.equal(resp.data.owner, '093hodhfno');
                        assert.equal(resp.data.id, '5');
                    });

                    it('returns text status', function() {
                        assert.equal(resp.textStatus, 'success');
                    });

                    it('returns jqxhr', function() {
                        assert.ok(resp.jqXHR);
                    });

                    it('returns a car object', function() {
                        assert.instanceOf(obj, SiestaModel);
                        assert.equal(obj.colour, 'red');
                        assert.equal(obj.name, 'Aston Martin');
                        assert.equal(obj.id, '5');
                    })
                });

                describe('multiple', function() {
                    beforeEach(function(done) {
                        siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                            method: 'GET',
                            mapping: carMapping,
                            path: '/cars/?'
                        }));
                        var raw = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            owner: 'ownerId',
                            id: '5'
                        }, {
                            colour: 'blue',
                            name: 'Bentley',
                            owner: 'ownerId',
                            id: '6'
                        }];
                        var headers = {
                            "Content-Type": "application/json"
                        };
                        var path = "http://mywebsite.co.uk/cars/";
                        var method = "GET";
                        var status = 200;
                        server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                        collection.GET('cars/', function(_err, _obj, _resp) {
                            if (_err) done(_err);
                            obj = _obj;
                            resp = _resp;
                            done();
                        });
                        server.respond();
                    });

                    it('returns 2 car objects', function() {
                        assert.equal(obj.length, 2);
                        _.each(obj, function(car) {
                            assert.instanceOf(car, SiestaModel);
                        })
                    });

                    it('maps owner onto same obj', function() {
                        assert.equal(obj[0].owner._id, obj[1].owner._id);
                        assert.equal(obj[0].owner.relatedObject, obj[1].owner.relatedObject);
                    });
                });
            });
        });

        describe('DELETE', function() {
            beforeEach(function(done) {
                configureCollection(done);
            });

            describe('success', function() {
                describe('default', function(done) {
                    var err, obj, resp, objectToDelete;

                    beforeEach(function(done) {
                        var data = {
                            id: 'xyz',
                            colour: 'red',
                            name: 'Aston Martin'
                        };
                        carMapping.map(data, function(err, _objectToDelete) {
                            if (err) done(err);
                            objectToDelete = _objectToDelete;
                            siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                                method: 'DELETE',
                                mapping: carMapping,
                                path: '/cars/(?<id>[0-9])/?'
                            }));
                            var headers = {
                                "Content-Type": "application/json"
                            };
                            var path = "http://mywebsite.co.uk/cars/5/";
                            var method = "DELETE";
                            var status = 200;
                            server.respondWith(method, path, [status, headers, '{"status": "ok"}']);
                            collection.DELETE('cars/5/', _objectToDelete, function(_err, _obj, _resp) {
                                err = _err;
                                obj = _obj;
                                resp = _resp;
                                done();
                            });
                            server.respond();
                        });
                    });

                    it('no error', function() {
                        assert.notOk(err);
                    });

                    it('returns text status', function() {
                        assert.equal(resp.textStatus, 'success');
                    });

                    it('returns jqxhr', function() {
                        assert.ok(resp.jqXHR);
                    });

                    it('returns no object', function() {
                        assert.notOk(obj);
                    });

                    it('removed', function() {
                        assert.ok(objectToDelete.removed);
                    });
                });

                describe('delete now', function() {
                    it('should be removed', function(done) {
                        var data = {
                            id: 'xyz',
                            colour: 'red',
                            name: 'Aston Martin'
                        };
                        carMapping.map(data, function(err, _objectToDelete) {
                            if (err) done(err);
                            objectToDelete = _objectToDelete;
                            siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                                method: 'DELETE',
                                mapping: carMapping,
                                path: '/cars/(?<id>[0-9])/?'
                            }));
                            var headers = {
                                "Content-Type": "application/json"
                            };
                            var path = "http://mywebsite.co.uk/cars/5/";
                            var method = "DELETE";
                            var status = 200;
                            server.respondWith(method, path, [status, headers, '{"status": "ok"}']);
                            collection.DELETE('cars/5/', _objectToDelete, {
                                deletionMode: 'now'
                            }, function(_err, _obj, _resp) {
                                assert.ok(_objectToDelete.removed)
                                done();
                            });
                            assert.ok(_objectToDelete.removed);
                            server.respond();
                        });
                    });
                });

                describe('on success', function() {
                    it('should only be removed once finished', function(done) {
                        var data = {
                            id: 'xyz',
                            colour: 'red',
                            name: 'Aston Martin'
                        };
                        carMapping.map(data, function(err, _objectToDelete) {
                            if (err) done(err);
                            objectToDelete = _objectToDelete;
                            siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                                method: 'DELETE',
                                mapping: carMapping,
                                path: '/cars/(?<id>[0-9])/?'
                            }));
                            var headers = {
                                "Content-Type": "application/json"
                            };
                            var path = "http://mywebsite.co.uk/cars/5/";
                            var method = "DELETE";
                            var status = 200;
                            server.respondWith(method, path, [status, headers, '{"status": "ok"}']);
                            collection.DELETE('cars/5/', _objectToDelete, {
                                deletionMode: 'success'
                            }, function(_err, _obj, _resp) {
                                assert.ok(_objectToDelete.removed)
                                done();
                            });
                            assert.notOk(_objectToDelete.removed);
                            server.respond();
                        });
                    });
                });

                describe('restore', function() {
                    it('should be restored on failure', function(done) {
                        var data = {
                            id: 'xyz',
                            colour: 'red',
                            name: 'Aston Martin'
                        };
                        carMapping.map(data, function(err, _objectToDelete) {
                            if (err) done(err);
                            objectToDelete = _objectToDelete;
                            siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(new siesta.ext.http.ResponseDescriptor({
                                method: 'DELETE',
                                mapping: carMapping,
                                path: '/cars/(?<id>[0-9])/?'
                            }));
                            var headers = {
                                "Content-Type": "application/json"
                            };
                            var path = "http://mywebsite.co.uk/cars/5/";
                            var method = "DELETE";
                            var status = 500;
                            server.respondWith(method, path, [status, headers, '{"status": "ok"}']);
                            collection.DELETE('cars/5/', _objectToDelete, {
                                deletionMode: 'restore'
                            }, function(_err, _obj, _resp) {
                                assert.notOk(_objectToDelete.removed)
                                done();
                            });
                            assert.ok(_objectToDelete.removed);
                            server.respond();
                        });
                    });
                });
            });

        });

        describe('POST', function() {
            var err, obj, resp;
            beforeEach(function(done) {
                configureCollection(done);
                var responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    method: 'POST',
                    mapping: carMapping,
                    path: 'cars/?'
                });
                siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(responseDescriptor);
                var requestDescriptor = new siesta.ext.http.RequestDescriptor({
                    method: 'POST',
                    mapping: carMapping,
                    path: 'cars/?'
                });
                siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(requestDescriptor);
            });

            describe('success', function() {
                var car;
                beforeEach(function(done) {
                    var raw = {
                        id: 'remoteId'
                    };
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/cars/";
                    var method = "POST";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    carMapping.map({
                        colour: 'red',
                        name: 'Aston Martin'
                    }, function(err, _car) {
                        if (err) done(err);
                        car = _car;
                        assert.equal(car.colour, 'red');
                        assert.equal(car.name, 'Aston Martin');
                        collection.POST('cars/', car, function(_err, _obj, _resp) {
                            err = _err;
                            obj = _obj;
                            resp = _resp;
                            done();
                        });
                        server.respond();
                    });
                });

                it('no error', function() {
                    assert.notOk(err);
                });

                it('mapped onto the posted object', function() {
                    assert.equal(car, obj);
                    assert.equal(car.id, 'remoteId');
                    assert.equal(car.colour, 'red');
                    assert.equal(car.name, 'Aston Martin');
                });
            });
        });

        describe('PUT', function() {
            var err, obj, resp;
            beforeEach(function(done) {
                configureCollection(done);
                var responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    method: 'PUT',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
                siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(responseDescriptor);
                var requestDescriptor = new siesta.ext.http.RequestDescriptor({
                    method: 'PUT',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
                siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(requestDescriptor);
            });

            describe('success', function() {
                var car;
                beforeEach(function(done) {
                    var raw = {
                        colour: 'red',
                        name: 'Aston Martin',
                        id: '5'
                    };
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/cars/5/";
                    var method = "PUT";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    carMapping.map({
                        colour: 'red',
                        name: 'Aston Martin',
                        id: '5'
                    }, function(err, _car) {
                        if (err) done(err);
                        car = _car;
                        assert.equal(car.colour, 'red');
                        assert.equal(car.name, 'Aston Martin');
                        assert.equal(car.id, '5');
                        collection.PUT('cars/5/', car, function(_err, _obj, _resp) {
                            err = _err;
                            obj = _obj;
                            resp = _resp;
                            done();
                        });
                        server.respond();
                    });
                });

                it('no error', function() {
                    assert.notOk(err);
                });

                it('mapped onto the posted object', function() {
                    assert.equal(obj, car);
                    assert.equal(car.id, '5');
                    assert.equal(car.colour, 'red');
                    assert.equal(car.name, 'Aston Martin');
                });
            });
        });

        describe('PATCH', function() {
            var err, obj, resp;
            beforeEach(function(done) {
                configureCollection(function() {
                    var responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                        method: 'PATCH',
                        mapping: carMapping,
                        path: '/cars/(?<id>[0-9])/?'
                    });
                    siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(responseDescriptor);
                    var requestDescriptor = new siesta.ext.http.RequestDescriptor({
                        method: 'PATCH',
                        mapping: carMapping,
                        path: '/cars/(?<id>[0-9])/?'
                    });
                    siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(requestDescriptor);
                    done();
                });
            });

            describe('success', function() {
                var car;
                beforeEach(function(done) {
                    var raw = {
                        colour: 'red',
                        name: 'Aston Martin',
                        id: '5'
                    };
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/cars/5/";
                    var method = "PATCH";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    carMapping.map({
                        colour: 'red',
                        name: 'Aston Martin',
                        id: '5'
                    }, function(err, _car) {
                        if (err) done(err);
                        car = _car;
                        assert.equal(car.colour, 'red');
                        assert.equal(car.name, 'Aston Martin');
                        assert.equal(car.id, '5');
                        collection.PATCH('cars/5/', car, function(_err, _obj, _resp) {
                            err = _err;
                            obj = _obj;
                            resp = _resp;
                            done();
                        });
                        server.respond();
                    });
                });

                it('no error', function() {
                    assert.notOk(err);
                });

                it('mapped onto the posted object', function() {
                    assert.equal(obj, car);
                    assert.equal(car.id, '5');
                    assert.equal(car.colour, 'red');
                    assert.equal(car.name, 'Aston Martin');
                });

                it('')
            });




        });

        describe('OPTIONS', function() {
            var err, obj, resp;
            beforeEach(function(done) {
                configureCollection(done);
            });

            describe('success', function() {
                beforeEach(function(done) {
                    var raw = {
                        option: 'something'
                    };
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/something/";
                    var method = "OPTIONS";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    collection.OPTIONS('something/', function(_err, _obj, _resp) {
                        err = _err;
                        obj = _obj;
                        resp = _resp;
                        done();
                    });
                    server.respond();
                });
                it('no err', function() {
                    assert.notOk(err);
                });
                it('no obj', function() {
                    assert.notOk(obj);
                });
                it('resp', function() {
                    assert.ok(resp);
                })
            });
        });

        describe('HEAD', function() {
            var err, obj, resp;
            beforeEach(function(done) {
                configureCollection(done);
            });

            describe('success', function() {
                beforeEach(function(done) {
                    var raw = {
                        option: 'something'
                    };
                    var headers = {
                        "Content-Type": "application/json"
                    };
                    var path = "http://mywebsite.co.uk/something/";
                    var method = "HEAD";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    collection.HEAD('something/', function(_err, _obj, _resp) {
                        err = _err;
                        obj = _obj;
                        resp = _resp;
                        done();
                    });
                    server.respond();
                });
                it('no err', function() {
                    assert.notOk(err);
                });
                it('no obj', function() {
                    assert.notOk(obj);
                });
                it('resp', function() {
                    assert.ok(resp);
                })
            });
        });

        /**
         * http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
         */
        describe('TRACE', function() {
            var err, obj, resp;
            beforeEach(function(done) {
                configureCollection(done);
                var responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    method: 'TRACE',
                    mapping: carMapping,
                    path: 'cars/'
                });
                siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(responseDescriptor);
                var requestDescriptor = new siesta.ext.http.RequestDescriptor({
                    method: 'TRACE',
                    mapping: carMapping,
                    path: 'cars/'
                });
                siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(requestDescriptor);
            });

            describe('success', function() {
                var car;
                beforeEach(function(done) {
                    var raw = {
                        colour: 'red'
                    }; // Trace is supposed to be a reflection of the response body.
                    var headers = {
                        "Content-Type": "message/http"
                    }; // http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html
                    var path = "http://mywebsite.co.uk/cars/";
                    var method = "TRACE";
                    var status = 200;
                    server.respondWith(method, path, [status, headers, JSON.stringify(raw)]);
                    carMapping.map({
                        colour: 'red'
                    }, function(err, _car) {
                        car = _car;
                        collection.TRACE('cars/', _car, function(_err, _obj, _resp) {
                            err = _err;
                            obj = _obj;
                            resp = _resp;
                            done();
                        });
                        server.respond();
                    });
                });
                it('no err', function() {
                    assert.notOk(err);
                });
                it('obj', function() {
                    assert.ok(obj);
                });
                it('resp', function() {
                    assert.equal(resp.jqXHR.responseText, '{"colour":"red"}');
                    assert.ok(resp);
                })
            });
        });

    });

    describe('ajax', function() {
        var dollar;
        var fakeDollar = {
            ajax: function() {}
        }

        before(function() {
            dollar = $;
        });

        beforeEach(function() {
            $ = fakeDollar;
            jQuery = fakeDollar;
        });

        after(function() {
            $ = dollar;
        });

        it('default', function() {
            assert.equal(s.ext.http.ajax, fakeDollar.ajax);
        });

        it('no $', function() {
            $ = undefined;
            assert.equal(s.ext.http.ajax, fakeDollar.ajax);
        });

        it('no ajax at all', function() {
            $ = undefined;
            jQuery = undefined;
            assert.throws(function() {
                var a = s.ext.http.ajax;
            }, InternalSiestaError);
        });

        it('set ajax', function() {
            var fakeAjax = function() {};
            s.setAjax(fakeAjax);
            assert.equal(s.ext.http.ajax, fakeAjax);
            assert.equal(s.getAjax(), fakeAjax);
        });

    });

    describe('specific fields', function() {
        beforeEach(function(done) {
            configureCollection(function() {
                var responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    method: 'PATCH',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
                siesta.ext.http.DescriptorRegistry.registerResponseDescriptor(responseDescriptor);
                var requestDescriptor = new siesta.ext.http.RequestDescriptor({
                    method: 'PATCH',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
                siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(requestDescriptor);
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    id: '5'
                }, function(err, _car) {
                    if (err) done(err);
                    car = _car;
                    assert.equal(car.colour, 'red');
                    assert.equal(car.name, 'Aston Martin');
                    assert.equal(car.id, '5');
                    siesta.ext.http._serialiseObject.call(requestDescriptor, {fields:['colour']}, car, function (err, data){
                        if (err) done(err);
                        else {
                            console.log('data', data);
                            var keys = Object.keys(data);
                            assert.equal(keys.length, 1);
                            assert.equal(keys[0], 'colour');
                            done();
                        }
                    } );
                });
            });
        });

        it('xyz', function() {
            dump('hello');
        });
    });

});
},{"../index":1,"../src/collection":45,"../src/error":47,"../src/object":53,"../src/relationship":58,"chai":9}],65:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;


describe('collection setup', function() {

    var Collection = require('../src/collection').Collection;
    var InternalSiestaError = require('../src/error').InternalSiestaError;

    beforeEach(function() {
        s.reset(true);
    });

    describe('install', function() {
        var collection;
        beforeEach(function() {
            collection = new Collection('MyCollection');
        });

        it('not installed', function() {
            assert.notOk(collection.installed);
        });

        describe('configure without mappings', function() {
            it('eventually finishes', function(done) {
                collection.install(function(err) {
                    if (err) done(err);
                    done();
                });
            });

            it('raises an error if trying to configure twice', function(done) {
                collection.install(function(err) {
                    if (err) done(err);
                    collection.install(function(err) {
                        assert.ok(err);
                        done();
                    })
                });
            });

            it('is accessible in the siesta object', function(done) {
                collection.install(function(err) {
                    if (err) done(err);
                    assert.equal(s.MyCollection, collection);
                    done();
                });
            });
        });

        it('raises an error if trying to configure twice', function(done) {
            collection.install(function(err) {
                if (err) done(err);
                collection.install(function(err) {
                    assert.ok(err);
                    done();
                })
            });
        });

        describe('configure with mappings', function() {
            it('name before object', function(done) {
                var mapping1 = collection.mapping('mapping1', {
                    id: 'id',
                    attributes: ['attr1', 'attr2']
                });
                var mapping2 = collection.mapping('mapping2', {
                    id: 'id',
                    attributes: ['attr1', 'attr2', 'attr3']
                });
                collection.install(function(err) {
                    if (err) done(err);
                    assert.equal(collection['mapping1'], mapping1);
                    assert.equal(collection['mapping2'], mapping2);
                    done();
                });
            });

            it('name within object', function(done) {
                var mapping1 = collection.mapping({
                    name: 'mapping1',
                    id: 'id',
                    attributes: ['attr1', 'attr2']
                });
                var mapping2 = collection.mapping({
                    name: 'mapping2',
                    id: 'id',
                    attributes: ['attr1', 'attr2', 'attr3']
                });
                collection.install(function(err) {
                    if (err) done(err);
                    assert.equal(collection['mapping1'], mapping1);
                    assert.equal(collection['mapping2'], mapping2);
                    done();
                });
            });

            it('no name specified within object', function() {
                assert.throws(function() {
                    collection.mapping({
                        id: 'id',
                        attributes: ['attr1', 'attr2']
                    });
                }, InternalSiestaError);
            });

            it('vararg', function(done) {
                var mappings = collection.mapping({
                    name: 'mapping1',
                    id: 'id',
                    attributes: ['attr1', 'attr2']
                }, {
                    name: 'mapping2',
                    id: 'id',
                    attributes: ['attr1', 'attr2', 'attr3']
                });
                collection.install(function(err) {
                    if (err) done(err);
                    assert.equal(collection['mapping1'], mappings[0]);
                    assert.equal(collection['mapping2'], mappings[1]);
                    done();
                });
            });

            it('array', function(done) {
                var mappings = collection.mapping([{
                    name: 'mapping1',
                    id: 'id',
                    attributes: ['attr1', 'attr2']
                }, {
                    name: 'mapping2',
                    id: 'id',
                    attributes: ['attr1', 'attr2', 'attr3']
                }]);
                collection.install(function(err) {
                    if (err) done(err);
                    assert.equal(collection['mapping1'], mappings[0]);
                    assert.equal(collection['mapping2'], mappings[1]);
                    done();
                });
            });
        });

        describe('configure with descriptors', function() {
            var mapping1, mapping2;
            beforeEach(function() {
                mapping1 = collection.mapping('mapping1', {
                    id: 'id',
                    attributes: ['attr1', 'attr2']
                });
                mapping2 = collection.mapping({
                    name: 'mapping2',
                    id: 'id',
                    attributes: ['attr1', 'attr2', 'attr3']
                });
            });
            describe('request descriptor', function() {
                it('single', function(done) {
                    var descriptors = collection.descriptor({
                        method: 'POST',
                        mapping: mapping1,
                        path: '/path/(?<id>[0-9])/?'
                    });
                    assert.equal(descriptors.length, 1);
                    var requestDescriptor1 = descriptors[0];
                    assert.instanceOf(requestDescriptor1, siesta.ext.http.RequestDescriptor);
                    descriptors = collection.descriptor({
                        method: 'POST',
                        mapping: mapping2,
                        path: '/path/(?<id>[0-9])/?'
                    });
                    var requestDescriptor2 = descriptors[0];
                    assert.instanceOf(requestDescriptor2, siesta.ext.http.RequestDescriptor);
                    collection.install(function(err) {
                        if (err) {
                            done(err);
                        }
                        assert.equal(requestDescriptor1.mapping, mapping1);
                        assert.equal(requestDescriptor2.mapping, mapping2);
                        done();
                    })
                });


            });
            describe('response descriptor', function() {
                it('single', function(done) {
                    var descriptors = collection.descriptor({
                        method: 'GET',
                        mapping: mapping1,
                        path: '/path/(?<id>[0-9])/?'
                    });
                    assert.equal(descriptors.length, 1);
                    var responseDescriptor1 = descriptors[0];
                    assert.instanceOf(responseDescriptor1, siesta.ext.http.ResponseDescriptor);
                    var descriptors = collection.descriptor({
                        method: 'GET',
                        mapping: mapping2,
                        path: '/path/(?<id>[0-9])/?'
                    });
                    assert.equal(descriptors.length, 1);
                    var responseDescriptor2 = descriptors[0];
                    assert.instanceOf(responseDescriptor2, siesta.ext.http.ResponseDescriptor);
                    collection.install(function(err) {
                        if (err) {
                            done(err);
                        }
                        assert.equal(responseDescriptor1.mapping, mapping1);
                        assert.equal(responseDescriptor2.mapping, mapping2);
                        done();
                    })
                });

            });

            describe('both', function() {
                var descriptors;

                beforeEach(function(done) {
                    descriptors = collection.descriptor({
                        method: ['GET', 'POST'],
                        mapping: mapping1,
                        path: '/path/(?<id>[0-9])/?'
                    }); 
                    collection.install(done)
                });

                it('two descriptors', function() {
                    assert.equal(descriptors.length, 2);
                });

                it('types', function() {
                    var responseDescriptor1 = descriptors[0];
                    assert.instanceOf(responseDescriptor1, siesta.ext.http.RequestDescriptor);
                    var requestDescriptor1 = descriptors[1];
                    assert.instanceOf(requestDescriptor1, siesta.ext.http.ResponseDescriptor);
                });

                it('registration', function () {
                    var registry = siesta.ext.http.DescriptorRegistry;
                    console.log('registry', registry);
                    var requestDescriptors = registry.requestDescriptors.MyCollection;
                    var responseDescriptors = registry.responseDescriptors.MyCollection;
                    assert.equal(requestDescriptors.length, 1);
                    assert.equal(responseDescriptors.length, 1);
                });

            });
        });
    });

});
},{"../index":1,"../src/collection":45,"../src/error":47,"chai":9}],66:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('request descriptor', function() {

    var Collection = require('../src/collection').Collection;
    var InternalSiestaError = require('../src/error').InternalSiestaError;
    var RelationshipType = require('../src/relationship').RelationshipType;

    var collection, carMapping, personMapping;

    beforeEach(function(done) {
        s.reset(true);
        collection = new Collection('myCollection');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            relationships: {
                owner: {
                    mapping: 'Person',
                    type: RelationshipType.OneToMany,
                    reverse: 'cars'
                }
            }
        });
        personMapping = collection.mapping('Person', {
            id: 'id',
            attributes: ['name']
        });
        collection.install(done);
    });

    describe('matching', function() {

        describe('path', function() {
            it('match id', function() {
                var r = new siesta.ext.http.Descriptor({
                    path: '/cars/(?<id>[0-9])/?',
                    mapping: carMapping
                });
                var match = r._matchPath('/cars/5/');
                assert.equal(match.id, '5');
                match = r._matchPath('/cars/5');
                assert.equal(match.id, '5');
            });

            it('query params', function() {
                var descriptor = new siesta.ext.http.Descriptor({
                    method: '*',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
                var match = descriptor._matchPath('/cars/5?x=5&y=random');
                assert.equal(match.id, '5');
            });
        });

        describe('http methods', function() {
            it('all http methods', function() {
                var r = new siesta.ext.http.Descriptor({
                    method: '*',
                    mapping: carMapping
                });
                _.each(r.httpMethods, function(method) {
                    assert.include(r.method, method);
                });
                r = new siesta.ext.http.Descriptor({
                    method: ['*'],
                    mapping: carMapping
                });
                _.each(r.httpMethods, function(method) {
                    assert.include(r.method, method);
                });
                r = new siesta.ext.http.Descriptor({
                    method: ['*', 'GET'],
                    mapping: carMapping
                });
                _.each(r.httpMethods, function(method) {
                    assert.include(r.method, method);
                });
            });
            it('match against all', function() {
                var r = new siesta.ext.http.Descriptor({
                    method: '*',
                    mapping: carMapping
                });
                _.each(r.httpMethods, function(method) {
                    assert.ok(r._matchMethod(method));
                    assert.ok(r._matchMethod(method.toUpperCase()));
                    assert.ok(r._matchMethod(method.toLowerCase()));
                });
            });
            it('match against some', function() {
                var r = new siesta.ext.http.Descriptor({
                    method: ['POST', 'PUT'],
                    mapping: carMapping
                });
                assert.ok(r._matchMethod('POST'));
                assert.ok(r._matchMethod('PUT'));
                assert.ok(r._matchMethod('post'));
                assert.ok(r._matchMethod('put'));
                assert.ok(r._matchMethod('PoSt'));
                assert.ok(r._matchMethod('pUt'));
                assert.notOk(r._matchMethod('HEAD'));
                assert.notOk(r._matchMethod('head'));
                assert.notOk(r._matchMethod('hEaD'));
            });
            it('match against single', function() {
                function assertMatchMethod(r) {
                    assert.ok(r._matchMethod('POST'));
                    assert.ok(r._matchMethod('post'));
                    assert.ok(r._matchMethod('PoSt'));
                    assert.notOk(r._matchMethod('HEAD'));
                    assert.notOk(r._matchMethod('head'));
                    assert.notOk(r._matchMethod('hEaD'));
                }

                assertMatchMethod(new siesta.ext.http.Descriptor({
                    method: ['POST'],
                    mapping: carMapping
                }));
                assertMatchMethod(new siesta.ext.http.Descriptor({
                    method: ['pOsT'],
                    mapping: carMapping
                }));
                assertMatchMethod(new siesta.ext.http.Descriptor({
                    method: 'pOsT',
                    mapping: carMapping
                }));
                assertMatchMethod(new siesta.ext.http.Descriptor({
                    method: 'post',
                    mapping: carMapping
                }));
                assertMatchMethod(new siesta.ext.http.Descriptor({
                    method: 'POST',
                    mapping: carMapping
                }));
            })
        });
    });

    describe('specify mapping', function() {
        it('as object', function() {
            var r = new siesta.ext.http.Descriptor({
                mapping: carMapping
            });
            assert.equal(r.mapping, carMapping);
        });
        it('as string', function() {
            var r = new siesta.ext.http.Descriptor({
                mapping: 'Car',
                collection: 'myCollection'
            });
            assert.equal('Car', r.mapping.type);
        });
        it('as string, but collection as object', function() {
            var r = new siesta.ext.http.Descriptor({
                mapping: 'Car',
                collection: collection
            });
            assert.equal('Car', r.mapping.type);
        });
        it('should throw an exception if passed as string without collection', function() {
            assert.throws(_.partial(siesta.ext.http.Descriptor, {
                mapping: 'Car'
            }), InternalSiestaError);
        });
    });

    describe('data', function() {
        it('if null, should be null', function() {
            var r = new siesta.ext.http.Descriptor({
                data: null,
                mapping: carMapping
            });
            assert.notOk(r.data);
        });
        it('if empty string, should be null', function() {
            var r = new siesta.ext.http.Descriptor({
                data: '',
                mapping: carMapping
            });
            assert.notOk(r.data);
        });
        it('if length 1, should be a string', function() {
            var r = new siesta.ext.http.Descriptor({
                data: 'abc',
                mapping: carMapping
            });
            assert.equal(r.data, 'abc');
        });
        it('if > length 1, should be an object', function() {
            var r = new siesta.ext.http.Descriptor({
                data: 'path.to.data',
                mapping: carMapping
            });
            assert.equal(r.data.path.to, 'data');
        });
        describe('embed', function() {
            var data = {
                x: 1,
                y: 2,
                z: 3
            };
            it('if null, should simply return the object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: null,
                    mapping: carMapping
                });
                assert.equal(data, r._embedData(data));
            });
            it('if empty string, should simply return the object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: '',
                    mapping: carMapping
                });
                assert.equal(data, r._embedData(data));
            });
            it('if length 1, should return 1 level deep object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: 'abc',
                    mapping: carMapping
                });
                assert.equal(data, r._embedData(data).abc);
            });
            it('if > length 1, should return n level deep object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: 'path.to.data',
                    mapping: carMapping
                });
                var extractData = r._embedData(data);
                assert.equal(data, extractData.path.to.data);
            });
        });
        describe('extract', function() {
            var data = {
                x: 1,
                y: 2,
                z: 3
            };
            it('if null, should simply return the object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: null,
                    mapping: carMapping
                });
                var extractData = r._extractData(data);
                assert.equal(extractData, data);
            });
            it('if empty string, should simply return the object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: '',
                    mapping: carMapping
                });
                var extractData = r._extractData(data);
                assert.equal(extractData, data);
            });
            it('if length 1, should return 1 level deep object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: 'abc',
                    mapping: carMapping
                });
                var extractData = r._extractData({
                    abc: data
                });
                assert.equal(extractData, data);
            });
            it('if > length 1, should return n level deep object', function() {
                var r = new siesta.ext.http.Descriptor({
                    data: 'path.to.data',
                    mapping: carMapping
                });
                var extractData = r._extractData({
                    path: {
                        to: {
                            data: data
                        }
                    }
                });
                assert.equal(extractData, data);
            });
        });
    });

    describe('registry', function() {
        it('should register request descriptor', function() {
            var r = new siesta.ext.http.RequestDescriptor({
                data: 'path.to.data',
                mapping: carMapping
            });
            siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(r);
            assert.include(siesta.ext.http.DescriptorRegistry.requestDescriptors[carMapping.collection], r);
        });
        describe('request descriptors for collection', function() {
            var descriptor;
            beforeEach(function() {
                descriptor = new siesta.ext.http.RequestDescriptor({
                    data: 'path.to.data',
                    mapping: carMapping
                });
                siesta.ext.http.DescriptorRegistry.registerRequestDescriptor(descriptor);
            });
            it('request descriptors should be accessible by collection name', function() {
                assert.include(siesta.ext.http.DescriptorRegistry.requestDescriptorsForCollection(carMapping.collection), descriptor);
            });
            it('request descriptors should be accessible by collection', function() {
                assert.include(siesta.ext.http.DescriptorRegistry.requestDescriptorsForCollection(collection), descriptor);
            });
        });

    });

    describe('match http config', function() {
        describe('no data', function() {
            var descriptor;
            beforeEach(function() {
                descriptor = new siesta.ext.http.Descriptor({
                    method: 'POST',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
            });
            it('match', function() {
                assert.ok(descriptor._matchConfig({
                    type: 'POST',
                    url: '/cars/5/'
                }));
            });
            it('no match because of method', function() {
                assert.notOk(descriptor._matchConfig({
                    type: 'GET',
                    url: '/cars/5/'
                }));
            });
            it('no match because of url', function() {
                assert.notOk(descriptor._matchConfig({
                    type: 'POST',
                    url: '/asdasd/'
                }));
            });
        });
    });

    describe('match against data', function() {
        var descriptor;

        describe('data specified', function() {
            beforeEach(function() {
                descriptor = new siesta.ext.http.Descriptor({
                    mapping: carMapping,
                    data: 'path.to.data'
                });
            });
            it('match', function() {
                assert.ok(descriptor._matchData({
                    path: {
                        to: {
                            data: {
                                x: 1,
                                y: 2
                            }
                        }
                    }
                }));
            });
            it('no match', function() {
                assert.notOk(descriptor._matchData({
                    path: { // Missing 'to'
                        data: {
                            x: 1,
                            y: 2
                        }
                    }
                }));
            });
        });

        describe('data unspecified', function() {

        })

    });

    describe('compound match', function() {
        var descriptor;
        beforeEach(function() {
            descriptor = new siesta.ext.http.Descriptor({
                method: 'POST',
                mapping: carMapping,
                path: '/cars/(?<id>[0-9])/?',
                data: 'path.to.data'
            });
        });

        it('success', function() {
            var config = {
                type: 'POST',
                url: '/cars/5/'
            };
            var data = {
                path: {
                    to: {
                        data: {
                            x: 1,
                            y: 2
                        }
                    }
                }
            };
            assert.ok(descriptor.match(config, data));
        });
    });

    describe('defaults', function() {
        var descriptor;
        beforeEach(function() {
            descriptor = new siesta.ext.http.Descriptor({
                mapping: carMapping
            });
        });
        it('default method is GET', function() {
            assert.equal(descriptor.method.length, 1);
            assert.equal(descriptor.method[0], 'GET');
        });
        it('default path is blank', function() {
            assert.equal(descriptor.path, '');
        });
        it('default data is null', function() {
            assert.equal(descriptor.data, null);
        })
    });

    describe('errors', function() {
        it('no mapping', function() {
            assert.throws(function() {
                new siesta.ext.http.Descriptor({
                    data: 'data'
                })
            }, InternalSiestaError);
        });
    });

    describe('siesta.ext.http.RequestDescriptor', function() {
        describe('serialisation', function() {
            it('default', function() {
                var requestDescriptor = new siesta.ext.http.RequestDescriptor({
                    method: 'POST',
                    mapping: carMapping,
                    path: '/cars/(?<id>[0-9])/?'
                });
                assert.notEqual(requestDescriptor.serialiser, siesta.ext.http.Serialiser.idSerialiser);
            });

            describe('built-in', function() {
                var requestDescriptor;

                describe('id', function() {
                    beforeEach(function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            method: 'POST',
                            mapping: carMapping,
                            path: '/cars/(?<id>[0-9])/?',
                            serialiser: siesta.ext.http.Serialiser.idSerialiser
                        });
                    });
                    it('uses the serialiser', function() {
                        assert.equal(requestDescriptor.serialiser, siesta.ext.http.Serialiser.idSerialiser);
                    });
                    it('serialises', function(done) {
                        carMapping.map({
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'xyz'
                        }, function(err, car) {
                            if (err) done(err);
                            requestDescriptor._serialise(car, function(err, data) {
                                if (err) done(err);
                                assert.equal(data, car.id);
                                done();
                            })
                        });
                    });
                });

                describe('depth', function() {
                    var requestDescriptor;
                    beforeEach(function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            method: 'POST',
                            mapping: carMapping,
                            path: '/cars/(?<id>[0-9])/?',
                            serialiser: siesta.ext.http.Serialiser.depthSerializer(0)
                        });
                    });

                    it('uses the serialiser', function() {
                        assert.notEqual(requestDescriptor.serialiser, siesta.ext.http.Serialiser.idSerialiser);
                    });

                    it('serialises at depth', function(done) {
                        carMapping.map({
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'xyz',
                            owner: {
                                id: '123',
                                name: 'Michael Ford'
                            }
                        }, function(err, car) {
                            if (err) done(err);
                            requestDescriptor._serialise(car, function(err, data) {
                                if (err) done(err);
                                assert.equal(data.owner, '123');
                                done();
                            })
                        });
                    });
                });

                describe('transforms', function() {
                    var requestDescriptor;

                    it('key paths', function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            mapping: carMapping,
                            transforms: {
                                'colour': 'path.to.colour'
                            }
                        });
                        var data = {
                            colour: 'red'
                        };
                        requestDescriptor._transformData(data);
                        assert.notOk(data.colour);
                        assert.equal(data.path.to.colour, 'red');
                    });

                    it('key', function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            mapping: carMapping,
                            transforms: {
                                'colour': 'color'
                            }
                        });
                        var data = {
                            colour: 'red'
                        };
                        requestDescriptor._transformData(data);
                        assert.notOk(data.colour);
                        assert.equal(data.color, 'red');
                    });

                    it('function with return val', function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            mapping: carMapping,
                            transforms: {
                                'colour': function(val) {
                                    var newVal = val;
                                    if (val == 'red') {
                                        newVal = 'blue';
                                    }
                                    return newVal;
                                }
                            }
                        });
                        var data = {
                            colour: 'red'
                        };
                        requestDescriptor._transformData(data);
                        assert.equal(data.colour, 'blue');
                    });

                    it('function with return val and key', function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            mapping: carMapping,
                            transforms: {
                                'colour': function(val) {
                                    var newVal = val;
                                    if (val == 'red') {
                                        newVal = 'blue';
                                    }
                                    return ['color', newVal];
                                }
                            }
                        });
                        var data = {
                            colour: 'red'
                        };
                        requestDescriptor._transformData(data);
                        assert.notOk(data.colour);
                        assert.equal(data.color, 'blue');
                    });

                    it('invalid', function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            mapping: carMapping,
                            transforms: {
                                'colour': {
                                    wtf: {
                                        is: 'this'
                                    }
                                }
                            }
                        });
                        var data = {
                            colour: 'red'
                        };
                        assert.throws(function() {
                            requestDescriptor._transformData(data);

                        }, InternalSiestaError);
                    });

                    describe('during serialisation', function() {
                        beforeEach(function() {
                            requestDescriptor = new siesta.ext.http.RequestDescriptor({
                                method: 'POST',
                                mapping: carMapping,
                                path: '/cars/(?<id>[0-9])/?',
                                serialiser: siesta.ext.http.Serialiser.depthSerializer(0),
                                transforms: {
                                    'colour': 'path.to.colour'
                                }
                            });
                        });

                        it('performs transform', function(done) {
                            carMapping.map({
                                colour: 'red',
                                name: 'Aston Martin',
                                id: 'xyz',
                                owner: {
                                    id: '123',
                                    name: 'Michael Ford'
                                }
                            }, function(err, car) {
                                if (err) done(err);
                                requestDescriptor._serialise(car, function(err, data) {
                                    if (err) done(err);
                                    assert.equal(data.owner, '123');
                                    assert.equal(data.name, 'Aston Martin');
                                    assert.notOk(data.colour);
                                    assert.equal(data.path.to.colour, 'red');
                                    done();
                                });
                            });
                        });
                    });

                });


            });

            describe('embed', function() {

                describe('id', function() {
                    var requestDescriptor;
                    beforeEach(function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            method: 'POST',
                            mapping: carMapping,
                            path: '/cars/(?<id>[0-9])/?',
                            data: 'path.to',
                            serialiser: siesta.ext.http.Serialiser.idSerialiser
                        });
                    });

                    it('serialises at depth', function(done) {
                        carMapping.map({
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'xyz',
                            owner: {
                                id: '123',
                                name: 'Michael Ford'
                            }
                        }, function(err, car) {
                            if (err) done(err);
                            requestDescriptor._serialise(car, function(err, data) {
                                if (err) done(err);
                                assert.equal(data.path.to, 'xyz');
                                done();
                            })
                        });
                    });
                });

                describe('depth', function() {
                    var requestDescriptor;
                    beforeEach(function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            method: 'POST',
                            mapping: carMapping,
                            path: '/cars/(?<id>[0-9])/?',
                            data: 'path.to'
                        });
                    });


                    it('serialises at depth', function(done) {
                        carMapping.map({
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'xyz',
                            owner: {
                                id: '123',
                                name: 'Michael Ford'
                            }
                        }, function(err, car) {
                            if (err) done(err);
                            requestDescriptor._serialise(car, function(err, data) {
                                if (err) done(err);
                                assert.equal(data.path.to.owner, '123');
                                done();
                            })
                        });
                    });
                });

                describe('custom', function() {
                    var requestDescriptor;
                    beforeEach(function() {
                        requestDescriptor = new siesta.ext.http.RequestDescriptor({
                            method: 'POST',
                            mapping: carMapping,
                            path: '/cars/(?<id>[0-9])/?',
                            data: 'path.to',
                            serialiser: function(obj) {
                                return obj.id
                            }
                        });
                    });


                    it('serialises', function(done) {
                        carMapping.map({
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'xyz',
                            owner: {
                                id: '123',
                                name: 'Michael Ford'
                            }
                        }, function(err, car) {
                            if (err) done(err);
                            requestDescriptor._serialise(car, function(err, data) {
                                if (err) done(err);
                                assert.equal(data.path.to, 'xyz');
                                done();
                            })
                        });
                    });
                });


            });

            describe('custom', function() {

                function carSerialiser(fields, car, done) {
                    var data = {};
                    for (var idx in fields) {
                        var field = fields[idx];
                        if (car[field]) {
                            data[field] = car[field];
                        }
                    }
                    car.ownerProxy.get(function(err, person) {
                        if (err) {
                            done(err);
                        } else {
                            if (person) {
                                data.owner = person.name;
                            }
                            done(null, data);
                        }
                    });
                }

                var requestDescriptor, serialiser;

                beforeEach(function() {
                    serialiser = _.partial(carSerialiser, ['name']);
                    requestDescriptor = new siesta.ext.http.RequestDescriptor({
                        method: 'POST',
                        mapping: carMapping,
                        path: '/cars/?',
                        serialiser: serialiser
                    });
                });

                it('uses the custom serialiser', function() {
                    assert.equal(requestDescriptor.serialiser, serialiser);
                });

                it('serialises', function(done) {
                    carMapping.map({
                        colour: 'red',
                        name: 'Aston Martin',
                        id: 'xyz',
                        owner: {
                            id: '123',
                            name: 'Michael Ford'
                        }
                    }, function(err, car) {
                        if (err) done(err);
                        requestDescriptor._serialise(car, function(err, data) {
                            if (err) done(err);
                            assert.equal(data.owner, 'Michael Ford');
                            assert.equal(data.name, 'Aston Martin');
                            assert.notOk(data.colour);
                            done();
                        })
                    });
                })
            })
        })
    });

    describe('ResponseDescriptor', function() {

        describe('transforms', function() {
            var responseDescriptor;
            it('key paths', function() {
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: {
                        'colour': 'path.to.colour'
                    }
                });
                var data = {
                    colour: 'red'
                };
                responseDescriptor._transformData(data);
                assert.notOk(data.colour);
                assert.equal(data.path.to.colour, 'red');
            });

            it('key', function() {
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: {
                        'colour': 'color'
                    }
                });
                var data = {
                    colour: 'red'
                };
                responseDescriptor._transformData(data);
                assert.notOk(data.colour);
                assert.equal(data.color, 'red');
            });

            it('function with return val', function() {
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: {
                        'colour': function(val) {
                            var newVal = val;
                            if (val == 'red') {
                                newVal = 'blue';
                            }
                            return newVal;
                        }
                    }
                });
                var data = {
                    colour: 'red'
                };
                responseDescriptor._transformData(data);
                assert.equal(data.colour, 'blue');
            });

            it('function with return val and key', function() {
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: {
                        'colour': function(val) {
                            var newVal = val;
                            if (val == 'red') {
                                newVal = 'blue';
                            }
                            return ['color', newVal];
                        }
                    }
                });
                var data = {
                    colour: 'red'
                };
                responseDescriptor._transformData(data);
                assert.notOk(data.colour);
                assert.equal(data.color, 'blue');
            });

            it('function', function() {
                var data = {
                    colour: 'red'
                };
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: function(_data) {
                        assert.equal(data, _data);
                        return {
                            key: 'value'
                        };
                    }
                });
                data = responseDescriptor._transformData(data);
                assert.notOk(data.colour);
                assert.equal(data.key, 'value');
            });

            it('invalid', function() {
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: {
                        'colour': {
                            wtf: {
                                is: 'this'
                            }
                        }
                    }
                });
                var data = {
                    colour: 'red'
                };
                assert.throws(function() {
                    responseDescriptor._transformData(data);

                }, InternalSiestaError);
            });

        });

        describe('transforms during deserialisation', function() {
            var responseDescriptor;

            beforeEach(function() {
                responseDescriptor = new siesta.ext.http.ResponseDescriptor({
                    mapping: carMapping,
                    transforms: {
                        'colour': 'color'
                    }
                });
            });

            it('transforms during extractData', function() {
                var extracted = responseDescriptor._extractData({
                    colour: 'red'
                });
                assert.equal(extracted.color, 'red');
                assert.notOk(extracted.colour);
            });
            it('transforms during matchData', function() {
                var extracted = responseDescriptor._matchData({
                    colour: 'red'
                });
                assert.equal(extracted.color, 'red');
                assert.notOk(extracted.colour);
            });
        });

    });


});
},{"../index":1,"../src/collection":45,"../src/error":47,"../src/relationship":58,"chai":9}],67:[function(require,module,exports){
/**
 * An integration test that creates two complex collections and then establishes inter-collection relationships
 * between the mappings in each before creating objects etc.
 *
 * We then proceed to test various aspects of the system.
 */

var s = require('../index'),
    assert = require('chai').assert;

var Collection = require('../src/collection').Collection;
var RelationshipType = require('../src/relationship').RelationshipType;
var cache = require('../src/cache');

var async = require('async');

describe('intercollection relationships', function() {
    var myOfflineCollection;
    var myOnlineCollection;

    beforeEach(function(done) {
        s.reset(true);

        myOfflineCollection = new Collection('MyOfflineCollection');
        myOnlineCollection = new Collection('MyOnlineCollection');

        myOfflineCollection.mapping('Folder', {
            attributes: ['name'],
            relationships: {
                createdBy: {
                    mapping: 'User',
                    type: RelationshipType.OneToMany,
                    reverse: 'folders'
                }
            }
        });

        myOfflineCollection.mapping('DownloadedPhoto', {
            attributes: ['creationDate'],
            relationships: {
                createdBy: {
                    mapping: 'User',
                    type: RelationshipType.OneToMany,
                    reverse: 'files'
                },
                folder: {
                    mapping: 'Folder',
                    type: RelationshipType.OneToMany,
                    reverse: 'files'
                },
                photo: {
                    mapping: 'MyOnlineCollection.Photo',
                    type: RelationshipType.OneToOne,
                    reverse: 'file'
                }
            }
        });

        myOfflineCollection.mapping('User', {
            attributes: ['username'],
            indexes: ['username']
        });



        myOnlineCollection.mapping('Photo', {
            id: 'photoId',
            attributes: ['height', 'width', 'url'],
            relationships: {
                createdBy: {
                    mapping: 'User',
                    type: RelationshipType.OneToMany,
                    reverse: 'photos'
                }
            }
        });

        myOnlineCollection.mapping('User', {
            id: 'userId',
            attributes: ['username', 'name']
        });

        var finishedCreatingMyOnlineCollection = false;
        var finishedCreatingMyOfflineCollection = false;

        myOfflineCollection.install(function(err) {
            if (err) done(err);
            finishedCreatingMyOfflineCollection = true;
            if (finishedCreatingMyOnlineCollection) {
                done();
            }
        });

        myOnlineCollection.install(function(err) {
            if (err) done(err);
            if (finishedCreatingMyOfflineCollection) {
                done();
            }
        });
    });

    function mapRemoteUsers(callback) {
        myOnlineCollection.User.map([{
            username: 'mtford',
            name: 'Michael Ford',
            userId: '1'
        }, {
            username: 'blahblah',
            name: 'Blah Blah',
            userId: '2'
        }, {
            username: 'bobm',
            name: 'Bob Marley',
            userId: '3'
        }], callback);
    }

    function mapRemotePhotos(callback) {
        myOnlineCollection.Photo.map([{
            height: 500,
            width: 500,
            url: 'http://somewhere/image.jpeg',
            photoId: '10',
            createdBy: '1'
        }, {
            height: 1500,
            width: 1500,
            url: 'http://somewhere/image2.jpeg',
            photoId: '11',
            createdBy: '1'
        }, {
            height: 500,
            width: 750,
            url: 'http://somewhere/image3.jpeg',
            photoId: '12',
            createdBy: '2'
        }], callback);
    }

    function mapOfflineUsers(callback) {
        myOfflineCollection.User.map([{
            username: 'mike'
        }, {
            username: 'gaz'
        }], callback);
    }

    function installOfflineFixtures(callback) {
        mapOfflineUsers(callback);
    }

    function installOnlineFixtures(callback) {
        async.series([
            mapRemoteUsers,
            mapRemotePhotos
        ], callback);
    }

    beforeEach(function(done) {
        installOfflineFixtures(function(err) {
            if (err) done(err);
            installOnlineFixtures(done);
        });
    });

    describe('local queries', function() {
        describe('offline', function() {
            it('should return mike when querying for him', function(done) {
                myOfflineCollection.User.query({
                    username: 'gaz'
                }, function(err, users) {
                    if (err) done(err);
                    assert.equal(users.length, 1);
                    assert.equal(users[0].username, 'gaz');
                    done();
                });
            });
        });

        describe('online', function() {

            it('should return 3 users when run a local all query against users', function(done) {
                myOnlineCollection.User.all(function(err, users) {
                    if (err) done(err);
                    assert.equal(users.length, 3);
                    done();
                });
            });

            it('should return 3 photos when run a local all query against photos', function(done) {
                myOnlineCollection.Photo.all(function(err, photos) {
                    if (err) done(err);
                    assert.equal(photos.length, 3);
                    done();
                });
            });

            it('should return 2 photos with height 500', function(done) {
                this.timeout(10000);
                myOnlineCollection.Photo.query({
                    height: 500
                }, function(err, photos) {
                    if (err) done(err);
                    assert.equal(photos.length, 2);
                    _.each(photos, function(p) {
                        assert.equal(p.height, 500);
                    });
                    done();
                });
            });

            it('should return 1 photo with height 500, width, 750', function(done) {
                this.timeout(10000);
                myOnlineCollection.Photo.query({
                    height: 500,
                    width: 750
                }, function(err, photos) {
                    if (err) done(err);
                    assert.equal(photos.length, 1);
                    assert.equal(photos[0].height, 500);
                    assert.equal(photos[0].width, 750);
                    done();
                });
            });

            it('should be able to query by remote identifier', function(done) {
                myOnlineCollection.User.get('1', function(err, user) {
                    if (err) done(err);
                    assert.equal(user.userId, '1');
                    done();
                })
            })


        });
    });
    describe('relationship mappings', function() {
        describe('online', function() {
            function assertNumPhotos(userId, numPhotos, done) {
                myOnlineCollection.User.get(userId, function(err, user) {
                    if (err) done(err);
                    assert.ok(user);
                    assert.equal(user.userId, userId);
                    var proxy = user.photosProxy;
                    proxy.get(function(err, photos) {
                        if (err) done(err);
                        assert.equal(photos ? photos.length : 0, numPhotos);
                        done();
                    });
                })
            }

            it('user with id 1 should have 2 photos', function(done) {
                assertNumPhotos('1', 2, done);
            });

            it('user with id 2 should have 1 photo...', function(done) {
                assertNumPhotos('2', 1, done);
            });

            it('user with id 3 should have no photos', function(done) {
                assertNumPhotos('3', 0, done);
            });

        });

    });





});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/relationship":58,"async":2,"chai":9}],68:[function(require,module,exports){
var s = require('../../index')
    , assert = require('chai').assert;

describe('intercoll relationships', function () {


    var SiestaModel = require('../../src/object').SiestaModel;
    var Collection = require('../../src/collection').Collection;
    var RelationshipType = require('../../src/relationship').RelationshipType;

    beforeEach(function () {
        s.reset(true);
    });

    var collection, carMapping, personMapping;

    function configureAPI(type, done) {
        collection = new Collection('myCollection');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            relationships: {
                owner: {
                    mapping: 'Person',
                    type: type,
                    reverse: 'cars'
                }
            }
        });
        personMapping = collection.mapping('Person', {
            id: 'id',
            attributes: ['name', 'age']
        });
        collection.install(done);
    }

    describe('Inter-collection', function () {
        var anotherCollection;
        var obj;

        beforeEach(function (done) {
            configureAPI(RelationshipType.OneToMany, done);
        });

        afterEach(function () {
            anotherCollection = undefined;
            obj = undefined;
        });

        describe('foreign key', function () {
            beforeEach(function (done) {
                anotherCollection = new Collection('anotherCollection');

                anotherCollection.mapping('AnotherMapping', {
                    attributes: ['field'],
                    relationships: {
                        person: {
                            mapping: 'myCollection.Person',
                            type: RelationshipType.OneToMany,
                            reverse: 'other'
                        }
                    }
                });

                anotherCollection.install(function (err) {
                    if (err) done(err);
                    anotherCollection['AnotherMapping'].map({field: 5, person: {name: 'Michael', age: 23, id: 'xyz'}}, function (err, _obj) {
                        if (err) done(err);
                        obj = _obj;
                        done();
                    });
                });

            });

            it('installs forward', function () {
                var person = obj.person;
                assert.instanceOf(person, SiestaModel);
                assert.equal(person.collection, 'myCollection');
                assert.equal(person.name, 'Michael');
                assert.equal(person.age, 23);
            });

            it('installs backwards', function () {
                var person = obj.person;
                assert.include(person.other, obj);
            });

        });
    });


});
},{"../../index":1,"../../src/collection":45,"../../src/object":53,"../../src/relationship":58,"chai":9}],69:[function(require,module,exports){
var s = require('../../index'),
    assert = require('chai').assert;

describe('perform mapping', function() {


    var Collection = require('../../src/collection').Collection;
    var RelationshipType = require('../../src/relationship').RelationshipType;

    var SiestaModel = require('../../src/object').SiestaModel;
    var cache = require('../../src/cache');
    var Operation = require('../../vendor/operations.js/src/operation').Operation;

    var collection, carMapping, personMapping;

    beforeEach(function() {
        collection = null;
        carMapping = null;
        personMapping = null;
        s.reset(true);
    });

    afterEach(function() {
        var numIncomplete = 0;
        _.each(Operation.running, function(op) {
            if (!op.completed) {
                numIncomplete++;
            }
        });
        assert.notOk(numIncomplete);
    });

    describe('empty', function() {
        beforeEach(function(done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(done);

        });
        it('empty', function() {
            carMapping.map({}, function(err, _obj) {
                assert.notOk(err);
                assert.notOk(_obj);
            });
        });
    });



    describe('no id', function() {
        beforeEach(function(done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(done);

        });
        it('xyz', function(done) {
            var obj;
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin'
            }, function(err, _obj) {
                if (err) {
                    done(err);
                } else {
                    obj = _obj;
                    done();
                }
            });
        })
    });

    describe('no relationships', function() {
        var obj;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(function(err) {
                if (err) done(err);
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    id: 'dfadf'
                }, function(err, _obj) {
                    if (err) {
                        done(err);
                    }
                    obj = _obj;
                    done();
                });
            });
        });

        describe('new', function() {

            it('returns a model', function() {
                assert.instanceOf(obj, SiestaModel);
            });

            it('has the right fields', function() {
                assert.equal(obj.colour, 'red');
                assert.equal(obj.name, 'Aston Martin');
                assert.equal(obj.id, 'dfadf');
                assert.ok(obj._id);
            });


        });

        describe('existing in cache', function() {

            describe('via id', function() {
                var newObj;
                beforeEach(function(done) {
                    carMapping.map({
                        colour: 'blue',
                        id: 'dfadf'
                    }, function(err, obj) {
                        if (err) done(err);
                        newObj = obj;
                        done();
                    });
                });

                it('should be mapped onto the old object', function() {
                    assert.equal(newObj, obj);
                });

                it('should have the new colour', function() {
                    assert.equal(newObj.colour, 'blue');
                });
            });

            describe('via _id', function() {
                var newObj;
                beforeEach(function(done) {
                    carMapping.map({
                        colour: 'blue',
                        _id: obj._id
                    }, function(err, obj) {
                        if (err) done(err);
                        newObj = obj;
                        done();
                    });
                });

                it('should be mapped onto the old object', function() {
                    assert.equal(newObj, obj);
                });

                it('should have the new colour', function() {
                    assert.equal(newObj.colour, 'blue');
                });
            });
        });
    });

    describe('with relationship', function() {
        describe('foreign key', function() {
            beforeEach(function(done) {
                collection = new Collection('myCollection');
                personMapping = collection.mapping('Person', {
                    id: 'id',
                    attributes: ['name', 'age']
                });
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colour', 'name'],
                    relationships: {
                        owner: {
                            mapping: 'Person',
                            type: RelationshipType.OneToMany,
                            reverse: 'cars'
                        }
                    }
                });
                collection.install(done);
            });



            describe('remote id', function() {

                describe('forward', function() {
                    describe('object that already exists', function() {
                        var person, car;
                        beforeEach(function(done) {
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId'
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                carMapping.map({
                                    name: 'Bentley',
                                    colour: 'black',
                                    owner: 'personRemoteId',
                                    id: 'carRemoteId'
                                }, function(err, _car) {
                                    if (err) {

                                        done(err);
                                    }
                                    car = _car;
                                    done();
                                });
                            });
                        });

                        it('owner of car should be michael', function(done) {
                            assert.equal(car.owner, person);
                            car.ownerProxy.get(function(err, owner) {
                                if (err) done(err);
                                assert.equal(owner, person);
                                done();
                            })
                        });
                        it('michael should own the car', function(done) {
                            person.carsProxy.get(function(err, cars) {
                                if (err) done(err);
                                assert.include(cars, car);
                                done();
                            });
                        });
                    });

                    describe('remote id of an object that doesnt exist', function() {
                        var car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: 'personRemoteId',
                                id: 'carRemoteId'
                            }, function(err, _car) {

                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                        it('car should have a new owner and new owner should have a car', function(done) {
                            car.ownerProxy.get(function(err, person) {
                                if (err) done(err);
                                assert.equal(person.id, 'personRemoteId');
                                person.carsProxy.get(function(err, cars) {
                                    if (err) done(err);
                                    assert.equal(cars.length, 1);
                                    assert.include(cars, car);
                                    done();
                                });
                            });
                        })

                    })
                });

                describe('reverse', function() {
                    describe('remoteids of objects that already exist', function() {
                        var person, cars;
                        beforeEach(function(done) {
                            var raw = [{
                                colour: 'red',
                                name: 'Aston Martin',
                                id: 'remoteId1'
                            }, {
                                colour: 'blue',
                                name: 'Lambo',
                                id: "remoteId2"
                            }, {
                                colour: 'green',
                                name: 'Ford',
                                id: "remoteId3"
                            }];
                            carMapping._mapBulk(raw, function(err, objs, res) {
                                if (err) {
                                    done(err);
                                } else {
                                    cars = objs;
                                    personMapping.map({
                                        name: 'Michael Ford',
                                        age: 23,
                                        id: 'personRemoteId',
                                        cars: ['remoteId1', 'remoteId2', 'remoteId3']
                                    }, function(err, _person) {
                                        if (err) {
                                            done(err);
                                        } else {
                                            person = _person;
                                            done();
                                        }

                                    });
                                }

                            });
                        });

                        it('cars should have person as their owner', function() {
                            _.each(cars, function(car) {
                                assert.equal(car.owner, person);
                            })
                        });

                        it('person should have car objects', function() {
                            _.each(cars, function(car) {
                                assert.include(person.cars, car);
                            })
                        });
                    });

                    describe('remoteids of objects that dont exist', function() {
                        var person;
                        beforeEach(function(done) {
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId',
                                cars: ['remoteId1', 'remoteId2', 'remoteId3']
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                done();
                            });
                        });

                        it('person has 3 new cars, and those cars are owned by the person', function(done) {
                            person.carsProxy.get(function(err, cars) {
                                done(err);
                                assert.equal(cars.length, 3);
                                _.each(cars, function(car) {
                                    assert.equal(car.owner, person);
                                })
                            });
                        })
                    });

                    describe('mixture', function() {
                        var person, cars;
                        beforeEach(function(done) {
                            var raw = [{
                                colour: 'red',
                                name: 'Aston Martin',
                                id: 'remoteId1'
                            }, {
                                colour: 'green',
                                name: 'Ford',
                                id: "remoteId3"
                            }];
                            carMapping._mapBulk(raw, function(err, objs, res) {
                                if (err) done(err);
                                cars = objs;
                                personMapping.map({
                                    name: 'Michael Ford',
                                    age: 23,
                                    id: 'personRemoteId',
                                    cars: ['remoteId1', 'remoteId2', 'remoteId3']
                                }, function(err, _person) {
                                    if (err) done(err);
                                    person = _person;
                                    done();
                                });
                            });
                        });

                        it('cars should have person as their owner', function() {
                            _.each(cars, function(car) {
                                assert.equal(car.owner, person);
                            })
                        });

                        it('person should have car objects', function() {
                            _.each(cars, function(car) {
                                assert.include(person.cars, car);
                            })
                        });

                        it('person has 3 new cars, and those cars are owned by the person', function(done) {
                            person.carsProxy.get(function(err, cars) {
                                done(err);
                                assert.equal(cars.length, 3);
                                _.each(cars, function(car) {
                                    assert.equal(car.owner, person);
                                })
                            });
                        })


                    })
                })

            });
            describe('object', function() {

                describe('forward', function() {
                    var person, car;
                    beforeEach(function(done) {
                        personMapping.map({
                            name: 'Michael Ford',
                            age: 23,
                            id: 'personRemoteId'
                        }, function(err, _person) {
                            if (err) done(err);
                            person = _person;
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: person,
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                    });
                    it('owner of car should be michael', function(done) {
                        car.ownerProxy.get(function(err, owner) {
                            if (err) done(err);
                            assert.equal(owner, person);
                            done();
                        })
                    });
                    it('michael should the car', function(done) {
                        person.carsProxy.get(function(err, cars) {
                            if (err) done(err);
                            assert.include(cars, car);
                            done();
                        });
                    });
                });

                describe('reverse', function() {
                    var person, cars;
                    beforeEach(function(done) {
                        var raw = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'remoteId1'
                        }, {
                            colour: 'blue',
                            name: 'Lambo',
                            id: "remoteId2"
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId3"
                        }];
                        carMapping._mapBulk(raw, function(err, objs, res) {
                            if (err) done(err);
                            cars = objs;
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId',
                                cars: objs
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                done();
                            });
                        });
                    });

                    it('cars should have person as their owner', function() {
                        _.each(cars, function(car) {
                            assert.equal(car.owner, person);
                        })
                    });

                    it('person should have car objects', function() {
                        _.each(cars, function(car) {
                            assert.include(person.cars, car);
                        })
                    });
                })

            });

            describe('local id within object', function() {
                describe('forward', function() {
                    var person, car;
                    beforeEach(function(done) {
                        personMapping.map({
                            name: 'Michael Ford',
                            age: 23,
                            id: 'personRemoteId'
                        }, function(err, _person) {
                            if (err) done(err);
                            person = _person;
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: {
                                    _id: person._id
                                },
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) {

                                    done(err);
                                }
                                car = _car;
                                done();
                            });
                        });
                    });
                    it('owner of car should be michael', function(done) {
                        car.ownerProxy.get(function(err, owner) {
                            if (err) done(err);
                            assert.equal(owner, person);
                            done();
                        })
                    });
                    it('michael should the car', function(done) {
                        person.carsProxy.get(function(err, cars) {
                            if (err) done(err);
                            assert.include(cars, car);
                            done();
                        });
                    });
                });
                describe('reverse', function() {
                    var person, cars;
                    beforeEach(function(done) {
                        var raw = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'remoteId1'
                        }, {
                            colour: 'blue',
                            name: 'Lambo',
                            id: "remoteId2"
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId3"
                        }];
                        carMapping._mapBulk(raw, function(err, objs, res) {
                            if (err) {

                                done(err);
                            } else {}
                            cars = objs;
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId',
                                cars: _.map(cars, function(car) {
                                    return {
                                        _id: car._id
                                    }
                                })
                            }, function(err, _person) {
                                if (err) {
                                    done(err);
                                } else {}
                                person = _person;
                                done();
                            });
                        });
                    });

                    it('cars should have person as their owner', function() {
                        _.each(cars, function(car) {
                            assert.equal(car.owner, person);
                        })
                    });

                    it('person should have car objects', function() {
                        _.each(cars, function(car) {
                            assert.include(person.cars, car);
                        })
                    });
                })
            });

            describe('remote id within object', function() {

                describe('forward', function() {
                    describe('object that already exists', function() {
                        var person, car;
                        beforeEach(function(done) {
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId123'
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                carMapping.map({
                                    name: 'Bentley',
                                    colour: 'black',
                                    owner: {
                                        id: 'personRemoteId123'
                                    },
                                    id: 'carRemoteId'
                                }, function(err, _car) {
                                    if (err) {
                                        done(err);
                                    }
                                    car = _car;
                                    done();
                                });
                            });
                        });
                        it('owner of car should be michael', function(done) {
                            car.ownerProxy.get(function(err, owner) {
                                if (err) done(err);
                                assert.equal(owner, person);
                                done();
                            })
                        });
                        it('michael should the car', function(done) {
                            person.carsProxy.get(function(err, cars) {
                                if (err) done(err);
                                assert.include(cars, car);
                                done();
                            });
                        });
                    });

                    describe('remote id of an object that doesnt exist', function() {
                        var car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: {
                                    id: 'personRemoteId'
                                },
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                        it('car should have a new owner and new owner should have a car', function(done) {
                            car.ownerProxy.get(function(err, person) {
                                if (err) done(err);
                                assert.equal(person.id, 'personRemoteId');
                                person.carsProxy.get(function(err, cars) {
                                    if (err) done(err);
                                    assert.equal(cars.length, 1);
                                    assert.include(cars, car);
                                    done();
                                });
                            });
                        })

                    })
                });

                describe('reverse', function() {
                    describe('remoteids of objects that already exist', function() {
                        var person, cars;
                        beforeEach(function(done) {
                            var raw = [{
                                colour: 'red',
                                name: 'Aston Martin',
                                id: 'remoteId1'
                            }, {
                                colour: 'blue',
                                name: 'Lambo',
                                id: "remoteId2"
                            }, {
                                colour: 'green',
                                name: 'Ford',
                                id: "remoteId3"
                            }];
                            carMapping._mapBulk(raw, function(err, objs, res) {
                                if (err) {

                                    done(err);
                                } else {

                                }
                                cars = objs;

                                personMapping.map({
                                    name: 'Michael Ford',
                                    age: 23,
                                    id: 'personRemoteId',
                                    cars: [{
                                        id: 'remoteId1'
                                    }, {
                                        id: 'remoteId2'
                                    }, {
                                        id: 'remoteId3'
                                    }]
                                }, function(err, _person) {
                                    if (err) {

                                        done(err);
                                    } else {

                                    }
                                    person = _person;
                                    done();
                                });
                            });
                        });

                        it('cars should have person as their owner', function() {
                            _.each(cars, function(car) {
                                assert.equal(car.owner, person);
                            })
                        });

                        it('person should have car objects', function() {
                            _.each(cars, function(car) {
                                assert.include(person.cars, car);
                            })
                        });
                    });

                    describe('remoteids of objects that dont exist', function() {
                        var person;
                        beforeEach(function(done) {
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId',
                                cars: [{
                                    id: 'remoteId1'
                                }, {
                                    id: 'remoteId2'
                                }, {
                                    id: 'remoteId3'
                                }]
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                done();
                            });
                        });

                        it('person has 3 new cars, and those cars are owned by the person', function(done) {
                            person.carsProxy.get(function(err, cars) {
                                done(err);
                                assert.equal(cars.length, 3);
                                _.each(cars, function(car) {
                                    assert.equal(car.owner, person);
                                })
                            });
                        })
                    });

                    describe('mixture', function() {
                        var person, cars;
                        beforeEach(function(done) {
                            var raw = [{
                                colour: 'red',
                                name: 'Aston Martin',
                                id: 'remoteId1'
                            }, {
                                colour: 'green',
                                name: 'Ford',
                                id: "remoteId3"
                            }];
                            carMapping._mapBulk(raw, function(err, objs, res) {
                                if (err) done(err);
                                cars = objs;
                                personMapping.map({
                                    name: 'Michael Ford',
                                    age: 23,
                                    id: 'personRemoteId',
                                    cars: [{
                                        id: 'remoteId1'
                                    }, {
                                        id: 'remoteId2'
                                    }, {
                                        id: 'remoteId3'
                                    }]
                                }, function(err, _person) {
                                    if (err) done(err);
                                    person = _person;
                                    done();
                                });
                            });
                        });

                        it('cars should have person as their owner', function() {
                            _.each(cars, function(car) {
                                assert.equal(car.owner, person);
                            })
                        });

                        it('person should have car objects', function() {
                            _.each(cars, function(car) {
                                assert.include(person.cars, car);
                            })
                        });

                        it('person has 3 new cars, and those cars are owned by the person', function(done) {
                            person.carsProxy.get(function(err, cars) {
                                done(err);
                                assert.equal(cars.length, 3);
                                _.each(cars, function(car) {
                                    assert.equal(car.owner, person);
                                })
                            });
                        })


                    })
                })

            });
        });

        describe('one-to-one', function() {
            var personMapping;
            beforeEach(function(done) {
                collection = new Collection('myCollection');
                personMapping = collection.mapping('Person', {
                    id: 'id',
                    attributes: ['name', 'age']
                });
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colour', 'name'],
                    relationships: {
                        owner: {
                            mapping: 'Person',
                            type: RelationshipType.OneToOne,
                            reverse: 'car'
                        }
                    }
                });
                collection.install(done);


            });


            describe('remote id', function() {
                describe('forward', function() {
                    describe('object that already exists', function() {
                        var person, car;
                        beforeEach(function(done) {
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId'
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                carMapping.map({
                                    name: 'Bentley',
                                    colour: 'black',
                                    id: 'carRemoteId',
                                    owner: 'personRemoteId'
                                }, function(err, _car) {
                                    if (err) {

                                        done(err);
                                    }
                                    car = _car;

                                    done();
                                });
                            });

                        });
                        it('owner of car should be michael', function(done) {
                            car.ownerProxy.get(function(err, owner) {
                                if (err) done(err);
                                assert.equal(owner, person);
                                done();
                            })
                        });
                        it('michael should own the car', function(done) {
                            person.carProxy.get(function(err, personsCar) {
                                if (err) done(err);
                                assert.equal(car, personsCar);
                                done();
                            });
                        });
                    });
                    describe('remote id of an object that doesnt exist', function() {
                        var car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: 'personRemoteId',
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                        it('car should have a new owner and new owner should have a car', function(done) {
                            car.ownerProxy.get(function(err, person) {
                                if (err) done(err);
                                assert.equal(person.id, 'personRemoteId');
                                person.carProxy.get(function(err, personsCar) {
                                    if (err) done(err);
                                    assert.equal(personsCar, car);
                                    done();
                                });
                            });
                        })

                    })
                });
                describe('reverse', function() {
                    describe('object that already exists', function() {
                        var person, car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) {

                                    done(err);
                                }
                                car = _car;
                                personMapping.map({
                                    name: 'Michael Ford',
                                    age: 23,
                                    car: 'carRemoteId',
                                    id: 'personRemoteId'
                                }, function(err, _person) {
                                    if (err) done(err);
                                    person = _person;
                                    done();
                                });
                            });
                        });
                        it('owner of car should be michael', function(done) {
                            car.ownerProxy.get(function(err, owner) {
                                if (err) done(err);
                                assert.equal(owner, person);
                                done();
                            })
                        });
                        it('michael should own the car', function(done) {
                            person.carProxy.get(function(err, personsCar) {
                                if (err) done(err);
                                assert.equal(car, personsCar);
                                done();
                            });
                        });
                    });

                    describe('remote id of an object that doesnt exist', function() {
                        var car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: 'personRemoteId',
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                        it('car should have a new owner and new owner should have a car', function(done) {
                            car.ownerProxy.get(function(err, person) {
                                if (err) done(err);
                                assert.equal(person.id, 'personRemoteId');
                                person.carProxy.get(function(err, personsCar) {
                                    if (err) done(err);
                                    assert.equal(personsCar, car);
                                    done();
                                });
                            });
                        })

                    })
                });
            });

            describe('remote id within object', function() {
                describe('forward', function() {
                    describe('object that already exists', function() {
                        var person, car;
                        beforeEach(function(done) {
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                id: 'personRemoteId'
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                carMapping.map({
                                    name: 'Bentley',
                                    colour: 'black',
                                    id: 'carRemoteId',
                                    owner: {
                                        id: 'personRemoteId'
                                    }
                                }, function(err, _car) {
                                    if (err) {

                                        done(err);
                                    }
                                    car = _car;

                                    done();
                                });
                            });
                        });
                        it('owner of car should be michael', function(done) {
                            car.ownerProxy.get(function(err, owner) {
                                if (err) done(err);
                                assert.equal(owner, person);
                                done();
                            })
                        });
                        it('michael should own the car', function(done) {
                            person.carProxy.get(function(err, personsCar) {
                                if (err) done(err);
                                assert.equal(car, personsCar);
                                done();
                            });
                        });
                    });

                    describe('remote id of an object that doesnt exist', function() {
                        var car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: {
                                    id: 'personRemoteId'
                                },
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                        it('car should have a new owner and new owner should have a car', function(done) {
                            car.ownerProxy.get(function(err, person) {
                                if (err) done(err);
                                assert.equal(person.id, 'personRemoteId');
                                person.carProxy.get(function(err, personsCar) {
                                    if (err) done(err);
                                    assert.equal(personsCar, car);
                                    done();
                                });
                            });
                        })

                    })
                });
                describe('reverse', function() {
                    describe('object that already exists', function() {
                        var person, car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) {

                                    done(err);
                                }
                                car = _car;
                                personMapping.map({
                                    name: 'Michael Ford',
                                    age: 23,
                                    car: {
                                        id: 'carRemoteId'
                                    },
                                    id: 'personRemoteId'
                                }, function(err, _person) {
                                    if (err) done(err);
                                    person = _person;
                                    done();
                                });
                            });
                        });
                        it('owner of car should be michael', function(done) {
                            car.ownerProxy.get(function(err, owner) {
                                if (err) done(err);
                                assert.equal(owner, person);
                                done();
                            })
                        });
                        it('michael should own the car', function(done) {
                            person.carProxy.get(function(err, personsCar) {
                                if (err) done(err);
                                assert.equal(car, personsCar);
                                done();
                            });
                        });
                    });

                    describe('remote id of an object that doesnt exist', function() {
                        var car;
                        beforeEach(function(done) {
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                owner: {
                                    id: 'personRemoteId'
                                },
                                id: 'carRemoteId'
                            }, function(err, _car) {
                                if (err) done(err);
                                car = _car;
                                done();
                            });
                        });
                        it('car should have a new owner and new owner should have a car', function(done) {
                            car.ownerProxy.get(function(err, person) {
                                if (err) done(err);
                                assert.equal(person.id, 'personRemoteId');
                                person.carProxy.get(function(err, personsCar) {
                                    if (err) done(err);
                                    assert.equal(personsCar, car);
                                    done();
                                });
                            });
                        })

                    })
                });
            });

            describe('_id within object', function() {
                describe('forward', function() {
                    var person, car;
                    beforeEach(function(done) {
                        personMapping.map({
                            name: 'Michael Ford',
                            age: 23,
                            id: 'personRemoteId'
                        }, function(err, _person) {
                            if (err) done(err);
                            person = _person;
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                id: 'carRemoteId',
                                owner: {
                                    _id: person._id
                                }
                            }, function(err, _car) {
                                if (err) {

                                    done(err);
                                }
                                car = _car;

                                done();
                            });
                        });
                    });
                    it('owner of car should be michael', function(done) {
                        car.ownerProxy.get(function(err, owner) {
                            if (err) done(err);
                            assert.equal(owner, person);
                            done();
                        })
                    });
                    it('michael should own the car', function(done) {
                        person.carProxy.get(function(err, personsCar) {
                            if (err) done(err);
                            assert.equal(car, personsCar);
                            done();
                        });
                    });
                });
                describe('reverse', function() {
                    var person, car;
                    beforeEach(function(done) {
                        carMapping.map({
                            name: 'Bentley',
                            colour: 'black',
                            id: 'carRemoteId'
                        }, function(err, _car) {
                            if (err) {

                                done(err);
                            }
                            car = _car;
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                car: {
                                    _id: car._id
                                },
                                id: 'personRemoteId'
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                done();
                            });
                        });
                    });
                    it('owner of car should be michael', function(done) {
                        car.ownerProxy.get(function(err, owner) {
                            if (err) done(err);
                            assert.equal(owner, person);
                            done();
                        })
                    });
                    it('michael should own the car', function(done) {
                        person.carProxy.get(function(err, personsCar) {
                            if (err) done(err);
                            assert.equal(car, personsCar);
                            done();
                        });
                    });

                });
            });

            describe('object', function() {
                describe('forward', function() {
                    var person, car;
                    beforeEach(function(done) {
                        personMapping.map({
                            name: 'Michael Ford',
                            age: 23,
                            id: 'personRemoteId'
                        }, function(err, _person) {
                            if (err) done(err);
                            person = _person;
                            carMapping.map({
                                name: 'Bentley',
                                colour: 'black',
                                id: 'carRemoteId',
                                owner: person
                            }, function(err, _car) {
                                if (err) {

                                    done(err);
                                }
                                car = _car;

                                done();
                            });
                        });
                    });
                    it('owner of car should be michael', function(done) {
                        car.ownerProxy.get(function(err, owner) {
                            if (err) done(err);
                            assert.equal(owner, person);
                            done();
                        })
                    });
                    it('michael should own the car', function(done) {
                        person.carProxy.get(function(err, personsCar) {
                            if (err) done(err);
                            assert.equal(car, personsCar);
                            done();
                        });
                    });
                });
                describe('reverse', function() {
                    var person, car;
                    beforeEach(function(done) {
                        carMapping.map({
                            name: 'Bentley',
                            colour: 'black',
                            id: 'carRemoteId'
                        }, function(err, _car) {
                            if (err) {

                                done(err);
                            }
                            car = _car;
                            personMapping.map({
                                name: 'Michael Ford',
                                age: 23,
                                car: car,
                                id: 'personRemoteId'
                            }, function(err, _person) {
                                if (err) done(err);
                                person = _person;
                                done();
                            });
                        });
                    });
                    it('owner of car should be michael', function(done) {
                        car.ownerProxy.get(function(err, owner) {
                            if (err) done(err);
                            assert.equal(owner, person);
                            done();
                        })
                    });
                    it('michael should own the car', function(done) {
                        person.carProxy.get(function(err, personsCar) {
                            if (err) done(err);
                            assert.equal(car, personsCar);
                            done();
                        });
                    });

                });
            });
        });
    });

    describe('caveats', function() {
        beforeEach(function(done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(done);
        });

        it('mapping an attribute that doesnt exist', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'aston martin',
                extraneous: 'blah'
            }, function(err, car) {
                if (err) done(err);
                assert.notOk(car.extraneous);
                done();
            });
        });

    });

    describe('errors', function() {
        describe('one-to-one', function() {
            var personMapping;
            beforeEach(function(done) {
                collection = new Collection('myCollection');
                personMapping = collection.mapping('Person', {
                    id: 'id',
                    attributes: ['name', 'age']
                });
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colour', 'name'],
                    relationships: {
                        owner: {
                            mapping: 'Person',
                            type: RelationshipType.OneToOne,
                            reverse: 'car'
                        }
                    }
                });
                collection.install(done);
            });

            it('assign array to scalar relationship', function(done) {
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    owner: ['remoteId1', 'remoteId2'],
                    id: 'carRemoteId'
                }, function(err, obj) {
                    var ownerError = err.owner;
                    assert.ok(ownerError);
                    done();
                });
            });

            it('assign array to scalar relationship reverse', function(done) {
                personMapping.map({
                    name: 'Michael Ford',
                    car: ['remoteId1', 'remoteId2'],
                    age: 23,
                    id: 'personRemoteId'
                }, function(err, obj) {
                    assert.ok(err.car);
                    done();
                });
            });


        });
        describe('foreign key', function() {

            var personMapping;
            beforeEach(function(done) {
                collection = new Collection('myCollection');
                personMapping = collection.mapping('Person', {
                    id: 'id',
                    attributes: ['name', 'age']
                });
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colour', 'name'],
                    relationships: {
                        owner: {
                            mapping: 'Person',
                            type: RelationshipType.OneToMany,
                            reverse: 'cars'
                        }
                    }
                });
                collection.install(done);
            });

            it('assign array to scalar relationship', function(done) {
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    owner: ['remoteId1', 'remoteId2'],
                    id: 'carRemoteId'
                }, function(err, obj) {
                    var ownerError = err.owner;
                    assert.ok(ownerError);
                    done();
                });
            });

            it('assign scalar to vector relationship reverse', function(done) {
                personMapping.map({
                    name: 'Michael Ford',
                    cars: 'remoteId1',
                    age: 23,
                    id: 'personRemoteId'
                }, function(err, obj) {
                    assert.ok(err.cars);
                    done();
                });
            });


        });
    });

    describe('bulk', function() {
        describe('new', function() {
            describe('no relationships', function() {
                beforeEach(function(done) {
                    collection = new Collection('myCollection');
                    carMapping = collection.mapping('Car', {
                        id: 'id',
                        attributes: ['colour', 'name']
                    });
                    collection.install(done);
                });

                it('all valid', function(done) {
                    var raw = [{
                        colour: 'red',
                        name: 'Aston Martin',
                        id: 'remoteId1sdfsdfdsfgsdf'
                    }, {
                        colour: 'blue',
                        name: 'Lambo',
                        id: "remoteId2dfgdfgdfg"
                    }, {
                        colour: 'green',
                        name: 'Ford',
                        id: "remoteId3dfgdfgdfgdfg"
                    }];
                    carMapping._mapBulk(raw, function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, raw.length);
                        assert.equal(objs[0].colour, 'red');
                        assert.equal(objs[1].colour, 'blue');
                        assert.equal(objs[2].colour, 'green');
                        done();
                    })
                });
            });
            describe('foreign key', function() {
                var personMapping;

                beforeEach(function(done) {
                    collection = new Collection('myCollection');
                    personMapping = collection.mapping('Person', {
                        id: 'id',
                        attributes: ['name', 'age']
                    });
                    carMapping = collection.mapping('Car', {
                        id: 'id',
                        attributes: ['colour', 'name'],
                        relationships: {
                            owner: {
                                mapping: 'Person',
                                type: RelationshipType.OneToMany,
                                reverse: 'cars'
                            }
                        }
                    });
                    collection.install(done);
                });

                it('same owner using _mapBulk', function(done) {
                    var ownerId = 'ownerId462345345';
                    var raw = [{
                        colour: 'red',
                        name: 'Aston Martin',
                        id: 'remoteId1',
                        owner: ownerId
                    }, {
                        colour: 'blue',
                        name: 'Lambo',
                        id: "remoteId2",
                        owner: ownerId
                    }, {
                        colour: 'green',
                        name: 'Ford',
                        id: "remoteId3",
                        owner: ownerId
                    }];
                    carMapping._mapBulk(raw, function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, raw.length);
                        assert.equal(objs[0].owner, objs[1].owner);
                        assert.equal(objs[1].owner, objs[2].owner);
                        done();
                    })
                });

                it('same owner using map', function(done) {
                    var ownerId = 'ownerId!!!334';
                    var carRaw1 = {
                        colour: 'red',
                        name: 'Aston Martin',
                        id: 'remoteId1',
                        owner: ownerId
                    };
                    var carRaw2 = {
                        colour: 'blue',
                        name: 'Lambo',
                        id: "remoteId2",
                        owner: ownerId
                    };
                    carMapping.map(carRaw1, function(err, car1) {
                        if (err) {
                            done(err);
                        } else {
                            carMapping.map(carRaw2, function(err, car2) {
                                if (err) done(err);
                                assert.equal(car1.owner, car2.owner);
                                done();
                            })
                        }
                    });
                })
            })
        });

        describe('faulted relationships', function() {
            var cars;

            var personMapping;

            beforeEach(function(done) {
                collection = new Collection('myCollection');
                personMapping = collection.mapping('Person', {
                    id: 'id',
                    attributes: ['name', 'age']
                });
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colour', 'name'],
                    relationships: {
                        owner: {
                            mapping: 'Person',
                            type: RelationshipType.OneToMany,
                            reverse: 'cars'
                        }
                    }
                });
                collection.install(done);
            });


            describe('via remote id', function() {
                beforeEach(function(done) {
                    personMapping.map({
                        name: 'Michael Ford',
                        age: 23,
                        id: 'personRemoteId'
                    }, function(err) {
                        if (err) done(err);
                        var raw = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'remoteId1',
                            owner: 'personRemoteId'
                        }, {
                            colour: 'blue',
                            name: 'Lambo',
                            id: "remoteId2",
                            owner: 'personRemoteId'
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId3",
                            owner: 'personRemoteId'
                        }];
                        carMapping._mapBulk(raw, function(err, objs, res) {
                            if (err) {
                                done(err);
                            }
                            cars = objs;
                            done();
                        });

                    });
                });

                it('should have mapped onto Michael', function() {
                    assert.equal(cars.length, 3);
                    assert.equal(cars[0].owner, cars[1].owner);
                    assert.equal(cars[1].owner, cars[2].owner);
                });

            });


            describe('bulk bulk', function() {
                beforeEach(function(done) {
                    cars = [];
                    personMapping.map({
                        name: 'Michael Ford',
                        age: 23,
                        id: 'personRemoteId'
                    }, function(err) {
                        if (err) done(err);
                        var raw1 = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'remoteId1',
                            owner: 'personRemoteId'
                        }, {
                            colour: 'blue',
                            name: 'Lambo',
                            id: "remoteId2",
                            owner: 'personRemoteId'
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId3",
                            owner: 'personRemoteId'
                        }];
                        carMapping._mapBulk(raw1, function(err, objs, res) {
                            if (err) {
                                done(err);
                            }
                            _.each(objs, function(o) {
                                cars.push(o);
                            });
                            if (cars.length == 9) {
                                done();
                            }
                        });
                        var raw2 = [{
                            colour: 'red',
                            name: 'Peauget',
                            id: 'remoteId4',
                            owner: 'personRemoteId'
                        }, {
                            colour: 'blue',
                            name: 'Chevy',
                            id: "remoteId5",
                            owner: 'personRemoteId'
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId6",
                            owner: 'personRemoteId'
                        }];
                        carMapping._mapBulk(raw2, function(err, objs, res) {
                            if (err) {
                                done(err);
                            }
                            _.each(objs, function(o) {
                                cars.push(o);
                            });
                            if (cars.length == 9) {
                                done();
                            }
                        });
                        var raw3 = [{
                            colour: 'red',
                            name: 'Ferarri',
                            id: 'remoteId7',
                            owner: 'personRemoteId'
                        }, {
                            colour: 'blue',
                            name: 'Volvo',
                            id: "remoteId8",
                            owner: 'personRemoteId'
                        }, {
                            colour: 'green',
                            name: 'Dodge',
                            id: "remoteId9",
                            owner: 'personRemoteId'
                        }];
                        carMapping._mapBulk(raw3, function(err, objs, res) {
                            if (err) {
                                done(err);
                            }
                            _.each(objs, function(o) {
                                cars.push(o);
                            });
                            if (cars.length == 9) {
                                done();
                            }
                        });

                    });
                });

                it('should have mapped onto Michael', function() {
                    assert.equal(cars.length, 9);
                    for (var i = 0; i < 8; i++) {
                        assert.equal(cars[i].owner, cars[i + 1].owner);
                    }
                });

            });

            describe('via nested remote id', function() {
                beforeEach(function(done) {
                    personMapping.map({
                        name: 'Michael Ford',
                        age: 23,
                        id: 'personRemoteId'
                    }, function(err) {
                        if (err) done(err);
                        var raw = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'remoteId1',
                            owner: {
                                id: 'personRemoteId'
                            }
                        }, {
                            colour: 'blue',
                            name: 'Lambo',
                            id: "remoteId2",
                            owner: {
                                id: 'personRemoteId'
                            }
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId3",
                            owner: {
                                id: 'personRemoteId'
                            }
                        }];
                        carMapping._mapBulk(raw, function(err, objs, res) {
                            if (err) {
                                done(err);
                            }
                            cars = objs;
                            done();
                        });

                    });
                });

                it('should have mapped onto Michael', function() {
                    assert.equal(cars.length, 3);
                    assert.equal(cars[0].owner, cars[1].owner);
                    assert.equal(cars[1].owner, cars[2].owner);
                });

            });

            describe('via nested remote id with unmergedChanges', function() {
                this.timeout(5000);
                beforeEach(function(done) {
                    personMapping.map({
                        name: 'Michael Ford',
                        age: 23,
                        id: 'personRemoteId'
                    }, function(err) {
                        if (err) done(err);
                        var raw = [{
                            colour: 'red',
                            name: 'Aston Martin',
                            id: 'remoteId1',
                            owner: {
                                id: 'personRemoteId'
                            }
                        }, {
                            colour: 'blue',
                            name: 'Lambo',
                            id: "remoteId2",
                            owner: {
                                id: 'personRemoteId',
                                name: 'Bob'
                            }
                        }, {
                            colour: 'green',
                            name: 'Ford',
                            id: "remoteId3",
                            owner: {
                                id: 'personRemoteId'
                            }
                        }];
                        carMapping._mapBulk(raw, function(err, objs, res) {
                            if (err) {
                                done(err);
                            }
                            cars = objs;
                            done();
                        });

                    });
                });

                it('should have mapped onto Michael', function() {
                    assert.equal(cars.length, 3);
                    assert.equal(cars[0].owner, cars[1].owner);
                    assert.equal(cars[1].owner, cars[2].owner);
                });
                it('should have changed the name', function() {
                    assert.equal(cars[0].owner.name, 'Bob');
                    assert.equal(cars[1].owner.name, 'Bob');
                    assert.equal(cars[2].owner.name, 'Bob');
                });

            })

        });


    });
});
},{"../../index":1,"../../src/cache":43,"../../src/collection":45,"../../src/object":53,"../../src/relationship":58,"../../vendor/operations.js/src/operation":108,"chai":9}],70:[function(require,module,exports){
var s = require('../../index')
    , assert = require('chai').assert;

describe('mapping!', function () {
    var Mapping = require('../../src/mapping').Mapping;

    beforeEach(function () {
        s.reset(true);
    });

    it('_fields', function () {
        var m = new Mapping({
            type: 'type',
            id: 'id',
            attributes: ['field1', 'field2']
        });
        assert.include(m._fields, 'id');
        assert.include(m._fields, 'field1');
        assert.include(m._fields, 'field2');
        assert.notInclude(m._fields, 'type');
    });

    it('attributes', function () {
        var m = new Mapping({
            type: 'type',
            id: 'id',
            attributes: ['field1', 'field2']
        });
        assert.include(m.attributes, 'field1');
        assert.include(m.attributes, 'field2');
    });

    it('type', function () {
        var m = new Mapping({
            type: 'type',
            id: 'id',
            attributes: ['field1', 'field2']
        });
        assert.equal(m.type, 'type');
    });

    it('id', function () {
        var m = new Mapping({
            type: 'type',
            id: 'id',
            attributes: ['field1', 'field2']
        });
        assert.equal(m.id, 'id');
    });




});
},{"../../index":1,"../../src/mapping":49,"chai":9}],71:[function(require,module,exports){
/*
 These tests deal with the creation of new SiestaModel objects.
 */

var s = require('../../index')
    , assert = require('chai').assert;

describe('mapping new object', function () {
    var Collection = require('../../src/collection').Collection;

    var RelationshipType = require('../../src/relationship').RelationshipType;
    var OneToManyProxy = require('../../src/oneToManyProxy').OneToManyProxy;
    var cache = require('../../src/cache');
    

    beforeEach(function () {
        s.reset(true);
    });

    describe('fields', function () {
        var collection, carMapping;

        beforeEach(function (done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(done);
        });

        it('valid', function () {
            var car = carMapping._new();
            _.each(carMapping._fields, function (f) {
                assert(car[f] !== undefined);
            });
        });

        describe('id field', function () {
            var car;
            beforeEach(function () {
                car = carMapping._new();
            });

            it('should be present', function () {
                assert.property(car, 'id');
            });

            describe('in cache', function () {
                beforeEach(function () {
                    cache.insert(car);
                    assert.equal(car, cache.get({_id: car._id}));
                    car.id = 'newRemoteId';
                });
                it('should update cache', function () {
                    assert.equal(car, cache.get({id: car.id, mapping: car.mapping}));
                });
                it('should remove previous', function () {
                    assert.equal(car, cache.get({id: car.id, mapping: car.mapping}));
                    car.id = 'brandNewRemoteId';
                    assert.equal(car, cache.get({id: car.id, mapping: car.mapping}));
                    assert.notOk(cache.get({id: 'newRemoteId', mapping: car.mapping}))
                });
                it('should remove all if set remoteid to null', function () {
                    assert.equal(car, cache.get({id: car.id, mapping: car.mapping}));
                    car.id = null;
                    assert.notOk(cache.get({id: 'newRemoteId', mapping: car.mapping}))
                })
            });
        });


    });

    describe('relationships', function () {
        var collection, carMapping, personMapping;

        function configureAPI(type, reverseName, done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        mapping: 'Person',
                        type: type,
                        reverse: reverseName
                    }
                }
            });
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['age', 'name']
            });
            collection.install(done);
        }

        beforeEach(function (done) {
            configureAPI(RelationshipType.OneToMany, 'cars', done);
        });

        describe('installation of proxies', function () {

            it('installs forward related object proxy', function () {
                var carObject = carMapping._new();
                assert.instanceOf(carObject.ownerProxy, OneToManyProxy);
            });

            it('installs reverse related object proxy', function () {
                var personObject = personMapping._new();
                assert.instanceOf(personObject.carsProxy, OneToManyProxy);
            });

        });

    });



});

},{"../../index":1,"../../src/cache":43,"../../src/collection":45,"../../src/oneToManyProxy":54,"../../src/relationship":58,"chai":9}],72:[function(require,module,exports){
var s = require('../../index'),
    assert = require('chai').assert;

describe('mapping queries', function() {

    var SiestaModel = require('../../src/object').SiestaModel;
    var Collection = require('../../src/collection').Collection;
    var RelationshipType = require('../../src/relationship').RelationshipType;
    var cache = require('../../src/cache');

    beforeEach(function() {
        s.reset(true);
    });

    describe('queries', function() {
        var collection, mapping;
        beforeEach(function(done) {
            collection = new Collection('myCollection');
            mapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['color', 'name']
            });
            collection.install(function(err) {
                if (err) done(err);
                mapping.map([{
                    id: 4,
                    color: 'red',
                    name: 'Aston Martin'
                }, {
                    id: 5,
                    color: 'blue',
                    name: 'Ford'
                }], done);
            });
        });

        it('all', function(done) {
            mapping.all(function(err, cars) {
                if (err) done(err);
                assert.equal(cars.length, 2);
                _.each(cars, function(car) {
                    assert.instanceOf(car, SiestaModel);
                });
                done();
            });
        });

        it('query', function(done) {
            this.timeout(10000);
            mapping.query({
                color: 'red'
            }, function(err, cars) {
                if (err) done(err);
                assert.equal(cars.length, 1);
                _.each(cars, function(car) {
                    assert.instanceOf(car, SiestaModel);
                });
                done();
            });
        });

        it('get', function(done) {
            mapping.get(4, function(err, car) {
                if (err) done(err);
                assert.ok(car);
                assert.instanceOf(car, SiestaModel);
                assert.equal(car.color, 'red');
                done();
            });
        });


    });

    describe('reverse', function() {
        var carMapping, personMapping;

        var collection;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        type: RelationshipType.OneToMany,
                        reverse: 'cars',
                        mapping: 'Person'
                    }
                }
            });
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            collection.install(done);
        });



        it('cached', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin',
                owner: {
                    name: 'Michael Ford',
                    age: 2,
                    id: '2'
                },
                id: 5
            }, function(err, car) {
                if (err) done(err);
                personMapping.get('2', function(err, p) {
                    if (err) done(err);
                    assert.ok(p, 'Should be able to fetch the person');
                    p.carsProxy.get(function(err, cars) {
                        assert.equal(cars.length, 1);
                        assert.equal(cars[0].owner, p);
                        done(err);
                    });
                });
            });
        });
    });


});
},{"../../index":1,"../../src/cache":43,"../../src/collection":45,"../../src/object":53,"../../src/relationship":58,"chai":9}],73:[function(require,module,exports){
var s = require('../../index')
    , assert = require('chai').assert;

describe('mapping validation', function () {
    var Mapping =  require('../../src/mapping').Mapping;

    beforeEach(function () {
        s.reset(true);
    });

    describe('validation', function () {
        it('no type', function () {
            var m = new Mapping({
                id: 'id',
                attributes: ['field1', 'field2'],
                collection: 'myCollection'
            });
            var errors = m._validate();
            assert.equal(1, errors.length);
        });
        it('no collection', function () {
            var m = new Mapping({
                id: 'id',
                attributes: ['field1', 'field2'],
                type: 'Car'
            });
            var errors = m._validate();
            assert.equal(1, errors.length);
        });
    });
});
},{"../../index":1,"../../src/mapping":49,"chai":9}],74:[function(require,module,exports){

var s = require('../index');

var assert = require('chai').assert;
var notificationCentre = require('../src/notificationCentre').notificationCentre;

describe('Notification Centre', function () {
    beforeEach(function () {
        s.reset(true);
    });

    describe('emissions', function () {
        it('simple emissions work', function (done) {
            notificationCentre.on('blah', function () {
                done();
            });
            notificationCentre.emit('blah');
        });

        it('emissions with payloads work', function (done) {
            var p = {};
            notificationCentre.on('blah', function (payload) {
                assert.equal(payload, p);
                done();
            });
            notificationCentre.emit('blah', p);
        });
    });





});
},{"../index":1,"../src/notificationCentre":52,"chai":9}],75:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('notifications', function() {

    var Collection = require('../src/collection').Collection,
        ChangeType = require('../src/changes').ChangeType,
        util = require('../src/util')
    notificationCentre = require('../src/notificationCentre').notificationCentre;

    beforeEach(function() {
        s.reset(true);
    });

    var car;
    var collection, carMapping;
    var car;

    var notif, collectionNotif, genericNotif, localIdNotif, remoteIdNotif;

    describe('attributes', function() {
        afterEach(function() {
            notif = null;
            collectionNotif = null;
            genericNotif = null;
            car = null;
            collection = null;
            carMapping = null;
        });

        describe('set value', function() {

            beforeEach(function(done) {
                collection = new Collection('myCollection');
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colour', 'name']
                });
                collection.install(function(err) {
                    if (err) done(err);
                    carMapping.map({
                        colour: 'red',
                        name: 'Aston Martin',
                        id: 'xyz'
                    }, function(err, _car) {
                        if (err) {
                            done(err);
                        } else {
                            car = _car;
                            function checkDone() {
                                if (notif && 
                                    genericNotif && 
                                    collectionNotif &&
                                    localIdNotif && 
                                    remoteIdNotif) {
                                    done();
                                }
                            }
                            s.once('myCollection:Car', function(n) {
                                notif = n;
                                checkDone();
                            });
                            s.once('myCollection', function(n) {
                                collectionNotif = n;
                                checkDone();
                            });
                            s.once('Siesta', function(n) {
                                genericNotif = n;
                                checkDone();
                            });  
                            s.once(_car._id, function (n) {
                                localIdNotif = n;
                                checkDone();
                            });
                            s.once('myCollection:Car:xyz', function (n) {
                                remoteIdNotif = n;
                                checkDone();
                            });
                            car.colour = 'blue';
                        }
                    });
                });

            });

            it('all notifs equal', function () {
                assert.equal(notif, genericNotif);
                assert.equal(genericNotif, collectionNotif);
                assert.equal(collectionNotif, localIdNotif);
                assert.equal(localIdNotif, remoteIdNotif);
            })

            it('notif contains collection', function() {
                assert.equal(notif.collection, 'myCollection');
            });

            it('notif contains mapping', function() {
                assert.equal(notif.mapping, 'Car');
            });

            it('changeDict contains attribute name', function() {
                assert.equal(notif.field, 'colour');
            });

            it('changeDict contains change type', function() {
                assert.equal(notif.type, ChangeType.Set);
            });

            it('changeDict contains old value', function() {
                assert.equal(notif.old, 'red');
            });

            it('changeDict contains new value', function() {
                assert.equal(notif.new, 'blue');
            });

            it('changeDict contains new value', function() {
                assert.equal(notif._id, car._id);
            });

        });

        describe('array notifications', function() {
            beforeEach(function(done) {
                collection = new Collection('myCollection');
                carMapping = collection.mapping('Car', {
                    id: 'id',
                    attributes: ['colours', 'name']
                });
                collection.install(done);
            });

            it('sends notifications for all levels', function(done) {
                var notifs = [];
                carMapping.map({
                    colours: ['red', 'blue'],
                    name: 'Aston Martin',
                    id: 'xyz'
                }, function(err, _car) {
                    car = _car;
                    if (err) done(err);
                    var listener = function(n) {
                        notifs.push(n);
                        if (notifs.length >= 5) {
                            done();
                        }
                    };
                    s.once('myCollection:Car', listener);
                    s.once('myCollection', listener);
                    s.once('Siesta', listener);
                    s.once(_car._id, listener);
                    s.once('myCollection:Car:xyz', listener);
                    car.colours.push('green');
                });
            });

            describe('push', function() {
                beforeEach(function(done) {
                    carMapping.map({
                        colours: ['red', 'blue'],
                        name: 'Aston Martin',
                        id: 'xyz'
                    }, function(err, _car) {
                        car = _car;
                        if (err) done(err);
                        s.once('myCollection:Car', function(n) {
                            notif = n;
                            done();
                        });
                        car.colours.push('green');

                    });
                });

                it('notif contains collection', function() {
                    assert.equal(notif.collection, 'myCollection');
                });

                it('notif contains mapping', function() {
                    assert.equal(notif.mapping, 'Car');
                });

                it('notif contains object', function() {
                    assert.equal(notif._id, car._id);
                });

                it('changeDict contains change', function() {
                    assert.equal(notif.field, 'colours');
                    assert.equal(notif.type, ChangeType.Splice);
                    assert.equal(notif.index, 2);
                    assert.equal(notif.removed.length, 0);
                    assert.equal(notif.added.length, 1);
                });

            });

            describe('pop', function() {
                beforeEach(function(done) {
                    carMapping.map({
                        colours: ['red', 'blue'],
                        name: 'Aston Martin',
                        id: 'xyz'
                    }, function(err, _car) {
                        car = _car;
                        if (err) done(err);
                        s.once('myCollection:Car', function(n) {
                            notif = n;
                            done();
                        });
                        car.colours.pop();
                    });
                });

                it('notif contains collection', function() {
                    assert.equal(notif.collection, 'myCollection');
                });

                it('notif contains mapping', function() {
                    assert.equal(notif.mapping, 'Car');
                });

                it('notif contains _id', function() {
                    assert.equal(notif._id, car._id);
                });

                it('notif contains change', function() {
                    assert.equal(notif.field, 'colours');
                    assert.equal(notif.type, ChangeType.Splice);
                    assert.equal(notif.index, 1);
                    assert.equal(notif.removed.length, 1);
                    assert.include(notif.removed, 'blue');
                    assert.equal(notif.added.length, 0);
                });
            });

            describe('shift', function() {
                beforeEach(function(done) {
                    carMapping.map({
                        colours: ['red', 'blue'],
                        name: 'Aston Martin',
                        id: 'xyz'
                    }, function(err, _car) {
                        car = _car;
                        if (err) done(err);
                        s.once('myCollection:Car', function(n) {
                            notif = n;
                            done();
                        });
                        car.colours.shift();
                    });
                });

                it('notif contains collection', function() {
                    assert.equal(notif.collection, 'myCollection');
                });

                it('notif contains mapping', function() {
                    assert.equal(notif.mapping, 'Car');
                });

                it('notif contains id', function() {
                    assert.equal(notif._id, car._id);
                });

                it('notif contains change', function() {
                    assert.equal(notif.field, 'colours');
                    assert.equal(notif.type, ChangeType.Splice);
                    assert.equal(notif.index, 0);
                    assert.equal(notif.removed.length, 1);
                    assert.include(notif.removed, 'red');
                    assert.equal(notif.added.length, 0);

                });


            });

            describe('unshift', function() {
                beforeEach(function(done) {
                    carMapping.map({
                        colours: ['red', 'blue'],
                        name: 'Aston Martin',
                        id: 'xyz'
                    }, function(err, _car) {
                        car = _car;

                        s.once('myCollection:Car', function(n) {
                            notif = n;
                            done();
                        });
                        car.colours.unshift('green');
                    });

                });

                it('notif contains type', function() {
                    assert.equal(notif.collection, 'myCollection');
                });

                it('notif contains mapping', function() {
                    assert.equal(notif.mapping, 'Car');
                });

                it('notif contains object', function() {
                    assert.equal(notif._id, car._id);
                });

                it('notif contains change', function() {
                    assert.equal(notif.field, 'colours');
                    assert.equal(notif.type, ChangeType.Splice);
                    assert.equal(notif.index, 0);
                    assert.equal(notif.removed.length, 0);
                    assert.equal(notif.added.length, 1);
                });

            });

            describe('sort', function() {
                var notifs = [];

                beforeEach(function(done) {
                    notifs = [];
                    carMapping.map({
                        colours: ['red', 'green', 'blue'],
                        name: 'Aston Martin',
                        id: 'xyz'
                    }, function(err, _car) {
                        car = _car;
                        if (err) done(err);
                        var listener = function(n) {
                            notifs.push(n);
                            if (notifs.length == 2) {
                                s.removeListener('myCollection:Car', listener);
                                done();
                            }
                        };
                        s.on('myCollection:Car', listener);
                        car.colours.sort();

                    });
                });

                it('notif contains colleciton', function() {
                    _.each(notifs, function(notif) {
                        assert.equal(notif.collection, 'myCollection');
                    });
                });

                it('notif contains mapping', function() {
                    _.each(notifs, function(notif) {
                        assert.equal(notif.mapping, 'Car');
                    });
                });

                it('notif contains object', function() {
                    _.each(notifs, function(notif) {
                        assert.equal(notif._id, car._id);
                    });
                });

                it('notif contains change', function() {
                    var removalNotif;
                    var addNotif;
                    _.each(notifs, function(notif) {
                        assert.equal(notif.field, 'colours');
                        assert.equal(notif.type, ChangeType.Splice);
                        if (notif.removed.length) {
                            removalNotif = notif;
                        } else if (notif.added) {
                            addNotif = notif;
                        }
                    });


                });
            });
        });

    });

    describe('relationships', function() {
        var collection;
        var car, person;
        var carMapping, personMapping;

        var Collection = require('../src/collection').Collection;


        beforeEach(function(done) {
            s.reset(true);
            done();
        });

        describe('array', function() {

            var personNotif, personGenericNotif, personCollectionNotif;
            var carNotif, carGenericNotif, carCollectionNotif;

            describe('foreign key', function() {
                beforeEach(function(done) {
                    collection = new Collection('myCollection');

                    carMapping = collection.mapping('Car', {
                        id: 'id',
                        attributes: ['colours', 'name'],
                        relationships: {
                            owner: {
                                mapping: 'Person',
                                type: RelationshipType.OneToMany,
                                reverse: 'cars'
                            }
                        }
                    });

                    personMapping = collection.mapping('Person', {
                        id: 'id',
                        attributes: ['name', 'age']
                    });

                    collection.install(done);
                });

                describe('push', function() {

                    var anotherCar;

                    beforeEach(function(done) {
                        car = carMapping._new();
                        anotherCar = carMapping._new();
                        person = personMapping._new();
                        person.cars = [car];
                        s.on('myCollection:Person', function(n) {
                            if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                personNotif = n;
                            }
                        });
                        s.on('myCollection', function(n) {
                            if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                personCollectionNotif = n;
                            }
                        });
                        s.on('Siesta', function(n) {
                            if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                personGenericNotif = n;
                            }
                        });
                        s.on('myCollection:Car', function(n) {
                            if (n.type == ChangeType.Set && n.mapping == 'Car') {
                                carNotif = n;
                            }
                        });
                        s.on('myCollection', function(n) {
                            if (n.type == ChangeType.Set && n.mapping == 'Car') {
                                carCollectionNotif = n;
                            }
                        });
                        s.on('Siesta', function(n) {
                            if (n.type == ChangeType.Set && n.mapping == 'Car') {
                                carGenericNotif = n;
                            }
                        });
                        person.cars.push(anotherCar);
                        util.next(function() {
                            notificationCentre.removeAllListeners();
                            done();
                        })
                    });

                    describe('person', function() {
                        it('type', function() {
                            assert.equal(personNotif.type, ChangeType.Splice);
                            assert.equal(personGenericNotif.type, ChangeType.Splice);
                            assert.equal(personCollectionNotif.type, ChangeType.Splice);
                        });

                        it('id', function() {
                            assert.include(personNotif.addedId, anotherCar._id);
                            assert.include(personGenericNotif.addedId, anotherCar._id);
                            assert.include(personCollectionNotif.addedId, anotherCar._id);
                        });

                        it('added', function() {
                            assert.include(personNotif.added, anotherCar);
                            assert.include(personGenericNotif.added, anotherCar);
                            assert.include(personCollectionNotif.added, anotherCar);
                        });
                    });

                    describe('car', function() {
                        it('type', function() {
                            assert.equal(carNotif.type, ChangeType.Set);
                            assert.equal(carGenericNotif.type, ChangeType.Set);
                            assert.equal(carCollectionNotif.type, ChangeType.Set);
                        });

                        it('id', function() {
                            assert.equal(carNotif.newId, person._id);
                            assert.equal(carGenericNotif.newId, person._id);
                            assert.equal(carCollectionNotif.newId, person._id);
                        });

                        it('new', function() {
                            assert.equal(carNotif.new, person);
                            assert.equal(carGenericNotif.new, person);
                            assert.equal(carCollectionNotif.new, person);
                        })
                    });
                });

                describe('splice', function(done) {

                    beforeEach(function(done) {
                        car = carMapping._new();
                        person = personMapping._new();
                        person.cars = [car];
                        s.on('myCollection:Person', function(n) {
                            if (n.type == ChangeType.Splice) {
                                personNotif = n;
                            }
                        });
                        s.on('myCollection', function(n) {
                            if (n.type == ChangeType.Splice) {
                                personCollectionNotif = n;
                            }
                        });
                        s.on('Siesta', function(n) {
                            if (n.type == ChangeType.Splice) {
                                personGenericNotif = n;
                            }
                        });
                        s.on('myCollection:Car', function(n) {
                            if (n.type == ChangeType.Set && n.mapping == 'Car') {
                                carNotif = n;
                            }
                        });
                        s.on('myCollection', function(n) {
                            if (n.type == ChangeType.Set && n.mapping == 'Car') {
                                carCollectionNotif = n;
                            }
                        });
                        s.on('Siesta', function(n) {
                            if (n.type == ChangeType.Set && n.mapping == 'Car') {
                                carGenericNotif = n;
                            }
                        });
                        person.cars.splice(0, 1);
                        util.next(function() {
                            notificationCentre.removeAllListeners();
                            done();
                        })
                    });

                    describe('person', function() {
                        it('type', function() {
                            assert.equal(personNotif.type, ChangeType.Splice);
                            assert.equal(personGenericNotif.type, ChangeType.Splice);
                            assert.equal(personCollectionNotif.type, ChangeType.Splice);
                        });

                        it('id', function() {
                            assert.include(personNotif.removedId, car._id);
                            assert.include(personGenericNotif.removedId, car._id);
                            assert.include(personCollectionNotif.removedId, car._id);
                        });

                        it('added', function() {
                            assert.include(personNotif.removed, car);
                            assert.include(personGenericNotif.removed, car);
                            assert.include(personCollectionNotif.removed, car);
                        });
                    });

                    describe('car', function() {
                        it('type', function() {
                            assert.equal(carNotif.type, ChangeType.Set);
                            assert.equal(carGenericNotif.type, ChangeType.Set);
                            assert.equal(carCollectionNotif.type, ChangeType.Set);
                        });

                        it('new id', function() {
                            assert.notOk(carNotif.newId)
                            assert.notOk(carGenericNotif.newId);
                            assert.notOk(carCollectionNotif.newId);
                        });

                        it('new', function() {
                            assert.notOk(carNotif.new);
                            assert.notOk(carGenericNotif.new);
                            assert.notOk(carCollectionNotif.new);
                        });

                        it('old', function() {
                            assert.equal(carNotif.old, person);
                            assert.equal(carGenericNotif.old, person);
                            assert.equal(carCollectionNotif.old, person);
                        });

                        it('old id', function() {
                            assert.equal(carNotif.oldId, person._id);
                            assert.equal(carGenericNotif.oldId, person._id);
                            assert.equal(carCollectionNotif.oldId, person._id);
                        });
                    });

                });

            });

            describe('many to many', function() {
                beforeEach(function(done) {
                    collection = new Collection('myCollection');

                    carMapping = collection.mapping('Car', {
                        id: 'id',
                        attributes: ['colours', 'name'],
                        relationships: {
                            owners: {
                                mapping: 'Person',
                                type: RelationshipType.ManyToMany,
                                reverse: 'cars'
                            }
                        }
                    });

                    personMapping = collection.mapping('Person', {
                        id: 'id',
                        attributes: ['name', 'age']
                    });

                    collection.install(done);
                });

                describe('no faults', function() {

                    var anotherCar;

                    describe('push', function(done) {
                        beforeEach(function(done) {
                            car = carMapping._new();
                            anotherCar = carMapping._new();
                            person = personMapping._new();
                            person.cars = [car];
                            s.on('myCollection:Person', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                    personNotif = n;
                                }
                            });
                            s.on('myCollection', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                    personCollectionNotif = n;
                                }
                            });
                            s.on('Siesta', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                    personGenericNotif = n;
                                }
                            });
                            s.on('myCollection:Car', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Car') {
                                    carNotif = n;
                                }
                            });
                            s.on('myCollection', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Car') {
                                    carCollectionNotif = n;
                                }
                            });
                            s.on('Siesta', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Car') {
                                    carGenericNotif = n;
                                }
                            });
                            person.cars.push(anotherCar);
                            util.next(function() {
                                notificationCentre.removeAllListeners();
                                done();
                            });
                        });

                        describe('person', function() {

                            it('type', function() {
                                assert.equal(personNotif.type, ChangeType.Splice);
                                assert.equal(personGenericNotif.type, ChangeType.Splice);
                                assert.equal(personCollectionNotif.type, ChangeType.Splice);
                            });

                            it('id', function() {
                                assert.include(personNotif.addedId, anotherCar._id);
                                assert.include(personGenericNotif.addedId, anotherCar._id);
                                assert.include(personCollectionNotif.addedId, anotherCar._id);
                            });

                            it('added', function() {
                                assert.include(personNotif.added, anotherCar);
                                assert.include(personGenericNotif.added, anotherCar);
                                assert.include(personCollectionNotif.added, anotherCar);
                            });
                        });

                        describe('car', function() {
                            it('type', function() {
                                assert.equal(carNotif.type, ChangeType.Splice);
                                assert.equal(carGenericNotif.type, ChangeType.Splice);
                                assert.equal(carCollectionNotif.type, ChangeType.Splice);
                            });

                            it('id', function() {
                                assert.include(carNotif.addedId, person._id);
                                assert.include(carGenericNotif.addedId, person._id);
                                assert.include(carCollectionNotif.addedId, person._id);
                            });

                            it('added', function() {
                                assert.include(carNotif.added, person);
                                assert.include(carGenericNotif.added, person);
                                assert.include(carCollectionNotif.added, person);
                            });
                        });




                    });

                    describe('splice', function() {
                        beforeEach(function(done) {
                            car = carMapping._new();
                            person = personMapping._new();
                            person.cars = [car];
                            s.on('myCollection:Person', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                    notif = n;
                                }
                            });
                            s.on('myCollection', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                    collectionNotif = n;
                                }
                            });
                            s.on('Siesta', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Person') {
                                    genericNotif = n;
                                }
                            });
                            s.on('myCollection:Car', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Car') {
                                    carNotif = n;
                                }
                            });
                            s.on('myCollection', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Car') {
                                    carCollectionNotif = n;
                                }
                            });
                            s.on('Siesta', function(n) {
                                if (n.type == ChangeType.Splice && n.mapping == 'Car') {
                                    carGenericNotif = n;
                                }
                            });
                            person.cars.splice(0, 1);
                            util.next(function() {
                                notificationCentre.removeAllListeners();
                                done();
                            })
                        });


                        it('type', function() {
                            assert.equal(notif.type, ChangeType.Splice);
                            assert.equal(genericNotif.type, ChangeType.Splice);
                            assert.equal(collectionNotif.type, ChangeType.Splice);
                            assert.equal(carNotif.type, ChangeType.Splice);
                            assert.equal(carGenericNotif.type, ChangeType.Splice);
                            assert.equal(carCollectionNotif.type, ChangeType.Splice);
                        });

                    });
                });

            });

        });

    });

    describe('new object', function() {

        beforeEach(function(done) {
            notif = null;
            genericNotif = null;
            collectionNotif = null;
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(function(err) {
                if (err) done(err);
                s.on('myCollection:Car', function(n) {
                    if (n.type == ChangeType.New) {
                        notif = n;
                    }
                });
                s.on('myCollection', function(n) {
                    if (n.type == ChangeType.New) {
                        collectionNotif = n;
                    }
                });
                s.on('Siesta', function(n) {
                    if (n.type == ChangeType.New) {
                        genericNotif = n;
                    }
                });
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    id: 'xyz'
                }, function(err, _car) {
                    if (err) {
                        done(err);
                    } else {
                        car = _car;
                        notificationCentre.removeAllListeners();
                        done();
                    }
                });
            });
        });

        it('is notif', function() {
            assert.ok(notif);
        });

        it('is genericNotif', function() {
            assert.ok(genericNotif);
        });

        it('is collectionNotif', function() {
            assert.ok(collectionNotif);
        });

        it('type is New', function() {
            assert.equal(notif.type, ChangeType.New);
            assert.equal(genericNotif.type, ChangeType.New);
            assert.equal(collectionNotif.type, ChangeType.New);
        });

        it('new', function() {
            assert.equal(notif.new, car);
            assert.equal(genericNotif.new, car);
            assert.equal(collectionNotif.new, car);
        });

        it('_id', function() {
            assert.equal(notif.newId, car._id);
            assert.equal(genericNotif.newId, car._id);
            assert.equal(collectionNotif.newId, car._id);
            assert.equal(notif._id, car._id);
            assert.equal(genericNotif._id, car._id);
            assert.equal(collectionNotif._id, car._id);
        });

    });

    describe('object removal', function() {

        beforeEach(function(done) {
            notif = null;
            genericNotif = null;
            collectionNotif = null;
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(function(err) {
                if (err) done(err);
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    id: 'xyz'
                }, function(err, _car) {
                    if (err) {
                        done(err);
                    } else {
                        car = _car;
                        s.on('myCollection:Car', function(n) {
                            if (n.type == ChangeType.Remove) {
                                notif = n;
                            }
                        });
                        s.on('myCollection', function(n) {
                            if (n.type == ChangeType.Remove) {
                                collectionNotif = n;
                            }
                        });
                        s.on('Siesta', function(n) {
                            if (n.type == ChangeType.Remove) {
                                genericNotif = n;
                            }
                        });
                        car.remove();
                        notificationCentre.removeAllListeners();
                        done();
                    }
                });
            });
        });

        it('is notif', function() {
            assert.ok(notif);
        });

        it('is genericNotif', function() {
            assert.ok(genericNotif);
        });

        it('is collectionNotif', function() {
            assert.ok(collectionNotif);
        });

        it('type is New', function() {
            assert.equal(notif.type, ChangeType.Remove);
            assert.equal(genericNotif.type, ChangeType.Remove);
            assert.equal(collectionNotif.type, ChangeType.Remove);
        });

        it('new', function() {
            assert.equal(notif.old, car);
            assert.equal(genericNotif.old, car);
            assert.equal(collectionNotif.old, car);
        });

        it('_id', function() {
            assert.equal(notif.oldId, car._id);
            assert.equal(genericNotif.oldId, car._id);
            assert.equal(collectionNotif.oldId, car._id);
            assert.equal(notif._id, car._id);
            assert.equal(genericNotif._id, car._id);
            assert.equal(collectionNotif._id, car._id);
        });

    });

    describe('object restoration', function() {
        beforeEach(function(done) {
            notif = null;
            genericNotif = null;
            collectionNotif = null;
            collection = new Collection('myCollection');
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name']
            });
            collection.install(function(err) {
                if (err) done(err);
                carMapping.map({
                    colour: 'red',
                    name: 'Aston Martin',
                    id: 'xyz'
                }, function(err, _car) {
                    if (err) {
                        done(err);
                    } else {
                        car = _car;
                        car.remove();
                        s.on('myCollection:Car', function(n) {
                            if (n.type == ChangeType.New) {
                                notif = n;
                            }
                        });
                        s.on('myCollection', function(n) {
                            if (n.type == ChangeType.New) {
                                collectionNotif = n;
                            }
                        });
                        s.on('Siesta', function(n) {
                            if (n.type == ChangeType.New) {
                                genericNotif = n;
                            }
                        });
                        car.restore();
                        notificationCentre.removeAllListeners();
                        done();
                    }
                });
            });
        });

        it('is notif', function() {
            assert.ok(notif);
        });

        it('is genericNotif', function() {
            assert.ok(genericNotif);
        });

        it('is collectionNotif', function() {
            assert.ok(collectionNotif);
        });

        it('type is New', function() {
            assert.equal(notif.type, ChangeType.New);
            assert.equal(genericNotif.type, ChangeType.New);
            assert.equal(collectionNotif.type, ChangeType.New);
        });

        it('new', function() {
            assert.equal(notif.new, car);
            assert.equal(genericNotif.new, car);
            assert.equal(collectionNotif.new, car);
        });

        it('_id', function() {
            assert.equal(notif.newId, car._id);
            assert.equal(genericNotif.newId, car._id);
            assert.equal(collectionNotif.newId, car._id);
            assert.equal(notif._id, car._id);
            assert.equal(genericNotif._id, car._id);
            assert.equal(collectionNotif._id, car._id);
        });
    });

});
},{"../index":1,"../src/changes":44,"../src/collection":45,"../src/notificationCentre":52,"../src/util":60,"chai":9}],76:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('object!!', function() {

    var SiestaModel = require('../src/object').SiestaModel;
    var Mapping = require('../src/mapping').Mapping;
    var cache = require('../src/cache');
    var Collection = require('../src/collection').Collection;

    var mapping, collection;

    beforeEach(function(done) {
        s.reset(true);
        collection = new Collection('myCollection');
        mapping = collection.mapping({
            name: 'Car',
            id: 'id',
            attributes: ['colour', 'name'],
            collection: 'myCollection'
        })
        collection.install(done);
    });

    describe('fields', function() {

        it('idField', function() {
            var r = new SiestaModel(mapping);
            assert.equal(r.idField, 'id');
        });

        it('type field', function() {
            var r = new SiestaModel(mapping);
            assert.equal(r.type, 'Car');
        });

        it('collection field', function() {
            var r = new SiestaModel(mapping);
            assert.equal(r.collection, 'myCollection');
        });

        it('type field', function() {
            var r = new SiestaModel(mapping);
            assert.notOk(r.isSaved);
        });

    });

    describe('removal', function() {

        var car;

        function remove() {
            car = new SiestaModel(mapping);
            car.colour = 'red';
            car.name = 'Aston Martin';
            car.id = '2';
            car._id = 'xyz';
            cache.insert(car);
            assert.notOk(car.removed);
            assert.ok(cache.contains(car));
            car.remove();
            assert.notOk(cache.contains(car));
            assert.ok(car.removed);
        }

        it('deletion', function() {
            remove();
        });

        it('restore', function() {
            remove();
            car.restore();
            assert.notOk(car.removed);
            assert.ok(cache.contains(car));
        });

    });

});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/mapping":49,"../src/object":53,"chai":9}],77:[function(require,module,exports){
var s = require('../index')
    , assert = require('chai').assert;

/**
 * Assertions against the observe-js library from polymer, modified to fit browserify.
 */

describe('observer', function () {

    var ArrayObserver = require('../vendor/observe-js/src/observe').ArrayObserver;

    it('indexes', function (done) {
        var arr = [1, 2, 3];
        var observer = new ArrayObserver(arr);
        observer.open(function (splices) {
            splices.forEach(function (splice) {
                try {
                    assert.include(splice.removed, 1);
                    assert.include(splice.removed, 2);
                    assert.equal(splice.addedCount, 2);
                    assert.equal(splice.index, 0);
                    done();
                }
                catch(err) {
                    done(err);
                }
            });
        });
        arr[0] = 4;
        arr[1] = 5;
    });

    it('push',function (done) {
        var arr = [1, 2, 3];
        var observer = new ArrayObserver(arr);
        observer.open(function (splices) {
            splices.forEach(function (splice) {
                try {
                    assert.equal(splice.removed.length, 0);
                    assert.equal(splice.index, 3);
                    assert.equal(splice.addedCount, 1);
                    done();
                }
                catch (err) {
                    done(err);
                }

            });
        });
        arr.push(6);
    });

    it('sort',function (done) {
        var arr = [2, 1, 3];
        var observer = new ArrayObserver(arr);
        observer.open(function (splices) {
            done();
        });
        arr.sort();
    });

});
},{"../index":1,"../vendor/observe-js/src/observe":106,"chai":9}],78:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('new object proxy', function() {

    var RelationshipProxy = require('../src/proxy').RelationshipProxy;
    var OneToOneProxy = require('../src/oneToOneProxy').OneToOneProxy;
    var OneToManyProxy = require('../src/oneToManyProxy').OneToManyProxy;
    var ManyToManyProxy = require('../src/manyToManyProxy').ManyToManyProxy;
    var SiestaModel = require('../src/object').SiestaModel;
    var Fault = require('../src/proxy').Fault;
    var InternalSiestaError = require('../src/error').InternalSiestaError;
    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');
    var ChangeType = require('../src/changes').ChangeType;

    var carMapping, personMapping;

    var collection;

    beforeEach(function(done) {
        s.reset(true);
        collection = new Collection('myCollection');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name']
        });
        personMapping = collection.mapping('Person', {
            id: 'id',
            attributes: ['name', 'age']
        });
        collection.install(done);
    });

    describe('generic', function() {
        describe('installation', function() {
            var car, person, relationship, proxy;

            beforeEach(function() {
                proxy = new RelationshipProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: true
                });
                car = new SiestaModel(carMapping);
                person = new SiestaModel(personMapping);
            });

            it('throws an error if try to install twice', function() {
                proxy.install(car);
                assert.throws(function() {
                    proxy.install(car);
                }, InternalSiestaError);
            });

            describe('forward installation', function() {
                beforeEach(function() {
                    proxy = new RelationshipProxy({
                        reverseMapping: personMapping,
                        forwardMapping: carMapping,
                        reverseName: 'cars',
                        forwardName: 'owner',
                        isForward: true
                    });
                    proxy.install(car);
                });

                it('installs setter', function() {
                    assert.ok(car['setOwner']);
                });
                it('installs getter', function() {
                    assert.ok(car['getOwner']);
                });

                describe('faults', function() {
                    it('is forward', function() {
                        assert.ok(proxy.isForward);
                    });

                    it('is not reverse', function() {
                        assert.notOk(proxy.isReverse);
                    });

                    describe('no relationship', function() {
                        it('is a fault object', function() {
                            assert.instanceOf(car.owner, Fault);
                        });

                        it('is faulted, as no relationship set', function() {
                            assert.ok(car.owner.isFault);
                        });
                    });

                    describe('relationship, faulted', function() {
                        beforeEach(function() {
                            proxy._id = 'xyz';
                        });

                        it('is a fault object', function() {
                            assert.instanceOf(car.owner, Fault);
                        });

                        it('is faulted, as _id exists, but no related object', function() {
                            assert.ok(car.owner.isFault);
                        });
                    });

                    describe('relationship, faulted', function() {
                        beforeEach(function() {
                            proxy._id = 'xyz';
                            proxy.related = new SiestaModel(personMapping);
                            proxy.related._id = 'xyz';
                        });

                        it('is a fault object', function() {
                            assert.equal(car.owner, proxy.related);
                        });

                        it('is not faulted, as relationship set and related assigned', function() {
                            assert.notOk(car.owner.isFault);
                        });
                    })
                });

            });

            describe('reverse installation', function() {
                beforeEach(function() {
                    proxy = new RelationshipProxy({
                        reverseMapping: personMapping,
                        forwardMapping: carMapping,
                        reverseName: 'cars',
                        forwardName: 'owner',
                        isForward: false
                    });
                    proxy.install(person);

                });

                describe('faults', function() {
                    it('is reerse', function() {
                        assert.ok(proxy.isReverse);
                    });

                    it('is not forward', function() {
                        assert.notOk(proxy.isForward);
                    });

                    describe('no relationship', function() {
                        it('is a fault object', function() {
                            assert.instanceOf(person.cars, Fault);
                        });

                        it('is faulted, as no relationship set', function() {
                            assert.ok(person.cars.isFault);
                        });
                    });

                    describe('relationship, faulted', function() {
                        beforeEach(function() {
                            proxy._id = ['xyz'];
                        });

                        it('is a fault object', function() {
                            assert.instanceOf(person.cars, Fault);
                        });

                        it('is faulted, as relationship set', function() {
                            assert.ok(person.cars.isFault);
                        });
                    });

                    describe('relationship, faulted', function() {
                        beforeEach(function() {
                            proxy._id = 'xyz';
                            proxy.related = [new SiestaModel(carMapping)];
                            proxy.related[0]._id = 'xyz';
                        });

                        it('is a fault object', function() {
                            assert.equal(person.cars[0], proxy.related[0]);
                        });

                        it('is not faulted, as relationship set and related assigned', function() {
                            assert.notOk(person.cars.isFault);
                        });
                    })
                });
            });
        });

        describe('subclass', function() {
            var car, person, proxy;

            beforeEach(function() {
                proxy = new RelationshipProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: true

                });
                car = new SiestaModel(carMapping);
                person = new SiestaModel(personMapping);
                proxy.install(car);
            });

            it('set should fail if not subclasses', function() {
                assert.throws(function() {
                    car.owner = person;
                }, InternalSiestaError);
                assert.throws(function() {
                    car.owner.set(person);
                }, InternalSiestaError);
            });

            it('get should fail if not subclasses', function() {
                assert.throws(function() {
                    car.owner.get(function() {

                    })
                }, InternalSiestaError);
            })
        })

    });

    describe('one-to-one', function() {
        var carProxy, personProxy;
        var car, person;

        describe('get', function() {
            beforeEach(function() {
                carProxy = new OneToOneProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: true
                });
                personProxy = new OneToOneProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: false
                });
                car = new SiestaModel(carMapping);
                car._id = 'car';
                carProxy.install(car);
                person = new SiestaModel(personMapping);
                person._id = 'person';
                personProxy.install(person);
                cache.insert(person);
                cache.insert(car);
            });

            it('forward', function(done) {
                carProxy._id = person._id;
                assert.ok(carProxy.isFault);
                carProxy.get(function(err, obj) {
                    if (err) done(err);
                    assert.equal(person, obj);
                    done();
                });
            });

            it('reverse', function(done) {
                personProxy._id = car._id;
                assert.ok(personProxy.isFault);
                personProxy.get(function(err, obj) {
                    if (err) done(err);
                    assert.equal(car, obj);
                    assert.equal(personProxy.related, car);
                    done();
                });
            });
        });

        describe('set', function() {
            var carProxy, personProxy;
            var car, person;
            beforeEach(function() {
                carProxy = new OneToOneProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: true
                });
                personProxy = new OneToOneProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: false
                });
                car = new SiestaModel(carMapping);
                car._id = 'car';
                carProxy.install(car);
                carProxy.isFault = false;
                person = new SiestaModel(personMapping);
                person._id = 'person';
                personProxy.install(person);
                personProxy.isFault = false;
            });

            describe('none pre-existing', function() {
                describe('forward', function() {
                    it('should set forward', function() {
                        car.owner = person;
                        assert.equal(car.owner, person);
                        assert.equal(carProxy._id, person._id);
                        assert.equal(carProxy.related, person);
                    });

                    it('should set reverse', function() {
                        car.owner = person;
                        assert.equal(person.cars, car);
                        assert.equal(personProxy._id, car._id);
                        assert.equal(personProxy.related, car);
                    });
                });

                describe('backwards', function() {
                    it('should set forward', function() {
                        person.cars = car;
                        assert.equal(person.cars, car);
                        assert.equal(personProxy._id, car._id);
                        assert.equal(personProxy.related, car);

                    });

                    it('should set reverse', function() {
                        person.cars = car;
                        assert.equal(car.owner, person);
                        assert.equal(carProxy._id, person._id);
                        assert.equal(carProxy.related, person);
                    });
                });


            });

            describe('pre-existing', function() {

                var anotherPerson, anotherPersonProxy;

                beforeEach(function() {
                    anotherPerson = new SiestaModel(personMapping);
                    anotherPerson._id = 'anotherPerson';
                    anotherPersonProxy = new OneToOneProxy({
                        reverseMapping: personMapping,
                        forwardMapping: carMapping,
                        reverseName: 'cars',
                        forwardName: 'owner',
                        isForward: false
                    });
                    anotherPersonProxy.install(anotherPerson);
                    anotherPersonProxy.isFault = false;
                    cache.insert(anotherPerson);
                    cache.insert(person);
                    cache.insert(car);
                });


                describe('no fault', function() {
                    beforeEach(function() {
                        car.owner = anotherPerson;
                    });
                    describe('forward', function() {
                        it('should set forward', function() {
                            car.owner = person;
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                        it('should set reverse', function() {
                            car.owner = person;
                            assert.equal(person.cars, car);
                            assert.equal(personProxy._id, car._id);
                            assert.equal(personProxy.related, car);
                        });

                        it('should clear the old', function() {
                            car.owner = person;
                            assert.notOk(anotherPersonProxy.isFault);
                            assert.notOk(anotherPersonProxy._id);
                            assert.notOk(anotherPersonProxy.related);
                        });
                    });
                    describe('backwards', function() {
                        it('should set forward', function() {
                            person.cars = car;
                            assert.equal(person.cars, car);
                            assert.equal(personProxy._id, car._id);
                            assert.equal(personProxy.related, car);

                        });

                        it('should set reverse', function() {
                            person.cars = car;
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                        it('should clear the old', function() {
                            person.cars = car;
                            assert.notOk(anotherPersonProxy._id);
                            assert.notOk(anotherPersonProxy.related);
                            assert.notOk(anotherPersonProxy.isFault);
                        });

                    });
                });

                describe('fault', function() {
                    beforeEach(function() {
                        car.owner = anotherPerson;
                        carProxy.related = undefined;
                        anotherPersonProxy.related = undefined;
                    });
                    describe('forward', function() {
                        it('should set forward', function() {
                            car.owner = person;
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                        it('should set reverse', function() {
                            car.owner = person;
                            assert.equal(person.cars, car);
                            assert.equal(personProxy._id, car._id);
                            assert.equal(personProxy.related, car);
                        });

                    });
                    describe('backwards', function() {
                        it('should set forward', function() {
                            person.cars = car;
                            assert.equal(person.cars, car);
                            assert.equal(personProxy._id, car._id);
                            assert.equal(personProxy.related, car);

                        });

                        it('should set reverse', function() {
                            person.cars = car;
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                    });
                });

            });
        })
    });

    describe('foreign key', function() {
        var carProxy, personProxy;
        var car, person;

        describe('get', function() {
            beforeEach(function() {
                carProxy = new OneToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: true
                });
                personProxy = new OneToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: false
                });
                car = new SiestaModel(carMapping);
                car._id = 'car';
                carProxy.install(car);
                person = new SiestaModel(personMapping);
                person._id = 'person';
                personProxy.install(person);
                cache.insert(person);
                cache.insert(car);
            });

            describe('get', function() {
                describe('no fault', function() {

                    beforeEach(function() {
                        carProxy.isFault = false;
                        personProxy.isFault = false;
                    });

                    it('forward', function(done) {
                        carProxy._id = person._id;
                        carProxy.related = person;
                        carProxy.get(function(err, obj) {
                            if (err) done(err);
                            assert.equal(person, obj);
                            done();
                        });
                    });

                    it('reverse', function(done) {
                        personProxy._id = [car._id];
                        personProxy.related = [car];
                        personProxy.get(function(err, cars) {
                            if (err) done(err);
                            assert.include(cars, car);
                            assert.include(personProxy.related, car);
                            done();
                        });
                    });
                });

                describe('fault', function() {
                    it('forward', function(done) {
                        carProxy._id = person._id;
                        carProxy.get(function(err, obj) {
                            if (err) done(err);
                            assert.equal(person, obj);
                            done();
                        });
                    });

                    it('reverse', function(done) {
                        personProxy._id = [car._id];
                        personProxy.get(function(err, cars) {
                            if (err) done(err);
                            assert.equal(cars.length, 1);
                            assert.include(cars, car);
                            assert.include(personProxy.related, car);
                            done();
                        });
                    });
                });

            });


        });

        describe('set', function() {
            var carProxy, personProxy;
            var car, person;
            beforeEach(function() {
                carProxy = new OneToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: true
                });
                personProxy = new OneToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owner',
                    isForward: false
                });
                car = new SiestaModel(carMapping);
                car._id = 'car';
                carProxy.install(car);
                carProxy.isFault = false;
                person = new SiestaModel(personMapping);
                person._id = 'person';
                personProxy.install(person);
                personProxy.isFault = false;
            });
            describe('none pre-existing', function() {

                describe('forward', function() {
                    it('should set forward', function() {
                        car.owner = person;
                        assert.equal(car.owner, person);
                        assert.equal(carProxy._id, person._id);
                        assert.equal(carProxy.related, person);
                    });

                    it('should set reverse', function() {
                        car.owner = person;
                        assert.include(person.cars, car);
                        assert.include(personProxy._id, car._id);
                        assert.include(personProxy.related, car);
                    });

                    it('multiple', function() {
                        car.owner = person;
                        var anotherCar = new SiestaModel(carMapping);
                        anotherCar._id = 'anotherCar';
                        var anotherCarProxy = new OneToManyProxy({
                            reverseMapping: personMapping,
                            forwardMapping: carMapping,
                            reverseName: 'cars',
                            forwardName: 'owner',
                            isForward: true
                        });
                        anotherCarProxy.install(anotherCar);
                        anotherCarProxy.isFault = false;
                        anotherCar.owner = person;
                        assert.include(person.cars, car);
                        assert.include(person.cars, anotherCar);
                        assert.equal(car.owner, person);
                        assert.equal(anotherCar.owner, person);
                    })
                });

                describe('backwards', function() {
                    it('should set forward', function() {
                        person.cars = [car];
                        assert.include(person.cars, car);
                        assert.include(personProxy._id, car._id);
                        assert.include(personProxy.related, car);

                    });

                    it('should set reverse', function() {
                        person.cars = [car];
                        assert.equal(car.owner, person);
                        assert.equal(carProxy._id, person._id);
                        assert.equal(carProxy.related, person);
                    });
                });
            });
            describe('pre-existing', function() {

                var anotherPerson, anotherPersonProxy;

                beforeEach(function() {
                    anotherPerson = new SiestaModel(personMapping);
                    anotherPerson._id = 'anotherPerson';
                    anotherPersonProxy = new OneToManyProxy({
                        reverseMapping: personMapping,
                        forwardMapping: carMapping,
                        reverseName: 'cars',
                        forwardName: 'owner',
                        isForward: false
                    });
                    anotherPersonProxy.install(anotherPerson);
                    anotherPersonProxy.isFault = false;
                    cache.insert(anotherPerson);
                    cache.insert(person);
                    cache.insert(car);
                });

                describe('no fault', function() {
                    beforeEach(function() {
                        car.owner = anotherPerson;
                    });
                    describe('forward', function() {
                        it('should set forward', function() {
                            car.owner = person;
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                        it('should set reverse', function() {
                            car.owner = person;
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                        it('should clear the old', function() {
                            car.owner = person;
                            assert.equal(anotherPersonProxy._id.length, 0);
                            assert.equal(anotherPersonProxy.related.length, 0);
                        });

                    });
                    describe('backwards', function() {
                        it('should set forward', function() {
                            person.cars = [car];
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                        it('should set reverse', function() {
                            person.cars = [car];
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                        it('should clear the old', function() {
                            person.cars = [car];
                            assert.equal(anotherPersonProxy._id.length, 0);
                            assert.equal(anotherPersonProxy.related.length, 0);
                        });

                    });
                });

                describe('fault', function() {
                    beforeEach(function() {
                        car.owner = anotherPerson;
                        carProxy.related = undefined;
                        anotherPersonProxy.related = undefined;
                    });
                    describe('forward', function() {
                        it('should set forward', function() {
                            car.owner = person;
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                        it('should set reverse', function() {
                            car.owner = person;
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                    });
                    describe('backwards', function() {
                        it('should set forward', function() {
                            person.cars = [car];
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                        it('should set reverse', function() {
                            person.cars = [car];
                            assert.equal(car.owner, person);
                            assert.equal(carProxy._id, person._id);
                            assert.equal(carProxy.related, person);
                        });

                    });
                });


            });
        });



    });

    describe('many to many', function() {
        var carProxy, personProxy;
        var car, person;

        describe('get', function() {
            beforeEach(function() {
                carProxy = new ManyToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owners',
                    isForward: true
                });
                personProxy = new ManyToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owners',
                    isReverse: true
                });
                car = new SiestaModel(carMapping);
                car._id = 'car';
                carProxy.install(car);
                person = new SiestaModel(personMapping);
                person._id = 'person';
                personProxy.install(person);
                cache.insert(person);
                cache.insert(car);
            });

            describe('no fault', function() {

                beforeEach(function() {
                    carProxy.isFault = false;
                    personProxy.isFault = false;
                });

                it('forward', function(done) {
                    carProxy._id = [person._id];
                    carProxy.related = [person];
                    carProxy.get(function(err, people) {
                        if (err) done(err);
                        assert.include(people, person);
                        assert.include(carProxy.related, person);
                        done();
                    });
                });

                it('reverse', function(done) {
                    personProxy._id = [car._id];
                    personProxy.related = [car];
                    personProxy.get(function(err, cars) {
                        if (err) done(err);
                        assert.include(cars, car);
                        assert.include(personProxy.related, car);
                        done();
                    });
                });
            });

            describe('fault', function() {
                it('forward', function(done) {
                    carProxy._id = [person._id];
                    carProxy.get(function(err, people) {
                        if (err) done(err);
                        assert.include(people, person);
                        assert.include(carProxy.related, person);
                        done();
                    });
                });

                it('reverse', function(done) {
                    personProxy._id = [car._id];
                    personProxy.get(function(err, cars) {
                        if (err) done(err);
                        assert.equal(cars.length, 1);
                        assert.include(cars, car);
                        assert.include(personProxy.related, car);
                        done();
                    });
                });
            });

        });

        describe('set', function() {
            var carProxy, personProxy;
            var car, person;
            beforeEach(function() {
                carProxy = new ManyToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owners', 
                    isForward: true
                });
                personProxy = new ManyToManyProxy({
                    reverseMapping: personMapping,
                    forwardMapping: carMapping,
                    reverseName: 'cars',
                    forwardName: 'owners',
                    isForward: false
                });
                car = new SiestaModel(carMapping);
                car._id = 'car';
                carProxy.install(car);
                carProxy.isFault = false;
                person = new SiestaModel(personMapping);
                person._id = 'person';
                personProxy.install(person);
                personProxy.isFault = false;
            });

            describe('none pre-existing', function() {

                describe('forward', function() {
                    it('should set forward', function() {
                        car.owners = [person];
                        assert.include(car.owners, person);
                        assert.include(carProxy._id, person._id);
                        assert.include(carProxy.related, person);
                    });

                    it('should set reverse', function() {
                        car.owners = [person];
                        assert.include(person.cars, car);
                        assert.include(personProxy._id, car._id);
                        assert.include(personProxy.related, car);
                    });
                });

                describe('backwards', function() {
                    it('should set forward', function() {
                        person.cars = [car];
                        assert.include(person.cars, car);
                        assert.include(personProxy._id, car._id);
                        assert.include(personProxy.related, car);

                    });

                    it('should set reverse', function() {
                        person.cars = [car];
                        assert.include(car.owners, person);
                        assert.include(carProxy._id, person._id);
                        assert.include(carProxy.related, person);
                    });
                });
            });


            describe('pre-existing', function() {

                var anotherPerson, anotherPersonProxy;

                beforeEach(function() {
                    anotherPerson = new SiestaModel(personMapping);
                    anotherPerson._id = 'anotherPerson';
                    anotherPersonProxy = new ManyToManyProxy({
                        reverseMapping: personMapping,
                        forwardMapping: carMapping,
                        reverseName: 'cars',
                        forwardName: 'owners',
                        isForward: false
                    });
                    anotherPersonProxy.install(anotherPerson);
                    anotherPersonProxy.isFault = false;
                    cache.insert(anotherPerson);
                    cache.insert(person);
                    cache.insert(car);
                });

                describe('no fault', function() {
                    beforeEach(function() {
                        car.owners = [anotherPerson];
                    });

                    describe('forward', function() {
                        it('should set forward', function() {
                            car.owners = [person];
                            assert.include(car.owners, person);
                            assert.include(carProxy._id, person._id);
                            assert.include(carProxy.related, person);
                        });

                        it('should set reverse', function() {
                            car.owners = [person];
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                        it('should clear the old', function() {
                            car.owners = [person];
                            assert.equal(anotherPersonProxy._id.length, 0);
                            assert.equal(anotherPersonProxy.related.length, 0);
                        });

                    });

                    describe('backwards', function() {
                        it('should set forward', function() {
                            person.cars = [car];
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                        it('should set reverse', function() {
                            person.cars = [car];
                            assert.include(car.owners, person);
                            assert.include(carProxy._id, person._id);
                            assert.include(carProxy.related, person);
                        });
                    });
                });

                describe('fault', function() {
                    beforeEach(function() {
                        car.owners = [anotherPerson];
                        carProxy.related = undefined;
                        anotherPersonProxy.related = undefined;
                    });
                    describe('forward', function() {
                        it('should set forward', function() {
                            car.owners = [person];
                            assert.include(car.owners, person);
                            assert.include(carProxy._id, person._id);
                            assert.include(carProxy.related, person);
                        });

                        it('should set reverse', function() {
                            car.owners = [person];
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                    });

                    describe('backwards', function() {
                        it('should set forward', function() {
                            person.cars = [car];
                            assert.include(person.cars, car);
                            assert.include(personProxy._id, car._id);
                            assert.include(personProxy.related, car);
                        });

                        it('should set reverse', function() {
                            person.cars = [car];
                            assert.include(carProxy._id, person._id);
                        });


                    });

                });



            });
        })


    });
});
},{"../index":1,"../src/cache":43,"../src/changes":44,"../src/collection":45,"../src/error":47,"../src/manyToManyProxy":48,"../src/object":53,"../src/oneToManyProxy":54,"../src/oneToOneProxy":55,"../src/proxy":56,"chai":9}],79:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('query', function() {
    var Query = require('../src/query').Query;
    var Collection = require('../src/collection').Collection;
    var SiestaModel = require('../src/object').SiestaModel;

    beforeEach(function() {
        s.reset(true);
    });

    describe('basic', function() {
        var collection, mapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            mapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            collection.install(done);
        });
        it('object exists', function(done) {
            mapping.map({
                name: 'Michael',
                age: 15
            }, function(err, obj) {
                if (err) done(err);
                else {
                    assert.ok(obj);
                    var q = new Query(mapping, {
                        age: 15
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 1);
                        assert.equal(objs[0], obj);
                        done();
                    });
                }
            });
        });

        it('object does not exist', function(done) {
            mapping.map({
                name: 'Michael',
                age: 21
            }, function(err, obj) {
                if (err) done(err);
                else {
                    assert.ok(obj);
                    var q = new Query(mapping, {
                        age: 15
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 0);
                        done();
                    });
                }
            });
        });

        it('multiple matches', function(done) {
            mapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(mapping, {
                        age: 21
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[0]);
                        assert.include(objs, mapped[1]);
                        done();
                    });
                }
            });
        });
    });

    describe('e', function() {
        var collection, personMapping, carMapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        type: 'OneToMany',
                        mapping: 'Person',
                        reverse: 'cars'
                    }
                }
            });
            collection.install(done);
        });

        describe('attributes', function() {
            it('matches', function(done) {
                personMapping.map([{
                    name: 'Michael',
                    age: 21
                }, {
                    name: 'Bob',
                    age: 21
                }], function(err, mapped) {
                    if (err) done(err);
                    else {
                        assert.ok(mapped);
                        var q = new Query(personMapping, {
                            age__e: 21
                        });
                        q.execute(function(err, objs) {
                            if (err) done(err);
                            assert.equal(objs.length, 2);
                            assert.include(objs, mapped[0]);
                            assert.include(objs, mapped[1]);
                            done();
                        });
                    }
                });
            });

            it('no matches', function(done) {
                personMapping.map([{
                    name: 'Michael',
                    age: 21
                }, {
                    name: 'Bob',
                    age: 21
                }], function(err, mapped) {
                    if (err) done(err);
                    else {
                        assert.ok(mapped);
                        var q = new Query(personMapping, {
                            age__e: 23
                        });
                        q.execute(function(err, objs) {
                            if (err) done(err);
                            assert.notOk(objs.length);
                            done();
                        });
                    }
                });
            });
        });

        describe('relationships', function() {
            it('model', function(done) {
                personMapping.map({
                    name: 'Michael',
                    age: 21
                }, function(err, person) {
                    if (err) done(err);
                    carMapping.map({
                        colour: 'red',
                        name: 'Aston Martin',
                        owner: person
                    }, function(err, car) {
                        if (err) done(err);
                        else {
                            var q = new Query(carMapping, {
                                owner__e: person
                            });
                            q.execute(function(err, objs) {
                                if (err) done(err);
                                assert.ok(objs.length);
                                done();
                            });
                        }
                    });
                });
            });
        });
    });

    describe('lt', function() {
        var collection, personMapping, carMapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            collection.install(done);
        });

        it('matches all', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__lt: 22
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[0]);
                        assert.include(objs, mapped[1]);
                        done();
                    });
                }
            });
        });

        it('matches some', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 22
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__lt: 22
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 1);
                        assert.include(objs, mapped[0]);
                        done();
                    });
                }
            });
        });

        it('no matches', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__lt: 21
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.notOk(objs.length);
                        done();
                    });
                }
            });
        });
    });

    describe('lte', function() {
        var collection, personMapping, carMapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            collection.install(done);
        });

        it('matches all', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__lte: 21
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[0]);
                        assert.include(objs, mapped[1]);
                        done();
                    });
                }
            });
        });

        it('matches some', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 22
            }, {
                name: 'John',
                age: 23
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__lte: 22
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[0]);
                        assert.include(objs, mapped[1]);
                        done();
                    });
                }
            });
        });

        it('no matches', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__lte: 20
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.notOk(objs.length);
                        done();
                    });
                }
            });
        });
    });

    describe('gt', function() {
        var collection, personMapping, carMapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            collection.install(done);
        });

        it('matches all', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__gt: 20
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[0]);
                        assert.include(objs, mapped[1]);
                        done();
                    });
                }
            });
        });

        it('matches some', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 22
            }, {
                name: 'John',
                age: 23
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__gt: 21
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[1]);
                        assert.include(objs, mapped[2]);
                        done();
                    });
                }
            });
        });

        it('no matches', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__gt: 21
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.notOk(objs.length);
                        done();
                    });
                }
            });
        });
    });

    describe('gte', function() {
        var collection, personMapping, carMapping;

        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            collection.install(done);
        });

        it('matches all', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__gte: 21
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[0]);
                        assert.include(objs, mapped[1]);
                        done();
                    });
                }
            });
        });

        it('matches some', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 22
            }, {
                name: 'John',
                age: 23
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__gte: 22
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.equal(objs.length, 2);
                        assert.include(objs, mapped[1]);
                        assert.include(objs, mapped[2]);
                        done();
                    });
                }
            });
        });

        it('no matches', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__gte: 22
                    });
                    q.execute(function(err, objs) {
                        if (err) done(err);
                        assert.notOk(objs.length);
                        done();
                    });
                }
            });
        });
    });



    describe('errors', function() {
        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        type: 'OneToMany',
                        mapping: 'Person',
                        reverse: 'cars'
                    }
                }
            });
            collection.install(done);
        });

        it('invalid op', function(done) {
            personMapping.map([{
                name: 'Michael',
                age: 21
            }, {
                name: 'Bob',
                age: 21
            }], function(err, mapped) {
                if (err) done(err);
                else {
                    assert.ok(mapped);
                    var q = new Query(personMapping, {
                        age__dfsoigsd: 21
                    });
                    q.execute(function(err, objs) {
                        assert.ok(err);
                        assert.notOk(objs);
                        done();
                    });
                }
            });
        })
    });





});
},{"../index":1,"../src/collection":45,"../src/object":53,"../src/query":57,"chai":9}],80:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('recursive relationships', function() {

    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');
    var collection;
    var Repo;

    beforeEach(function(done) {
        s.reset(true);
        collection = new Collection('MyCollection');
        collection.baseURL = 'https://api.github.com';
        Repo = collection.mapping('Repo', {
            id: 'id',
            attributes: ['name'],
            relationships: {
                forkedFrom: {
                    mapping: 'Repo',
                    type: 'OneToMany',
                    reverse: 'forks'
                }
            }
        });
        collection.install(done);
    });

    it('map', function (done) {
    	var masterRepoData = {id: '5', name: 'Master Repo'};
    	Repo.map(masterRepoData, function (err, repo) {
    		if (err) {
    			done(err);
    		}
    		else {
    			var childRepoData = {id: '6', name: 'Child Repo', forkedFrom: {_id: repo._id}};
    			Repo.map(childRepoData, function (err, childRepo) {
    				if (err) {
    					done(err);
    				}
    				else {
    					assert.include(repo.forks, childRepo);
    					assert.equal(childRepo.forkedFrom, repo);
    					done();
    				}
    			});
    		}
    	});
    });

});
},{"../index":1,"../src/cache":43,"../src/collection":45,"chai":9}],81:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('mapping relationships', function() {


    var Collection = require('../src/collection').Collection;
    var InternalSiestaError = require('../src/error').InternalSiestaError;
    var RelationshipType = require('../src/relationship').RelationshipType;


    beforeEach(function() {
        s.reset(true);
    });

    var collection, carMapping, personMapping;

    function configureAPI(type, done) {
        collection = new Collection('myCollection');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            relationships: {
                owner: {
                    mapping: 'Person',
                    type: type,
                    reverse: 'cars'
                }
            }
        });
        personMapping = collection.mapping('Person', {
            id: 'id',
            attributes: ['name', 'age']
        });
        collection.install(done);
    }

    describe('valid', function() {


        describe('Foreign Key', function() {

            beforeEach(function(done) {
                configureAPI(RelationshipType.OneToMany, function(err) {
                    if (err) done(err);
                    done();
                });
            });

            it('configures reverse mapping', function() {
                assert.equal(carMapping.relationships.owner.reverseMapping, personMapping);
            });

            it('configures reverse name', function() {
                assert.equal(carMapping.relationships.owner.reverseName, 'cars');

                it('configures forward mapping', function() {
                    assert.equal(carMapping.relationships.owner.forwardMapping, carMapping);
                });

            });
            it('configures forward name', function() {
                assert.equal(carMapping.relationships.owner.forwardName, 'owner');
            });

            it('installs on reverse', function() {
                var keys = Object.keys(personMapping.relationships.cars);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key != 'isForward' && key != 'isReverse') {
                        assert.equal(personMapping.relationships.cars[key], carMapping.relationships.owner[key]);
                    }
                }
            });


        });

        describe('OneToOne', function() {

            beforeEach(function(done) {
                configureAPI(RelationshipType.OneToOne, function(err) {
                    if (err) done(err);
                    done();
                });


            });
            it('configures reverse mapping', function() {
                assert.equal(carMapping.relationships.owner.reverseMapping, personMapping);
            });

            it('configures reverse name', function() {
                assert.equal(carMapping.relationships.owner.reverseName, 'cars');



            });

            it('configures forward mapping', function() {
                assert.equal(carMapping.relationships.owner.forwardMapping, carMapping);
            });
            it('configures forward name', function() {
                assert.equal(carMapping.relationships.owner.forwardName, 'owner');
            });

            it('installs on reverse', function() {
                var keys = Object.keys(personMapping.relationships.cars);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key != 'isForward' && key != 'isReverse') {
                        assert.equal(personMapping.relationships.cars[key], carMapping.relationships.owner[key]);
                    }
                }
            });





        });

    });



    describe('invalid', function() {
        it('No such mapping', function(done) {
            var collection = new Collection('myCollection');
            collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        mapping: 'asd',
                        type: RelationshipType.OneToMany,
                        reverse: 'cars'
                    }
                }
            });
            collection.install(function(err) {
                assert.ok(err);
                done();
            });
        });

        it('No such relationship type', function(done) {
            var collection = new Collection('myCollection');
            collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        mapping: 'Person',

                        type: 'invalidtype',
                        reverse: 'cars'
                    }
                }
            });
            collection.mapping('Person', {
                id: 'id',
                attributes: ['name', 'age']
            });

            collection.install(function(err) {
                assert.ok(err);
                done();
            });

        });
    });


});
},{"../index":1,"../src/collection":45,"../src/error":47,"../src/relationship":58,"chai":9}],82:[function(require,module,exports){
var s = require('../index')
    , assert = require('chai').assert;


describe('rest', function () {
    var Collection = require('../src/collection').Collection;
    var CollectionRegistry = require('../src/collectionRegistry').CollectionRegistry;
    var collection;


    beforeEach(function () {
        s.reset(true);
    });

    describe('Create Basic Rest API', function () {

        beforeEach(function (done) {
            collection = new Collection('myCollection');
            collection.install(done);
        });

        it('global access', function () {
            assert.equal(CollectionRegistry.myCollection, collection);
        });

    });

    describe('Object mapping registration', function () {

        var collection;
        describe('basic', function () {

            beforeEach(function (done) {
                collection = new Collection('myCollection');
                collection.mapping('Person', {
                    id: 'id',
                    attributes: ['name', 'age']
                });
                collection.install(done);
            });

            describe('raw mapping to Mapping object', function () {
                function assertMapping(collection) {
                    var rawMapping = collection._rawMappings.Person;
                    assert.ok(rawMapping);
                    var mappingObj = collection.Person;
                    assert.equal(mappingObj.type, 'Person');
                    assert.equal(mappingObj.id, 'id');
                    assert.equal(mappingObj.collection, 'myCollection');
                    assert.include(mappingObj._fields, 'name');
                    assert.include(mappingObj._fields, 'age');
                    assert.ok(mappingObj);
                }

                it('mappings', function () {
                    assertMapping(collection);
                });
            });

        });


    })

});
},{"../index":1,"../src/collection":45,"../src/collectionRegistry":46,"chai":9}],83:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('serialisers', function() {

    var Collection = require('../src/collection').Collection;
    var RelationshipType = require('../src/relationship').RelationshipType;

    var collection, carMapping, personMapping, vitalSignsMapping;


    beforeEach(function() {
        s.reset(true);
    });

    describe('id serialiser', function() {
        beforeEach(function(done) {
            collection = new Collection('myCollection');
            personMapping = collection.mapping('Person', {
                attributes: ['name', 'age']
            });
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        mapping: 'Person',
                        type: RelationshipType.OneToMany,
                        reverse: 'cars'
                    }
                }
            });
            collection.install(done);
        });
        it('should return the id if has one', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin',
                id: 5
            }, function(err, car) {
                if (err) done(err);
                assert.equal(siesta.ext.http.Serialiser.idSerialiser(car), car.id);
                done();
            });
        });
        it('should return null if doesnt have an id', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin'
            }, function(err, car) {
                if (err) done(err);
                assert.equal(siesta.ext.http.Serialiser.idSerialiser(car), null);
                done();
            });
        });
        it('should return null if no id field', function(done) {
            personMapping.map({
                name: 'Michael Ford',
                id: 5
            }, function(err, car) {
                if (err) done(err);
                assert.equal(siesta.ext.http.Serialiser.idSerialiser(car), null);
                done();
            });
        });
    });

    describe('depth serialiser', function() {
        beforeEach(function(done) {
            collection = new Collection('myCollection');

            personMapping = collection.mapping('Person', {
                attributes: ['name', 'age'],
                id: 'id',
                relationships: {
                    vitalSigns: {
                        mapping: 'VitalSigns',
                        type: RelationshipType.OneToOne,
                        reverse: 'person'
                    }
                }
            });
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                relationships: {
                    owner: {
                        mapping: 'Person',
                        type: RelationshipType.OneToMany,
                        reverse: 'cars'
                    }
                }
            });
            vitalSignsMapping = collection.mapping('VitalSigns', {
                id: 'id',
                attributes: ['heartRate', 'bloodPressure']
            });
            collection.install(done);

        });

        it('depth 0', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin',
                id: 5,
                owner: {
                    name: 'Michael Ford',
                    id: 28
                }
            }, function(err, car) {
                if (err) done(err);
                siesta.ext.http.Serialiser.depthSerializer(0)(car, function(err, data) {
                    if (err) done(err);
                    assert.equal(data.colour, car.colour);
                    assert.equal(data.name, car.name);
                    assert.equal(data.id, car.id);
                    assert.equal(data.owner, 28);
                    done();
                });
            });
        });

        it('depth 1', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin',
                id: 5,
                owner: {
                    name: 'Michael Ford',
                    id: 28,
                    vitalSigns: {
                        id: 35,
                        heartRate: 65
                    }
                }
            }, function(err, car) {
                if (err) done(err);
                siesta.ext.http.Serialiser.depthSerializer(1)(car, function(err, data) {
                    if (err) done(err);
                    assert.equal(data.colour, car.colour);
                    assert.equal(data.name, car.name);
                    assert.equal(data.id, car.id);
                    assert.equal(data.owner.id, 28);
                    assert.equal(data.owner.vitalSigns, 35);
                    done();
                });
            });
        });

        it('depth 2', function(done) {
            carMapping.map({
                colour: 'red',
                name: 'Aston Martin',
                id: 5,
                owner: {
                    name: 'Michael Ford',
                    id: 28,
                    vitalSigns: {
                        id: 35,
                        heartRate: 65
                    }
                }
            }, function(err, car) {
                if (err) done(err);
                siesta.ext.http.Serialiser.depthSerializer(2)(car, function(err, data) {
                    if (err) done(err);
                    assert.equal(data.colour, car.colour);
                    assert.equal(data.name, car.name);
                    assert.equal(data.id, car.id);
                    assert.equal(data.owner.id, 28);
                    assert.equal(data.owner.vitalSigns.heartRate, 65);
                    done();
                });
            });
        });

    });

    describe('availibility on siesta', function() {
        it('id, anglophone', function () {
            assert.equal(s.serialisers.id, siesta.ext.http.Serialiser.idSerialiser);
        });

        it('root, anglophone', function () {
            assert.equal(s.serialisers.depth, siesta.ext.http.Serialiser.depthSerializer);
        });
        it('id, american', function () {
            assert.equal(s.serializers.id, siesta.ext.http.Serialiser.idSerialiser);
        });

        it('root, american', function () {
            assert.equal(s.serializers.depth, siesta.ext.http.Serialiser.depthSerializer);
        });
    });


});
},{"../index":1,"../src/collection":45,"../src/relationship":58,"chai":9}],84:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('singleton mapping', function() {

    var SiestaModel = require('../src/object').SiestaModel;
    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');
    var store = require('../src/store');

    var collection, carMapping;

    function CarObject() {
        SiestaModel.apply(this, arguments);
    }

    CarObject.prototype = Object.create(SiestaModel.prototype);

    beforeEach(function(done) {
        s.reset(true);
        collection = new Collection('Car');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            singleton: true
        });
        collection.install(done);
    });

    it('should map onto the same singleton object, even if a different identifier', function(done) {
        carMapping.map({
            colour: 'red',
            id: 5
        }, function(err, car) {
            if (err) done(err);
            carMapping.map({
                colour: 'blue',
                id: 10
            }, function(err, car2) {
                if (err) done(err);
                assert.equal(car, car2);
                assert.equal(car.colour, 'blue');
                assert.equal(car.id, 10);
                done();
            });
        });
    });

    it('should map onto the same singleton object', function(done) {
        carMapping.map({
            colour: 'red'
        }, function(err, car) {
            if (err) done(err);
            carMapping.map({
                colour: 'blue'
            }, function(err, car2) {
                if (err) done(err);
                assert.equal(car, car2);
                assert.equal(car.colour, 'blue');
                done();
            });
        });
    });



    it('cache should return singleton', function(done) {
        carMapping.map({
            colour: 'red',
            id: 5
        }, function(err, car) {
            if (err) done(err);
            var obj = cache.get({
                mapping: carMapping
            });
            assert.equal(obj, car);
            done();
        });
    });

    it('get should simply return the car', function(done) {
        this.timeout(5000);
        carMapping.map({
            colour: 'red',
            id: 5
        }, function(err, car) {
            if (err) done(err);
            carMapping.get(function(err, _car) {
                if (err) done(err);
                assert.equal(car, _car);
                done();
            });
        });
    });

});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/object":53,"../src/store":59,"chai":9}],85:[function(require,module,exports){
var siesta = require('../index');
var assert = require('chai').assert;

describe('statistics', function() {
    var Car, Person, coll;

    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');

    beforeEach(function(done) {
        siesta.reset(true);
        coll = new Collection('myCollection');
        Car = coll.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            relationships: {
                owner: {
                    mapping: 'Person',
                    type: 'OneToMany',
                    reverse: 'cars'
                }
            }
        });
        Person = coll.mapping('Person', {
            id: 'id',
            attributes: ['age', 'name']
        });
        coll.install(done);
    });

    before(function() {
        siesta.ext.storageEnabled = false;
    });
    after(function() {
        siesta.ext.storageEnabled = true;
    });
    describe('collection level', function() {
        describe('single mapping', function() {
            it('no objects', function(done) {
                coll.count(function(err, n) {
                    if (err) done(err);
                    assert.equal(n, 0);
                    done();
                });
            });

            it('one object', function(done) {
                Car.map({
                    colour: 'red',
                    name: 'Aston Martin'
                }, function(err, obj) {
                    if (err) done(err);
                    coll.count(function(err, n) {
                        if (err) done(err);
                        assert.equal(n, 1);
                        done();
                    });
                });
            });

            it('multiple objects', function(done) {
                Car.map([{
                    colour: 'red',
                    name: 'Aston Martin'
                }, {
                    colour: 'blue',
                    name: 'Bentley'
                }, {
                    colour: 'green',
                    name: 'Lambo'
                }], function(err) {
                    if (err) done(err);
                    coll.count(function(err, n) {
                        if (err) done(err);
                        assert.equal(n, 3);
                        done();
                    });
                });
            });
        });
        describe('multiple mappings', function() {
            it('multiple objects', function(done) {
                Car.map([{
                    colour: 'red',
                    name: 'Aston Martin'
                }, {
                    colour: 'blue',
                    name: 'Bentley'
                }, {
                    colour: 'green',
                    name: 'Lambo'
                }], function(err) {
                    if (err) done(err);
                    Person.map([{
                        age: 24,
                        name: 'Michael Ford'
                    }, {
                        age: 25,
                        name: 'John Doe'
                    }], function(err) {
                        if (err) done(err);
                        coll.count(function(err, n) {
                            if (err) done(err);
                            assert.equal(n, 5);
                            done();
                        });
                    });
                });
            });
        });
    });


});
},{"../index":1,"../src/cache":43,"../src/collection":45,"chai":9}],86:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;

// describe('generation of changes during array operations', function () {

//     var collection;
//     var car, person;
//     var carMapping, personMapping;

//     var Collection = require('../src/collection').Collection;
    
//     var ChangeType = require('../src/changes').ChangeType;
//     var RelationshipType = require('../src/relationship').RelationshipType;
//     var util = require('../src/util');

//     beforeEach(function (done) {
//         s.reset(true);
//         done();
//     });

//     describe('against attributes', function () {

//         beforeEach(function (done) {
//             collection = new Collection('myCollection');

//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['colours', 'name']
//             });

//             personMapping = collection.mapping('Person', {
//                 id: 'id',
//                 attributes: ['name', 'age']
//             });

//             collection.install(done);
//         });

//         it('push', function (done) {
//             car = carMapping._new();
//             car.colours = [];
//             s.ext.storage.changes.resetChanges();
//             car.colours.push('red');
//             util.next(function () {
//                 assert.equal(1, s.ext.storage.changes.allChanges.length);
//                 var change = s.ext.storage.changes.allChanges[0];
//                 assert.equal(change.type, ChangeType.Splice);
//                 assert.include(change.added, 'red');
//                 assert.equal(change.index, 0);
//                 assert.equal(change.field, 'colours');
//                 done();
//             });
//         });

//         it('splice', function (done) {
//             car = carMapping._new();
//             car.colours = ['red'];
//             s.ext.storage.changes.resetChanges();
//             car.colours.splice(0, 1);
//             util.next(function () {
//                 assert.equal(1, s.ext.storage.changes.allChanges.length);
//                 var change = s.ext.storage.changes.allChanges[0];
//                 assert.equal(change.type, ChangeType.Splice);
//                 assert.include(change.removed, 'red');
//                 assert.equal(change.index, 0);
//                 assert.equal(change.field, 'colours');
//                 done();
//             });
//         });

//         it('sort', function (done) {
//             car = carMapping._new();
//             car.colours = ['red', 'blue', 'green'];
//             s.ext.storage.changes.resetChanges();
//             car.colours.sort();
//             // Red is removed and inserted elsewhere.
//             util.next(function () {
//                 assert.equal(2, s.ext.storage.changes.allChanges.length);
//                 done();
//             });
//         });

//     });

//     describe('against relationships', function () {

//         describe('foreign key', function () {

//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');

//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colours', 'name'],
//                     relationships: {
//                         owner: {
//                             mapping: 'Person',
//                             type: RelationshipType.OneToMany,
//                             reverse: 'cars'
//                         }
//                     }
//                 });

//                 personMapping = collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['name', 'age']
//                 });

//                 collection.install(done);
//             });

//             it('push', function (done) {
//                 car = carMapping._new();
//                 var anotherCar = carMapping._new();
//                 person = personMapping._new();
//                 person.cars = [car];
//                 s.ext.storage.changes.resetChanges();
//                 person.cars.push(anotherCar);
//                 util.next(function () {
//                     assert.equal(car.owner, person);
//                     assert.equal(anotherCar.owner, person);
//                     var allChanges = s.ext.storage.changes.allChanges;
//                     assert.equal(allChanges.length, 2);
//                     var splicePredicate = function (x) {return x.type === ChangeType.Splice};
//                     var spliceChange = _.find(allChanges, splicePredicate);
//                     assert.equal(spliceChange.type, ChangeType.Splice);
//                     assert.include(spliceChange.added, anotherCar);
//                     assert.equal(spliceChange.index, 1);
//                     assert.equal(spliceChange.field, 'cars');
//                     done();
//                 });
//             });
//             it('splice', function (done) {
//                 car = carMapping._new();
//                 person = personMapping._new();
//                 person.cars = [car];
//                 s.ext.storage.changes.resetChanges();
//                 person.cars.splice(0, 1);
//                 util.next(function () {
//                     assert.notOk(car.ownerProxy._id);
//                     assert.notOk(car.ownerProxy.related);
//                     var allChanges = s.ext.storage.changes.allChanges;
//                     assert.equal(allChanges.length, 2);
//                     var splicePredicate = function (x) {return x.type === ChangeType.Splice};
//                     var spliceChange = _.find(allChanges, splicePredicate);
//                     assert.include(spliceChange.removed, car);
//                     assert.equal(spliceChange.type, ChangeType.Splice);
//                     done();
//                 });
//             });

//         });

//         describe('many to many', function () {
//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');

//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colours', 'name'],
//                     relationships: {
//                         owners: {
//                             mapping: 'Person',
//                             type: RelationshipType.ManyToMany,
//                             reverse: 'cars'
//                         }
//                     }
//                 });

//                 personMapping = collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['name', 'age']
//                 });

//                 collection.install(done);
//             });

//             describe('no faults', function () {
//                 it('push', function (done) {
//                     car = carMapping._new();
//                     var anotherCar = carMapping._new();
//                     person = personMapping._new();
//                     person.cars = [car];
//                     s.ext.storage.changes.resetChanges();
//                     person.cars.push(anotherCar);
//                     util.next(function () {
//                         assert.include(car.owners, person, 'original car should have owner');
//                         assert.include(anotherCar.owners, person, 'new car should have owner');
//                         var allChanges = s.ext.storage.changes.allChanges;
//                         assert.equal(allChanges.length, 2);
//                         var splicePredicate = function (x) {return x._id === person._id};
//                         var spliceChange = _.find(allChanges, splicePredicate);
//                         assert.equal(spliceChange.type, ChangeType.Splice);
//                         assert.include(spliceChange.added, anotherCar);
//                         assert.equal(spliceChange.index, 1);
//                         assert.equal(spliceChange.field, 'cars');
//                         done();
//                     });
//                 });

//                 it('splice', function (done) {
//                     car = carMapping._new();
//                     person = personMapping._new();
//                     person.cars = [car];
//                     s.ext.storage.changes.resetChanges();
//                     person.cars.splice(0, 1);
//                     util.next(function () {
//                         var allChanges = s.ext.storage.changes.allChanges;
//                         assert.equal(allChanges.length, 2);
//                         var personPred = function (x) {return x._id === person._id};
//                         var personChange = _.find(allChanges, personPred);
//                         var carPred = function (x) {return x._id === car._id};
//                         var carChange = _.find(allChanges, carPred);
//                         assert.include(personChange.removed, car);
//                         assert.notOk(car.ownersProxy._id.length);
//                         assert.notOk(car.ownersProxy.related.length);
//                         assert.equal(personChange.type, ChangeType.Splice);
//                         done();
//                     });
//                 });
//             });

//             describe('fault in the reverse', function () {
//                 it('push', function (done) {
//                     car = carMapping._new();
//                     var anotherCar = carMapping._new();
//                     person = personMapping._new();
//                     person.cars = [car];
//                     s.ext.storage.changes.resetChanges();
//                     car.ownersProxy.related = null;
//                     person.cars.push(anotherCar);
//                     util.next(function () {
//                         var allChanges = s.ext.storage.changes.allChanges;
//                         assert.equal(allChanges.length, 2);
//                         var splicePredicate = function (x) {return x._id === person._id};
//                         var spliceChange = _.find(allChanges, splicePredicate);
//                         assert.equal(spliceChange.type, ChangeType.Splice);
//                         assert.include(spliceChange.addedId, anotherCar._id);
//                         assert.equal(spliceChange.index, 1);
//                         assert.equal(spliceChange.field, 'cars');
//                         done();
//                     });
//                 });

//                 it('splice', function (done) {
//                     car = carMapping._new();
//                     person = personMapping._new();
//                     person.cars = [car];
//                     s.ext.storage.changes.resetChanges();
//                     car.ownersProxy.related = null;
//                     person.cars.splice(0, 1);
//                     util.next(function () {
//                         var allChanges = s.ext.storage.changes.allChanges;
//                         assert.equal(allChanges.length, 2);
//                         var personPred = function (x) {return x._id === person._id};
//                         var personChange = _.find(allChanges, personPred);
//                         var carPred = function (x) {return x._id === car._id};
//                         var carChange = _.find(allChanges, carPred);
//                         assert.include(personChange.removed, car);
//                         assert.notOk(car.ownersProxy._id.length);
//                         assert.equal(personChange.type, ChangeType.Splice);
//                         done();
//                     });
//                 });
//             });




//         });

//     });
// });
},{}],87:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;

// describe('attribute s.ext.storage.changes', function () {

//     var Collection = require('../src/collection').Collection
//         , ChangeType = require('../src/changes').ChangeType;

//     beforeEach(function () {
//         s.reset(true);
//     });

//     describe('attributes', function () {
//         var collection, carMapping;
//         var car;

//         var notif, collectionNotif, genericNotif;

//         afterEach(function () {
//             notif = null;
//             collectionNotif = null;
//             genericNotif = null;
//             car = null;
//             collection = null;
//             carMapping = null;
//         });

//         describe('set', function () {

//             beforeEach(function (done) {

//                 collection = new Collection('myCollection');
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colour', 'name']
//                 });
//                 collection.install(done);

//             });

//             it('no previous value', function () {
//                 var model = carMapping._new();
//                 model.colour = 'red';
//                 var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                 assert.equal(cs.length, 1);
//                 var c = cs[0];
//                 assert.equal(c.type, ChangeType.Set);
//                 assert.equal(c.new, 'red');
//                 assert.equal(c._id, model._id);
//                 assert.equal(c.collection, 'myCollection');
//                 assert.equal(c.mapping, 'Car');
//                 assert.equal(c.field, 'colour');
//                 assert.notOk(c.old);
//             });

//             it('has previous value', function () {
//                 var model = carMapping._new();
//                 model.__values.colour = 'blue';
//                 model.colour = 'red';
//                 var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                 assert.equal(cs.length, 1);
//                 var c = cs[0];
//                 assert.equal(c.type, ChangeType.Set);
//                 assert.equal(c.new, 'red');
//                 assert.equal(c.old, 'blue');
//                 assert.equal(c._id, model._id);
//                 assert.equal(c.collection, 'myCollection');
//                 assert.equal(c.mapping, 'Car');
//                 assert.equal(c.field, 'colour');
//             });

//             it('remote id', function () {
//                 var model = carMapping._new();
//                 model.id = 'xyz';
//                 var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                 assert.equal(cs.length, 1);
//                 var c = cs[0];
//                 assert.equal(c.type, ChangeType.Set);
//                 assert.equal(c.new, 'xyz');
//                 assert.notOk(c.old);
//                 assert.equal(c._id, model._id);
//                 assert.equal(c.collection, 'myCollection');
//                 assert.equal(c.mapping, 'Car');
//                 assert.equal(c.field, 'id');
//             });

//         });

//         describe('array', function () {
//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colours', 'name']
//                 });
//                 collection.install(done);
//             });

//             describe('set', function () {
//                 it('no previous value', function () {
//                     var model = carMapping._new();
//                     model.colours = ['green', 'blue'];
//                     var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                     assert.equal(cs.length, 1);
//                     var c = cs[0];
//                     assert.equal(c.type, ChangeType.Set);
//                     assert.equal(c.new, model.colours);
//                     assert.notOk(c.old);
//                     assert.equal(c._id, model._id);
//                     assert.equal(c.collection, 'myCollection');
//                     assert.equal(c.mapping, 'Car');
//                     assert.equal(c.field, 'colours');
//                 });

//                 it('has previous value', function () {
//                     var model = carMapping._new();
//                     var oldColours = ['purple', 'red'];
//                     model.__values.colours = oldColours;
//                     model.colours = ['green', 'blue'];
//                     var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                     assert.equal(cs.length, 1);
//                     var c = cs[0];
//                     assert.equal(c.type, ChangeType.Set);
//                     assert.equal(c.new, model.colours);
//                     assert.equal(c.old, oldColours);
//                     assert.equal(c._id, model._id);
//                     assert.equal(c.collection, 'myCollection');
//                     assert.equal(c.mapping, 'Car');
//                     assert.equal(c.field, 'colours');
//                 });
//             });

//             it('push', function (done) {
//                 var model = carMapping._new();
//                 model.colours = [];
//                 s.ext.storage.changes.resetChanges();
//                 model.colours.push('red');
//                 setTimeout(function () {
//                     var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                     assert.equal(cs.length, 1);
//                     var c = cs[0];
//                     assert.equal(c.type, ChangeType.Splice);
//                     assert.equal(c.index, 0);
//                     assert.equal(c.removed.length, 0);
//                     assert.equal(c.added.length, 1);
//                     assert.equal(c.added[0], 'red');
//                     assert.equal(c._id, model._id);
//                     assert.equal(c.collection, 'myCollection');
//                     assert.equal(c.mapping, 'Car');
//                     assert.equal(c.field, 'colours');
//                     done();
//                 });
//             });

//             it('index', function (done) {
//                 var model = carMapping._new();
//                 model.colours = ['blue', 'green', 'purple'];
//                 s.ext.storage.changes.resetChanges();
//                 model.colours[1] = 'red';
//                 setTimeout(function () {
//                     var cs = s.ext.storage.changes.changesForIdentifier(model._id);
//                     assert.equal(cs.length, 1);
//                     var c = cs[0];
//                     assert.equal(c.type, ChangeType.Splice);
//                     assert.equal(c.index, 1);
//                     assert.equal(c.removed.length, 1);
//                     assert.equal(c.removed[0], 'green');
//                     assert.equal(c.added.length, 1);
//                     assert.equal(c.added[0], 'red');
//                     assert.equal(c._id, model._id);
//                     assert.equal(c.collection, 'myCollection');
//                     assert.equal(c.mapping, 'Car');
//                     assert.equal(c.field, 'colours');
//                     done();
//                 });
//             });

//         });

//     });

// });
},{}],88:[function(require,module,exports){
// var chai = require('chai');
// var s = require('../index')
//     , assert = chai.assert;

// var mappingOperation = require('../src/mappingOperation');
// var BulkMappingOperation = mappingOperation.BulkMappingOperation;
// var util = require('../src/util');
// var RelationshipType = require('../src/relationship').RelationshipType;
// var Collection = require('../src/collection').Collection;
// var cache = require('../src/cache');
// var collection;
// var Repo, User;


// describe('bulk mapping operation', function () {
//     describe('general', function () {
//         beforeEach(function (done) {
//             s.reset(true);
//             collection = new Collection('MyCollection');
//             collection.baseURL = 'https://api.github.com';
//             Repo = collection.mapping('Repo', {
//                 id: 'id',
//                 attributes: ['name', 'full_name', 'description'],
//                 relationships: {
//                     owner: {
//                         mapping: 'User',
//                         type: RelationshipType.OneToMany,
//                         reverse: 'repositories'
//                     }
//                 }
//             });
//             User = collection.mapping('User', {
//                 id: 'id',
//                 attributes: ['login']
//             });
//             collection.install(done);
//         });


//         describe('new', function () {

//             describe('foreign key', function () {
//                 describe('reverse', function () {
//                     it('existing', function (done) {
//                         s.ext.storage.Pouch.getPouch().post({
//                             id: '5',
//                             name: 'Old Name',
//                             full_name: 'Old Full Name',
//                             collection: 'MyCollection',
//                             type: 'Repo'
//                         }, function (err, resp) {
//                             if (err) {
//                                 done(err);
//                             }
//                             else {
//                                 var data = [
//                                     {
//                                         login: 'mike',
//                                         id: '123',
//                                         repositories: [
//                                             {id: '5', name: 'Repo', full_name: 'A Big Repo'}
//                                         ]
//                                     }
//                                 ];
//                                 var op = new BulkMappingOperation({mapping: User, data: data});
//                                 op.onCompletion(function () {
//                                     if (op.error) {
//                                         done(op.error);
//                                     }
//                                     else {
//                                         var objects = op.result;
//                                         try {
//                                             assert.equal(objects.length, 1);
//                                             var obj = objects[0];
//                                             assert.equal(obj.login, 'mike');
//                                             assert.equal(obj.id, '123');
//                                             assert.equal(obj.repositories.length, 1);
//                                             var repo = obj.repositories[0];
//                                             assert.equal(repo.id, 5);
//                                             assert.equal(repo.name, 'Repo');
//                                             assert.equal(repo.full_name, 'A Big Repo');
//                                             assert.equal(repo._id, resp.id);
//                                             assert.equal(repo.owner, obj);
//                                             done();
//                                         }
//                                         catch (err) {
//                                             done(err);
//                                         }
//                                     }

//                                 });
//                                 op.start();
//                             }

//                         })
//                     })
//                 });
//             });
//         });
//     });

//     describe('singleton...', function () {
//         var op;

//         beforeEach(function (done) {
//             s.reset(true);

//             collection = new Collection('MyCollection');
//             collection.baseURL = 'https://api.github.com';
//             Repo = collection.mapping('Repo', {
//                 id: 'id',
//                 attributes: ['name', 'full_name', 'description'],
//                 relationships: {
//                     owner: {
//                         mapping: 'User',
//                         type: RelationshipType.OneToMany,
//                         reverse: 'repositories'
//                     }
//                 }
//             });
//             User = collection.mapping('User', {
//                 id: 'id',
//                 attributes: ['login'],
//                 singleton: true
//             });
//             collection.install(done);
//         });

//         describe('existing, faulted', function () {

//             beforeEach(function (done) {
//                 var doc = {id: '567', _id: 'localId', type: 'User', collection: 'MyCollection'};
//                 s.ext.storage.Pouch.getPouch().put(doc, function (err, resp) {
//                     if (err) done(err);
//                     doc._rev = resp.rev;
//                     var data = [
//                         {login: 'mike', id: '123'},
//                         {login: 'bob', id: '1234'}
//                     ];
//                     op = new BulkMappingOperation({mapping: User, data: data});
//                     done();
//                 });
//             });

//             it('lookupSingleton', function (done) {
//                 op._lookupSingleton(function (err) {
//                     if (!err) {
//                         assert.equal(op.objects.length, 2);
//                         assert.equal(op.objects[0]._id, 'localId');
//                         assert.equal(op.objects[0], op.objects[1]);
//                     }
//                     done(err);
//                 });
//             });

//             it('map', function (done) {
//                 op.onCompletion(function () {
//                     var err = op.error;
//                     if (!err) {
//                         assert.equal(op.objects.length, 2);
//                         assert.equal(op.objects[0]._id, 'localId');
//                         assert.equal(op.objects[0], op.objects[1]);
//                         assert.equal(op.objects[0].login, 'bob');
//                         assert.equal(op.objects[0].id, '1234');
//                     }
//                     done(err);
//                 });
//                 op.start();
//             });
//         });
//     });
// });
},{}],89:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('./util').assert;

// describe('changes!', function () {

//     var ChangeType = require('../src/changes').ChangeType;
//     var RelationshipType = require('../src/relationship').RelationshipType;

//     var InternalSiestaError = require('../src/error').InternalSiestaError;

//     var Collection = require('../src/collection').Collection;

//     var cache = require('../src/cache');

//     var coreChanges = require('../src/changes');

//     var Change = coreChanges.Change;
//     var util = require('../src/util');

//     var collection, carMapping;

//     beforeEach(function () {
//         s.reset(true);
//     });

//     describe('registering changes', function () {
//         beforeEach(function (done) {
//             collection = new Collection('myCollection');
//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['colour', 'name']
//             });
//             collection.install(done);
//         });

//         it('registers a change', function () {
//             coreChanges.registerChange({
//                 collection: collection,
//                 mapping: carMapping,
//                 _id: 'xyz'
//             });
//             var objChanges = s.ext.storage.changes.changes[collection.name][carMapping.type]['xyz'];
//             assert.equal(objChanges.length, 1);
//             var change = objChanges[0];
//             assert.equal(change.collection, collection);
//             assert.equal(change.mapping, carMapping);
//             assert.equal(change._id, 'xyz');
//         });

//         describe('errors', function () {
//             it('should throw an error if no mapping', function () {
//                 assert.throws(
//                     function () {
//                         coreChanges.registerChange({
//                             collection: collection,
//                             _id: 'xyz'
//                         })
//                     }, InternalSiestaError
//                 );
//             });

//             it('should throw an error if no collection', function () {
//                 assert.throws(
//                     function () {
//                         coreChanges.registerChange({
//                             mapping: carMapping,
//                             _id: 'xyz'
//                         })
//                     }, InternalSiestaError
//                 );
//             });

//             it('should throw an error if no _id', function () {
//                 assert.throws(
//                     function () {
//                         coreChanges.registerChange({
//                             mapping: carMapping,
//                             collection: collection
//                         })
//                     }, InternalSiestaError
//                 );
//             })
//         });
//     });

//     describe('all s.ext.storage.changes', function () {
//         beforeEach(function (done) {
//             collection = new Collection('myCollection');
//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['colour', 'name']
//             });
//             collection.install(done);
//         });

//         it('all s.ext.storage.changes', function () {
//             s.ext.storage.changes.changes = {
//                 collection: {
//                     mapping1: {
//                         xyz: ['adsd', 'asdas']
//                     },
//                     mapping2: {
//                         xyz1: ['dsasda', 'fh43']
//                     }
//                 },
//                 anotherCollection: {
//                     anotherMapping: {
//                         obj1: ['asd'],
//                         obj2: ['123', '567']
//                     }
//                 }
//             };

//             assert.equal(s.ext.storage.changes.allChanges.length, 7);
//             assert.include(s.ext.storage.changes.allChanges, 'adsd');
//             assert.include(s.ext.storage.changes.allChanges, 'asdas');
//             assert.include(s.ext.storage.changes.allChanges, 'dsasda');
//             assert.include(s.ext.storage.changes.allChanges, 'fh43');
//             assert.include(s.ext.storage.changes.allChanges, 'asd');
//             assert.include(s.ext.storage.changes.allChanges, '123');
//             assert.include(s.ext.storage.changes.allChanges, '567');
//         });
//     });

//     describe('applying changes', function () {

//         describe('set', function () {
//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colour', 'name']
//                 });
//                 collection.install(done);
//             });

//             it('set', function () {
//                 var obj = carMapping._new({colour: 'red', name: 'Aston Martin'});
//                 var c = new Change();
//                 c.collection = collection._name;
//                 c.mapping = carMapping.type;
//                 c.field = 'colour';
//                 c.type = ChangeType.Set;
//                 c.new = 'blue';
//                 c.old = 'red';
//                 c._id = obj._id;
//                 c.apply(obj);
//                 assert.equal(obj.colour, 'blue');
//             });

//             describe('errors', function () {


//                 it('incorrect _id', function () {
//                     var obj = carMapping._new({colour: 'red', name: 'Aston Martin'});
//                     var c = new Change();
//                     c.collection = collection._name;
//                     c.mapping = carMapping.type;
//                     c.field = 'colour';
//                     c.type = ChangeType.Set;
//                     c.new = 'blue';
//                     c.old = 'red';
//                     c._id = 'randomid';
//                     assert.throws(function () {
//                         c.apply(obj);
//                     }, InternalSiestaError);
//                 });
//                 it('old does not match current', function () {
//                     var obj = carMapping._new({colour: 'red', name: 'Aston Martin'});
//                     var c = new Change();
//                     c.collection = collection._name;
//                     c.mapping = carMapping.type;
//                     c.field = 'colour';
//                     c.type = ChangeType.Set;
//                     c.new = 'blue';
//                     c.old = 'purple';
//                     c._id = obj._id;
//                     assert.throws(function () {
//                         c.apply(obj);
//                     }, InternalSiestaError);
//                 });
//             })
//         });
//         describe('splice', function () {

//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colours', 'name']
//                 });
//                 collection.install(done);
//             });

//             it('works', function () {
//                 var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                 var c = new Change();
//                 c.collection = collection;
//                 c.mapping = carMapping;
//                 c.field = 'colours';
//                 c.type = ChangeType.Splice;
//                 c.index = 1;
//                 c.added = ['green'];
//                 c.removed = ['blue'];
//                 c._id = obj._id;
//                 c.apply(obj);
//                 assert.equal(obj.colours.length, 2);
//                 assert.equal(obj.colours[0], 'red');
//                 assert.equal(obj.colours[1], 'green');
//             });

//             describe('errors', function () {
//                 it('no remove or added', function () {
//                     var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                     var c = new Change();
//                     c.collection = collection;
//                     c.mapping = carMapping;
//                     c.field = 'colours';
//                     c.type = ChangeType.Splice;
//                     c.index = 2;
//                     c._id = obj._id;
//                     assert.throws(function () {
//                         c.apply(obj);
//                     }, InternalSiestaError);
//                 });
//                 it('no index', function () {
//                     var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                     var c = new Change();
//                     c.collection = collection;
//                     c.mapping = carMapping;
//                     c.field = 'colours';
//                     c.type = ChangeType.Splice;
//                     c.added = ['green'];
//                     c.removedCount = 1;
//                     c._id = obj._id;
//                     assert.throws(function () {
//                         c.apply(obj);
//                     }, InternalSiestaError);
//                 });
//                 it('removed doesnt match', function () {
//                     var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                     var c = new Change();
//                     c.collection = collection;
//                     c.mapping = carMapping;
//                     c.field = 'colours';
//                     c.type = ChangeType.Splice;
//                     c.index = 1;
//                     c.added = ['green'];
//                     c.removed = ['purple'];
//                     c._id = obj._id;
//                     assert.throws(function () {
//                         c.apply(obj);
//                     }, InternalSiestaError);
//                 });
//             });
//         });
//         describe('remove', function () {
//             it('works', function () {
//                 var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                 var c = new Change();
//                 c.collection = collection;
//                 c.mapping = carMapping;
//                 c.field = 'colours';
//                 c.type = ChangeType.Delete;
//                 c.removed = ['red'];
//                 c._id = obj._id;
//                 c.apply(obj);
//                 assert.equal(obj.colours.length, 1);
//                 assert.equal(obj.colours[0], 'blue');
//             });
//             describe('errors', function () {
//                 it('no removed', function () {
//                     var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                     var c = new Change();
//                     c.collection = collection;
//                     c.mapping = carMapping;
//                     c.field = 'colours';
//                     c.type = ChangeType.Delete;
//                     c._id = obj._id;
//                     assert.throws(function () {
//                         c.apply(obj);
//                     }, InternalSiestaError);
//                 });

//             });
//         })

//     });

//     describe('merge changes', function () {
//         function testMerge(changes, docs, callback) {
//             var db = s.ext.storage.Pouch.getPouch();
//             db.bulkDocs(docs, function (err) {
//                 if (err) {
//                     callback(err);
//                 }
//                 else {
//                     s.ext.storage.changes.changes = changes;
//                     s.ext.storage.changes.mergeChanges(function (err) {
//                         if (err) {
//                             callback(err);
//                         }
//                         else {
//                             db.allDocs({keys: _.pluck(docs, '_id'), include_docs: true}, function (err, resp) {
//                                 if (err) {
//                                     callback(err);
//                                 }
//                                 else {
//                                     callback(null, _.pluck(resp.rows, 'doc'));
//                                 }
//                             })
//                         }
//                     });
//                 }
//             });
//         }

//         describe('set', function () {


//             describe('attribute', function () {
//                 beforeEach(function (done) {
//                     collection = new Collection('myCollection');
//                     carMapping = collection.mapping('Car', {
//                         id: 'id',
//                         attributes: ['colour', 'name']
//                     });
//                     collection.install(done);
//                 });
//                 it('set attribute', function (done) {
//                     var changes = {
//                         myCollection: {
//                             Car: {
//                                 localId: [
//                                     new Change({
//                                         collection: collection._name,
//                                         mapping: carMapping.type,
//                                         field: 'colour',
//                                         type: ChangeType.Set,
//                                         new: 'blue',
//                                         old: 'red',
//                                         _id: 'localId'
//                                     })
//                                 ]
//                             }
//                         }
//                     };

//                     var docs = [
//                         {
//                             _id: 'localId',
//                             name: 'Aston Martin',
//                             colour: 'red',
//                             collection: 'myCollection',
//                             type: 'Car'
//                         }
//                     ];

//                     testMerge(changes, docs, function (err, docs) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var doc = docs[0];
//                             assert.equal(doc.colour, 'blue');
//                             assert.notOk(s.ext.storage.changes.allChanges.length);
//                             done();
//                         }
//                     });
//                 });

//             });

//             describe('relationship', function () {
//                 var personMapping;
//                 describe('foreign key', function () {
//                     beforeEach(function (done) {
//                         collection = new Collection('myCollection');
//                         carMapping = collection.mapping('Car', {
//                             id: 'id',
//                             attributes: ['colour', 'name'],
//                             relationships: {
//                                 owner: {
//                                     type: RelationshipType.OneToMany,
//                                     reverse: 'cars',
//                                     mapping: 'Person'
//                                 }
//                             }
//                         });
//                         personMapping = collection.mapping('Person', {
//                             id: 'id',
//                             attributes: ['name', 'age']
//                         });
//                         collection.install(done);
//                     });

//                     it('forward', function (done) {
//                         var changes = {
//                             myCollection: {
//                                 Car: {
//                                     carId: [
//                                         new Change({
//                                             collection: collection._name,
//                                             mapping: carMapping.type,
//                                             field: 'owner',
//                                             type: ChangeType.Set,
//                                             newId: 'personId',
//                                             oldId: null,
//                                             _id: 'carId'
//                                         })
//                                     ]
//                                 }
//                             }
//                         };
//                         var docs = [
//                             {
//                                 _id: 'carId',
//                                 name: 'Aston Martin',
//                                 colour: 'red',
//                                 collection: 'myCollection',
//                                 type: 'Car'
//                             }
//                         ];

//                         testMerge(changes, docs, function (err, docs) {
//                             if (err) {
//                                 done(err);
//                             }
//                             else {
//                                 var doc = docs[0];
//                                 assert.equal(doc.owner, 'personId');
//                                 done();
//                             }
//                         });
//                     });

//                     it('reverse', function (done) {
//                         var changes = {
//                             myCollection: {
//                                 Car: {
//                                     personId: [
//                                         new Change({
//                                             collection: collection._name,
//                                             mapping: carMapping.type,
//                                             field: 'owner',
//                                             type: ChangeType.Set,
//                                             newId: ['carId1', 'carId2', 'carId3'],
//                                             oldId: null,
//                                             _id: 'personId'
//                                         })
//                                     ]
//                                 }
//                             }
//                         };
//                         var docs = [
//                             {
//                                 _id: 'personId',
//                                 name: 'Michael Ford',
//                                 age: 24,
//                                 collection: 'myCollection',
//                                 type: 'Person'
//                             }
//                         ];

//                         testMerge(changes, docs, function (err, docs) {
//                             if (err) {
//                                 done(err);
//                             }
//                             else {
//                                 var doc = docs[0];
//                                 assert.arrEqual(doc.owner, ['carId1', 'carId2', 'carId3']);
//                                 done();
//                             }
//                         });
//                     });
//                 });


//             });

//         });

//     });

//     describe('apply changes', function () {

//         describe('attribute', function () {

//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colours', 'name']
//                 });
//                 collection.install(done);
//             });

//             it('set', function () {
//                 var obj = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                 var c = new Change({
//                     collection: collection,
//                     mapping: carMapping,
//                     field: 'colours',
//                     type: ChangeType.Set,
//                     new: 'blue',
//                     old: 'red',
//                     _id: obj._id
//                 });
//                 c.applySiestaModel(obj);
//                 assert.equal(obj.colours, 'blue');
//             });

//             it('set, old is wrong', function () {
//                 var obj = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                 var c = new Change({
//                     collection: collection,
//                     mapping: carMapping,
//                     field: 'colours',
//                     type: ChangeType.Set,
//                     new: 'blue',
//                     old: 'green',
//                     _id: obj._id
//                 });
//                 assert.throws(function () {
//                     c.applySiestaModel(obj);
//                 }, InternalSiestaError);
//             });

//             it('splice', function () {
//                 var obj = carMapping._new({colours: ['red', 'blue'], name: 'Aston Martin'});
//                 var c = new Change({
//                     collection: collection,
//                     mapping: carMapping,
//                     field: 'colours',
//                     type: ChangeType.Splice,
//                     index: 1,
//                     added: ['green'],
//                     removed: ['blue'],
//                     _id: obj._id
//                 });
//                 c.apply(obj);
//                 assert.equal(obj.colours.length, 2);
//                 assert.equal(obj.colours[0], 'red');
//                 assert.equal(obj.colours[1], 'green');
//             });

//         });

//         describe('relationships', function () {

//             var personMapping;

//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colours', 'name'],
//                     relationships: {
//                         owner: {
//                             type: RelationshipType.OneToMany,
//                             reverse: 'cars',
//                             mapping: 'Person'
//                         }
//                     }
//                 });
//                 personMapping = collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['name', 'age']
//                 });
//                 collection.install(done);
//             });

//             describe('set', function () {

//                 describe('no old', function () {
//                     it('new only', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             new: person,
//                             old: null,
//                             _id: car._id
//                         });
//                         c.applySiestaModel(car);
//                         var proxy = car.ownerProxy;
//                         assert.equal(proxy._id, person._id, 'Should set _id');
//                         assert.equal(proxy.related, person, 'Should set person');
//                         assert.equal(car.owner, person);
//                     });

//                     it('newId only', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             newId: person._id,
//                             old: null,
//                             _id: car._id
//                         });
//                         c.applySiestaModel(car);
//                         var proxy = car.ownerProxy;
//                         assert.equal(proxy._id, person._id, 'Should set _id');
//                         // person object should be pulled from cache.
//                         assert.equal(proxy.related, person, 'Should set person');
//                         assert.equal(car.owner, person);
//                     });

//                     it('both new and newId', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             newId: person._id,
//                             new: person,
//                             old: null,
//                             _id: car._id
//                         });
//                         c.applySiestaModel(car);
//                         var proxy = car.ownerProxy;
//                         assert.equal(proxy._id, person._id, 'Should set _id');
//                         assert.equal(proxy.related, person, 'Should set person');
//                         assert.equal(car.owner, person);
//                     });
//                 });

//                 describe('old', function () {
//                     it('new and old only', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         car.owner = person;
//                         var newOwner = carMapping._new({name: 'Bob', age: 24});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             new: newOwner,
//                             old: person,
//                             _id: car._id
//                         });
//                         c.applySiestaModel(car);
//                         var proxy = car.ownerProxy;
//                         assert.equal(proxy._id, newOwner._id, 'Should set _id');
//                         assert.equal(proxy.related, newOwner, 'Should set person');
//                         assert.equal(car.owner, newOwner);
//                     });

//                     it('newId and oldId only, no fault', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         car.owner = person;
//                         var newOwner = carMapping._new({name: 'Bob', age: 24});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             newId: newOwner._id,
//                             oldId: person._id,
//                             _id: car._id
//                         });
//                         c.applySiestaModel(car);
//                         var proxy = car.ownerProxy;
//                         assert.equal(proxy._id, newOwner._id, 'Should set _id');
//                         assert.equal(proxy.related, newOwner, 'Should set person');
//                         assert.equal(car.owner, newOwner);
//                     });

//                     it('newId and oldId only, fault', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         car.owner = person;
//                         var newOwner = carMapping._new({name: 'Bob', age: 24});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             newId: newOwner._id,
//                             oldId: person._id,
//                             _id: car._id
//                         });
//                         cache.reset();
//                         c.applySiestaModel(car);
//                         var proxy = car.ownerProxy;
//                         assert.equal(proxy._id, newOwner._id, 'Should set _id');
//                         assert.notOk(proxy.related);
//                         assert.ok(proxy.isFault);
//                     });

//                 });


//                 describe('errors', function () {
//                     it('invalid oldId', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             new: person,
//                             oldId: 'xyz',
//                             _id: car._id
//                         });
//                         assert.throws(function () {
//                             c.applySiestaModel(car);
//                         }, InternalSiestaError);
//                     });
//                     it('invalid old', function () {
//                         var car = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                         var person = personMapping._new({name: 'Michael Ford', age: 23});
//                         var c = new Change({
//                             collection: collection,
//                             mapping: carMapping,
//                             field: 'owner',
//                             type: ChangeType.Set,
//                             new: person,
//                             old: {_id: 'xyz'},
//                             _id: car._id
//                         });
//                         assert.throws(function () {
//                             c.applySiestaModel(car);
//                         }, InternalSiestaError);
//                     });

//                 })

//             });

//             describe('splice', function () {

//                 it('removed only', function () {
//                     var person = personMapping._new({name: 'Michael Ford', age: 23});
//                     var car1 = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                     var car2 = carMapping._new({colours: 'blue', name: 'Aston Martin'});
//                     person.cars = [car1, car2];
//                     var c = new Change({
//                         collection: collection,
//                         mapping: personMapping,
//                         field: 'cars',
//                         type: ChangeType.Splice,
//                         index: 0,
//                         removed: [car1],
//                         _id: person._id
//                     });
//                     c.applySiestaModel(person);
//                     var proxy = person.carsProxy;
//                     assert.equal(proxy._id.length, 1);
//                     assert.include(proxy._id, car2._id);
//                     assert.equal(proxy.related.length, 1);
//                     assert.include(proxy.related, car2);
//                     assert.equal(person.cars.length, 1);
//                 });

//                 it('removedId only, no fault', function () {
//                     var person = personMapping._new({name: 'Michael Ford', age: 23});
//                     var car1 = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                     var car2 = carMapping._new({colours: 'blue', name: 'Aston Martin'});
//                     person.cars = [car1, car2];
//                     var c = new Change({
//                         collection: collection,
//                         mapping: personMapping,
//                         field: 'cars',
//                         type: ChangeType.Splice,
//                         index: 0,
//                         removedId: [car1._id],
//                         _id: person._id
//                     });
//                     c.applySiestaModel(person);
//                     var proxy = person.carsProxy;
//                     assert.equal(proxy._id.length, 1);
//                     assert.include(proxy._id, car2._id);
//                     assert.equal(proxy.related.length, 1);
//                     assert.include(proxy.related, car2);
//                     assert.equal(person.cars.length, 1);
//                 });

//                 it('removedId only, fault', function () {
//                     var person = personMapping._new({name: 'Michael Ford', age: 23});
//                     var car1 = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                     var car2 = carMapping._new({colours: 'blue', name: 'Aston Martin'});
//                     person.cars = [car1, car2];
//                     var c = new Change({
//                         collection: collection,
//                         mapping: personMapping,
//                         field: 'cars',
//                         type: ChangeType.Splice,
//                         index: 0,
//                         removedId: [car1._id],
//                         _id: person._id
//                     });
//                     cache.reset();
//                     var proxy = person.carsProxy;
//                     proxy.related = null;
//                     c.applySiestaModel(person);
//                     assert.equal(proxy._id.length, 1);
//                     assert.include(proxy._id, car2._id);
//                     assert.ok(proxy.isFault);
//                 });

//                 it('added only', function () {
//                     var person = personMapping._new({name: 'Michael Ford', age: 23});
//                     var car1 = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                     var car2 = carMapping._new({colours: 'blue', name: 'Aston Martin'});
//                     var car3 = carMapping._new({colours: 'purple', name: 'Aston Martin'});
//                     person.cars = [car1, car2];
//                     var c = new Change({
//                         collection: collection,
//                         mapping: personMapping,
//                         field: 'cars',
//                         type: ChangeType.Splice,
//                         index: 0,
//                         added: [car3],
//                         _id: person._id
//                     });
//                     c.applySiestaModel(person);
//                     var proxy = person.carsProxy;
//                     assert.equal(proxy._id.length, 3);
//                     assert.include(proxy._id, car3._id);
//                     assert.equal(proxy.related.length, 3);
//                     assert.include(proxy.related, car3);
//                     assert.equal(person.cars.length, 3);
//                 });


//                 it('addedId only, no fault', function () {
//                     var person = personMapping._new({name: 'Michael Ford', age: 23});
//                     var car1 = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                     var car2 = carMapping._new({colours: 'blue', name: 'Aston Martin'});
//                     var car3 = carMapping._new({colours: 'purple', name: 'Aston Martin'});
//                     person.cars = [car1, car2];
//                     var c = new Change({
//                         collection: collection,
//                         mapping: personMapping,
//                         field: 'cars',
//                         type: ChangeType.Splice,
//                         index: 0,
//                         addedId: [car3._id],
//                         _id: person._id
//                     });
//                     c.applySiestaModel(person);
//                     var proxy = person.carsProxy;
//                     assert.equal(proxy._id.length, 3);
//                     assert.include(proxy._id, car3._id);
//                     assert.equal(proxy.related.length, 3);
//                     assert.include(proxy.related, car3);
//                     assert.equal(person.cars.length, 3);
//                 });


//                 it('addedId only, fault', function () {
//                     var person = personMapping._new({name: 'Michael Ford', age: 23});
//                     var car1 = carMapping._new({colours: 'red', name: 'Aston Martin'});
//                     var car2 = carMapping._new({colours: 'blue', name: 'Aston Martin'});
//                     var car3 = carMapping._new({colours: 'purple', name: 'Aston Martin'});
//                     person.cars = [car1, car2];
//                     var c = new Change({
//                         collection: collection,
//                         mapping: personMapping,
//                         field: 'cars',
//                         type: ChangeType.Splice,
//                         index: 0,
//                         addedId: [car3._id],
//                         _id: person._id
//                     });
//                     cache.reset();
//                     c.applySiestaModel(person);
//                     var proxy = person.carsProxy;
//                     assert.equal(proxy._id.length, 3);
//                     assert.include(proxy._id, car3._id);
//                     assert.notOk(proxy.related);
//                     assert.ok(proxy.isFault);
//                 });


//             });


//         });

//     });

//     describe('save', function () {

//         var collection, carMapping, personMapping;
//         var car, person, carChanges, personChanges;

//         beforeEach(function (done) {
//             collection = new Collection('myCollection');
//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['colour', 'name'],
//                 relationships: {
//                     owner: {
//                         type: RelationshipType.OneToMany,
//                         reverse: 'cars',
//                         mapping: 'Person'
//                     }
//                 }
//             });
//             personMapping = collection.mapping('Person', {
//                 id: 'id',
//                 attributes: ['age', 'name']
//             });
//             collection.install(function (err) {
//                 if (err) done(err);
//                 personMapping.map({name: 'Michael Ford', age: 23}, function (err, _person) {
//                     if (err) done(err);
//                     person = _person;
//                     carMapping.map({colour: 'red', name: 'Aston Martin', owner: person}, function (err, _car) {
//                         if (err) done(err);
//                         car = _car;
//                         util.next(function () {
//                             carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             collection.save(done);
//                         });
//                     });
//                 });
//             });
//         });

//         describe('registers changes', function () {
//             it('forward', function () {
//                 assert.equal(carChanges.length, 3);
//                 _.chain(carChanges).pluck('_id').each(function (x) {assert.equal(x, car._id);});
//                 _.chain(carChanges).pluck('collection').each(function (x) {assert.equal(x, 'myCollection');});
//                 _.chain(carChanges).pluck('mapping').each(function (x) {assert.equal(x, 'Car');});
//                 var colourChange = _.findWhere(carChanges, {field: 'colour'});
//                 assert.ok(colourChange);
//                 assert.equal(colourChange.new, 'red');
//                 assert.notOk(colourChange.old);
//                 var nameChange = _.findWhere(carChanges, {field: 'name'});
//                 assert.ok(nameChange);
//                 assert.equal(nameChange.new, 'Aston Martin');
//                 assert.notOk(nameChange.old);
//                 var ownerChange = _.findWhere(carChanges, {field: 'owner'});
//                 assert.ok(ownerChange);
//                 assert.equal(ownerChange.new, person);
//                 assert.equal(ownerChange.newId, person._id);
//                 assert.notOk(ownerChange.old);
//             });

//             it('reverse', function () {

//             });
//         });

//         describe('saves', function () {
//             it('saves changes', function (done) {
//                 s.ext.storage.changes.mergeChanges(function (err) {
//                     if (err) done(err);
//                     assert.notOk(s.ext.storage.changes.allChanges.length);
//                     s.ext.storage.Pouch.getPouch().get(car._id, function (err, doc) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             assert.equal(doc.colour, 'red');
//                             assert.equal(doc.name, 'Aston Martin');
//                             assert.equal(doc.collection, 'myCollection');
//                             assert.equal(doc.mapping, 'Car');
//                             done();
//                         }
//                     });
//                 })
//             });
//         })

//     });

// });
},{}],90:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;


// describe('indexes', function () {

//     beforeEach(function () {
//         s.reset(true);
//     });

//     describe('Index', function () {
//         it('index name', function () {
//             var i = new s.ext.storage.Index('myCollection', 'Car', ['colour', 'name']);
//             assert.equal(i._getName(), 'myCollection_Index_Car_colour_name');
//             i = new s.ext.storage.Index('myCollection', 'Car', ['name', 'colour']);
//             assert.equal(i._getName(), 'myCollection_Index_Car_colour_name');
//         });

//         describe('map func', function () {



//             it('map func', function () {
//                 var i = new s.ext.storage.Index('myCollection', 'Car', ['colour', 'name']);
//                 var emissions = [];

//                 function emit(id, doc) {
//                     emissions.push({id: id, doc: doc});
//                 }

//                 var rawMap = i._constructMapFunction();
//                 eval('var mapFunc = ' + rawMap);
//                 mapFunc({type: 'Car', colour: 'red', name: 'Aston Martin', collection: 'myCollection'});
//                 assert.equal(1, emissions.length);
//                 var emission = emissions[0];
//                 assert.equal(emission.id, 'red_Aston Martin')
//             });



//         });


//         // Check that queries using the s.ext.storage.index work as expected with s.ext.storage.PouchDB.
//         it('pouchdb s.ext.storage.index', function (done) {
//             var i = new s.ext.storage.Index('myCollection', 'Car', ['colour', 'name']);
//             var view = i._constructPouchDbView();
//             s.ext.storage.Pouch.getPouch().put(view, function (err, resp) {
//                 if (err) done(err);
//                 s.ext.storage.Pouch.getPouch().post({type: 'Car', colour: 'red', name: 'Aston Martin', collection: 'myCollection'}, function (err, resp) {
//                     if (err) done(err);
//                     s.ext.storage.Pouch.getPouch().query(i._getName(), {key: 'red_Aston Martin'}, function (err, resp) {
//                         if (err) done(err);
//                         assert.equal(resp.total_rows, 1);
//                         done();
//                     });
//                 });
//             });
//         });

//         it('installation', function (done) {
//             var i = new s.ext.storage.Index('myCollection', 'Car', ['colour', 'name']);
//             i.install(function (err) {
//                 if (err) done(err);
//                 assert.include(s.ext.storage.Index.indexes, i);
//                 s.ext.storage.Pouch.getPouch().get('_design/' + i._getName(), function (err, doc) {
//                     if (err) done(err);
//                     assert.ok(doc);
//                     done();
//                 });
//             });
//         })
//     });

//     describe('Indexes', function () {
//         it('field combinations', function () {
//             var combinations = s.ext.storage.index._getFieldCombinations(['field1', 'field2', 'field3']);
//             assert.equal(8, combinations.length);
//         });

//         it('indexes', function () {
//             var indexes = s.ext.storage.index._constructIndexes('myCollection', 'Car', ['field1', 'field2', 'field3']);
//             assert.equal(8, indexes.length);
//             _.each(indexes, function (i) {assert.ok(i.install)});
//         });

//         it('bulk installation', function (done) {
//             s.ext.storage.index.installIndexes('myCollection', 'Car', ['field1', 'field2', 'field3'], function (err) {
//                 if (err) done(err);
//                 // Should be able to handle conflicts.
//                 s.ext.storage.index.installIndexes('myCollection', 'Car', ['field1', 'field2', 'field3'], function (err) {
//                     done(err);
//                 });
//             });
//         });
//     });


// });



    // describe('index installation', function () {

    //     it('installation', function (done) {
    //         var m = new Mapping({
    //             type: 'Type',
    //             id: 'id',
    //             attributes: ['field1', 'field2'],
    //             collection: 'myCollection'
    //         });
    //         m.install(function (err) {
    //             if (err) done(err);
    //             var indexes = s.ext.storage.Index.indexes;
    //             assert.equal(indexes.length, 2);
    //             done();
    //         });
    //     });

    //     it('no indexes specified', function () {
    //         var m = new Mapping({
    //             type: 'Type',
    //             id: 'id',
    //             attributes: ['field1', 'field2'],
    //             collection: 'myCollection'
    //         });
    //         var indexes = m.getIndexesToInstall();
    //         assert.equal(indexes.length, 1);
    //         assert.include(indexes, 'id');
    //     });

    //     it('indexes specified', function () {
    //         var m = new Mapping({
    //             type: 'Type',
    //             id: 'id',
    //             attributes: ['field1', 'field2'],
    //             collection: 'myCollection',
    //             indexes: ['field1']
    //         });
    //         var indexes = m.getIndexesToInstall();
    //         assert.equal(indexes.length, 2);
    //         assert.include(indexes, 'id');
    //         assert.include(indexes, 'field1');
    //     });

    //     it('invalid indexes specified', function () {
    //         var m = new Mapping({
    //             type: 'Type',
    //             id: 'id',
    //             attributes: ['field1', 'field2'],
    //             collection: 'myCollection',
    //             indexes: ['fgdofgndfog']
    //         });
    //         var indexes = m.getIndexesToInstall();
    //         assert.equal(indexes.length, 1);
    //         assert.include(indexes, 'id');
    //     });

    // });
},{}],91:[function(require,module,exports){
// /**
//  * An integration test that creates two complex collections and then establishes inter-collection relationships
//  * between the mappings in each before creating objects etc.
//  *
//  * We then proceed to test various aspects of the system.
//  */

// var s = require('../../index')
//     , assert = require('chai').assert;

// var Collection = require('../../src/collection').Collection;
// var RelationshipType = require('../../src/relationship').RelationshipType;
// var cache = require('../../src/cache');

// var async = require('async');

// describe('intercollection relationships', function () {
//     var myOfflineCollection;
//     var myOnlineCollection;

//     beforeEach(function (done) {
//         s.reset(true);
//         var finishedCreatingMyOfflineCollection = false;

//         myOfflineCollection = new Collection('MyOfflineCollection');

//         myOfflineCollection.mapping('Folder', {
//             attributes: ['name'],
//             relationships: {
//                 createdBy: {
//                     mapping: 'User',
//                     type: RelationshipType.OneToMany,
//                     reverse: 'folders'
//                 }
//             }
//         });

//         myOfflineCollection.mapping('DownloadedPhoto', {
//             attributes: ['creationDate'],
//             relationships: {
//                 createdBy: {
//                     mapping: 'User',
//                     type: RelationshipType.OneToMany,
//                     reverse: 'files'
//                 },
//                 folder: {
//                     mapping: 'Folder',
//                     type: RelationshipType.OneToMany,
//                     reverse: 'files'
//                 },
//                 photo: {
//                     mapping: 'MyOnlineCollection.Photo',
//                     type: RelationshipType.OneToOne,
//                     reverse: 'file'
//                 }
//             }
//         });

//         myOfflineCollection.mapping('User', {
//             attributes: ['username'],
//             indexes: ['username']
//         });

//         myOfflineCollection.install(function (err) {
//             if (err) done(err);
//             finishedCreatingMyOfflineCollection = true;
//             if (finishedCreatingMyOnlineCollection) {
//                 done();
//             }
//         });

//         var finishedCreatingMyOnlineCollection = false;

//         myOnlineCollection = new Collection('MyOnlineCollection');

//         myOnlineCollection.mapping('Photo', {
//             id: 'photoId',
//             attributes: ['height', 'width', 'url'],
//             relationships: {
//                 createdBy: {
//                     mapping: 'User',
//                     type: RelationshipType.OneToMany,
//                     reverse: 'photos'
//                 }
//             }
//         });

//         myOnlineCollection.mapping('User', {
//             id: 'userId',
//             attributes: ['username', 'name']
//         });

//         myOnlineCollection.install(function (err) {
//             if (err) done(err);
//             if (finishedCreatingMyOfflineCollection) {
//                 done();
//             }
//         });
//     });

//     function mapRemoteUsers(callback) {
//         myOnlineCollection.User.map([
//             {username: 'mtford', name: 'Michael Ford', userId: '1'},
//             {username: 'blahblah', name: 'Blah Blah', userId: '2'},
//             {username: 'bobm', name: 'Bob Marley', userId: '3'}
//         ], callback);
//     }

//     function mapRemotePhotos(callback) {
//         myOnlineCollection.Photo.map([
//             {height: 500, width: 500, url: 'http://somewhere/image.jpeg', photoId: '10', createdBy: '1'},
//             {height: 1500, width: 1500, url: 'http://somewhere/image2.jpeg', photoId: '11', createdBy: '1'},
//             {height: 500, width: 750, url: 'http://somewhere/image3.jpeg', photoId: '12', createdBy: '2'}
//         ], callback);
//     }

//     function mapOfflineUsers(callback) {
//         myOfflineCollection.User.map([
//             {username: 'mike'},
//             {username: 'gaz'}
//         ], callback);
//     }

//     function installOfflineFixtures(callback) {
//         mapOfflineUsers(function (err) {
//             if (!err) {
//                 myOfflineCollection.save(callback);
//             }
//             else {
//                 callback(err);
//             }
//         });
//     }

//     function installOnlineFixtures(callback) {
//         async.series([
//             mapRemoteUsers,
//             mapRemotePhotos
//         ], function (err) {
//             if (!err) {
//                 myOnlineCollection.save(callback);
//             }
//             else {
//                 callback(err);
//             }
//         });
//     }

//     describe('can install', function () {
//         it('Can install offline fixtures', function (done) {
//             installOfflineFixtures(function (err) {
//                 if (err) done(err);
//                 assert.notOk(s.ext.storage.changes.allChanges.length);
//                 done();
//             });
//         });

//         it('can install online fixtures', function (done) {
//             installOnlineFixtures(function (err) {
//                 if (err) done(err);
//                 assert.notOk(s.ext.storage.changes.allChanges.length);
//                 done();
//             });
//         });

//         it('can install both', function (done) {
//             installOfflineFixtures(function (err) {
//                 if (err) done(err);
//                 installOnlineFixtures(function (err) {
//                     if (err) done(err);
//                     assert.notOk(s.ext.storage.changes.allChanges.length);
//                     done();
//                 });
//             });
//         })
//     });


//     /**
//      * Execute the integration test. Seperated out into a function so can be executed having manipulated s.ext.storage.Pouch
//      */
//     function tests() {
//         describe('local queries', function () {
//             describe('offline', function () {
//                 it('should return mike when querying for him', function (done) {
//                     myOfflineCollection.User.query({username: 'gaz'}, function (err, users) {
//                         if (err) done(err);
//                         assert.equal(users.length, 1);
//                         assert.equal(users[0].username, 'gaz');
//                         done();
//                     });
//                 });
//             });

//             describe('online', function () {

//                 it('should return 3 users when run a local all query against users', function (done) {
//                     myOnlineCollection.User.all(function (err, users) {
//                         if (err) done(err);
//                         assert.equal(users.length, 3);
//                         done();
//                     });
//                 });

//                 it('should return 3 photos when run a local all query against photos', function (done) {
//                     myOnlineCollection.Photo.all(function (err, photos) {
//                         if (err) done(err);
//                         assert.equal(photos.length, 3);
//                         done();
//                     });
//                 });

//                 it('should return 2 photos with height 500', function (done) {
//                     this.timeout(10000);
//                     myOnlineCollection.Photo.query({height: 500}, function (err, photos) {
//                         if (err) done(err);
//                         assert.equal(photos.length, 2);
//                         _.each(photos, function (p) {
//                             assert.equal(p.height, 500);
//                         });
//                         done();
//                     });
//                 });

//                 it('should return 1 photo with height 500, width, 750', function (done) {
//                     this.timeout(10000);
//                     myOnlineCollection.Photo.query({height: 500, width: 750}, function (err, photos) {
//                         if (err) done(err);
//                         assert.equal(photos.length, 1);
//                         assert.equal(photos[0].height, 500);
//                         assert.equal(photos[0].width, 750);
//                         done();
//                     });
//                 });

//                 it('should be able to query by remote identifier', function (done) {
//                     myOnlineCollection.User.get('1', function (err, user) {
//                         if (err) done(err);
//                         assert.equal(user.userId, '1');
//                         done();
//                     })
//                 })


//             });
//         });
//         describe('relationship mappings', function () {
//             describe('online', function () {
//                 function assertNumPhotos(userId, numPhotos, done) {
//                     myOnlineCollection.User.get(userId, function (err, user) {
//                         if (err) done(err);
//                         assert.ok(user);
//                         assert.equal(user.userId, userId);
//                         var proxy = user.photosProxy;
//                         proxy.get(function (err, photos) {
//                             if (err) done(err);
//                             assert.equal(photos ? photos.length : 0, numPhotos);
//                             done();
//                         });
//                     })
//                 }

//                 it('user with id 1 should have 2 photos', function (done) {
//                     assertNumPhotos('1', 2, done);
//                 });

//                 it('user with id 2 should have 1 photo...', function (done) {
//                     assertNumPhotos('2', 1, done);
//                 });

//                 it('user with id 3 should have no photos', function (done) {
//                     assertNumPhotos('3', 0, done);
//                 });

//             });

//         });
//     }

//     describe('no cache', function () {
//         beforeEach(function (done) {
//             installOfflineFixtures(function (err) {
//                 if (err) done(err);
//                 installOnlineFixtures(function (err) {
//                     if (err) done(err);
//                     cache.reset();
//                     done();
//                 });
//             });
//         });
//         tests();
//     });

// //    describe('cached', function () {
// //        beforeEach(function (done) {
// //            installOfflineFixtures(function (err) {
// //                if (err) done(err);
// //                installOnlineFixtures(done);
// //            });
// //        });
// //        tests();
// //    });


// });
},{}],92:[function(require,module,exports){
// var s = require('../../index')
//     , assert = require('chai').assert;

// describe('perform mapping', function () {


//     var Collection = require('../../src/collection').Collection;
//     var RelationshipType = require('../../src/relationship').RelationshipType;

//     var SiestaModel = require('../../src/object').SiestaModel;
//     var cache = require('../../src/cache');
//     var Operation = require('../../vendor/operations.js/src/operation').Operation;

//     var collection, carMapping, personMapping;

//     beforeEach(function () {
//         collection = null;
//         carMapping = null;
//         personMapping = null;
//         s.reset(true);
//     });

//     afterEach(function () {
//         var numIncomplete = 0;
//         _.each(Operation.running, function (op) {
//             if (!op.completed) {
//                 numIncomplete++;
//             }
//         });
//         assert.notOk(numIncomplete);
//     });


//     describe('no relationships', function () {
//         var obj;

//         beforeEach(function (done) {
//             collection = new Collection('myCollection');
//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['colour', 'name']
//             });
//             collection.install(function (err) {
//                 if (err) done(err);
//                 carMapping.map({colour: 'red', name: 'Aston Martin', id: 'dfadf'}, function (err, _obj) {
//                     if (err) {
//                         done(err);
//                     }
//                     obj = _obj;
//                     done();
//                 });
//             });
//         });

//         describe('existing in pouch', function () {

//             describe('via id', function () {
//                 var newObj;
//                 beforeEach(function (done) {
//                     var doc = {_id: 'localId', type: 'Car', collection: 'myCollection', colour: 'red', id: 'remoteId'};
//                     s.ext.storage.Pouch.getPouch().put(doc, function (err, doc) {
//                         if (err) done(err);
//                         carMapping.map({colour: 'blue', id: 'remoteId'}, function (err, obj) {
//                             if (err) done(err);
//                             newObj = obj;
//                             done();
//                         });
//                     });

//                 });

//                 it('should be mapped onto the old object', function () {
//                     assert.equal(newObj._id, 'localId');
//                 });

//                 it('should have the new colour', function () {
//                     assert.equal(newObj.colour, 'blue');
//                 });

//             });

//             describe('via _id', function () {
//                 var newObj;
//                 beforeEach(function (done) {
//                     var doc = {_id: 'localId', type: 'Car', collection: 'myCollection', colour: 'red', id: 'remoteId'};
//                     s.ext.storage.Pouch.getPouch().put(doc, function (err, doc) {
//                         if (err) done(err);
//                         carMapping.map({colour: 'blue', _id: 'localId'}, function (err, obj) {
//                             if (err) {
//                                 console.error(err);
//                                 done(err);
//                             }
//                             newObj = obj;
//                             done();
//                         });
//                     });
//                 });

//                 it('should be mapped onto the old object', function () {
//                     assert.equal(newObj._id, 'localId');
//                 });

//                 it('should have the new colour', function () {
//                     assert.equal(newObj.colour, 'blue');
//                 });
//                 it('obj removed from cache should not have the new colour', function () {
//                     assert.notEqual(obj.colour, 'blue');
//                 });
//             });
//         });


//     });

//     describe('with relationship', function () {

//         describe('foreign key', function () {
//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 personMapping = collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['name', 'age']
//                 });
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colour', 'name'],
//                     relationships: {
//                         owner: {
//                             mapping: 'Person',
//                             type: RelationshipType.OneToMany,
//                             reverse: 'cars'
//                         }
//                     }
//                 });
//                 collection.install(done);
//             });

//             describe('faulted relationship', function () {
//                 var person, car;

//                 beforeEach(function (done) {
//                     var doc = {name: 'Michael Ford', age: 23, id: 'personRemoteId', collection: 'myCollection', type: 'Person', _id: 'personLocalId'};
//                     s.ext.storage.Pouch.getPouch().put(doc, function (err) {
//                         if (err) done(err);
//                         carMapping.map({name: 'Bentley', colour: 'black', owner: 'personRemoteId', id: 'carRemoteId'}, function (err, _car) {
//                             if (err) {
//                                 done(err);
//                             }
//                             car = _car;
//                             person = car.owner;
//                             done();
//                         });
//                     });

//                 });

//                 it('should have mapped onto Michael', function () {
//                     assert.equal(person.name, 'Michael Ford');
//                     assert.equal(person.age, 23);
//                 });

//             });

//         });


//     });


  
//     describe('bulk', function () {
//         describe('new', function () {
//             describe('no relationships', function () {
//                 beforeEach(function (done) {
//                     collection = new Collection('myCollection');
//                     carMapping = collection.mapping('Car', {
//                         id: 'id',
//                         attributes: ['colour', 'name']
//                     });
//                     collection.install(done);
//                 });

//                 it('all valid', function (done) {
//                     var raw = [
//                         {colour: 'red', name: 'Aston Martin', id: 'remoteId1sdfsdfdsfgsdf'},
//                         {colour: 'blue', name: 'Lambo', id: "remoteId2dfgdfgdfg"},
//                         {colour: 'green', name: 'Ford', id: "remoteId3dfgdfgdfgdfg"}
//                     ];
//                     carMapping._mapBulk(raw, function (err, objs) {
//                         if (err) done(err);
//                         assert.equal(objs.length, raw.length);
//                         assert.equal(objs[0].colour, 'red');
//                         assert.equal(objs[1].colour, 'blue');
//                         assert.equal(objs[2].colour, 'green');
//                         done();
//                     })
//                 });
//             });
//             describe('foreign key', function () {
//                 var personMapping;

//                 beforeEach(function (done) {
//                     collection = new Collection('myCollection');
//                     personMapping = collection.mapping('Person', {
//                         id: 'id',
//                         attributes: ['name', 'age']
//                     });
//                     carMapping = collection.mapping('Car', {
//                         id: 'id',
//                         attributes: ['colour', 'name'],
//                         relationships: {
//                             owner: {
//                                 mapping: 'Person',
//                                 type: RelationshipType.OneToMany,
//                                 reverse: 'cars'
//                             }
//                         }
//                     });
//                     collection.install(done);
//                 });

//                 it('same owner using _mapBulk', function (done) {
//                     var ownerId = 'ownerId462345345';
//                     var raw = [
//                         {colour: 'red', name: 'Aston Martin', id: 'remoteId1', owner: ownerId},
//                         {colour: 'blue', name: 'Lambo', id: "remoteId2", owner: ownerId},
//                         {colour: 'green', name: 'Ford', id: "remoteId3", owner: ownerId}
//                     ];
//                     carMapping._mapBulk(raw, function (err, objs) {
//                         if (err) done(err);
//                         assert.equal(objs.length, raw.length);
//                         assert.equal(objs[0].owner, objs[1].owner);
//                         assert.equal(objs[1].owner, objs[2].owner);
//                         done();
//                     })
//                 });

//                 it('same owner using map', function (done) {
//                     var ownerId = 'ownerId!!!334';
//                     var carRaw1 = {colour: 'red', name: 'Aston Martin', id: 'remoteId1', owner: ownerId};
//                     var carRaw2 = {colour: 'blue', name: 'Lambo', id: "remoteId2", owner: ownerId};
//                     carMapping.map(carRaw1, function (err, car1) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             carMapping.map(carRaw2, function (err, car2) {
//                                 if (err) done(err);
//                                 assert.equal(car1.owner, car2.owner);
//                                 done();
//                             })
//                         }
//                     });
//                 })
//             })
//         });

//         describe('faulted relationships', function () {
//             var cars;

//             var personMapping;

//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');
//                 personMapping = collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['name', 'age']
//                 });
//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['colour', 'name'],
//                     relationships: {
//                         owner: {
//                             mapping: 'Person',
//                             type: RelationshipType.OneToMany,
//                             reverse: 'cars'
//                         }
//                     }
//                 });
//                 collection.install(done);
//             });


//             describe('via remote id', function () {
//                 beforeEach(function (done) {
//                     personMapping.map({name: 'Michael Ford', age: 23, id: 'personRemoteId'}, function (err) {
//                         if (err) done(err);
//                         cache.reset();
//                         var raw = [
//                             {colour: 'red', name: 'Aston Martin', id: 'remoteId1', owner: 'personRemoteId'},
//                             {colour: 'blue', name: 'Lambo', id: "remoteId2", owner: 'personRemoteId'},
//                             {colour: 'green', name: 'Ford', id: "remoteId3", owner: 'personRemoteId'}
//                         ];
//                         carMapping._mapBulk(raw, function (err, objs, res) {
//                             if (err) {
//                                 done(err);
//                             }
//                             cars = objs;
//                             done();
//                         });

//                     });
//                 });

//                 it('should have mapped onto Michael', function () {
//                     assert.equal(cars.length, 3);
//                     assert.equal(cars[0].owner, cars[1].owner);
//                     assert.equal(cars[1].owner, cars[2].owner);
//                 });

//             });


//             describe('bulk bulk', function () {
//                 beforeEach(function (done) {
//                     cars = [];
//                     personMapping.map({name: 'Michael Ford', age: 23, id: 'personRemoteId'}, function (err) {
//                         if (err) done(err);
//                         cache.reset();
//                         var raw1 = [
//                             {colour: 'red', name: 'Aston Martin', id: 'remoteId1', owner: 'personRemoteId'},
//                             {colour: 'blue', name: 'Lambo', id: "remoteId2", owner: 'personRemoteId'},
//                             {colour: 'green', name: 'Ford', id: "remoteId3", owner: 'personRemoteId'}
//                         ];
//                         carMapping._mapBulk(raw1, function (err, objs, res) {
//                             if (err) {
//                                 done(err);
//                             }
//                             _.each(objs, function (o) {
//                                 cars.push(o);
//                             });
//                             if (cars.length == 9) {
//                                 done();
//                             }
//                         });
//                         var raw2 = [
//                             {colour: 'red', name: 'Peauget', id: 'remoteId4', owner: 'personRemoteId'},
//                             {colour: 'blue', name: 'Chevy', id: "remoteId5", owner: 'personRemoteId'},
//                             {colour: 'green', name: 'Ford', id: "remoteId6", owner: 'personRemoteId'}
//                         ];
//                         carMapping._mapBulk(raw2, function (err, objs, res) {
//                             if (err) {
//                                 done(err);
//                             }
//                             _.each(objs, function (o) {
//                                 cars.push(o);
//                             });
//                             if (cars.length == 9) {
//                                 done();
//                             }
//                         });
//                         var raw3 = [
//                             {colour: 'red', name: 'Ferarri', id: 'remoteId7', owner: 'personRemoteId'},
//                             {colour: 'blue', name: 'Volvo', id: "remoteId8", owner: 'personRemoteId'},
//                             {colour: 'green', name: 'Dodge', id: "remoteId9", owner: 'personRemoteId'}
//                         ];
//                         carMapping._mapBulk(raw3, function (err, objs, res) {
//                             if (err) {
//                                 done(err);
//                             }
//                             _.each(objs, function (o) {
//                                 cars.push(o);
//                             });
//                             console.log(cars.length);
//                             if (cars.length == 9) {
//                                 done();
//                             }
//                         });

//                     });
//                 });

//                 it('should have mapped onto Michael', function () {
//                     assert.equal(cars.length, 9);
//                     for (var i = 0; i < 8; i++) {
//                         assert.equal(cars[i].owner, cars[i + 1].owner);
//                     }
//                 });

//             });

//             describe('via nested remote id', function () {
//                 beforeEach(function (done) {
//                     personMapping.map({name: 'Michael Ford', age: 23, id: 'personRemoteId'}, function (err) {
//                         if (err) done(err);
//                         cache.reset();
//                         var raw = [
//                             {colour: 'red', name: 'Aston Martin', id: 'remoteId1', owner: {id: 'personRemoteId'}},
//                             {colour: 'blue', name: 'Lambo', id: "remoteId2", owner: {id: 'personRemoteId'}},
//                             {colour: 'green', name: 'Ford', id: "remoteId3", owner: {id: 'personRemoteId'}}
//                         ];
//                         carMapping._mapBulk(raw, function (err, objs, res) {
//                             if (err) {
//                                 done(err);
//                             }
//                             cars = objs;
//                             done();
//                         });

//                     });
//                 });

//                 it('should have mapped onto Michael', function () {
//                     assert.equal(cars.length, 3);
//                     assert.equal(cars[0].owner, cars[1].owner);
//                     assert.equal(cars[1].owner, cars[2].owner);
//                 });

//             });

//             describe('via nested remote id with unmergedChanges', function () {
//                 this.timeout(5000);
//                 beforeEach(function (done) {
//                     personMapping.map({name: 'Michael Ford', age: 23, id: 'personRemoteId'}, function (err) {
//                         if (err) done(err);
//                         cache.reset();
//                         var raw = [
//                             {colour: 'red', name: 'Aston Martin', id: 'remoteId1', owner: {id: 'personRemoteId'}},
//                             {colour: 'blue', name: 'Lambo', id: "remoteId2", owner: {id: 'personRemoteId', name: 'Bob'}},
//                             {colour: 'green', name: 'Ford', id: "remoteId3", owner: {id: 'personRemoteId'}}
//                         ];
//                         carMapping._mapBulk(raw, function (err, objs, res) {
//                             if (err) {
//                                 done(err);
//                             }
//                             cars = objs;
//                             done();
//                         });

//                     });
//                 });

//                 it('should have mapped onto Michael', function () {
//                     assert.equal(cars.length, 3);
//                     assert.equal(cars[0].owner, cars[1].owner);
//                     assert.equal(cars[1].owner, cars[2].owner);
//                 });
//                 it('should have changed the name', function () {
//                     assert.equal(cars[0].owner.name, 'Bob');
//                     assert.equal(cars[1].owner.name, 'Bob');
//                     assert.equal(cars[2].owner.name, 'Bob');
//                 });

//             })

//         });


//     });
// });
},{}],93:[function(require,module,exports){
// var s = require('../../index'),
//     assert = require('chai').assert;

// describe('performance', function() {

//     var Collection = require('../../src/collection').Collection;
//     var cache = require('../../src/cache');
//     var collection;
//     var Repo, User, Fork, Follow;

//     beforeEach(function(done) {
//         s.reset(true);
//         collection = new Collection('MyCollection');
//         collection.baseURL = 'https://api.github.com';
//         Repo = collection.mapping('Repo', {
//             id: 'id',
//             attributes: ['name', 'full_name', 'description', 'html_url', 'watchers_count', 'stargazers_count', 'forks'],
//             relationships: {
//                 owner: {
//                     mapping: 'User',
//                     type: 'OneToMany',
//                     reverse: 'repositories'
//                 }
//             }
//         });
//         Fork = collection.mapping('Fork', {
//             relationships: {
//                 source: {
//                     mapping: 'Repo',
//                     type: 'OneToMany',
//                     reverse: 'forked_to'
//                 },
//                 fork: {
//                     mapping: 'Repo',
//                     type: 'OneToOne',
//                     reverse: 'forked_from'
//                 }
//             }
//         });
//         Follow = collection.mapping('Follow', {
//             relationships: {
//                 followed: {
//                     mapping: 'User',
//                     type: 'OneToMany',
//                     reverse: 'followers'
//                 },
//                 follower: {
//                     mapping: 'User',
//                     type: 'OneToMany',
//                     reverse: 'following'
//                 }
//             }
//         });
//         User = collection.mapping('User', {
//             id: 'id',
//             attributes: ['login', 'avatar_url']
//         });
//         collection.install(done);
//     });

//     describe('fresh database', function() {

//         /**
//          * On Mike's Mac, 3.4ghz Intel Core i5, 16gb 1600Mhz DDR3, OSX 10.9.3, logging disabled:
//          *    - 11/9/2014 13:16: 2.415 secs
//          *    - 12/9/2014 08:36: 1.084 secs
//          *    - 13/9/2014 08:46: 0.53 secs
//          *
//          * On Mike's MacBook Air, 1.7 GHz Intel Core i5, 4 GB 1333 MHz DDR3, OSX 10.10 Beta, logging disabled:
//          *    - 26/9/2014 11:42: 0.987 secs
//          */
//         it('xyz', function(done) {
//             this.timeout(10000);
//             var json = require('./repos').repos;
//             Repo.map(json, done);
//         });

//         it('store', function(done) {
//             this.timeout(10000);
//             var json = require('./repos').repos;
//             Repo.map(json, function(err, objs) {
//                 if (err) done(err);
//                 siesta.save(function(err) {
//                     if (err) done(err);
//                     cache.reset();
//                     var idents = _.pluck(objs, 'id');
//                     var results = {
//                         cached: {},
//                         notCached: idents
//                     };
//                     siesta.ext.storage.store.getMultipleRemoteFrompouch(Repo, idents, results, function() {
//                         assert.equal(30, Object.keys(results.cached).length);
//                         assert.notOk(results.notCached.length);
//                         done();
//                     });
//                 });
//             });
//         });

//         it('fork', function(done) {
//             this.timeout(8000);
//             var repos = require('./repos').repos;
//             Repo.map(repos, function(err, objs) {
//                 if (err) done(err);
//                 var forks = require('./repos').forks;
//                 var rawFork = _.map(forks, function(f) {
//                     return {
//                         fork: f,
//                         source: {
//                             _id: objs[0]._id
//                         }
//                     };
//                 });
//                 Fork.map(rawFork, function(err, forks) {
//                     if (err) done(err);
//                     assert.equal(forks.length, 6);
//                     for (var i = 0; i < forks.length; i++) {
//                         var fork = forks[i];
//                         assert.equal(fork.source, objs[0]);
//                     }
//                     done();
//                 });
//             });
//         });

//         it('follow', function(done) {
//             this.timeout(8000);
//             var repos = require('./repos').repos;
//             Repo.map(repos, function(err, objs) {
//                 if (err) done(err);
//                 var user = objs[0].owner;

//                 Follow.map(require('./repos').follows, function(err, followers) {
//                     done();
//                 });
//             });
//         });

//         describe('proxies', function() {
//             describe('User', function() {
//                 it('followersProxy', function() {
//                     User.map({id: '5'}, function(err, obj) {
//                         assert.ok(obj['followersProxy']);
//                     });
//                 });

//                 it('followingProxy', function() {
//                       User.map({id: '5'}, function(err, obj) {
//                         assert.ok(obj['followingProxy']);
//                     });
//                 });
//             });


    

//         });


//     });


// });
},{}],94:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;


// describe('pouch doc adapter', function () {

//     var Collection = require('../src/collection').Collection;

//     var InternalSiestaError = require('../src/error').InternalSiestaError;
//     var RelationshipType = require('../src/relationship').RelationshipType;

//     var SiestaModel = require('../src/object').SiestaModel;
//     var cache = require('../src/cache');
//     var coreChanges = require('../src/changes');
//     var ChangeType = coreChanges.ChangeType;

//     beforeEach(function () {
//         s.reset(true);
//     });

//     describe('from pouch to siesta', function () {
//         describe('new', function () {

//             describe('simple', function () {
//                 var collection;
//                 beforeEach(function (done) {
//                     collection = new Collection('myCollection');
//                     collection.mapping('Person', {
//                         id: 'id',
//                         attributes: ['name', 'age'],
//                         indexes: ['name', 'age']
//                     });
//                     collection.install(done);
//                 });

//                 it('absorbs properties', function () {
//                     var doc = {name: 'Michael', type: 'Person', collection: 'myCollection', age: 23, _id: 'randomId', _rev: 'randomRev'};
//                     var obj = s.ext.storage.Pouch.toNew(doc);
//                     assert.equal(obj.name, 'Michael');
//                     assert.equal(obj.age, 23);
//                     assert.ok(obj.isSaved);
//                 });

//             });

//         });

//         describe('toSiesta', function () {

//             var collection, personMapping;

//             beforeEach(function (done) {
//                 collection = new Collection('MyOnlineCollection');
//                 personMapping = collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['age', 'name']
//                 });
//                 collection.install(done);
//             });

//             it('existing', function (done) {
//                 var doc = {name: 'Michael', age: 12, _id: 'localId', collection: 'MyOnlineCollection', type: 'Person'};
//                 s.ext.storage.Pouch.getPouch().put(doc, function (err, resp) {
//                     if (err) done(err);
//                     collection.Person.map({_id: 'localId', age: 23}, function (err, person) {
//                         if (err) done(err);
//                         assert.equal(person._id, doc._id);
//                         collection.save(function (err) {
//                             if (err) done(err);
//                             s.ext.storage.Pouch.getPouch().get(person._id, function (err, doc) {
//                                 if (err) done(err);
//                                 var objs = s.ext.storage.Pouch.toSiesta([doc]);
//                                 assert.equal(objs.length, 1);
//                                 assert.equal(objs[0], person);
//                                 done();
//                             });
//                         });
//                     });
//                 });
//             });

//             it('new', function (done) {
//                 collection.Person.map({name: 'Michael', age: 23}, function (err, person) {
//                     if (err) done(err);
//                     collection.save(function (err) {
//                         if (err) done(err);
//                         s.ext.storage.Pouch.getPouch().get(person._id, function (err, doc) {
//                             if (err) done(err);
//                             doc._id = 'randomid';
//                             doc._rev = 'randomrev';
//                             doc.id = 'randomremoteid';
//                             if (err) done(err);
//                             var objs = s.ext.storage.Pouch.toSiesta([doc]);
//                             assert.equal(objs.length, 1);
//                             assert.notEqual(objs[0], person);
//                             assert.instanceOf(objs[0], SiestaModel);
//                             done();
//                         });
//                     });
//                 });
//             });

//             it('cached', function (done) {
//                 collection.Person.map({name: 'Michael', age: 23, id: '2'}, function (err, person) {
//                     if (err) done(err);
//                     collection.save(function (err) {
//                         if (err) done(err);
//                         s.ext.storage.Pouch.getPouch().get(person._id, function (err, doc) {
//                             if (err) done(err);
//                             var objs = s.ext.storage.Pouch.toSiesta([doc]);
//                             assert.equal(objs.length, 1);
//                             assert.equal(objs[0], person);
//                             assert.instanceOf(objs[0], SiestaModel);
//                             done();
//                         });
//                     });
//                 });
//             })


//         });

//         describe('validation', function () {
//             it('No API field', function () {
//                 assert.throw(_.bind(s.ext.storage.Pouch._validate, s.ext.storage.Pouch, {type: 'Car'}), InternalSiestaError);
//             });

//             it('No type field', function (done) {
//                 var collection = new Collection('myCollection');
//                 collection.install(function (err) {
//                     if (err) done(err);
//                     assert.throw(_.bind(s.ext.storage.Pouch._validate, s.ext.storage.Pouch, {collection: 'myCollection'}), InternalSiestaError);
//                     done();
//                 });
//             });

//             it('non existent API', function () {
//                 assert.throw(_.bind(s.ext.storage.Pouch._validate, s.ext.storage.Pouch, {collection: 'myCollection', type: 'Car'}), InternalSiestaError);
//             });

//             it('non existent type', function (done) {
//                 var collection = new Collection('myCollection');
//                 collection.install(function (err) {
//                     if (err) done(err);
//                     assert.throw(_.bind(s.ext.storage.Pouch._validate, s.ext.storage.Pouch, {collection: 'myCollection', type: 'Car'}), InternalSiestaError);
//                     done();
//                 });
//             });

//             it('valid', function (done) {
//                 var collection = new Collection('myCollection');
//                 collection.mapping('Person', {
//                     id: 'id',
//                     attributes: ['name', 'age'],
//                     indexes: ['name', 'age']
//                 });
//                 collection.install(function (err) {
//                     if (err) done(err);
//                     var mapping = s.ext.storage.Pouch._validate({name: 'Michael', type: 'Person', collection: 'myCollection', age: 23});
//                     assert.ok(mapping);
//                     done();
//                 });
//             });

//         });

//         describe('changes', function () {
//             var collection, carMapping;
//             beforeEach(function (done) {
//                 collection = new Collection('myCollection');

//                 carMapping = collection.mapping('Car', {
//                     id: 'id',
//                     attributes: ['name', 'colour']
//                 });
//                 collection.install(done);

//             });

//             it('pouch adapter should apply unmerged s.ext.storage.changes', function (done) {
//                 var doc = {
//                     collection: 'myCollection',
//                     type: 'Car',
//                     colour: 'red',
//                     _id: 'localId',
//                     name: 'Aston Martin'
//                 };
//                 s.ext.storage.Pouch.getPouch().put(doc, function (err, resp) {
//                     if (err) done(err);
//                     doc._rev = resp.rev;
//                     s.ext.storage.changes.registerChange({
//                         collection: collection._name,
//                         mapping: carMapping.type,
//                         field: 'colour',
//                         type: ChangeType.Set,
//                         new: 'blue',
//                         old: 'red',
//                         _id: 'localId'
//                     });
//                     s.ext.storage.changes.registerChange({
//                         collection: collection._name,
//                         mapping: carMapping.type,
//                         field: 'name',
//                         type: ChangeType.Set,
//                         new: 'Bentley',
//                         old: 'Aston Martin',
//                         _id: 'localId'
//                     });
//                     var models = s.ext.storage.Pouch.toSiesta([doc]);
//                     assert.equal(models[0].colour, 'blue');
//                     assert.equal(models[0].name, 'Bentley');
//                     done();
//                 });

//             });
//         });


//     });

//     describe('from siesta to pouch', function () {

//         var collection, personMapping, carMapping;

//         beforeEach(function (done) {
//             collection = new Collection('myCollection');
//             personMapping = collection.mapping('Person', {
//                 id: 'id',
//                 attributes: ['name', 'age'],
//                 indexes: ['name', 'age']
//             });
//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['name', 'colour'],
//                 relationships: {
//                     owner: {
//                         mapping: 'Person',
//                         type: RelationshipType.OneToMany,
//                         reverse: 'cars'
//                     }
//                 }
//             });
//             collection.install(done);
//         });

//         it('should convert objects with no relationships successfully', function (done) {
//             personMapping.map({name: 'Michael', age: 23, id: 'xyz'}, function (err, person) {
//                 if (err) done(err);
//                 var adapted = s.ext.storage.Pouch.from(person);
//                 assert.equal(adapted.name, 'Michael');
//                 assert.equal(adapted.age, 23);
//                 assert.equal(adapted.id, 'xyz');
//                 assert.equal(adapted._id, person._id);
//                 assert.equal(adapted.type, person.mapping.type);
//                 assert.equal(adapted.collection, person.collection);
//                 done();
//             });
//         });

//         it('should convert objects with relationship successfully', function (done) {
//             personMapping.map({name: 'Michael', age: 23, id: 'xyz'}, function (err, person) {
//                 if (err) done(err);
//                 carMapping.map({name: 'Aston Martin', id: 'xyz123', owner: {_id: person._id}}, function (err, car) {
//                     if (err) done(err);
//                     var adapted = s.ext.storage.Pouch.from(car);
//                     assert.equal(adapted.name, 'Aston Martin');
//                     assert.equal(adapted.id, 'xyz123');
//                     assert.equal(adapted._id, car._id);
//                     assert.equal(adapted.type, car.mapping.type);
//                     assert.equal(adapted.collection, car.collection);
//                     assert.equal(adapted.owner, person._id);
//                     done();
//                 });
//             });

//         });


//     });

// });
},{}],95:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;

// describe('new object proxy', function () {

//     var RelationshipProxy = require('../src/proxy').RelationshipProxy;
//     var OneToOneProxy = require('../src/oneToOneProxy').OneToOneProxy;
//     var OneToManyProxy = require('../src/oneToManyProxy').OneToManyProxy;
//     var ManyToManyProxy = require('../src/manyToManyProxy').ManyToManyProxy;
//     var SiestaModel = require('../src/object').SiestaModel;
//     var Fault = require('../src/proxy').Fault;
//     var InternalSiestaError = require('../src/error').InternalSiestaError;
//     var Collection = require('../src/collection').Collection;
//     var cache = require('../src/cache');
//     var ChangeType = require('../src/changes').ChangeType;

//     var carMapping, personMapping;

//     var collection;

//     beforeEach(function (done) {
//         s.reset(true);
//         collection = new Collection('myCollection');
//         carMapping = collection.mapping('Car', {
//             id: 'id',
//             attributes: ['colour', 'name']
//         });
//         personMapping = collection.mapping('Person', {
//             id: 'id',
//             attributes: ['name', 'age']
//         });
//         collection.install(done);
//     });

//     describe('foreign key', function () {
//         var carProxy, personProxy;
//         var car, person;

//         describe('get', function () {
//             beforeEach(function () {
//                 carProxy = new OneToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owner'
//                 });
//                 personProxy = new OneToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owner'
//                 });
//                 car = new SiestaModel(carMapping);
//                 car._id = 'car';
//                 carProxy.install(car);
//                 person = new SiestaModel(personMapping);
//                 person._id = 'person';
//                 personProxy.install(person);
//                 cache.insert(person);
//                 cache.insert(car);
//             });


//         });

//         describe('set', function () {
//             var carProxy, personProxy;
//             var car, person;
//             beforeEach(function () {
//                 carProxy = new OneToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owner'
//                 });
//                 personProxy = new OneToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owner'
//                 });
//                 car = new SiestaModel(carMapping);
//                 car._id = 'car';
//                 carProxy.install(car);
//                 carProxy.isFault = false;
//                 person = new SiestaModel(personMapping);
//                 person._id = 'person';
//                 personProxy.install(person);
//                 personProxy.isFault = false;
//             });
       
//             describe('pre-existing', function () {

//                 var anotherPerson, anotherPersonProxy;

//                 beforeEach(function () {
//                     anotherPerson = new SiestaModel(personMapping);
//                     anotherPerson._id = 'anotherPerson';
//                     anotherPersonProxy = new OneToManyProxy({
//                         reverseMapping: personMapping,
//                         forwardMapping: carMapping,
//                         reverseName: 'cars',
//                         forwardName: 'owner'
//                     });
//                     anotherPersonProxy.install(anotherPerson);
//                     anotherPersonProxy.isFault = false;
//                     cache.insert(anotherPerson);
//                     cache.insert(person);
//                     cache.insert(car);
//                 });

//                 describe('no fault', function () {
//                     beforeEach(function () {
//                         car.owner = anotherPerson;
//                     });
//                     describe('forward', function () {

//                         it('generates correct s.ext.storage.changes', function () {
//                             car.owner = person;
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 2);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             var secondAnotherPersonChange = anotherPersonChanges[1];
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.equal(personChange.index, 0);
//                             assert.equal(personChange.added.length, 1);
//                             assert.include(personChange.added, car);
//                             assert.equal(personChange.addedId.length, 1);
//                             assert.include(personChange.addedId, car._id);
//                             assert.equal(personChange.type, ChangeType.Splice);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1, 'First change addedId populated');
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(secondAnotherPersonChange.mapping, 'Person');
//                             assert.equal(secondAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(secondAnotherPersonChange.field, 'cars');
//                             assert.equal(secondAnotherPersonChange.index, 0);
//                             assert.equal(secondAnotherPersonChange.added.length, 0);
//                             assert.equal(secondAnotherPersonChange.removedId.length, 1);
//                             assert.include(secondAnotherPersonChange.removedId, car._id);
//                             assert.equal(secondAnotherPersonChange.removed.length, 1);
//                             assert.include(secondAnotherPersonChange.removed, car);
//                             assert.equal(secondAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owner');
//                             assert.equal(secondCarChange.new, person);
//                             assert.equal(secondCarChange.newId, person._id);
//                             assert.equal(secondCarChange.old, anotherPerson);
//                             assert.equal(secondCarChange.oldId, anotherPerson._id);
//                             assert.equal(secondCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owner');
//                             assert.equal(firstCarChange.newId, anotherPerson._id);
//                             assert.equal(firstCarChange.new, anotherPerson);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                         });

//                     });
//                     describe('backwards', function () {
//                         it('generates correct s.ext.storage.changes', function () {
//                             person.cars = [car];
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 2);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             var secondAnotherPersonChange = anotherPersonChanges[1];
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.notOk(personChange.old);
//                             assert.notOk(personChange.oldId);
//                             assert.equal(personChange.new.length, 1);
//                             assert.equal(personChange.newId.length, 1);
//                             assert.include(personChange.newId, car._id);
//                             assert.include(personChange.new, car);
//                             assert.equal(personChange.type, ChangeType.Set);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.removedId.length, 0);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.equal(secondAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(secondAnotherPersonChange.mapping, 'Person');
//                             assert.equal(secondAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(secondAnotherPersonChange.field, 'cars');
//                             assert.equal(secondAnotherPersonChange.index, 0);
//                             assert.equal(secondAnotherPersonChange.added.length, 0);
//                             assert.equal(secondAnotherPersonChange.addedId.length, 0);
//                             assert.equal(secondAnotherPersonChange.removed.length, 1);
//                             assert.equal(secondAnotherPersonChange.removedId.length, 1);
//                             assert.include(secondAnotherPersonChange.removedId, car._id);
//                             assert.include(secondAnotherPersonChange.removed, car);
//                             assert.equal(secondAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owner');
//                             assert.equal(secondCarChange.newId, person._id);
//                             assert.equal(secondCarChange.new, person);
//                             assert.equal(secondCarChange.old, anotherPerson);
//                             assert.equal(secondCarChange.oldId, anotherPerson._id);
//                             assert.equal(secondCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owner');
//                             assert.equal(firstCarChange.new, anotherPerson);
//                             assert.equal(firstCarChange.newId, anotherPerson._id);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                         });
//                     });
//                 });

//                 describe('fault', function () {
//                     beforeEach(function () {
//                         car.owner = anotherPerson;
//                         carProxy.related = undefined;
//                         anotherPersonProxy.related = undefined;
//                     });
//                     describe('forward', function () {
//                         it('generates correct s.ext.storage.changes', function () {
//                             car.owner = person;
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 2);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             var secondAnotherPersonChange = anotherPersonChanges[1];
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.equal(personChange.index, 0);
//                             assert.equal(personChange.addedId.length, 1);
//                             assert.include(personChange.addedId, car._id);
//                             assert.equal(personChange.added.length, 1);
//                             assert.include(personChange.added, car);
//                             assert.equal(personChange.type, ChangeType.Splice);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(secondAnotherPersonChange.mapping, 'Person');
//                             assert.equal(secondAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(secondAnotherPersonChange.field, 'cars');
//                             assert.equal(secondAnotherPersonChange.removed.length, 1);
//                             assert.include(secondAnotherPersonChange.removed, car);
//                             assert.equal(secondAnotherPersonChange.removedId.length, 1);
//                             assert.include(secondAnotherPersonChange.removedId, car._id);
//                             assert.equal(secondAnotherPersonChange.type, ChangeType.Delete);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owner');
//                             assert.equal(secondCarChange.new, person);
//                             // Due to the fault.
//                             assert.notOk(secondCarChange.old);
//                             assert.equal(secondCarChange.newId, person._id);
//                             assert.equal(secondCarChange.oldId, anotherPerson._id);
//                             assert.equal(secondCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owner');
//                             assert.equal(firstCarChange.newId, anotherPerson._id);
//                             assert.equal(firstCarChange.new, anotherPerson);
//                             assert.notOk(firstCarChange.old);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                         });

//                     });
//                     describe('backwards', function () {

//                         it('generates correct s.ext.storage.changes', function () {
//                             person.cars = [car];
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 2);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             var secondAnotherPersonChange = anotherPersonChanges[1];
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.notOk(personChange.old);
//                             assert.equal(personChange.newId.length, 1);
//                             assert.include(personChange.newId, car._id);
//                             assert.equal(personChange.new.length, 1);
//                             assert.include(personChange.new, car);
//                             assert.equal(personChange.newId.length, 1);
//                             assert.include(personChange.newId, car._id);
//                             assert.equal(personChange.type, ChangeType.Set);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.removedId.length, 0);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(secondAnotherPersonChange.mapping, 'Person');
//                             assert.equal(secondAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(secondAnotherPersonChange.field, 'cars');
//                             assert.equal(secondAnotherPersonChange.removed.length, 1);
//                             assert.include(secondAnotherPersonChange.removed, car);
//                             assert.equal(secondAnotherPersonChange.removedId.length, 1);
//                             assert.include(secondAnotherPersonChange.removedId, car._id);
//                             assert.equal(secondAnotherPersonChange.type, ChangeType.Delete);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owner');
//                             assert.equal(secondCarChange.newId, person._id);
//                             assert.equal(secondCarChange.oldId, anotherPerson._id);
//                             assert.equal(secondCarChange.new, person);
//                             // Due to fault.
//                             assert.notOk(secondCarChange.old);
//                             assert.equal(secondCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owner');
//                             assert.equal(firstCarChange.newId, anotherPerson._id);
//                             assert.equal(firstCarChange.new, anotherPerson);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                         });

//                     });
//                 });


//             });
//         });



//     });

//     describe('many to many', function () {
//         var carProxy, personProxy;
//         var car, person;

//         describe('get', function () {
//             beforeEach(function () {
//                 carProxy = new ManyToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owners'
//                 });
//                 personProxy = new ManyToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owners'
//                 });
//                 car = new SiestaModel(carMapping);
//                 car._id = 'car';
//                 carProxy.install(car);
//                 person = new SiestaModel(personMapping);
//                 person._id = 'person';
//                 personProxy.install(person);
//                 cache.insert(person);
//                 cache.insert(car);
//             });


//         });

//         describe('set', function () {
//             var carProxy, personProxy;
//             var car, person;
//             beforeEach(function () {
//                 carProxy = new ManyToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owners'
//                 });
//                 personProxy = new ManyToManyProxy({
//                     reverseMapping: personMapping,
//                     forwardMapping: carMapping,
//                     reverseName: 'cars',
//                     forwardName: 'owners'
//                 });
//                 car = new SiestaModel(carMapping);
//                 car._id = 'car';
//                 carProxy.install(car);
//                 carProxy.isFault = false;
//                 person = new SiestaModel(personMapping);
//                 person._id = 'person';
//                 personProxy.install(person);
//                 personProxy.isFault = false;
//             });

//             describe('pre-existing', function () {

//                 var anotherPerson, anotherPersonProxy;

//                 beforeEach(function () {
//                     anotherPerson = new SiestaModel(personMapping);
//                     anotherPerson._id = 'anotherPerson';
//                     anotherPersonProxy = new ManyToManyProxy({
//                         reverseMapping: personMapping,
//                         forwardMapping: carMapping,
//                         reverseName: 'cars',
//                         forwardName: 'owners'
//                     });
//                     anotherPersonProxy.install(anotherPerson);
//                     anotherPersonProxy.isFault = false;
//                     cache.insert(anotherPerson);
//                     cache.insert(person);
//                     cache.insert(car);
//                 });

//                 describe('no fault', function () {
//                     beforeEach(function () {
//                         car.owners = [anotherPerson];
//                     });

//                     describe('forward', function () {
//                         it('generates correct s.ext.storage.changes', function () {
//                             car.owners = [person];
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 2);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             var secondAnotherPersonChange = anotherPersonChanges[1];
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.equal(personChange.index, 0);
//                             assert.equal(personChange.addedId.length, 1);
//                             assert.include(personChange.addedId, car._id);
//                             assert.equal(personChange.added.length, 1);
//                             assert.include(personChange.added, car);
//                             assert.equal(personChange.type, ChangeType.Splice);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(secondAnotherPersonChange.mapping, 'Person');
//                             assert.equal(secondAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(secondAnotherPersonChange.field, 'cars');
//                             assert.equal(secondAnotherPersonChange.index, 0);
//                             assert.equal(secondAnotherPersonChange.added.length, 0);
//                             assert.equal(secondAnotherPersonChange.removedId.length, 1);
//                             assert.include(secondAnotherPersonChange.removedId, car._id);
//                             assert.equal(secondAnotherPersonChange.removed.length, 1);
//                             assert.include(secondAnotherPersonChange.removed, car);
//                             assert.equal(secondAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owners');
//                             assert.equal(secondCarChange.old.length, 1);
//                             assert.equal(secondCarChange.new.length, 1);
//                             assert.include(secondCarChange.new, person);
//                             assert.equal(secondCarChange.newId.length, 1);
//                             assert.include(secondCarChange.newId, person._id);
//                             assert.equal(secondCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owners');
//                             assert.equal(firstCarChange.new.length, 1);
//                             assert.include(firstCarChange.new, anotherPerson);
//                             assert.equal(firstCarChange.newId.length, 1);
//                             assert.include(firstCarChange.newId, anotherPerson._id);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                         });

//                     });

//                     describe('backwards', function () {
//                         it('generates correct s.ext.storage.changes', function () {
//                             person.cars = [car];
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 1);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.notOk(personChange.old);
//                             assert.equal(personChange.new.length, 1);
//                             assert.include(personChange.new, car);
//                             assert.equal(personChange.newId.length, 1);
//                             assert.include(personChange.newId, car._id);
//                             assert.equal(personChange.type, ChangeType.Set);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.removedId.length, 0);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owners');
//                             assert.equal(secondCarChange.index, 1);
//                             assert.equal(secondCarChange.type, ChangeType.Splice);
//                             assert.include(secondCarChange.added, person);
//                             assert.include(secondCarChange.addedId, person._id);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owners');
//                             assert.include(firstCarChange.new, anotherPerson);
//                             assert.include(firstCarChange.newId, anotherPerson._id);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                         });
//                     });
//                 });

//                 describe('fault', function () {
//                     beforeEach(function () {
//                         car.owners = [anotherPerson];
//                         carProxy.related = undefined;
//                         anotherPersonProxy.related = undefined;
//                     });
//                     describe('forward', function () {
//                         it('generates correct s.ext.storage.changes', function () {
//                             car.owners = [person];
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 2);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             var secondAnotherPersonChange = anotherPersonChanges[1];
//                             assert.equal(personChange.type, ChangeType.Splice);
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.equal(personChange.index, 0);
//                             assert.equal(personChange.addedId.length, 1);
//                             assert.include(personChange.addedId, car._id);
//                             assert.equal(personChange.added.length, 1);
//                             assert.include(personChange.added, car);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.equal(firstAnotherPersonChange.removedId.length, 0);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(secondAnotherPersonChange.type, ChangeType.Delete);
//                             assert.equal(secondAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(secondAnotherPersonChange.mapping, 'Person');
//                             assert.equal(secondAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(secondAnotherPersonChange.field, 'cars');
//                             assert.equal(secondAnotherPersonChange.removed.length, 1);
//                             assert.include(secondAnotherPersonChange.removed, car);
//                             assert.equal(secondAnotherPersonChange.removedId.length, 1);
//                             assert.include(secondAnotherPersonChange.removedId, car._id);
//                             assert.equal(secondCarChange.type, ChangeType.Set);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owners');
//                             assert.equal(secondCarChange.oldId.length, 1);
//                             assert.equal(secondCarChange.newId.length, 1);
//                             assert.include(secondCarChange.new, person);
//                             assert.include(secondCarChange.newId, person._id);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owners');
//                             assert.equal(firstCarChange.new.length, 1);
//                             assert.equal(firstCarChange.newId.length, 1);
//                             assert.include(firstCarChange.new, anotherPerson);
//                             assert.include(firstCarChange.newId, anotherPerson._id);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                         });

//                     });

//                     describe('backwards', function () {
//                         it('generates correct s.ext.storage.changes', function () {
//                             person.cars = [car];
//                             var carChanges = s.ext.storage.changes.changesForIdentifier(car._id);
//                             assert.equal(carChanges.length, 2);
//                             var personChanges = s.ext.storage.changes.changesForIdentifier(person._id);
//                             assert.equal(personChanges.length, 1);
//                             var anotherPersonChanges = s.ext.storage.changes.changesForIdentifier(anotherPerson._id);
//                             assert.equal(anotherPersonChanges.length, 1);
//                             var personChange = personChanges[0];
//                             var firstCarChange = carChanges[0];
//                             var secondCarChange = carChanges[1];
//                             var firstAnotherPersonChange = anotherPersonChanges[0];
//                             assert.equal(personChange.type, ChangeType.Set);
//                             assert.equal(personChange.collection, 'myCollection');
//                             assert.equal(personChange.mapping, 'Person');
//                             assert.equal(personChange._id, person._id);
//                             assert.equal(personChange.field, 'cars');
//                             assert.notOk(personChange.old);
//                             assert.equal(personChange.new.length, 1);
//                             assert.equal(personChange.newId.length, 1);
//                             assert.include(personChange.newId, car._id);
//                             assert.include(personChange.new, car);
//                             assert.equal(firstAnotherPersonChange.type, ChangeType.Splice);
//                             assert.equal(firstAnotherPersonChange.collection, 'myCollection');
//                             assert.equal(firstAnotherPersonChange.mapping, 'Person');
//                             assert.equal(firstAnotherPersonChange._id, anotherPerson._id);
//                             assert.equal(firstAnotherPersonChange.field, 'cars');
//                             assert.equal(firstAnotherPersonChange.index, 0);
//                             assert.equal(firstAnotherPersonChange.added.length, 1);
//                             assert.equal(firstAnotherPersonChange.addedId.length, 1);
//                             assert.include(firstAnotherPersonChange.addedId, car._id);
//                             assert.include(firstAnotherPersonChange.added, car);
//                             assert.equal(firstAnotherPersonChange.removed.length, 0);
//                             assert.equal(firstAnotherPersonChange.removedId.length, 0);
//                             assert.equal(secondCarChange.type, ChangeType.Splice);
//                             assert.equal(secondCarChange.collection, 'myCollection');
//                             assert.equal(secondCarChange.mapping, 'Car');
//                             assert.equal(secondCarChange._id, car._id);
//                             assert.equal(secondCarChange.field, 'owners');
//                             assert.equal(secondCarChange.index, 1);
//                             assert.include(secondCarChange.addedId, person._id);
//                             assert.include(secondCarChange.added, person);
//                             assert.equal(firstCarChange.type, ChangeType.Set);
//                             assert.equal(firstCarChange.collection, 'myCollection');
//                             assert.equal(firstCarChange.mapping, 'Car');
//                             assert.equal(firstCarChange._id, car._id);
//                             assert.equal(firstCarChange.field, 'owners');
//                             assert.include(firstCarChange.new, anotherPerson);
//                             assert.include(firstCarChange.newId, anotherPerson._id);
//                             assert.notOk(firstCarChange.old);
//                             assert.notOk(firstCarChange.oldId);
//                         });


//                     });

//                 });



//             });
//         })


//     });
// });


},{}],96:[function(require,module,exports){
// var s = require('../../index')
//     , assert = require('chai').assert;

// describe('proxy integration', function () {

//     var Collection = require('../../src/collection').Collection;
//     var cache = require('../../src/cache');
//     var RelationshipType = require('../../src/relationship').RelationshipType;

//     var carMapping, personMapping;

//     var collection;

//     beforeEach(function (done) {
//         s.reset(true);
//         collection = new Collection('myCollection');
//         carMapping = collection.mapping('Car', {
//             id: 'id',
//             attributes: ['colour', 'name'],
//             relationships: {
//                 owner: {
//                     type: RelationshipType.OneToMany,
//                     reverse: 'cars',
//                     mapping: 'Person'
//                 }
//             }
//         });
//         personMapping = collection.mapping('Person', {
//             id: 'id',
//             attributes: ['name', 'age']
//         });
//         collection.install(done);
//     });

//     it('xyz', function (done) {
//         carMapping.map({
//             colour: 'red',
//             name: 'Aston Martin', owner: {
//                 name: 'Michael Ford',
//                 age: 2,
//                 id: 2
//             },
//             id: 5
//         }, function (err, car) {
//             if (err) done(err);
//             collection.save(function (err) {
//                 if (err) done(err);
//                 cache.reset();
//                 personMapping.get(2, function (err, p) {
//                     var proxy = p.carsProxy;
//                     assert.ok(p.cars.isFault);
//                     p.carsProxy.get(function (err, cars) {
//                         assert.equal(cars.length, 1);
//                         done(err);
//                     });
//                 });
//             });
//         });
//     });

// });
},{}],97:[function(require,module,exports){
// var s = require('../../index'),
//     assert = require('chai').assert;

// describe('mapping queries', function() {

//     var SiestaModel = require('../../src/object').SiestaModel;
//     var Collection = require('../../src/collection').Collection;
//     var RelationshipType = require('../../src/relationship').RelationshipType;
//     var cache = require('../../src/cache');

//     beforeEach(function() {
//         s.reset(true);
//     });

//     describe('queries', function() {
//         var collection, mapping;
//         beforeEach(function(done) {
//             collection = new Collection('myCollection');
//             mapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['color', 'name']
//             });
//             collection.install(function(err) {
//                 if (err) done(err);
//                 s.ext.storage.Pouch.getPouch().bulkDocs([{
//                     type: 'Car',
//                     id: 4,
//                     color: 'red',
//                     name: 'Aston Martin',
//                     collection: 'myCollection'
//                 }, {
//                     type: 'Car',
//                     id: 5,
//                     color: 'blue',
//                     name: 'Ford',
//                     collection: 'myCollection'
//                 }], function(err) {
//                     done(err);
//                 });
//             });
//         });


//         it('all', function(done) {
//             cache.reset();
//             mapping.all(function(err, cars) {
//                 if (err) done(err);
//                 assert.equal(cars.length, 2);
//                 _.each(cars, function(car) {
//                     assert.instanceOf(car, SiestaModel);
//                 });
//                 done();
//             });
//         });

//         it('query', function(done) {
//             this.timeout(10000);
//             cache.reset();
//             mapping.query({
//                 color: 'red'
//             }, function(err, cars) {
//                 if (err) done(err);
//                 assert.equal(cars.length, 1);
//                 _.each(cars, function(car) {
//                     assert.instanceOf(car, SiestaModel);
//                 });
//                 done();
//             });
//         });

//         it('get', function(done) {
//             cache.reset();
//             mapping.get(4, function(err, car) {
//                 if (err) done(err);
//                 assert.ok(car);
//                 assert.instanceOf(car, SiestaModel);
//                 assert.equal(car.color, 'red');
//                 done();
//             });
//         });

//     });

//     describe('reverse', function() {
//         var carMapping, personMapping;

//         var collection;

//         beforeEach(function(done) {
//             collection = new Collection('myCollection');
//             carMapping = collection.mapping('Car', {
//                 id: 'id',
//                 attributes: ['colour', 'name'],
//                 relationships: {
//                     owner: {
//                         type: RelationshipType.OneToMany,
//                         reverse: 'cars',
//                         mapping: 'Person'
//                     }
//                 }
//             });
//             personMapping = collection.mapping('Person', {
//                 id: 'id',
//                 attributes: ['name', 'age']
//             });
//             collection.install(done);
//         });


//         it('not cached', function(done) {
//             this.timeout(5000);
//             carMapping.map({
//                 colour: 'red',
//                 name: 'Aston Martin',
//                 owner: {
//                     name: 'Michael Ford',
//                     age: 2,
//                     id: '2'
//                 },
//                 id: 5
//             }, function(err, car) {
//                 if (err) done(err);
//                 collection.save(function(err) {
//                     if (err) done(err);
//                     cache.reset();
//                     personMapping.get('2', function(err, p) {
//                         if (err) done(err);
//                         assert.ok(p, 'Should be able to fetch the person');
//                         p.carsProxy.get(function(err, cars) {
//                             if (err) done(err);
//                             try {
//                                 assert.equal(cars.length, 1);
//                             } catch (err) {
//                                 done(err);
//                             }
//                             cars[0].owner.get(function(err, owner) {
//                                 if (err) done(err);
//                                 assert.equal(cars[0].owner, p);
//                                 done();
//                             })

//                         });
//                     });
//                 });
//             });
//         });
//     });


// });
},{}],98:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;

// describe('query', function () {
//     var Query = require('../src/query').Query;
//     var Collection = require('../src/collection').Collection;
//     var SiestaModel = require('../src/object').SiestaModel;

//     beforeEach(function () {
//         s.reset(true);
//     });

//     // TODO: Storage

//     // describe('raw query', function () {
//     //     it('design doc name', function () {
//     //         var name = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'})._getDesignDocName();
//     //         assert.equal(name, '_design/myCollection_Index_Car_colour_name');
//     //     });


//     //     it('fields', function () {
//     //         var q = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'});
//     //         var fields = q._getFields();
//     //         assert.include(fields, 'colour');
//     //         assert.include(fields, 'name');
//     //     });

//     //     it('construct key', function () {
//     //         var q = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'});
//     //         var key = q._constructKey();
//     //         assert.equal(key, 'red_Aston Martin');
//     //     });

//     //     it('execute with no rows and no index', function (done) {
//     //         this.timeout(10000); // Can take quite a long time sometimes.
//     //         var q = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'});
//     //         q.execute(function (err, results) {
//     //             if (done) done(err);
//     //             assert.equal(results.length, 0);
//     //             done();
//     //         });
//     //     });

//     //     it('execute with index', function (done) {
//     //         var q = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'});
//     //         var i = new s.ext.storage.Index('myCollection', 'Car', ['colour', 'name']);
//     //         i.install(function (err) {
//     //             if (err) done(err);
//     //             q.execute(function (err, results) {
//     //                 if (done) done(err);
//     //                 assert.equal(results.length, 0);
//     //                 done();
//     //             });
//     //         });
//     //     });

//     //     it('execute with index with rows', function (done) {
//     //         var q = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'});
//     //         var i = new s.ext.storage.Index('myCollection', 'Car', ['colour', 'name']);
//     //         i.install(function (err) {
//     //             if (err) done(err);
//     //             s.ext.storage.Pouch.getPouch().post({'type': 'Car', colour: 'red', name: 'Aston Martin', collection: 'myCollection'}, function (err) {
//     //                 if (err) done(err);
//     //                 q.execute(function (err, results) {
//     //                     if (done) done(err);
//     //                     assert.equal(results.length, 1);
//     //                     done();
//     //                 });
//     //             });
//     //         });
//     //     });

//     //     it('execute without index with rows', function (done) {
//     //         this.timeout(10000); // Can take quite a long time sometimes.
//     //         var q = new s.ext.storage.RawQuery('myCollection', 'Car', {colour: 'red', name: 'Aston Martin'});
//     //         s.ext.storage.Pouch.getPouch().post({'type': 'Car', colour: 'red', name: 'Aston Martin', collection: 'myCollection'}, function (err) {
//     //             if (err) done(err);
//     //             q.execute(function (err, results) {
//     //                 if (done) done(err);
//     //                 assert.equal(results.length, 1);
//     //                 done();
//     //             });
//     //         });
//     //     });


//     // });

//     // describe('query', function () {
//     //     var collection, mapping;

//     //     it('asdasd', function (done) {
//     //         collection = new Collection('myCollection');
//     //         mapping = collection.mapping('Person', {
//     //             id: 'id',
//     //             attributes: ['name', 'age']
//     //         });
//     //         collection.install(function (err) {
//     //             if (err) done(err);
//     //             s.ext.storage.Pouch.getPouch().post({type: 'Person', age: 23, collection: 'myCollection', name: 'Michael'}, function (err, resp) {
//     //                 if (err) done(err);
//     //                 var q = new Query(mapping, {age: 23});
//     //                 q.execute(function (err, objs) {
//     //                     if (err) done(err);
//     //                     try {
//     //                         assert.ok(objs.length);
//     //                         _.each(objs, function (obj) {
//     //                             assert.instanceOf(obj, SiestaModel);
//     //                         });
//     //                         done();
//     //                     }
//     //                     catch (err) {
//     //                         done(err);
//     //                     }

//     //                 });
//     //             });
//     //         });


//     //     })
//     // });


// });
},{}],99:[function(require,module,exports){
// var s = require('../../index')
//     , assert = require('chai').assert;

// describe('raw query behaviour', function () {

//     beforeEach(function () {
//         s.reset(true);
//     });

//     describe('data types', function () {

//         describe('indexed', function () {
//             describe('singular', function () {

//                 beforeEach(function (done) {
//                     var index = new s.ext.storage.Index('myCollection', 'Car', ['id']);
//                     index.install(done);
//                 });

//                 it('string', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 'blah'
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 'blah'});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('numeric', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 5
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 5});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('numeric with string query', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 5
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: '5'});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('string with numeric query', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: '5'
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 5});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });


//             });

//             describe('multiple', function () {

//                 beforeEach(function (done) {
//                     var index = new s.ext.storage.Index('myCollection', 'Car', ['id', 'colour', 'age']);
//                     index.install(done);
//                 });

//                 it('numeric', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 5,
//                         age: 2
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 5, colour: 'red', age: 2});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('string', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: '5',
//                         age: 2
//                     }, function (err) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: '5', colour: 'red', age: 2});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });




//             });
//         });

//         describe('not indexed', function () {
//             describe('singular', function () {

//                 it('string', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 'blah'
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 'blah'});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('numeric', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 5
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 5});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('numeric with string query', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 5
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: '5'});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//                 it('string with numeric query', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: '5'
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 5});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });


//             });

//             describe('multiple', function () {


//                 it('numeric', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: 5,
//                         age: 2
//                     }, function (err, resp) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: 5, colour: 'red', age: 2});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });  

//                 it('string', function (done) {
//                     s.ext.storage.Pouch.getPouch().post({
//                         type: 'Car',
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         collection: 'myCollection',
//                         id: '5',
//                         age: 2
//                     }, function (err) {
//                         if (err) {
//                             done(err);
//                         }
//                         else {
//                             var q = new s.ext.storage.RawQuery('myCollection', 'Car', {id: '5', colour: 'red', age: 2});
//                             q.execute(function (err, docs) {
//                                 if (err) done(err);
//                                 assert.equal(docs.length, 1);
//                                 done();
//                             });
//                         }
//                     });
//                 });

//             });
//         });

//     });

// });
},{}],100:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;

// describe('singleton mapping', function () {

//     var SiestaModel = require('../src/object').SiestaModel;
//     var Collection = require('../src/collection').Collection;
//     var cache = require('../src/cache');
//     var store = require('../src/store');

//     var collection, carMapping;

//     function CarObject() {
//         SiestaModel.apply(this, arguments);
//     }

//     CarObject.prototype = Object.create(SiestaModel.prototype);

//     beforeEach(function (done) {
//         s.reset(true);
//         collection = new Collection('Car');
//         carMapping = collection.mapping('Car', {
//             id: 'id',
//             attributes: ['colour', 'name'],
//             singleton: true
//         });
//         collection.install(done);
//     });


//     it('store should return singleton', function (done) {
//         this.timeout(5000);
//         carMapping.map({colour: 'red', id: 5}, function (err, car) {
//             if (err) done(err);
//             collection.save(function (err) {
//                 if (err) done(err);
//                 cache.reset();
//                 store.get({mapping: carMapping}, function (err, obj) {
//                     if (err) done(err);
//                     assert.equal(obj._id, car._id);
//                     done();
//                 });
//             });
//         });
//     });



// });
},{}],101:[function(require,module,exports){
// var siesta = require('../index');
// var assert = require('chai').assert;

// describe('statistics', function() {
//     var Car, Person, coll;

//     var Collection = require('../src/collection').Collection;
//     var cache = require('../src/cache');

//     beforeEach(function(done) {
//         siesta.reset(true);
//         coll = new Collection('myCollection');
//         Car = coll.mapping('Car', {
//             id: 'id',
//             attributes: ['colour', 'name'],
//             relationships: {
//                 owner: {
//                     mapping: 'Person',
//                     type: 'OneToMany',
//                     reverse: 'cars'
//                 }
//             }
//         });
//         Person = coll.mapping('Person', {
//             id: 'id',
//             attributes: ['age', 'name']
//         });
//         coll.install(done);
//     });

//     describe('no faults', function() {
//         describe('collection level', function() {
//             describe('single mapping', function() {
//                 it('no objects', function(done) {
//                     coll.count(function(err, n) {
//                         if (err) done(err);
//                         assert.equal(n, 0);
//                         done();
//                     });
//                 });

//                 it('one object', function(done) {
//                     Car.map({
//                         colour: 'red',
//                         name: 'Aston Martin'
//                     }, function(err, obj) {
//                         if (err) done(err);
//                         coll.count(function(err, n) {
//                             if (err) done(err);
//                             assert.equal(n, 1);
//                             done();
//                         });
//                     });
//                 });

//                 it('multiple objects', function(done) {
//                     Car.map([{
//                         colour: 'red',
//                         name: 'Aston Martin'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo'
//                     }], function(err) {
//                         if (err) done(err);
//                         coll.count(function(err, n) {
//                             if (err) done(err);
//                             assert.equal(n, 3);
//                             done();
//                         });
//                     });
//                 });
//             });
//             describe('multiple mappings', function() {
//                 it('multiple objects', function(done) {
//                     Car.map([{
//                         colour: 'red',
//                         name: 'Aston Martin'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo'
//                     }], function(err) {
//                         if (err) done(err);
//                         Person.map([{
//                             age: 24,
//                             name: 'Michael Ford'
//                         }, {
//                             age: 25,
//                             name: 'John Doe'
//                         }], function(err) {
//                             if (err) done(err);
//                             coll.count(function(err, n) {
//                                 if (err) done(err);
//                                 assert.equal(n, 5);
//                                 done();
//                             });
//                         });
//                     });
//                 });
//             });
//         });
//     });
//     describe('all faulted', function() {
//         describe('collection level', function() {
//             describe('single mapping', function() {
//                 it('one object', function(done) {
//                     Car.map({
//                         colour: 'red',
//                         name: 'Aston Martin'
//                     }, function(err, obj) {
//                         if (err) done(err);
//                         siesta.save(function(err) {
//                             if (err) done(err);
//                             cache.reset();
//                             coll.count(function(err, n) {
//                                 if (err) done(err);
//                                 assert.equal(n, 1);
//                                 done();
//                             });
//                         });
//                     });
//                 });

//                 it('multiple objects', function(done) {
//                     Car.map([{
//                         colour: 'red',
//                         name: 'Aston Martin'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo'
//                     }], function(err) {
//                         if (err) done(err);
//                         siesta.save(function(err) {
//                             if (err) done(err);
//                             cache.reset();
//                             coll.count(function(err, n) {
//                                 if (err) done(err);
//                                 assert.equal(n, 3);
//                                 done();
//                             });
//                         });
//                     });
//                 });
//             });
//             describe('multiple mappings', function() {
//                 it('multiple objects', function(done) {
//                     Car.map([{
//                         colour: 'red',
//                         name: 'Aston Martin'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo'
//                     }], function(err) {
//                         if (err) done(err);

//                         Person.map([{
//                             age: 24,
//                             name: 'Michael Ford'
//                         }, {
//                             age: 25,
//                             name: 'John Doe'
//                         }], function(err) {
//                             if (err) done(err);
//                             siesta.save(function(err) {
//                                 if (err) done(err);
//                                 cache.reset();
//                                 cache.reset();
//                                 coll.count(function(err, n) {
//                                     if (err) done(err);
//                                     assert.equal(n, 5);
//                                     done();
//                                 });
//                             });
//                         });
//                     });

//                 });
//             });
//         });

//     });
//     describe('some faulted', function() {
//         describe('collection level', function() {
//             describe('single mapping', function() {
//                 it('multiple objects', function(done) {
//                     Car.map([{
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         id: '1'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley',
//                         id: '2'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo',
//                         id: '3'
//                     }], function(err, objs) {
//                         if (err) done(err);
//                         siesta.save(function(err) {
//                             if (err) done(err);
//                             delete cache._localCache()[objs[1]._id];
//                             coll.count(function(err, n) {
//                                 if (err) done(err);
//                                 assert.equal(n, 3);
//                                 done();
//                             });
//                         });
//                     });
//                 });
//             });
//             describe('multiple mappings', function() {
//                 it('multiple objects', function(done) {
//                     Car.map([{
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         id: '1'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley',
//                         id: '2'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo',
//                         id: '3'
//                     }], function(err, cars) {
//                         if (err) done(err);
//                         Person.map([{
//                             age: 24,
//                             name: 'Michael Ford',
//                             id: '4'
//                         }, {
//                             age: 25,
//                             name: 'John Doe',
//                             id: '5'
//                         }], function(err, people) {
//                             if (err) done(err);
//                             siesta.save(function(err) {
//                                 if (err) done(err);
//                                 delete cache._localCache()[cars[1]._id];
//                                 delete cache._localCache()[people[1]._id];
//                                 coll.count(function(err, n) {
//                                     if (err) done(err);
//                                     assert.equal(n, 5);
//                                     done();
//                                 });
//                             });
//                         });
//                     });

//                 });
//             });
//         });

//     });


//     describe('all faulted, then mapped again', function() {
//         describe('collection level', function() {
//             describe('single mapping', function() {
//                 it('one object', function(done) {
//                     var data = {
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         id: '1'
//                     };
//                     Car.map(data, function(err) {
//                         if (err) done(err);
//                         siesta.save(function(err) {
//                             if (err) done(err);
//                             cache.reset();
//                             Car.map(data, function(err) {
//                                 if (err) done(err);
//                                 coll.count(function(err, n) {
//                                     if (err) done(err);
//                                     assert.equal(n, 1);
//                                     done();
//                                 });
//                             });
//                         });
//                     });
//                 });

//                 it('multiple objects', function(done) {
//                     var data = [{
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         id: '1'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley',
//                         id: '2'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo',
//                         id: '3'
//                     }];
//                     Car.map(data, function(err) {
//                         if (err) done(err);
//                         siesta.save(function(err) {
//                             if (err) done(err);
//                             cache.reset();
//                             Car.map(data, function(err) {
//                                 if (err) done(err);
//                                 coll.count(function(err, n) {
//                                     if (err) done(err);
//                                     assert.equal(n, 3);
//                                     done();
//                                 });
//                             });
//                         });
//                     });
//                 });
//             });
//             describe('multiple mappings', function() {
//                 it('multiple objects', function(done) {
//                     var carData = [{
//                         colour: 'red',
//                         name: 'Aston Martin',
//                         id: '1'
//                     }, {
//                         colour: 'blue',
//                         name: 'Bentley',
//                         id: '2'
//                     }, {
//                         colour: 'green',
//                         name: 'Lambo',
//                         id: '3'
//                     }];
//                     Car.map(carData, function(err) {
//                         if (err) done(err);
//                         var personData = [{
//                             age: 24,
//                             name: 'Michael Ford',
//                             id: '4'
//                         }, {
//                             age: 25,
//                             name: 'John Doe',
//                             id: '5'
//                         }];
//                         Person.map(personData, function(err) {
//                             if (err) done(err);
//                             siesta.save(function(err) {
//                                 if (err) done(err);
//                                 cache.reset();
//                                 Car.map(carData, function(err) {
//                                     if (err) done(err);
//                                     Person.map(personData, function(err) {
//                                         if (err) done(err);
//                                         siesta.save(function(err) {
//                                             if (err) done(err);
//                                             var pouch = siesta.ext.storage.Pouch.getPouch();
//                                             pouch.query(function(doc) {
//                                                 if (doc.type == 'Car') {
//                                                     emit(doc._id, doc);
//                                                 }
//                                             }, function(err, resp) {
//                                                 dump('err', err);
//                                                 dump('resp', resp);
//                                                 coll.count(function(err, n) {
//                                                     if (err) done(err);
//                                                     assert.equal(n, 5);
//                                                     done();
//                                                 });
//                                             });

//                                         });
//                                     });
//                                 });
//                             });
//                         });
//                     });

//                 });
//             });
//         });

//     });



// });
},{}],102:[function(require,module,exports){
// var s = require('../index')
//     , assert = require('chai').assert;

// describe('store', function () {
//     var Store = require('../src/store');
//     var SiestaModel = require('../src/object').SiestaModel;
//     var Collection = require('../src/collection').Collection;
//     var cache = require('../src/cache');

//     var carMapping, collection;

//     beforeEach(function (done) {
//         s.reset(true);
//         collection = new Collection('myCollection');
//         carMapping = collection.mapping('Car', {
//             id: 'id',
//             attributes: ['colour', 'name']
//         });
//         collection.install(done);
//     });

//     describe('get', function () {

//         it('in pouch, have _id', function (done) {
//             var pouchid = 'pouchId';
//             s.ext.storage.Pouch.getPouch().put({type: 'Car', collection: 'myCollection', colour: 'red', _id: pouchid}, function (err, doc) {
//                 if (err) done(err);
//                 Store.get({_id: pouchid}, function (err, obj) {
//                     if (err) done(err);
//                     var cachedObject = cache.get({_id: obj._id});
//                     try {
//                         assert.equal(cachedObject, obj);
//                         done();
//                     }
//                     catch (err) {
//                         done(err);
//                     }
//                 });
//             });
//         });

//         it('in pouch, dont have _id', function (done) {
//             var pouchid = 'pouchId';
//             var remoteId = 'xyz';
//             s.ext.storage.Pouch.getPouch().put({type: 'Car', collection: 'myCollection', colour: 'red', _id: pouchid, id: remoteId}, function (err, doc) {
//                 if (err) done(err);
//                 Store.get({id: remoteId, mapping: carMapping}, function (err, doc) {
//                     if (err) done(err);
//                     done();
//                 });
//             });
//         });

//         describe('multiple', function () {

//             describe('getMultiple', function () {

//                 describe('not cached', function () {
//                     beforeEach(function (done) {
//                         s.ext.storage.Pouch.getPouch().bulkDocs(
//                             [
//                                 {type: 'Car', collection: 'myCollection', colour: 'red', _id: 'localId1', id: 'remoteId1'},
//                                 {type: 'Car', collection: 'myCollection', colour: 'blue', _id: 'localId2', id: 'remoteId2'},
//                                 {type: 'Car', collection: 'myCollection', colour: 'green', _id: 'localId3', id: 'remoteId3'}
//                             ],
//                             function (err) {
//                                 done(err);
//                             }
//                         );
//                     });
//                     it('getMultiple should return multiple', function (done) {
//                         Store.getMultiple([
//                             {_id: 'localId1'},
//                             {_id: 'localId2'},
//                             {_id: 'localId3'}
//                         ], function (err, docs) {
//                             if (err) done(err);
//                             _.each(docs, function (d) {
//                                 assert.instanceOf(d, SiestaModel);
//                             });
//                             done();
//                         });
//                     });

//                     it('get should proxy to getMultiple if _id is an array', function (done) {
//                         Store.get({_id: ['localId1', 'localId2', 'localId3']}, function (err, docs) {
//                             if (err) done(err);
//                             _.each(docs, function (d) {
//                                 assert.instanceOf(d, SiestaModel);
//                             });
//                             done();
//                         });
//                     });


//                 });

//             });

//             describe('getMultipleLocal', function () {

//                 describe('not cached', function () {

//                     beforeEach(function (done) {
//                         s.ext.storage.Pouch.getPouch().bulkDocs(
//                             [
//                                 {type: 'Car', collection: 'myCollection', colour: 'red', _id: 'localId1', id: 'remoteId1'},
//                                 {type: 'Car', collection: 'myCollection', colour: 'blue', _id: 'localId2', id: 'remoteId2'},
//                                 {type: 'Car', collection: 'myCollection', colour: 'green', _id: 'localId3', id: 'remoteId3'}
//                             ],
//                             function (err) {
//                                 done(err);
//                             }
//                         );
//                     });

//                     it('xyz', function (done) {
//                         Store.getMultipleLocal(['localId1', 'localId2', 'localId3'], function (err, docs) {
//                             if (err) done(err);
//                             assert.equal(docs.length, 3);
//                             _.each(docs, function (d) {
//                                 assert.instanceOf(d, SiestaModel);
//                             });
//                             done();
//                         })
//                     })
//                 });
//                 describe('partially cached', function () {
//                     var cars;

//                     beforeEach(function (done) {
//                         var o = carMapping._new({colour: 'red', id: 'remoteId1'});
//                         var o2 = carMapping._new({colour: 'green', id: 'remoteId3'});
//                         cars = [o, o2];
//                         cache.insert(o);
//                         cache.insert(o2);
//                         s.ext.storage.Pouch.getPouch().bulkDocs(
//                             [
//                                 {type: 'Car', collection: 'myCollection', colour: 'blue', _id: 'localId2', id: 'remoteId2'}
//                             ],
//                             function (err) {
//                                 done(err);
//                             }
//                         );
//                     });

//                     it('xyz', function (done) {
//                         var localIdentifiers = _.pluck(cars, '_id');
//                         localIdentifiers.push('localId2');
//                         Store.getMultipleLocal(localIdentifiers, function (err, docs) {
//                             if (err) done(err);
//                             assert.equal(docs.length, 3);
//                             _.each(docs, function (d) {
//                                 assert.instanceOf(d, SiestaModel);
//                             });
//                             done();
//                         })
//                     })
//                 });

//             });

//             describe('getMultipleRemote', function () {
//                 describe('not cached', function () {

//                     beforeEach(function (done) {
//                         s.ext.storage.Pouch.getPouch().bulkDocs(
//                             [
//                                 {type: 'Car', collection: 'myCollection', colour: 'red', _id: 'localId1', id: 'remoteId1'},
//                                 {type: 'Car', collection: 'myCollection', colour: 'blue', _id: 'localId2', id: 'remoteId2'},
//                                 {type: 'Car', collection: 'myCollection', colour: 'green', _id: 'localId3', id: 'remoteId3'}
//                             ],
//                             function (err) {
//                                 done(err);
//                             }
//                         );
//                     });

//                     it('xyz', function (done) {
//                         Store.getMultipleRemote(['remoteId1', 'remoteId2', 'remoteId3'], carMapping, function (err, docs) {
//                             if (err) done(err);
//                             assert.equal(docs.length, 3);
//                             _.each(docs, function (d) {
//                                 assert.instanceOf(d, SiestaModel);
//                             });
//                             done();
//                         })
//                     })
//                 });
//                 describe('partially cached', function () {
//                     var cars;

//                     beforeEach(function (done) {
//                         carMapping.map([
//                             {colour: 'red', id: 'remoteId1'},
//                             {colour: 'green', id: 'remoteId3'}
//                         ], function (err, _cars) {
//                             if (err) done(err);
//                             cars = _cars;
//                             s.ext.storage.Pouch.getPouch().bulkDocs(
//                                 [
//                                     {type: 'Car', collection: 'myCollection', colour: 'blue', _id: 'localId2', id: 'remoteId2'}
//                                 ],
//                                 function (err) {
//                                     done(err);
//                                 }
//                             );
//                         });
//                     });

//                     it('xyz', function (done) {
//                         Store.getMultipleRemote(['remoteId1', 'remoteId2', 'remoteId3'], carMapping, function (err, docs) {
//                             if (err) done(err);
//                             assert.equal(docs.length, 3);
//                             _.each(docs, function (d) {
//                                 assert.instanceOf(d, SiestaModel);
//                             });
//                             done();
//                         })
//                     })


//                 });

//             })


//         });

//     });


// });
},{}],103:[function(require,module,exports){
var s = require('../index'),
    assert = require('chai').assert;

describe('store......', function() {
    var Store = require('../src/store');
    var SiestaModel = require('../src/object').SiestaModel;
    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');

    var carMapping, collection;

    beforeEach(function(done) {
        s.reset(true);
        collection = new Collection('myCollection');
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name']
        });
        collection.install(done);
    });

    describe('get', function() {
        it('already cached', function(done) {
            var model = new SiestaModel(carMapping);
            var pouchId = 'pouchId';
            model._id = pouchId;
            cache.insert(model);
            Store.get({
                _id: pouchId
            }, function(err, doc) {
                if (err) done(err);
                assert.equal(doc, model);
                done();
            });
        });

        describe('multiple', function() {

            describe('getMultiple', function() {
                //TODO
            });

            describe('getMultipleLocal', function() {
                var cars;

                beforeEach(function() {
                    var o = carMapping._new({
                        colour: 'red',
                        id: 'remoteId1'
                    });
                    var o1 = carMapping._new({
                        colour: 'blue',
                        id: 'remoteId2'
                    });
                    var o2 = carMapping._new({
                        colour: 'green',
                        id: 'remoteId3'
                    });
                    cars = [o, o1, o2];
                    cache.insert(o);
                    cache.insert(o1);
                    cache.insert(o2);
                });

                it('xyz', function(done) {
                    Store.getMultipleLocal(_.pluck(cars, '_id'), function(err, docs) {
                        if (err) done(err);
                        assert.equal(docs.length, 3);
                        _.each(docs, function(d) {
                            assert.instanceOf(d, SiestaModel);
                        });
                        done();
                    })
                })


            });

            describe('getMultipleRemote', function() {
                describe('cached', function() {

                    var cars;

                    beforeEach(function() {
                        var o = carMapping._new({
                            colour: 'red',
                            id: 'remoteId1'
                        });
                        var o1 = carMapping._new({
                            colour: 'blue',
                            id: 'remoteId2'
                        });
                        var o2 = carMapping._new({
                            colour: 'green',
                            id: 'remoteId3'
                        });
                        cars = [o, o1, o2];
                        cache.insert(o);
                        cache.insert(o1);
                        cache.insert(o2);
                    });

                    it('xyz', function(done) {
                        Store.getMultipleRemote(_.pluck(cars, 'id'), carMapping, function(err, docs) {
                            if (err) done(err);
                            assert.equal(docs.length, 3);
                            _.each(docs, function(d) {
                                assert.instanceOf(d, SiestaModel);
                            });
                            done();
                        })
                    })


                });

            })


        });

    });


});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/object":53,"../src/store":59,"chai":9}],104:[function(require,module,exports){
var s = require('../index')
    , assert = require('chai').assert;

describe('subclassing', function () {

    var SiestaModel = require('../src/object').SiestaModel;
    var InternalSiestaError = require('../src/error').InternalSiestaError;
    var Collection = require('../src/collection').Collection;
    var cache = require('../src/cache');

    var collection, carMapping;

    function CarObject() {
        SiestaModel.apply(this, arguments);
    }

    CarObject.prototype = Object.create(SiestaModel.prototype);

    beforeEach(function (done) {
        s.reset(true);
        collection = new Collection('Car');

        collection.install(done);
    });

    function installMapping(mapping, callback) {
        mapping.install(function (err) {
            if (err) callback(err);
            else {
                mapping.installRelationships();
                mapping.installReverseRelationships();
                callback();
            }
        });
    }

    it('should instantiate with subclass if present', function (done) {
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name'],
            subclass: CarObject
        });
        installMapping(carMapping, function () {
            var car = carMapping._new({colour: 'red', name: 'Aston Martin'});
            assert.instanceOf(car, CarObject);
            done();
        });

    });

    it('should instantiate with SiestaModel if not present', function (done) {
        carMapping = collection.mapping('Car', {
            id: 'id',
            attributes: ['colour', 'name']
        });
        installMapping(carMapping, function () {
            var car = carMapping._new({colour: 'red', name: 'Aston Martin'});
            assert.instanceOf(car, SiestaModel);
            done();
        });

    });

    it('should throw an error if setup prototype, but do not call super', function () {
        function CarObject() {}

        CarObject.prototype = Object.create(SiestaModel.prototype);
        assert.throws(function () {
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                subclass: CarObject
            });
        }, InternalSiestaError);
    });


    it('should throw an error if do not call super or setup prototype', function () {
        function CarObject() {
        }

        assert.throws(function () {
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                subclass: CarObject
            });
        }, InternalSiestaError);
    });

    it('should throw an error if do not use a new instance of the prototype, as this is an anti-pattern', function () {
        function CarObject() {
            SiestaModel.apply(this, arguments);
        }

        CarObject.prototype = SiestaModel.prototype;
        assert.throws(function () {
            carMapping = collection.mapping('Car', {
                id: 'id',
                attributes: ['colour', 'name'],
                subclass: CarObject
            });
        }, InternalSiestaError);
    });

});
},{"../index":1,"../src/cache":43,"../src/collection":45,"../src/error":47,"../src/object":53,"chai":9}],105:[function(require,module,exports){
var s = require('../index')
    , assert = require('chai').assert;


var util = require('../src/util');
var q = require('q');

describe('constructCallbackAndPromiseHandler', function () {
    describe('no error or result', function () {
        function doSomethingWithNoErrorOrResult (callback) {
            setTimeout(callback);
        }

        it('promise returns', function (done) {
            var deferred = q.defer();
            doSomethingWithNoErrorOrResult (util.constructCallbackAndPromiseHandler(null, deferred));
            deferred.promise.then(function () {
                done();
            });
        });

        it('callback returns', function (done) {
            doSomethingWithNoErrorOrResult (util.constructCallbackAndPromiseHandler(done));
        });

        it('promise & callback returns', function (done) {
            var deferred = q.defer();
            var callbackReturned = false;
            var promiseReturned = false;
            doSomethingWithNoErrorOrResult(util.constructCallbackAndPromiseHandler(function () {
                callbackReturned = true;
                if (callbackReturned && promiseReturned) done();
            }, deferred));
            deferred.promise.then(function () {
                promiseReturned = true;
                if (callbackReturned && promiseReturned) done();
            });
        });
    });

    describe('an error, no result', function () {
        function doSomethingWithAnError (callback) {
            setTimeout(function () {
                callback('some error');
            });
        }

        it('promise returns', function (done) {
            var deferred = q.defer();
            doSomethingWithAnError (util.constructCallbackAndPromiseHandler(null, deferred));
            deferred.promise.fail(function () {
                done();
            });
        });

        it('callback returns', function (done) {
            doSomethingWithAnError (util.constructCallbackAndPromiseHandler(function (err) {
                assert.ok(err);
                done();
            }));
        });

        it('promise & callback returns', function (done) {
            var deferred = q.defer();
            var callbackReturned = false;
            var promiseReturned = false;
            doSomethingWithAnError(util.constructCallbackAndPromiseHandler(function (err) {
                assert.ok(err);
                callbackReturned = true;
                if (callbackReturned && promiseReturned) done();
            }, deferred));
            deferred.promise.fail(function () {
                promiseReturned = true;
                if (callbackReturned && promiseReturned) done();
            });
        });
    });

    describe('no error and a single result', function () {
        function doSomethingWithNoErrorAndASingleResult (callback) {
            setTimeout(function () {
                callback(null, 'result');
            });
        }

        it('promise returns', function (done) {
            var deferred = q.defer();
            doSomethingWithNoErrorAndASingleResult(util.constructCallbackAndPromiseHandler(null, deferred));
            deferred.promise.then(function () {
                done();
            });
        });

        it('callback returns', function (done) {
            doSomethingWithNoErrorAndASingleResult (util.constructCallbackAndPromiseHandler(function (err, res) {
                assert.notOk(err);
                assert.equal(res, 'result');
                done();
            }));
        });

        it('promise & callback returns', function (done) {
            var deferred = q.defer();
            var callbackReturned = false;
            var promiseReturned = false;
            doSomethingWithNoErrorAndASingleResult(util.constructCallbackAndPromiseHandler(function () {
                callbackReturned = true;
                if (callbackReturned && promiseReturned) done();
            }, deferred));
            deferred.promise.then(function (res) {
                assert.equal(res, 'result');
                promiseReturned = true;
                if (callbackReturned && promiseReturned) done();
            });
        });

    });

    describe('no error and multiple results', function () {
        function doSomethingWithNoErrorAndMultipleResults (callback) {
            setTimeout(function () {
                callback(null, 'result1', 'result2', 'result3');
            });
        }

        it('promise returns', function (done) {
            var deferred = q.defer();
            doSomethingWithNoErrorAndMultipleResults(util.constructCallbackAndPromiseHandler(null, deferred));
            deferred.promise.then(function () {
                done();
            });
        });

        it('callback returns', function (done) {
            doSomethingWithNoErrorAndMultipleResults (util.constructCallbackAndPromiseHandler(function (err, res1, res2, res3) {
                assert.notOk(err);
                assert.equal(res1, 'result1');
                assert.equal(res2, 'result2');
                assert.equal(res3, 'result3');
                done();
            }));
        });

        it('promise & callback returns', function (done) {
            var deferred = q.defer();
            var callbackReturned = false;
            var promiseReturned = false;
            doSomethingWithNoErrorAndMultipleResults(util.constructCallbackAndPromiseHandler(function (err, res1, res2, res3) {
                try {
                    assert.equal(res1, 'result1');
                    assert.equal(res2, 'result2');
                    assert.equal(res3, 'result3');
                }
                catch (e) {
                    done(e);
                }

                callbackReturned = true;
                if (callbackReturned && promiseReturned) done();
            }, deferred));
            deferred.promise.then(function (res1, res2, res3) {
                try {
                    assert.equal(res1, 'result1');
                    // Promise resolution only accepts one result...
                    assert.notOk(res2);
                    assert.notOk(res3);
                }
                catch (e) {
                    done(e);
                }
                promiseReturned = true;
                if (callbackReturned && promiseReturned) done();
            });
        });
    });





});
},{"../index":1,"../src/util":60,"chai":9,"q":42}],106:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(global) {
  'use strict';

  var testingExposeCycleCount = global.testingExposeCycleCount;

  // Detect and do basic sanity checking on Object/Array.observe.
  function detectObjectObserve() {
    if (typeof Object.observe !== 'function' ||
        typeof Array.observe !== 'function') {
      return false;
    }

    var records = [];

    function callback(recs) {
      records = recs;
    }

    var test = {};
    var arr = [];
    Object.observe(test, callback);
    Array.observe(arr, callback);
    test.id = 1;
    test.id = 2;
    delete test.id;
    arr.push(1, 2);
    arr.length = 0;

    Object.deliverChangeRecords(callback);
    if (records.length !== 5)
      return false;

    if (records[0].type != 'add' ||
        records[1].type != 'update' ||
        records[2].type != 'delete' ||
        records[3].type != 'splice' ||
        records[4].type != 'splice') {
      return false;
    }

    Object.unobserve(test, callback);
    Array.unobserve(arr, callback);

    return true;
  }

  var hasObserve = detectObjectObserve();

  function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
      return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (navigator.getDeviceStorage) {
      return false;
    }

    try {
      var f = new Function('', 'return true;');
      return f();
    } catch (ex) {
      return false;
    }
  }

  var hasEval = detectEval();

  function isIndex(s) {
    return +s === s >>> 0 && s !== '';
  }

  function toNumber(s) {
    return +s;
  }

  function isObject(obj) {
    return obj === Object(obj);
  }

  var numberIsNaN = global.Number.isNaN || function(value) {
    return typeof value === 'number' && global.isNaN(value);
  }

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;

    return left !== left && right !== right;
  }

  var createObject = ('__proto__' in {}) ?
    function(obj) { return obj; } :
    function(obj) {
      var proto = obj.__proto__;
      if (!proto)
        return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        Object.defineProperty(newObject, name,
                             Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
    };

  var identStart = '[\$_a-zA-Z]';
  var identPart = '[\$_a-zA-Z0-9]';
  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

  function getPathCharType(char) {
    if (char === undefined)
      return 'eof';

    var code = char.charCodeAt(0);

    switch(code) {
      case 0x5B: // [
      case 0x5D: // ]
      case 0x2E: // .
      case 0x22: // "
      case 0x27: // '
      case 0x30: // 0
        return char;

      case 0x5F: // _
      case 0x24: // $
        return 'ident';

      case 0x20: // Space
      case 0x09: // Tab
      case 0x0A: // Newline
      case 0x0D: // Return
      case 0xA0:  // No-break space
      case 0xFEFF:  // Byte Order Mark
      case 0x2028:  // Line Separator
      case 0x2029:  // Paragraph Separator
        return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
      return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
      return 'number';

    return 'else';
  }

  var pathStateMachine = {
    'beforePath': {
      'ws': ['beforePath'],
      'ident': ['inIdent', 'append'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'inPath': {
      'ws': ['inPath'],
      '.': ['beforeIdent'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'beforeIdent': {
      'ws': ['beforeIdent'],
      'ident': ['inIdent', 'append']
    },

    'inIdent': {
      'ident': ['inIdent', 'append'],
      '0': ['inIdent', 'append'],
      'number': ['inIdent', 'append'],
      'ws': ['inPath', 'push'],
      '.': ['beforeIdent', 'push'],
      '[': ['beforeElement', 'push'],
      'eof': ['afterPath', 'push']
    },

    'beforeElement': {
      'ws': ['beforeElement'],
      '0': ['afterZero', 'append'],
      'number': ['inIndex', 'append'],
      "'": ['inSingleQuote', 'append', ''],
      '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
      'ws': ['afterElement', 'push'],
      ']': ['inPath', 'push']
    },

    'inIndex': {
      '0': ['inIndex', 'append'],
      'number': ['inIndex', 'append'],
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    },

    'inSingleQuote': {
      "'": ['afterElement'],
      'eof': ['error'],
      'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
      '"': ['afterElement'],
      'eof': ['error'],
      'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    }
  }

  function noop() {}

  function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
      push: function() {
        if (key === undefined)
          return;

        keys.push(key);
        key = undefined;
      },

      append: function() {
        if (key === undefined)
          key = newChar
        else
          key += newChar;
      }
    };

    function maybeUnescapeQuote() {
      if (index >= path.length)
        return;

      var nextChar = path[index + 1];
      if ((mode == 'inSingleQuote' && nextChar == "'") ||
          (mode == 'inDoubleQuote' && nextChar == '"')) {
        index++;
        newChar = nextChar;
        actions.append();
        return true;
      }
    }

    while (mode) {
      index++;
      c = path[index];

      if (c == '\\' && maybeUnescapeQuote(mode))
        continue;

      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap['else'] || 'error';

      if (transition == 'error')
        return; // parse error;

      mode = transition[0];
      action = actions[transition[1]] || noop;
      newChar = transition[2] === undefined ? c : transition[2];
      action();

      if (mode === 'afterPath') {
        return keys;
      }
    }

    return; // parse error
  }

  function isIdent(s) {
    return identRegExp.test(s);
  }

  var constructorIsPrivate = {};

  function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
      throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
      this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
      this.getValueFrom = this.compiledGetValueFromFn();
    }
  }

  // TODO(rafaelw): Make simple LRU cache
  var pathCache = {};

  function getPath(pathString) {
    if (pathString instanceof Path)
      return pathString;

    if (pathString == null || pathString.length == 0)
      pathString = '';

    if (typeof pathString != 'string') {
      if (isIndex(pathString.length)) {
        // Constructed with array-like (pre-parsed) keys
        return new Path(pathString, constructorIsPrivate);
      }

      pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
      return path;

    var parts = parsePath(pathString);
    if (!parts)
      return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
  }

  Path.get = getPath;

  function formatAccessor(key) {
    if (isIndex(key)) {
      return '[' + key + ']';
    } else {
      return '["' + key.replace(/"/g, '\\"') + '"]';
    }
  }

  Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function() {
      var pathString = '';
      for (var i = 0; i < this.length; i++) {
        var key = this[i];
        if (isIdent(key)) {
          pathString += i ? '.' + key : key;
        } else {
          pathString += formatAccessor(key);
        }
      }

      return pathString;
    },

    getValueFrom: function(obj, directObserver) {
      for (var i = 0; i < this.length; i++) {
        if (obj == null)
          return;
        obj = obj[this[i]];
      }
      return obj;
    },

    iterateObjects: function(obj, observe) {
      for (var i = 0; i < this.length; i++) {
        if (i)
          obj = obj[this[i - 1]];
        if (!isObject(obj))
          return;
        observe(obj, this[0]);
      }
    },

    compiledGetValueFromFn: function() {
      var str = '';
      var pathString = 'obj';
      str += 'if (obj != null';
      var i = 0;
      var key;
      for (; i < (this.length - 1); i++) {
        key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);
        str += ' &&\n     ' + pathString + ' != null';
      }
      str += ')\n';

      var key = this[i];
      pathString += isIdent(key) ? '.' + key : formatAccessor(key);

      str += '  return ' + pathString + ';\nelse\n  return undefined;';
      return new Function('obj', str);
    },

    setValueFrom: function(obj, value) {
      if (!this.length)
        return false;

      for (var i = 0; i < this.length - 1; i++) {
        if (!isObject(obj))
          return false;
        obj = obj[this[i]];
      }

      if (!isObject(obj))
        return false;

      obj[this[i]] = value;
      return true;
    }
  });

  var invalidPath = new Path('', constructorIsPrivate);
  invalidPath.valid = false;
  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};

  var MAX_DIRTY_CHECK_CYCLES = 1000;

  function dirtyCheck(observer) {
    var cycles = 0;
    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {
      cycles++;
    }
    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    return cycles > 0;
  }

  function objectIsEmpty(object) {
    for (var prop in object)
      return false;
    return true;
  }

  function diffIsEmpty(diff) {
    return objectIsEmpty(diff.added) &&
           objectIsEmpty(diff.removed) &&
           objectIsEmpty(diff.changed);
  }

  function diffObjectFromOldObject(object, oldObject) {
    var added = {};
    var removed = {};
    var changed = {};

    for (var prop in oldObject) {
      var newValue = object[prop];

      if (newValue !== undefined && newValue === oldObject[prop])
        continue;

      if (!(prop in object)) {
        removed[prop] = undefined;
        continue;
      }

      if (newValue !== oldObject[prop])
        changed[prop] = newValue;
    }

    for (var prop in object) {
      if (prop in oldObject)
        continue;

      added[prop] = object[prop];
    }

    if (Array.isArray(object) && object.length !== oldObject.length)
      changed.length = object.length;

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  var eomTasks = [];
  function runEOMTasks() {
    if (!eomTasks.length)
      return false;

    for (var i = 0; i < eomTasks.length; i++) {
      eomTasks[i]();
    }
    eomTasks.length = 0;
    return true;
  }

  var runEOM = hasObserve ? (function(){
    var eomObj = { pingPong: true };
    var eomRunScheduled = false;

    Object.observe(eomObj, function() {
      runEOMTasks();
      eomRunScheduled = false;
    });

    return function(fn) {
      eomTasks.push(fn);
      if (!eomRunScheduled) {
        eomRunScheduled = true;
        eomObj.pingPong = !eomObj.pingPong;
      }
    };
  })() :
  (function() {
    return function(fn) {
      eomTasks.push(fn);
    };
  })();

  var observedObjectCache = [];

  function newObservedObject() {
    var observer;
    var object;
    var discardRecords = false;
    var first = true;

    function callback(records) {
      if (observer && observer.state_ === OPENED && !discardRecords)
        observer.check_(records);
    }

    return {
      open: function(obs) {
        if (observer)
          throw Error('ObservedObject in use');

        if (!first)
          Object.deliverChangeRecords(callback);

        observer = obs;
        first = false;
      },
      observe: function(obj, arrayObserve) {
        object = obj;
        if (arrayObserve)
          Array.observe(object, callback);
        else
          Object.observe(object, callback);
      },
      deliver: function(discard) {
        discardRecords = discard;
        Object.deliverChangeRecords(callback);
        discardRecords = false;
      },
      close: function() {
        observer = undefined;
        Object.unobserve(object, callback);
        observedObjectCache.push(this);
      }
    };
  }

  /*
   * The observedSet abstraction is a perf optimization which reduces the total
   * number of Object.observe observations of a set of objects. The idea is that
   * groups of Observers will have some object dependencies in common and this
   * observed set ensures that each object in the transitive closure of
   * dependencies is only observed once. The observedSet acts as a write barrier
   * such that whenever any change comes through, all Observers are checked for
   * changed values.
   *
   * Note that this optimization is explicitly moving work from setup-time to
   * change-time.
   *
   * TODO(rafaelw): Implement "garbage collection". In order to move work off
   * the critical path, when Observers are closed, their observed objects are
   * not Object.unobserve(d). As a result, it'siesta possible that if the observedSet
   * is kept open, but some Observers have been closed, it could cause "leaks"
   * (prevent otherwise collectable objects from being collected). At some
   * point, we should implement incremental "gc" which keeps a list of
   * observedSets which may need clean-up and does small amounts of cleanup on a
   * timeout until all is clean.
   */

  function getObservedObject(observer, object, arrayObserve) {
    var dir = observedObjectCache.pop() || newObservedObject();
    dir.open(observer);
    dir.observe(object, arrayObserve);
    return dir;
  }

  var observedSetCache = [];

  function newObservedSet() {
    var observerCount = 0;
    var observers = [];
    var objects = [];
    var rootObj;
    var rootObjProps;

    function observe(obj, prop) {
      if (!obj)
        return;

      if (obj === rootObj)
        rootObjProps[prop] = true;

      if (objects.indexOf(obj) < 0) {
        objects.push(obj);
        Object.observe(obj, callback);
      }

      observe(Object.getPrototypeOf(obj), prop);
    }

    function allRootObjNonObservedProps(recs) {
      for (var i = 0; i < recs.length; i++) {
        var rec = recs[i];
        if (rec.object !== rootObj ||
            rootObjProps[rec.name] ||
            rec.type === 'setPrototype') {
          return false;
        }
      }
      return true;
    }

    function callback(recs) {
      if (allRootObjNonObservedProps(recs))
        return;

      var observer;
      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.iterateObjects_(observe);
        }
      }

      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.check_();
        }
      }
    }

    var record = {
      object: undefined,
      objects: objects,
      open: function(obs, object) {
        if (!rootObj) {
          rootObj = object;
          rootObjProps = {};
        }

        observers.push(obs);
        observerCount++;
        obs.iterateObjects_(observe);
      },
      close: function(obs) {
        observerCount--;
        if (observerCount > 0) {
          return;
        }

        for (var i = 0; i < objects.length; i++) {
          Object.unobserve(objects[i], callback);
          Observer.unobservedCount++;
        }

        observers.length = 0;
        objects.length = 0;
        rootObj = undefined;
        rootObjProps = undefined;
        observedSetCache.push(this);
      }
    };

    return record;
  }

  var lastObservedSet;

  function getObservedSet(observer, obj) {
    if (!lastObservedSet || lastObservedSet.object !== obj) {
      lastObservedSet = observedSetCache.pop() || newObservedSet();
      lastObservedSet.object = obj;
    }
    lastObservedSet.open(observer, obj);
    return lastObservedSet;
  }

  var UNOPENED = 0;
  var OPENED = 1;
  var CLOSED = 2;
  var RESETTING = 3;

  var nextObserverId = 1;

  function Observer() {
    this.state_ = UNOPENED;
    this.callback_ = undefined;
    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef
    this.directObserver_ = undefined;
    this.value_ = undefined;
    this.id_ = nextObserverId++;
  }

  Observer.prototype = {
    open: function(callback, target) {
      if (this.state_ != UNOPENED)
        throw Error('Observer has already been opened.');

      addToAll(this);
      this.callback_ = callback;
      this.target_ = target;
      this.connect_();
      this.state_ = OPENED;
      return this.value_;
    },

    close: function() {
      if (this.state_ != OPENED)
        return;

      removeFromAll(this);
      this.disconnect_();
      this.value_ = undefined;
      this.callback_ = undefined;
      this.target_ = undefined;
      this.state_ = CLOSED;
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      dirtyCheck(this);
    },

    report_: function(changes) {
      try {
        this.callback_.apply(this.target_, changes);
      } catch (ex) {
        Observer._errorThrownDuringCallback = true;
        console.error('Exception caught during observer callback: ' +
                       (ex.stack || ex));
      }
    },

    discardChanges: function() {
      this.check_(undefined, true);
      return this.value_;
    }
  }

  var collectObservers = !hasObserve;
  var allObservers;
  Observer._allObserversCount = 0;

  if (collectObservers) {
    allObservers = [];
  }

  function addToAll(observer) {
    Observer._allObserversCount++;
    if (!collectObservers)
      return;

    allObservers.push(observer);
  }

  function removeFromAll(observer) {
    Observer._allObserversCount--;
  }

  var runningMicrotaskCheckpoint = false;

  var hasDebugForceFullDelivery = hasObserve && hasEval && (function() {
    try {
      eval('%RunMicrotasks()');
      return true;
    } catch (ex) {
      return false;
    }
  })();

  global.Platform = global.Platform || {};

  global.Platform.performMicrotaskCheckpoint = function() {
    if (runningMicrotaskCheckpoint)
      return;

    if (hasDebugForceFullDelivery) {
      eval('%RunMicrotasks()');
      return;
    }

    if (!collectObservers)
      return;

    runningMicrotaskCheckpoint = true;

    var cycles = 0;
    var anyChanged, toCheck;

    do {
      cycles++;
      toCheck = allObservers;
      allObservers = [];
      anyChanged = false;

      for (var i = 0; i < toCheck.length; i++) {
        var observer = toCheck[i];
        if (observer.state_ != OPENED)
          continue;

        if (observer.check_())
          anyChanged = true;

        allObservers.push(observer);
      }
      if (runEOMTasks())
        anyChanged = true;
    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);

    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    runningMicrotaskCheckpoint = false;
  };

  if (collectObservers) {
    global.Platform.clearObservers = function() {
      allObservers = [];
    };
  }

  function ObjectObserver(object) {
    Observer.call(this);
    this.value_ = object;
    this.oldObject_ = undefined;
  }

  ObjectObserver.prototype = createObject({
    __proto__: Observer.prototype,

    arrayObserve: false,

    connect_: function(callback, target) {
      if (hasObserve) {
        this.directObserver_ = getObservedObject(this, this.value_,
                                                 this.arrayObserve);
      } else {
        this.oldObject_ = this.copyObject(this.value_);
      }

    },

    copyObject: function(object) {
      var copy = Array.isArray(object) ? [] : {};
      for (var prop in object) {
        copy[prop] = object[prop];
      };
      if (Array.isArray(object))
        copy.length = object.length;
      return copy;
    },

    check_: function(changeRecords, skipChanges) {
      var diff;
      var oldValues;
      if (hasObserve) {
        if (!changeRecords)
          return false;

        oldValues = {};
        diff = diffObjectFromChangeRecords(this.value_, changeRecords,
                                           oldValues);
      } else {
        oldValues = this.oldObject_;
        diff = diffObjectFromOldObject(this.value_, this.oldObject_);
      }

      if (diffIsEmpty(diff))
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([
        diff.added || {},
        diff.removed || {},
        diff.changed || {},
        function(property) {
          return oldValues[property];
        }
      ]);

      return true;
    },

    disconnect_: function() {
      if (hasObserve) {
        this.directObserver_.close();
        this.directObserver_ = undefined;
      } else {
        this.oldObject_ = undefined;
      }
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      if (hasObserve)
        this.directObserver_.deliver(false);
      else
        dirtyCheck(this);
    },

    discardChanges: function() {
      if (this.directObserver_)
        this.directObserver_.deliver(true);
      else
        this.oldObject_ = this.copyObject(this.value_);

      return this.value_;
    }
  });

  function ArrayObserver(array) {
    if (!Array.isArray(array))
      throw Error('Provided object is not an Array');
    ObjectObserver.call(this, array);
  }

  ArrayObserver.prototype = createObject({

    __proto__: ObjectObserver.prototype,

    arrayObserve: true,

    copyObject: function(arr) {
      return arr.slice();
    },

    check_: function(changeRecords) {
      var splices;
      if (hasObserve) {
        if (!changeRecords)
          return false;
        splices = projectArraySplices(this.value_, changeRecords);
      } else {
        splices = calcSplices(this.value_, 0, this.value_.length,
                              this.oldObject_, 0, this.oldObject_.length);
      }

      if (!splices || !splices.length)
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([splices]);
      return true;
    }
  });

  ArrayObserver.applySplices = function(previous, current, splices) {
    splices.forEach(function(splice) {
      var spliceArgs = [splice.index, splice.removed.length];
      var addIndex = splice.index;
      while (addIndex < splice.index + splice.addedCount) {
        spliceArgs.push(current[addIndex]);
        addIndex++;
      }

      Array.prototype.splice.apply(previous, spliceArgs);
    });
  };

  function PathObserver(object, path) {
    Observer.call(this);

    this.object_ = object;
    this.path_ = getPath(path);
    this.directObserver_ = undefined;
  }

  PathObserver.prototype = createObject({
    __proto__: Observer.prototype,

    get path() {
      return this.path_;
    },

    connect_: function() {
      if (hasObserve)
        this.directObserver_ = getObservedSet(this, this.object_);

      this.check_(undefined, true);
    },

    disconnect_: function() {
      this.value_ = undefined;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    iterateObjects_: function(observe) {
      this.path_.iterateObjects(this.object_, observe);
    },

    check_: function(changeRecords, skipChanges) {
      var oldValue = this.value_;
      this.value_ = this.path_.getValueFrom(this.object_);
      if (skipChanges || areSameValue(this.value_, oldValue))
        return false;

      this.report_([this.value_, oldValue, this]);
      return true;
    },

    setValue: function(newValue) {
      if (this.path_)
        this.path_.setValueFrom(this.object_, newValue);
    }
  });

  function CompoundObserver(reportChangesOnOpen) {
    Observer.call(this);

    this.reportChangesOnOpen_ = reportChangesOnOpen;
    this.value_ = [];
    this.directObserver_ = undefined;
    this.observed_ = [];
  }

  var observerSentinel = {};

  CompoundObserver.prototype = createObject({
    __proto__: Observer.prototype,

    connect_: function() {
      if (hasObserve) {
        var object;
        var needsDirectObserver = false;
        for (var i = 0; i < this.observed_.length; i += 2) {
          object = this.observed_[i]
          if (object !== observerSentinel) {
            needsDirectObserver = true;
            break;
          }
        }

        if (needsDirectObserver)
          this.directObserver_ = getObservedSet(this, object);
      }

      this.check_(undefined, !this.reportChangesOnOpen_);
    },

    disconnect_: function() {
      for (var i = 0; i < this.observed_.length; i += 2) {
        if (this.observed_[i] === observerSentinel)
          this.observed_[i + 1].close();
      }
      this.observed_.length = 0;
      this.value_.length = 0;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    addPath: function(object, path) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add paths once started.');

      var path = getPath(path);
      this.observed_.push(object, path);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = path.getValueFrom(object);
    },

    addObserver: function(observer) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add observers once started.');

      this.observed_.push(observerSentinel, observer);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = observer.open(this.deliver, this);
    },

    startReset: function() {
      if (this.state_ != OPENED)
        throw Error('Can only reset while open');

      this.state_ = RESETTING;
      this.disconnect_();
    },

    finishReset: function() {
      if (this.state_ != RESETTING)
        throw Error('Can only finishReset after startReset');
      this.state_ = OPENED;
      this.connect_();

      return this.value_;
    },

    iterateObjects_: function(observe) {
      var object;
      for (var i = 0; i < this.observed_.length; i += 2) {
        object = this.observed_[i]
        if (object !== observerSentinel)
          this.observed_[i + 1].iterateObjects(object, observe)
      }
    },

    check_: function(changeRecords, skipChanges) {
      var oldValues;
      for (var i = 0; i < this.observed_.length; i += 2) {
        var object = this.observed_[i];
        var path = this.observed_[i+1];
        var value;
        if (object === observerSentinel) {
          var observable = path;
          value = this.state_ === UNOPENED ?
              observable.open(this.deliver, this) :
              observable.discardChanges();
        } else {
          value = path.getValueFrom(object);
        }

        if (skipChanges) {
          this.value_[i / 2] = value;
          continue;
        }

        if (areSameValue(value, this.value_[i / 2]))
          continue;

        oldValues = oldValues || [];
        oldValues[i / 2] = this.value_[i / 2];
        this.value_[i / 2] = value;
      }

      if (!oldValues)
        return false;

      // TODO(rafaelw): Having observed_ as the third callback arg here is
      // pretty lame API. Fix.
      this.report_([this.value_, oldValues, this.observed_]);
      return true;
    }
  });

  function identFn(value) { return value; }

  function ObserverTransform(observable, getValueFn, setValueFn,
                             dontPassThroughSet) {
    this.callback_ = undefined;
    this.target_ = undefined;
    this.value_ = undefined;
    this.observable_ = observable;
    this.getValueFn_ = getValueFn || identFn;
    this.setValueFn_ = setValueFn || identFn;
    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this
    // at the moment because of a bug in it'siesta dependency tracking.
    this.dontPassThroughSet_ = dontPassThroughSet;
  }

  ObserverTransform.prototype = {
    open: function(callback, target) {
      this.callback_ = callback;
      this.target_ = target;
      this.value_ =
          this.getValueFn_(this.observable_.open(this.observedCallback_, this));
      return this.value_;
    },

    observedCallback_: function(value) {
      value = this.getValueFn_(value);
      if (areSameValue(value, this.value_))
        return;
      var oldValue = this.value_;
      this.value_ = value;
      this.callback_.call(this.target_, this.value_, oldValue);
    },

    discardChanges: function() {
      this.value_ = this.getValueFn_(this.observable_.discardChanges());
      return this.value_;
    },

    deliver: function() {
      return this.observable_.deliver();
    },

    setValue: function(value) {
      value = this.setValueFn_(value);
      if (!this.dontPassThroughSet_ && this.observable_.setValue)
        return this.observable_.setValue(value);
    },

    close: function() {
      if (this.observable_)
        this.observable_.close();
      this.callback_ = undefined;
      this.target_ = undefined;
      this.observable_ = undefined;
      this.value_ = undefined;
      this.getValueFn_ = undefined;
      this.setValueFn_ = undefined;
    }
  }

  var expectedRecordTypes = {
    add: true,
    update: true,
    delete: true
  };

  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
    var added = {};
    var removed = {};

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      if (!expectedRecordTypes[record.type]) {
        console.error('Unknown changeRecord type: ' + record.type);
        console.error(record);
        continue;
      }

      if (!(record.name in oldValues))
        oldValues[record.name] = record.oldValue;

      if (record.type == 'update')
        continue;

      if (record.type == 'add') {
        if (record.name in removed)
          delete removed[record.name];
        else
          added[record.name] = true;

        continue;
      }

      // type = 'delete'
      if (record.name in added) {
        delete added[record.name];
        delete oldValues[record.name];
      } else {
        removed[record.name] = true;
      }
    }

    for (var prop in added)
      added[prop] = object[prop];

    for (var prop in removed)
      removed[prop] = undefined;

    var changed = {};
    for (var prop in oldValues) {
      if (prop in added || prop in removed)
        continue;

      var newValue = object[prop];
      if (oldValues[prop] !== newValue)
        changed[prop] = newValue;
    }

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  function ArraySplice() {}

  ArraySplice.prototype = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances: function(current, currentStart, currentEnd,
                                old, oldStart, oldEnd) {
      // "Deletion" columns
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (var j = 0; j < columnCount; j++)
        distances[0][j] = j;

      for (var i = 1; i < rowCount; i++) {
        for (var j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            var north = distances[i - 1][j] + 1;
            var west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances: function(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices: function(current, currentStart, currentEnd,
                          old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];

      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);

        return [ splice ];
      } else if (oldStart == oldEnd)
        return [ newSplice(currentStart, [], currentEnd - currentStart) ];

      var ops = this.spliceOperationsFromEditDistances(
          this.calcEditDistances(current, currentStart, currentEnd,
                                 old, oldStart, oldEnd));

      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch(ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix: function(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },

    sharedSuffix: function(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;

      return count;
    },

    calculateSplices: function(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0,
                              previous.length);
    },

    equals: function(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var arraySplice = new ArraySplice();

  function calcSplices(current, currentStart, currentEnd,
                       old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd,
                                   old, oldStart, oldEnd);
  }

  function intersect(start1, end1, start2, end2) {
    // Disjoint
    if (end1 < start2 || end2 < start1)
      return -1;

    // Adjacent
    if (end1 == start2 || end2 == start1)
      return 0;

    // Non-zero intersect, span1 first
    if (start1 < start2) {
      if (end1 < end2)
        return end1 - start2; // Overlap
      else
        return end2 - start2; // Contained
    } else {
      // Non-zero intersect, span2 first
      if (end2 < end1)
        return end2 - start1; // Overlap
      else
        return end1 - start1; // Contained
    }
  }

  function mergeSplice(splices, index, removed, addedCount) {

    var splice = newSplice(index, removed, addedCount);

    var inserted = false;
    var insertionOffset = 0;

    for (var i = 0; i < splices.length; i++) {
      var current = splices[i];
      current.index += insertionOffset;

      if (inserted)
        continue;

      var intersectCount = intersect(splice.index,
                                     splice.index + splice.removed.length,
                                     current.index,
                                     current.index + current.addedCount);

      if (intersectCount >= 0) {
        // Merge the two splices

        splices.splice(i, 1);
        i--;

        insertionOffset -= current.addedCount - current.removed.length;

        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length +
                          current.removed.length - intersectCount;

        if (!splice.addedCount && !deleteCount) {
          // merged splice is a noop. discard.
          inserted = true;
        } else {
          var removed = current.removed;

          if (splice.index < current.index) {
            // some prefix of splice.removed is prepended to current.removed.
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, removed);
            removed = prepend;
          }

          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            // some suffix of splice.removed is appended to current.removed.
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(removed, append);
          }

          splice.removed = removed;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {
        // Insert splice here.

        inserted = true;

        splices.splice(i, 0, splice);
        i++;

        var offset = splice.addedCount - splice.removed.length
        current.index += offset;
        insertionOffset += offset;
      }
    }

    if (!inserted)
      splices.push(splice);
  }

  function createInitialSplices(array, changeRecords) {
    var splices = [];

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      switch(record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name))
            continue;
          var index = toNumber(record.name);
          if (index < 0)
            continue;
          mergeSplice(splices, index, [record.oldValue], 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }

    return splices;
  }

  function projectArraySplices(array, changeRecords) {
    var splices = [];

    createInitialSplices(array, changeRecords).forEach(function(splice) {
      if (splice.addedCount == 1 && splice.removed.length == 1) {
        if (splice.removed[0] !== array[splice.index])
          splices.push(splice);

        return
      };

      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,
                                           splice.removed, 0, splice.removed.length));
    });

    return splices;
  }

 // Export the observe-js object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, export as a global object.
var expose = global;
if (typeof exports !== 'undefined') {
if (typeof module !== 'undefined' && module.exports) {
expose = exports = module.exports;
}
expose = exports;
}
expose.Observer = Observer;
expose.Observer.runEOM_ = runEOM;
expose.Observer.observerSentinel_ = observerSentinel; // for testing.
expose.Observer.hasObjectObserve = hasObserve;
expose.ArrayObserver = ArrayObserver;
expose.ArrayObserver.calculateSplices = function(current, previous) {
return arraySplice.calculateSplices(current, previous);
};
expose.Platform = global.Platform;
expose.ArraySplice = ArraySplice;
expose.ObjectObserver = ObjectObserver;
expose.PathObserver = PathObserver;
expose.CompoundObserver = CompoundObserver;
expose.Path = Path;
expose.ObserverTransform = ObserverTransform;
})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],107:[function(require,module,exports){
function Logger (name) {
    if (!this) return new Logger(name);
    this.name = name;

    this.trace = constructPerformer(this, _.bind(console.debug ? console.debug : console.log, console), Logger.Level.trace);
    this.debug = constructPerformer(this, _.bind(console.debug ? console.debug  : console.log, console), Logger.Level.debug);
    this.info = constructPerformer(this, _.bind(console.info ? console.info : console.log, console), Logger.Level.info);
    this.log = constructPerformer(this, _.bind(console.log ? console.log : console.log, console), Logger.Level.info);
    this.warn = constructPerformer(this, _.bind(console.warn ? console.warn : console.log, console), Logger.Level.warning);
    this.error = constructPerformer(this, _.bind(console.error ? console.error : console.log, console), Logger.Level.error);
    this.fatal = constructPerformer(this, _.bind(console.error ? console.error : console.log, console), Logger.Level.fatal);

}

var logLevels = {};

function constructPerformer (logger, f, level) {
    var performer = function (message) {
        logger.performLog(f, level, message, arguments);
    };
    Object.defineProperty(performer, 'isEnabled', {
        get: function () {
            var currentLevel = logger.currentLevel();
            return level >= currentLevel;
        },
        enumerable: true,
        configurable: true
    });
    performer.f = f;
    performer.logger = logger;
    performer.level = level;
    return performer;
}

Logger.Level = {
    trace: 0,
    debug: 1,
    info: 2,
    warning: 3,
    warn: 3,
    error: 4,
    fatal: 5
};

Logger.LevelText = {};
Logger.LevelText [Logger.Level.trace] = 'TRACE';
Logger.LevelText [Logger.Level.debug] = 'DEBUG';
Logger.LevelText [Logger.Level.info] = 'INFO ';
Logger.LevelText [Logger.Level.warning] = 'WARN ';
Logger.LevelText [Logger.Level.error] = 'ERROR';

Logger.levelAsText = function (level) {
    return this.LevelText[level];
};

Logger.loggerWithName = function (name) {
    return new Logger(name);
};

Logger.prototype.currentLevel = function () {
    var logLevel = logLevels[this.name];
    return  logLevel ? logLevel : Logger.Level.trace;
};

Logger.prototype.setLevel = function (level) {
    logLevels[this.name] = level;
};

Logger.prototype.override = function (level, override, message) {
    var levelAsText = Logger.levelAsText(level);
    var performer = this[levelAsText.trim().toLowerCase()];
    var f = performer.f;
    var otherArguments = Array.prototype.slice.call(arguments, 3, arguments.length);
    this.performLog(f, level, message, otherArguments, override);
};

Logger.prototype.performLog = function (logFunc, level, message, otherArguments, override) {
    var self = this;
    var currentLevel = override !== undefined ? override : this.currentLevel();
    if (currentLevel <= level) {
        logFunc = _.partial(logFunc, Logger.levelAsText(level) + ' [' + self.name + ']: ' + message);
        var args = [];
        for (var i=0; i<otherArguments.length; i++) {
            args[i] = otherArguments[i];
        }
        args.splice(0, 1);
        logFunc.apply(logFunc, args);
    }
};

module.exports = Logger;

},{}],108:[function(require,module,exports){
var log = require('./log');
var Logger = log.loggerWithName('Operation');

function Operation() {
    if (!this) {
        return new (Function.prototype.bind.apply(Operation, arguments));
    }
    var self = this;
    if (arguments.length) {
        if (typeof(arguments[0]) == 'string') {
            this.name = arguments[0];
            this.work = arguments[1];
            this.completion = arguments[2];
        }
        else if (typeof(arguments[0]) == 'function' ||
            Object.prototype.toString.call(arguments[0]) === '[object Array]' ||
            arguments[0] instanceof Operation) {
            this.work = arguments[0];
            this.completion = arguments[1];
        }
    }
    this.error = null;
    this.completed = false;
    this.result = null;
    this.running = false;
    this.cancelled = false;
    this.dependencies = [];
    this._mustSucceed = [];
    this._onCompletion = [];
    this.logLevel = null; // Override.

    Object.defineProperty(this, 'failed', {
        get: function () {
            return  !!self.error || self.failedDueToDependency;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(this, 'composite', {
        get: function () {
            return self.work instanceof Operation ||
                Object.prototype.toString.call(self.work) === '[object Array]'
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(this, 'numOperationsRemaining', {
        get: function () {
            if (self.work instanceof Operation) {
                return self.work.completed ? 0 : 1
            }
            else if (Object.prototype.toString.call(self.work) === '[object Array]') {
                return _.reduce(self.work, function (memo, op) {
                    if (!op.completed) {
                        return memo + 1;
                    }
                    return memo;
                }, 0);
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(this, 'canRun', {
        get: function () {
            if (self.dependencies.length) {
                return _.reduce(self.dependencies, function (memo, dep) {
                    var mustSucceed = self._mustSucceed.indexOf(dep) > -1;
                    var canRun = memo && dep.completed;
                    if (mustSucceed && canRun) {
                        canRun = canRun && !(dep.failed || dep.cancelled);
                    }
                    return canRun;
                }, true);
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(this, 'failedDueToDependency', {
        get: function () {
            if (self.dependencies.length) {
                var failedDeps = _.reduce(self.dependencies, function (memo, dep) {
                    var mustSucceed = self._mustSucceed.indexOf(dep) > -1;
                    var failed = ((dep.failed || dep.cancelled) && mustSucceed);
                    if (failed) {
                        memo.push(dep);
                    }
                    return memo;
                }, []);
                return failedDeps.length ? failedDeps : false;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(this, 'failedDueToCancellationOfDependency', {
        get: function () {
            if (self.dependencies.length) {
                var cancelled = _.reduce(self.dependencies, function (memo, dep) {
                    var mustSucceed = self._mustSucceed.indexOf(dep) > -1;
                    if (mustSucceed) {
                        if (dep.cancelled) memo.push(dep);
                    }
                    return memo;
                }, []);
                return cancelled.length ? cancelled : false;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(this, 'loggingOveridden', {
        get: function () {
            if (self.logLevel) {
                return self.logLevel <= log.Level.info;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    })


}

Operation.running = [];

Operation.prototype._startSingle = function () {
    var self = this;
    this.work(function (err, payload) {
        self.result = payload;
        self.error = err;
        self.completed = true;
        self.running = false;
        self._complete();
    });
};

Operation.prototype._startComposite = function () {
    var self = this;
    var operations = self.work instanceof Operation ? [self.work] : self.work;
    _.each(operations, function (op) {
        op.onCompletion(function () {
            var numOperationsRemaining = self.numOperationsRemaining;
            var name = self.name || 'Unnamed';
            Logger.debug(name + ' has ' + numOperationsRemaining.toString() + ' operations remaining');
            if (!numOperationsRemaining) {
                var errors = _.pluck(operations, 'error');
                var results = _.pluck(operations, 'result');
                self.result = _.some(results) ? results : null;
                self.error = _.some(errors) ? errors : null;
                self.completed = true;
                self.running = false;
                self._complete();
            }
        });
        op.start();
    });
};

Operation.prototype._logCompletion = function () {
    var logFunc = this._getLogFunc();
    if (Logger.info.isEnabled || this.loggingOveridden) {
        var name = this.name || 'Unnamed';
        var failedDependencies = this.failedDueToDependency;
        if (failedDependencies) {
            logFunc('"' + name + '" failed due to failure/cancellation of dependencies: ' + _.pluck(failedDependencies, 'name').join(', '));
        }
        else if (this.failed) {
            var err = this.error;
            // Remove null errors.
            if (Object.prototype.toString.call(err) === '[object Array]') {
                err = _.filter(err, function (e) {return e });
            }
            else {
                err = [this.error];
            }
            logFunc('"' + name + '" failed due to errors:', err);
        }
        else if (this.cancelled) {
            logFunc('"' + name + '" has been cancelled.');
        }
        else {
            logFunc('"' + name + '" has succeeded.');
        }
    }
};

Operation.prototype._getLogFunc = function () {
    if (this.logLevel) {
        return _.bind(Logger.override, Logger, log.Level.info, this.logLevel);
    }
    return Logger.info;
};

Operation.prototype._logStart = function () {
    if (Logger.info.isEnabled || this.loggingOveridden) {
        var name = this.name || 'Unnamed';
        var logFunc = this._getLogFunc();
        logFunc('"' + name + '" has started.');
    }
};


Operation.prototype._complete = function () {
    var self = this;
    this.completed = true;
    var idx = Operation.running.indexOf(this);
    Operation.running.splice(idx, 1);
    if (this.completion) {
        _.bind(this.completion, this)();
    }
    this._logCompletion();
    _.each(this._onCompletion, function (o) {
        _.bind(o, self)();
    });
};

Operation.prototype.__start = function () {
    this._logStart();
    if (this.work) {
        if (this.composite) {
            this._startComposite();
        }
        else {
            this._startSingle();
        }
        Operation.running.push(this);
    }
    else {
        this.result = null;
        this.error = null;
        this.running = false;
        this._complete();
    }
};

Operation.prototype.start = function () {
    var self = this;
    var neverStarted = !this.running && !this.completed;
    var neverStartedAndFailed = neverStarted && this.failed;
    // A dependency failed or was cancelled before this operation started.
    if (neverStartedAndFailed) {
        this._complete();
    }
    else if (neverStarted) {
        this.running = true;
        if (this.canRun) {
            this.__start();
        }
        else {
            _.each(this.dependencies, function (dep) {
                dep.onCompletion(function () {
                    if (self.canRun) {
                        self.__start();
                    }
                })
            });
        }
    }
};


Operation.prototype.addDependency = function () {
    var self = this;
    if (arguments.length == 1) {
        this.dependencies.push(arguments[0]);
    }
    else if (arguments.length) {
        var args = arguments;
        var lastArg = args[args.length - 1];
        var mustSucceed = false;
        if (typeof(lastArg) == 'boolean') {
            args = Array.prototype.slice.call(args, 0, args.length - 1);
            mustSucceed = lastArg;
        }
        _.each(args, function (arg) {
            self.dependencies.push(arg);
        });
        if (mustSucceed) {
            _.each(args, function (arg) {
                self._mustSucceed.push(arg);
            })
        }
    }
};

Operation.prototype.onCompletion = function (o) {
    if (!this.completed) {
        this._onCompletion.push(o);
    }
    else {
        _.bind(o, this)();
    }
};

Operation.prototype.cancel = function (callback) {
    if (!this.cancelled) {
        this.cancelled = true;
        Logger.debug('Cancelling ' + this.name, this);
        if (this.composite) {
            _.each(this.work, function (subop) {
                subop.cancel();
            });
        }
        this.onCompletion(function () {
            this.running = false;
            if (callback) callback();
        });
    }
};

Object.defineProperty(Operation, 'logLevel', {
    get: function () {
        return Logger.currentLevel();
    },
    set: function (v) {
        Logger.setLevel(v);
    },
    configurable: true,
    enumerable: true
});

module.exports.Operation = Operation;

},{"./log":107}],109:[function(require,module,exports){

var log = require('./log');
var Logger = log.loggerWithName('OperationQueue');


function OperationQueue() {

    if (!this) {
        return new (Function.prototype.bind.apply(OperationQueue, arguments));
    }
    var self = this;

    if (arguments.length) {
        if (typeof(arguments[0]) == 'number') {
            this.maxConcurrentOperations = arguments[0];
        }
        else {
            this.name = arguments[0];
            this.maxConcurrentOperations = arguments[1];
        }
    }

    this._queuedOperations = [];
    this._runningOperations = [];
    this._running = false;
    this._onStart = [];
    this._onStop = [];
    this.logLevel = null;

    Object.defineProperty(this, 'numRunningOperations', {
        get: function () {
            return self._runningOperations.length;
        },
        configurable: true,
        enumerable: true
    });

    Object.defineProperty(this, 'loggingOveridden', {
        get: function () {
            if (self.logLevel) {
                return self.logLevel <= log.Level.info;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    })
}

OperationQueue.prototype._nextOperations = function () {
    var self = this;
    while ((self._runningOperations.length < self.maxConcurrentOperations) && self._queuedOperations.length) {
        var op = self._queuedOperations[0];
        self._queuedOperations.splice(0, 1);
        self._runOperation(op);
    }
};


OperationQueue.prototype._runOperation = function (op) {
    var self = this;
    for (var i = 0; i < this._queuedOperations.length; i++) {
        if (this._queuedOperations[i] == op) {
            this._queuedOperations.splice(i, 1);
            break;
        }
    }
    this._runningOperations.push(op);
    op.completion = function () {
        var idx = self._runningOperations.indexOf(op);
        self._runningOperations.splice(idx, 1);
        if (self._running) {
            self._nextOperations();
        }
        self._logStatus();
    };
    op.start();
    this._logStatus();
};

OperationQueue.prototype._logStatus = function () {
    var logFunc = this._getLogFunc();
    if (Logger.info.isEnabled || this.loggingOveridden) {
        var numRunning = this.numRunningOperations;
        var numQueued = this._queuedOperations.length;
        var name = this.name || "Unnamed Queue";
        if (numRunning && numQueued) {
            logFunc('"' + name + '" now has ' + numRunning.toString() + ' operations running and ' + numQueued.toString() + ' operations queued');
        }
        else if (numRunning) {
            logFunc('"' + name + '" now has ' + numRunning.toString() + ' operations running');
        }
        else if (numQueued) {
            logFunc('"' + name + '" now has ' + numQueued.toString() + ' operations queued');
        }
        else {
            logFunc('"' + name + '" has no operations running or queued');
        }
    }
};

OperationQueue.prototype._logStart = function () {
    var logFunc = this._getLogFunc();
    if (Logger.info.isEnabled || this.loggingOveridden) {
        var name = this.name || "Unnamed Queue";
        logFunc('"' + name + '" is now running');
    }
};

OperationQueue.prototype._getLogFunc = function () {
    if (this.logLevel) {
        return _.bind(Logger.override, Logger, log.Level.info, this.logLevel);
    }
    return Logger.info;
};


OperationQueue.prototype._logStop = function () {
    var logFunc = this._getLogFunc();
    if (Logger.info.isEnabled || this.loggingOveridden) {
        var name = this.name || "Unnamed Queue";
        logFunc('"' + name + '" is no longer running');
    }
};

OperationQueue.prototype._addOperation = function (op) {
    if (this.numRunningOperations < this.maxConcurrentOperations && this._running) {
        this._runOperation(op);
    }
    else {
        this._queuedOperations.push(op);
    }
    this._logStatus();
};

OperationQueue.prototype.addOperation = function (operationOrOperations) {
    var self = this;
    if (Object.prototype.toString.call(operationOrOperations) === '[object Array]') {
        _.each(operationOrOperations, function (op) {self._addOperation(op)});
    }
    else {
        this._addOperation(operationOrOperations);
    }
};

OperationQueue.prototype.start = function () {
    var self = this;
    var wasRunning = this._running;
    this._running = true;
    if (!wasRunning) {
        _.each(self._onStart, function (c) {
            _.bind(c, self)();
        });
        self._nextOperations();
        self._logStart();
    }
};

OperationQueue.prototype.stop = function (cancel) {
    var self = this;
    var wasRunning = this._running;
    this._running = false;
    if (wasRunning) {
        if (cancel) {
            var operations = this._runningOperations.slice(0); // Clone so not fighting callbacks.
            _.each(operations, function (o) {
                o.cancel();
            });
        }
        self._logStop();
        _.each(self._onStop, function (c) {
            _.bind(c, self)();
        });
    }
};

OperationQueue.prototype.onStart = function (o) {
    this._onStart.push(o);
};
OperationQueue.prototype.onStop = function (o) {
    this._onStop.push(o);
};

Object.defineProperty(OperationQueue, 'logLevel', {
    get: function () {
        return Logger.currentLevel();
    },
    set: function (v) {
        Logger.setLevel(v);
    },
    configurable: true,
    enumerable: true
});


module.exports.OperationQueue = OperationQueue;

},{"./log":107}]},{},[61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9pbmRleC5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9hc3luYy9saWIvYXN5bmMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaXMtYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9pbmRleC5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvYXNzZXJ0aW9uLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29uZmlnLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvY29yZS9hc3NlcnRpb25zLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvaW50ZXJmYWNlL2Fzc2VydC5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL2ludGVyZmFjZS9leHBlY3QuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS9pbnRlcmZhY2Uvc2hvdWxkLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkQ2hhaW5hYmxlTWV0aG9kLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkTWV0aG9kLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvYWRkUHJvcGVydHkuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9mbGFnLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0QWN0dWFsLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9nZXRNZXNzYWdlLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvZ2V0TmFtZS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFBhdGhWYWx1ZS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2dldFByb3BlcnRpZXMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9pbmRleC5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL2luc3BlY3QuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy9vYmpEaXNwbGF5LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlTWV0aG9kLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvb3ZlcndyaXRlUHJvcGVydHkuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9saWIvY2hhaS91dGlscy90ZXN0LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbGliL2NoYWkvdXRpbHMvdHJhbnNmZXJGbGFncy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9jaGFpL2xpYi9jaGFpL3V0aWxzL3R5cGUuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvYXNzZXJ0aW9uLWVycm9yL2luZGV4LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2luZGV4LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL2xpYi9lcWwuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvY2hhaS9ub2RlX21vZHVsZXMvZGVlcC1lcWwvbm9kZV9tb2R1bGVzL3R5cGUtZGV0ZWN0L2luZGV4LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvbm9kZV9tb2R1bGVzL2NoYWkvbm9kZV9tb2R1bGVzL2RlZXAtZXFsL25vZGVfbW9kdWxlcy90eXBlLWRldGVjdC9saWIvdHlwZS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L25vZGVfbW9kdWxlcy9leHRlbmQvaW5kZXguanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9ub2RlX21vZHVsZXMvcS9xLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvc3JjL2NhY2hlLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvc3JjL2NoYW5nZXMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvY29sbGVjdGlvbi5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3NyYy9jb2xsZWN0aW9uUmVnaXN0cnkuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvZXJyb3IuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvbWFueVRvTWFueVByb3h5LmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvc3JjL21hcHBpbmcuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvbWFwcGluZ09wZXJhdGlvbi5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3NyYy9taXNjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3Qvc3JjL25vdGlmaWNhdGlvbkNlbnRyZS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3NyYy9vYmplY3QuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvb25lVG9NYW55UHJveHkuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvb25lVG9PbmVQcm94eS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3NyYy9wcm94eS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3NyYy9xdWVyeS5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3NyYy9yZWxhdGlvbnNoaXAuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvc3RvcmUuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC9zcmMvdXRpbC5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvYnVsa01hcHBpbmdPcGVyYXRpb24uc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvY2FjaGUuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvY2hhbmdlSWRlbnRpZmllcnMuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvY29sbGVjdGlvbi5odHRwLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L2NvbGxlY3Rpb24uc2V0dXAuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvZGVzY3JpcHRvci5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9pbnRlZ3JhdGlvbi5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9tYXBwaW5nL2ludGVyY29sbGVjdGlvbi5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9tYXBwaW5nL21hcC5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9tYXBwaW5nL21hcHBpbmcuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvbWFwcGluZy9uZXcuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3QvbWFwcGluZy9xdWVyaWVzLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L21hcHBpbmcvdmFsaWRhdGlvbi5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9ub3RpZmljYXRpb25DZW50cmUuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvbm90aWZpY2F0aW9ucy5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9vYmplY3Quc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvb2JzZXJ2ZS5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9wcm94eS5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9xdWVyeS5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9yZWN1cnNpdmVSZWxhdGlvbnNoaXBzLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3JlbGF0aW9uc2hpcEluc3RhbGxhdGlvbi5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9yZXN0LnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3NlcmlhbGlzZXIuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc2luZ2xldG9uLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0YXRzLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JhZ2UvYXJyYXkuY2hhbmdlcy5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9zdG9yYWdlL2F0dHJpYnV0ZUNoYW5nZXMuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc3RvcmFnZS9idWxrTWFwcGluZ09wZXJhdGlvbi5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9zdG9yYWdlL2NoYW5nZXMuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc3RvcmFnZS9pbmRleC5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9zdG9yYWdlL2ludGVncmF0aW9uLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JhZ2UvbWFwLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JhZ2UvcGVyZm9ybWFuY2UvcGVyZm9ybWFuY2Uuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc3RvcmFnZS9wb3VjaERvY0FkYXB0ZXIuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc3RvcmFnZS9wcm94eS5jaGFuZ2VzLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JhZ2UvcHJveHkuaW50LnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JhZ2UvcXVlcmllcy5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9zdG9yYWdlL3F1ZXJ5LnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JhZ2UvcmF3cXVlcnkuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc3RvcmFnZS9zaW5nbGV0b24uc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3Rlc3Qvc3RvcmFnZS9zdGF0cy5zcGVjLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdGVzdC9zdG9yYWdlL3N0b3JlLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N0b3JlLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3N1YmNsYXNzaW5nLnNwZWMuanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC90ZXN0L3V0aWwuc3BlYy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3ZlbmRvci9vYnNlcnZlLWpzL3NyYy9vYnNlcnZlLmpzIiwiL1VzZXJzL210Zm9yZC9QbGF5Z3JvdW5kL3Jlc3QvdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL2xvZy5qcyIsIi9Vc2Vycy9tdGZvcmQvUGxheWdyb3VuZC9yZXN0L3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9vcGVyYXRpb24uanMiLCIvVXNlcnMvbXRmb3JkL1BsYXlncm91bmQvcmVzdC92ZW5kb3Ivb3BlcmF0aW9ucy5qcy9zcmMvcXVldWUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalFBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3I4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnpEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNubEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNydkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIEBtb2R1bGUgc2llc3RhXG4gKi9cblxudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL3NyYy9jb2xsZWN0aW9uJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vc3JjL3V0aWwnKTtcblxudmFyIENvbGxlY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vc3JjL2NvbGxlY3Rpb25SZWdpc3RyeScpLkNvbGxlY3Rpb25SZWdpc3RyeSxcbiAgICBDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5Db2xsZWN0aW9uLFxuICAgIGNhY2hlID0gcmVxdWlyZSgnLi9zcmMvY2FjaGUnKSxcbiAgICBNYXBwaW5nID0gcmVxdWlyZSgnLi9zcmMvbWFwcGluZycpLk1hcHBpbmcsXG4gICAgbm90aWZpY2F0aW9uQ2VudHJlID0gcmVxdWlyZSgnLi9zcmMvbm90aWZpY2F0aW9uQ2VudHJlJykubm90aWZpY2F0aW9uQ2VudHJlLFxuICAgIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL29wZXJhdGlvbicpLk9wZXJhdGlvbixcbiAgICBPcGVyYXRpb25RdWV1ZSA9IHJlcXVpcmUoJy4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL3F1ZXVlJykuT3BlcmF0aW9uUXVldWUsXG4gICAgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4vc3JjL3JlbGF0aW9uc2hpcCcpLlJlbGF0aW9uc2hpcFR5cGUsXG4gICAgbG9nID0gcmVxdWlyZSgnLi92ZW5kb3Ivb3BlcmF0aW9ucy5qcy9zcmMvbG9nJyksXG4gICAgcSA9IHJlcXVpcmUoJ3EnKSxcbiAgICBfID0gdXRpbC5fO1xuXG5cbk9wZXJhdGlvbi5sb2dMZXZlbCA9IGxvZy5MZXZlbC53YXJuO1xuT3BlcmF0aW9uUXVldWUubG9nTGV2ZWwgPSBsb2cuTGV2ZWwud2FybjtcblxuXG52YXIgc2llc3RhO1xuaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzaWVzdGEgPSBtb2R1bGUuZXhwb3J0cztcbn0gZWxzZSB7XG4gICAgc2llc3RhID0ge307XG59XG5cbi8vIHNpZXN0YS5zYXZlID0gZnVuY3Rpb24gc2F2ZShjYWxsYmFjaykge1xuLy8gICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbi8vICAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuLy8gICAgIGlmIChzaWVzdGEuZXh0LnN0b3JhZ2VFbmFibGVkKSB7XG4vLyAgICAgICAgIHV0aWwubmV4dChmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgIHZhciBtZXJnZUNoYW5nZXMgPSBzaWVzdGEuZXh0LnN0b3JhZ2UuY2hhbmdlcy5tZXJnZUNoYW5nZXM7XG4vLyAgICAgICAgICAgICBtZXJnZUNoYW5nZXMoY2FsbGJhY2spO1xuLy8gICAgICAgICB9KTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgICBjYWxsYmFjaygnU3RvcmFnZSBtb2R1bGUgbm90IGluc3RhbGxlZCcpO1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbi8vIH07XG5cbi8qKlxuICogV2lwZSBldmVyeXRoaW5nIVxuICovXG5zaWVzdGEucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBjYWNoZS5yZXNldCgpO1xuICAgIENvbGxlY3Rpb25SZWdpc3RyeS5yZXNldCgpO1xuICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVzZXQoKTtcbiAgICAvL25vaW5zcGVjdGlvbiBKU0FjY2Vzc2liaWxpdHlDaGVja1xufTtcblxuXG4vKipcbiAqIExpc3RlbiB0byBub3RpZmljYXRvbnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90aWZpY2F0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5zaWVzdGEub24gPSBfLmJpbmQobm90aWZpY2F0aW9uQ2VudHJlLm9uLCBub3RpZmljYXRpb25DZW50cmUpO1xuXG4vKipcbiAqIExpc3RlbiB0byBub3RpZmljYXRvbnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90aWZpY2F0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5zaWVzdGEuYWRkTGlzdGVuZXIgPSBzaWVzdGEub247XG5cbi8qKlxuICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBwYXJ0aWN1bGFyIG5vdGlmaWNhdGlvblxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90aWZpY2F0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5zaWVzdGEub2ZmID0gXy5iaW5kKG5vdGlmaWNhdGlvbkNlbnRyZS5yZW1vdmVMaXN0ZW5lciwgbm90aWZpY2F0aW9uQ2VudHJlKTtcblxuLyoqXG4gKiBTdG9wIGxpc3RlbmluZyB0byBhIHBhcnRpY3VsYXIgbm90aWZpY2F0aW9uXG4gKiBcbiAqIEBwYXJhbSB7U3RyaW5nfSBub3RpZmljYXRpb25OYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbnNpZXN0YS5yZW1vdmVMaXN0ZW5lciA9IHNpZXN0YS5vZmY7XG5cbi8qKlxuICogTGlzdGVuIHRvIG9uZSBhbmQgb25seSBvbmUgbm90aWZpY2F0aW9uLlxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gbm90aWZpY2F0aW9uTmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5zaWVzdGEub25jZSA9IF8uYmluZChub3RpZmljYXRpb25DZW50cmUub25jZSwgbm90aWZpY2F0aW9uQ2VudHJlKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuXG4gKi9cbnNpZXN0YS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBfLmJpbmQobm90aWZpY2F0aW9uQ2VudHJlLnJlbW92ZUFsbExpc3RlbmVycywgbm90aWZpY2F0aW9uQ2VudHJlKTtcblxuc2llc3RhLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuc2llc3RhLlJlbGF0aW9uc2hpcFR5cGUgPSBSZWxhdGlvbnNoaXBUeXBlO1xuXG4vLyBVc2VkIGJ5IG1vZHVsZXMuXG52YXIgY29yZUNoYW5nZXMgPSByZXF1aXJlKCcuL3NyYy9jaGFuZ2VzJyk7XG5cbi8vIE1ha2UgYXZhaWxhYmxlIG1vZHVsZXMgdG8gZXh0ZW5zaW9ucy5cbnNpZXN0YS5faW50ZXJuYWwgPSB7XG4gICAgbG9nOiBsb2csXG4gICAgTWFwcGluZzogTWFwcGluZyxcbiAgICBtYXBwaW5nOiByZXF1aXJlKCcuL3NyYy9tYXBwaW5nJyksXG4gICAgZXJyb3I6IHJlcXVpcmUoJy4vc3JjL2Vycm9yJyksXG4gICAgQ2hhbmdlVHlwZTogY29yZUNoYW5nZXMuQ2hhbmdlVHlwZSxcbiAgICBvYmplY3Q6IHJlcXVpcmUoJy4vc3JjL29iamVjdCcpLFxuICAgIGV4dGVuZDogcmVxdWlyZSgnZXh0ZW5kJyksXG4gICAgbm90aWZpY2F0aW9uQ2VudHJlOiByZXF1aXJlKCcuL3NyYy9ub3RpZmljYXRpb25DZW50cmUnKSxcbiAgICBjYWNoZTogcmVxdWlyZSgnLi9zcmMvY2FjaGUnKSxcbiAgICBtaXNjOiByZXF1aXJlKCcuL3NyYy9taXNjJyksXG4gICAgT3BlcmF0aW9uOiBPcGVyYXRpb24sXG4gICAgT3BlcmF0aW9uUXVldWU6IE9wZXJhdGlvblF1ZXVlLFxuICAgIGNvcmVDaGFuZ2VzOiBjb3JlQ2hhbmdlcyxcbiAgICBDb2xsZWN0aW9uUmVnaXN0cnk6IHJlcXVpcmUoJy4vc3JjL2NvbGxlY3Rpb25SZWdpc3RyeScpLkNvbGxlY3Rpb25SZWdpc3RyeSxcbiAgICBDb2xsZWN0aW9uOiBjb2xsZWN0aW9uLkNvbGxlY3Rpb24sXG4gICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbiAgICB1dGlsczogdXRpbCxcbiAgICB1dGlsOiB1dGlsLFxuICAgIF86IHV0aWwuXyxcbiAgICBxdWVyeTogcmVxdWlyZSgnLi9zcmMvcXVlcnknKSxcbiAgICBzdG9yZTogcmVxdWlyZSgnLi9zcmMvc3RvcmUnKSxcbiAgICBxOiByZXF1aXJlKCdxJylcbn07XG5cbnNpZXN0YS5wZXJmb3JtYW5jZU1vbml0b3JpbmdFbmFibGVkID0gZmFsc2U7XG5zaWVzdGEuaHR0cEVuYWJsZWQgPSBmYWxzZTtcbnNpZXN0YS5zdG9yYWdlRW5hYmxlZCA9IGZhbHNlO1xuXG5zaWVzdGEuZXh0ID0ge307XG5cbi8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWVzdGEsICdzZXRQb3VjaCcsIHtcbi8vICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBpZiAoc2llc3RhLmV4dC5zdG9yYWdlRW5hYmxlZCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIHNpZXN0YS5leHQuc3RvcmFnZS5wb3VjaC5zZXRQb3VjaDtcbi8vICAgICAgICAgfVxuLy8gICAgICAgICByZXR1cm4gbnVsbDtcbi8vICAgICB9XG4vLyB9KTtcblxuLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpZXN0YS5leHQsICdzdG9yYWdlRW5hYmxlZCcsIHtcbi8vICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBpZiAoc2llc3RhLmV4dC5fc3RvcmFnZUVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuIHNpZXN0YS5leHQuX3N0b3JhZ2VFbmFibGVkO1xuLy8gICAgICAgICB9XG4vLyAgICAgICAgIHJldHVybiAhIXNpZXN0YS5leHQuc3RvcmFnZTtcbi8vICAgICB9LFxuLy8gICAgIHNldDogZnVuY3Rpb24odikge1xuLy8gICAgICAgICBzaWVzdGEuZXh0Ll9zdG9yYWdlRW5hYmxlZCA9IHY7XG4vLyAgICAgfVxuLy8gfSk7XG5cbi8qKlxuICogVHJ1ZSBpZiBzaWVzdGEuaHR0cC5qcyBpcyBpbnN0YWxsZWQgY29ycmVjdGx5IChvciBzaWVzdGEuYnVuZGxlLmpzIGlzIGJlaW5nIHVzZWQgaW5zdGVhZCkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWVzdGEuZXh0LCAnaHR0cEVuYWJsZWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNpZXN0YS5leHQuX2h0dHBFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWVzdGEuZXh0Ll9odHRwRW5hYmxlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFzaWVzdGEuZXh0Lmh0dHA7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgc2llc3RhLmV4dC5faHR0cEVuYWJsZWQgPSB2O1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIG5ldyBDb2xsZWN0aW9uLlxuICogQHBhcmFtICB7W3R5cGVdfSBuYW1lXG4gKiBAcGFyYW0gIHtbdHlwZV19IG9wdHNcbiAqIEByZXR1cm4ge0NvbGxlY3Rpb259XG4gKi9cbnNpZXN0YS5jb2xsZWN0aW9uID0gZnVuY3Rpb24obmFtZSwgb3B0cykge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihuYW1lLCBvcHRzKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgYWpheCBmdW5jdGlvbiB0byB1c2UgZS5nLiAkLmFqYXhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFqYXhcbiAqIEBleGFtcGxlXG4gKiAvLyBVc2UgemVwdG8gaW5zdGVhZCBvZiBqUXVlcnkgZm9yIGh0dHAgYWpheCByZXF1ZXN0cy5cbiAqIHNpZXN0YS5zZXRBamF4KHplcHRvLmFqYXgpO1xuICovXG5zaWVzdGEuc2V0QWpheCA9IGZ1bmN0aW9uKGFqYXgpIHtcbiAgICBpZiAoc2llc3RhLmV4dC5odHRwRW5hYmxlZCkge1xuICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuYWpheCA9IGFqYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdodHRwIG1vZHVsZSBub3QgaW5zdGFsbGVkIGNvcnJlY3RseSAoaGF2ZSB5b3UgaW5jbHVkZWQgc2llc3RhLmh0dHAuanM/KScpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWpheCBmdW5jdGlvbiBiZWluZyB1c2VkLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnNpZXN0YS5nZXRBamF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpZXN0YS5leHQuaHR0cC5hamF4O1xufTtcblxuc2llc3RhLm5vdGlmeSA9IHV0aWwubmV4dDtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aG9zIGtleXMgbWFwIG9udG8gc3RyaW5nIGNvbnN0YW50cyB1c2VkIGZvciBsb2cgbGV2ZWxzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuc2llc3RhLkxvZ0xldmVsID0gbG9nLkxldmVsO1xuXG4vKipcbiAqIFNldHMgdGhlIGxvZyBsZXZlbCBmb3IgdGhlIG5hbWVkIGxvZ2dlclxuICogQHBhcmFtIHtTdHJpbmd9IGxvZ2dlck5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBMb2dnZXIgdXNlZCBieSBIVFRQIHJlcXVlc3QvcmVzcG9uc2UgZGVzY3JpcHRvcnMuXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ0Rlc2NyaXB0b3InLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gTG9nZ2VyIHVzZWQgYnkgcmVxdWVzdCBkZXNjcmlwdG9ycyBzcGVjaWZpY2FsbHkuXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ1JlcXVlc3REZXNjcmlwdG9yJywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIC8vIExvZ2dlciB1c2VkIGJ5IHJlc3BvbnNlIGRlc2NyaXB0b3JzIHNwZWNpZmljYWxseS5cbiAqIHNpZXN0YS5zZXRMb2dMZXZlbCgnUmVzcG9uc2VEZXNjcmlwdG9yJywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIC8vIEFsbCBkZXNjcmlwdG9ycyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgRGVzY3JpcHRvclJlZ2lzdHJ5LlxuICogc2llc3RhLnNldExvZ0xldmVsKCdEZXNjcmlwdG9yUmVnaXN0cnknLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gTG9nZ2VyIHVzZWQgYnkgSFRUUCByZXF1ZXN0cy9yZXNwb25zZXMuXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ0hUVFAnLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gT2JqZWN0cyBhcmUgY2FjaGVkIGJ5IGxvY2FsIGlkIChfaWQpIG9yIHRoZWlyIHJlbW90ZSBpZC4gVGhpcyBsb2dnZXIgaXMgdXNlZCBieSB0aGUgbG9jYWwgb2JqZWN0IGNhY2hlLlxuICogc2llc3RhLnNldExvZ0xldmVsKCdMb2NhbENhY2hlJywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIC8vIE9iamVjdHMgYXJlIGNhY2hlZCBieSBsb2NhbCBpZCAoX2lkKSBvciB0aGVpciByZW1vdGUgaWQuIFRoaXMgbG9nZ2VyIGlzIHVzZWQgYnkgdGhlIHJlbW90ZSBvYmplY3QgY2FjaGUuXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ1JlbW90ZUNhY2hlJywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIC8vIFRoZSBsb2dnZXIgdXNlZCBieSBjaGFuZ2Ugbm90aWZpY2F0aW9ucy5cbiAqIHNpZXN0YS5zZXRMb2dMZXZlbCgnY2hhbmdlcycsIHNpZXN0YS5Mb2dMZXZlbC50cmFjZSk7XG4gKiAvLyBUaGUgbG9nZ2VyIHVzZWQgYnkgdGhlIENvbGxlY3Rpb24gY2xhc3MsIHdoaWNoIGlzIHVzZWQgdG8gZGVzY3JpYmUgYSBzZXQgb2YgbWFwcGluZ3MuXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ0NvbGxlY3Rpb24nLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gVGhlIGxvZ2dlciB1c2VkIGJ5IHRoZSBNYXBwaW5nIGNsYXNzLlxuICogc2llc3RhLnNldExvZ0xldmVsKCdNYXBwaW5nJywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIC8vIFRoZSBsb2dnZXIgdXNlZCBkdXJpbmcgbWFwcGluZyBvcGVyYXRpb25zLCBpLmUuIG1hcHBpbmcgZGF0YSBvbnRvIHRoZSBvYmplY3QgZ3JhcGguXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ01hcHBpbmdPcGVyYXRpb24nLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gVGhlIGxvZ2dlciB1c2VkIGJ5IHRoZSBTaWVzdGFNb2RlbCBjbGFzcywgd2hpY2ggbWFrZXMgdXAgdGhlIGluZGl2aWR1YWwgbm9kZXMgb2YgdGhlIG9iamVjdCBncmFwaC5cbiAqIHNpZXN0YS5zZXRMb2dMZXZlbCgnU2llc3RhTW9kZWwnLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gVGhlIGxvZ2dlciB1c2VkIGJ5IHRoZSBwZXJmb3JtYW5jZSBtb25pdG9yaW5nIGV4dGVuc2lvbiAoc2llc3RhLnBlcmYuanMpXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ1BlcmZvcm1hbmNlJywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIC8vIFRoZSBsb2dnZXIgdXNlZCBkdXJpbmcgbG9jYWwgcXVlcmllcyBhZ2FpbnN0IHRoZSBvYmplY3QgZ3JhcGguXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ1F1ZXJ5Jywgc2llc3RhLkxvZ0xldmVsLnRyYWNlKTtcbiAqIHNpZXN0YS5zZXRMb2dMZXZlbCgnU3RvcmUnLCBzaWVzdGEuTG9nTGV2ZWwudHJhY2UpO1xuICogLy8gTXVjaCBsb2dpYyBpbiBTaWVzdGEgaXMgdGllZCB1cCBpbiAnT3BlcmF0aW9ucycuXG4gKiBzaWVzdGEuc2V0TG9nTGV2ZWwoJ09wZXJhdGlvbicsIHNpZXN0YS5Mb2dMZXZlbC50cmFjZSk7XG4gKiAvLyBTaWVzdGEgbWFrZXMgdXNlIG9mIHF1ZXVlcyBvZiBvcGVyYXRpb25zIGZvciBtYW5hZ2luZyBjb25jdXJyZW5jeSBhbmQgY29uY3VycmVudCBvcGVyYXRpb24gbGltaXRzLlxuICogc2llc3RhLnNldExvZ0xldmVsKCdPcGVyYXRpb25RdWV1ZScsIHNpZXN0YS5Mb2dMZXZlbC50cmFjZSk7XG4gKi9cbnNpZXN0YS5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxvZ2dlck5hbWUsIGxldmVsKSB7XG4gICAgdmFyIExvZ2dlciA9IGxvZy5sb2dnZXJXaXRoTmFtZShsb2dnZXJOYW1lKTtcbiAgICBMb2dnZXIuc2V0TGV2ZWwobGV2ZWwpO1xufTtcblxuXG5cbnNpZXN0YS5zZXJpYWxpc2VycyA9IHt9O1xuc2llc3RhLnNlcmlhbGl6ZXJzID0gc2llc3RhLnNlcmlhbGlzZXJzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2llc3RhLnNlcmlhbGlzZXJzLCAnaWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNpZXN0YS5leHQuaHR0cEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5pZFNlcmlhbGlzZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWVzdGEuc2VyaWFsaXNlcnMsICdkZXB0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc2llc3RhLmV4dC5odHRwRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZXN0YS5leHQuaHR0cC5TZXJpYWxpc2VyLmRlcHRoU2VyaWFsaXplcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KTtcblxuLy8gKiBgc2llc3RhLm1hcGAgaXMgZXF1aXZhbGVudCB0byBbXy5tYXBdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNtYXApXG4vLyAqIGBzaWVzdGEuZWFjaGAgaXMgZXF1aXZhbGVudCB0byBbXy5lYWNoXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZWFjaClcbi8vICogYHNpZXN0YS5wYXJ0aWFsYCBpcyBlcXVpdmFsZW50IHRvIFtfLnBhcnRpYWxdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNwYXJ0aWFsKVxuLy8gKiBgc2llc3RhLmJpbmRgIGlzIGVxdWl2YWxlbnQgdG8gW18uYmluZF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2JpbmQpXG4vLyAqIGBzaWVzdGEucGx1Y2tgIGlzIGVxdWl2YWxlbnQgdG8gW18ucGx1Y2tdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNwbHVjaylcbi8vICogYHNpZXN0YS5wcm9wZXJ0eWAgaXMgZXF1aXZhbGVudCB0byBbXy5wcm9wZXJ0eV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI3Byb3BlcnR5KVxuLy8gKiBgc2llc3RhLnNvcnRCeWAgaXMgZXF1aXZhbGVudCB0byBbXy5zb3J0QnldKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNzb3J0QnkpXG4vLyAqIGBzaWVzdGEucGFyYWxsZWxgIGlzIGVxdWl2YWxlbnQgdG8gW2FzeW5jLnBhcmFsbGVsXShodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jI3BhcmFsbGVsKVxuLy8gKiBgc2llc3RhLnNlcmllc2AgaXMgZXF1aXZhbGVudCB0byBbYXN5bmMuc2VyaWVzXShodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jI3Nlcmllcylcbi8vICogYHNpZXN0YS5xYCBpcyB0aGUgZW50aXJlIFtxIHByb21pc2VzIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcSlcblxuc2llc3RhLm1hcCA9IHV0aWwuXy5tYXA7XG5zaWVzdGEuZWFjaCA9IHV0aWwuXy5lYWNoO1xuc2llc3RhLnBhcnRpYWwgPSB1dGlsLl8ucGFydGlhbDtcbnNpZXN0YS5iaW5kID0gdXRpbC5fLmJpbmQ7XG5zaWVzdGEucGx1Y2sgPSB1dGlsLl8ucGx1Y2s7XG5zaWVzdGEucHJvcGVydHkgPSB1dGlsLl8ucGx1Y2s7XG5zaWVzdGEuc29ydEJ5ID0gdXRpbC5fLnNvcnRCeTtcbnNpZXN0YS5zZXJpZXMgPSB1dGlsLnNlcmllcztcbnNpZXN0YS5wYXJhbGxlbCA9IHV0aWwucGFyYWxsZWw7XG5zaWVzdGEucSA9IHE7XG5cbi8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaWVzdGEsICdpc0RpcnR5Jywge1xuLy8gICAgIGdldDogZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIHJldHVybiBDb2xsZWN0aW9uLmlzRGlydHlcbi8vICAgICB9LFxuLy8gICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbi8vICAgICBlbnVtZXJhYmxlOiB0cnVlXG4vLyB9KTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB3aW5kb3cuc2llc3RhID0gc2llc3RhO1xufVxuXG5leHBvcnRzLnNpZXN0YSA9IHNpZXN0YTsiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyohXG4gKiBhc3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Nhb2xhbi9hc3luY1xuICpcbiAqIENvcHlyaWdodCAyMDEwLTIwMTQgQ2FvbGFuIE1jTWFob25cbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG4vKmpzaGludCBvbmV2YXI6IGZhbHNlLCBpbmRlbnQ6NCAqL1xuLypnbG9iYWwgc2V0SW1tZWRpYXRlOiBmYWxzZSwgc2V0VGltZW91dDogZmFsc2UsIGNvbnNvbGU6IGZhbHNlICovXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGFzeW5jID0ge307XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHJvb3QsIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgcm9vdCA9IHRoaXM7XG4gICAgaWYgKHJvb3QgIT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNfYXN5bmMgPSByb290LmFzeW5jO1xuICAgIH1cblxuICAgIGFzeW5jLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBwcmV2aW91c19hc3luYztcbiAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBvbmx5X29uY2UoZm4pIHtcbiAgICAgICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuXCIpO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHJvb3QsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJsaXR5IGZ1bmN0aW9ucyAvLy8vXG5cbiAgICB2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuICAgIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuXG4gICAgdmFyIF9lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5mb3JFYWNoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLmZvckVhY2goaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9tYXAgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5tYXAoaXRlcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvcih4LCBpLCBhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgdmFyIF9yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWVtbykge1xuICAgICAgICBpZiAoYXJyLnJlZHVjZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoaXRlcmF0b3IsIG1lbW8pO1xuICAgICAgICB9XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGksIGEpIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvcihtZW1vLCB4LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG5cbiAgICB2YXIgX2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfTtcblxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXG5cbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8ICEocHJvY2Vzcy5uZXh0VGljaykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMuZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZG9uZSkgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaCA9IGFzeW5jLmVhY2g7XG5cbiAgICBhc3luYy5lYWNoU2VyaWVzID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2NvbXBsZXRlZF0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGl0ZXJhdGUoKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPSBhc3luYy5lYWNoU2VyaWVzO1xuXG4gICAgYXN5bmMuZWFjaExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZm4gPSBfZWFjaExpbWl0KGxpbWl0KTtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgW2FyciwgaXRlcmF0b3IsIGNhbGxiYWNrXSk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoTGltaXQgPSBhc3luYy5lYWNoTGltaXQ7XG5cbiAgICB2YXIgX2VhY2hMaW1pdCA9IGZ1bmN0aW9uIChsaW1pdCkge1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBpZiAoIWFyci5sZW5ndGggfHwgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RhcnRlZCA9IDA7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG5cbiAgICAgICAgICAgIChmdW5jdGlvbiByZXBsZW5pc2ggKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmIHN0YXJ0ZWQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihhcnJbc3RhcnRlZCAtIDFdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBkb1BhcmFsbGVsID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9QYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24obGltaXQsIGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW19lYWNoTGltaXQobGltaXQpXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvU2VyaWVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgW2FzeW5jLmVhY2hTZXJpZXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIF9hc3luY01hcCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3guaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLm1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBTZXJpZXMgPSBkb1NlcmllcyhfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcExpbWl0ID0gZnVuY3Rpb24gKGFyciwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX21hcExpbWl0KGxpbWl0KShhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBfbWFwTGltaXQgPSBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgICByZXR1cm4gZG9QYXJhbGxlbExpbWl0KGxpbWl0LCBfYXN5bmNNYXApO1xuICAgIH07XG5cbiAgICAvLyByZWR1Y2Ugb25seSBoYXMgYSBzZXJpZXMgdmVyc2lvbiwgYXMgZG9pbmcgcmVkdWNlIGluIHBhcmFsbGVsIHdvbid0XG4gICAgLy8gd29yayBpbiBtYW55IHNpdHVhdGlvbnMuXG4gICAgYXN5bmMucmVkdWNlID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKG1lbW8sIHgsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICBtZW1vID0gdjtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gaW5qZWN0IGFsaWFzXG4gICAgYXN5bmMuaW5qZWN0ID0gYXN5bmMucmVkdWNlO1xuICAgIC8vIGZvbGRsIGFsaWFzXG4gICAgYXN5bmMuZm9sZGwgPSBhc3luYy5yZWR1Y2U7XG5cbiAgICBhc3luYy5yZWR1Y2VSaWdodCA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmV2ZXJzZWQgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9KS5yZXZlcnNlKCk7XG4gICAgICAgIGFzeW5jLnJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvbGRyIGFsaWFzXG4gICAgYXN5bmMuZm9sZHIgPSBhc3luYy5yZWR1Y2VSaWdodDtcblxuICAgIHZhciBfZmlsdGVyID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcbiAgICBhc3luYy5maWx0ZXJTZXJpZXMgPSBkb1NlcmllcyhfZmlsdGVyKTtcbiAgICAvLyBzZWxlY3QgYWxpYXNcbiAgICBhc3luYy5zZWxlY3QgPSBhc3luYy5maWx0ZXI7XG4gICAgYXN5bmMuc2VsZWN0U2VyaWVzID0gYXN5bmMuZmlsdGVyU2VyaWVzO1xuXG4gICAgdmFyIF9yZWplY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMucmVqZWN0ID0gZG9QYXJhbGxlbChfcmVqZWN0KTtcbiAgICBhc3luYy5yZWplY3RTZXJpZXMgPSBkb1NlcmllcyhfcmVqZWN0KTtcblxuICAgIHZhciBfZGV0ZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soeCk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5kZXRlY3QgPSBkb1BhcmFsbGVsKF9kZXRlY3QpO1xuICAgIGFzeW5jLmRldGVjdFNlcmllcyA9IGRvU2VyaWVzKF9kZXRlY3QpO1xuXG4gICAgYXN5bmMuc29tZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFueSBhbGlhc1xuICAgIGFzeW5jLmFueSA9IGFzeW5jLnNvbWU7XG5cbiAgICBhc3luYy5ldmVyeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLmVhY2goYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbGwgYWxpYXNcbiAgICBhc3luYy5hbGwgPSBhc3luYy5ldmVyeTtcblxuICAgIGFzeW5jLnNvcnRCeSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5tYXAoYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfbWFwKHJlc3VsdHMuc29ydChmbiksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLmF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICB2YXIgcmVtYWluaW5nVGFza3MgPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICB2YXIgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXNrQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW1haW5pbmdUYXNrcy0tXG4gICAgICAgICAgICBfZWFjaChsaXN0ZW5lcnMuc2xpY2UoMCksIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRMaXN0ZW5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXJlbWFpbmluZ1Rhc2tzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBmaW5hbCBjYWxsYmFjayBmcm9tIGNhbGxpbmcgaXRzZWxmIGlmIGl0IGVycm9yc1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgICAgICAgICAgICB0aGVDYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2VhY2goa2V5cywgZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gX2lzQXJyYXkodGFza3Nba10pID8gdGFza3Nba106IFt0YXNrc1trXV07XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2VhY2goX2tleXMocmVzdWx0cyksIGZ1bmN0aW9uKHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gcmVzdWx0c1tya2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3Agc3Vic2VxdWVudCBlcnJvcnMgaGl0dGluZyBjYWxsYmFjayBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSh0YXNrQ29tcGxldGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIE1hdGguYWJzKHRhc2subGVuZ3RoIC0gMSkpIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5yZXRyeSA9IGZ1bmN0aW9uKHRpbWVzLCB0YXNrLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7XG4gICAgICAgIHZhciBhdHRlbXB0cyA9IFtdO1xuICAgICAgICAvLyBVc2UgZGVmYXVsdHMgaWYgdGltZXMgbm90IHBhc3NlZFxuICAgICAgICBpZiAodHlwZW9mIHRpbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2s7XG4gICAgICAgICAgICB0YXNrID0gdGltZXM7XG4gICAgICAgICAgICB0aW1lcyA9IERFRkFVTFRfVElNRVM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRpbWVzIGlzIGEgbnVtYmVyXG4gICAgICAgIHRpbWVzID0gcGFyc2VJbnQodGltZXMsIDEwKSB8fCBERUZBVUxUX1RJTUVTO1xuICAgICAgICB2YXIgd3JhcHBlZFRhc2sgPSBmdW5jdGlvbih3cmFwcGVkQ2FsbGJhY2ssIHdyYXBwZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgcmV0cnlBdHRlbXB0ID0gZnVuY3Rpb24odGFzaywgZmluYWxBdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soZnVuY3Rpb24oZXJyLCByZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2soIWVyciB8fCBmaW5hbEF0dGVtcHQsIHtlcnI6IGVyciwgcmVzdWx0OiByZXN1bHR9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgd3JhcHBlZFJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2hpbGUgKHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChyZXRyeUF0dGVtcHQodGFzaywgISh0aW1lcy09MSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzeW5jLnNlcmllcyhhdHRlbXB0cywgZnVuY3Rpb24oZG9uZSwgZGF0YSl7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAod3JhcHBlZENhbGxiYWNrIHx8IGNhbGxiYWNrKShkYXRhLmVyciwgZGF0YS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBjYWxsYmFjayBpcyBwYXNzZWQsIHJ1biB0aGlzIGFzIGEgY29udHJvbGwgZmxvd1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB3cmFwcGVkVGFzaygpIDogd3JhcHBlZFRhc2tcbiAgICB9O1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIV9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICB2YXIgX3BhcmFsbGVsID0gZnVuY3Rpb24oZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZWFjaGZuLmVhY2goX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBhc3luYy5tYXAsIGVhY2g6IGFzeW5jLmVhY2ggfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKHsgbWFwOiBfbWFwTGltaXQobGltaXQpLCBlYWNoOiBfZWFjaExpbWl0KGxpbWl0KSB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIGFzeW5jLm1hcFNlcmllcyh0YXNrcywgZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLml0ZXJhdG9yID0gZnVuY3Rpb24gKHRhc2tzKSB7XG4gICAgICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZuLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFrZUNhbGxiYWNrKDApO1xuICAgIH07XG5cbiAgICBhc3luYy5hcHBseSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoXG4gICAgICAgICAgICAgICAgbnVsbCwgYXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBfY29uY2F0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHIgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNiKSB7XG4gICAgICAgICAgICBmbih4LCBmdW5jdGlvbiAoZXJyLCB5KSB7XG4gICAgICAgICAgICAgICAgciA9IHIuY29uY2F0KHkgfHwgW10pO1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMud2hpbHN0KHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9XaGlsc3QgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICh0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy51bnRpbCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvVW50aWwgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGlmICghdGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvVW50aWwoaXRlcmF0b3IsIHRlc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5xdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25jdXJyZW5jeSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwb3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xuICAgICAgICB2YXIgcSA9IHtcbiAgICAgICAgICAgIHRhc2tzOiBbXSxcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcS5kcmFpbiA9IG51bGw7XG4gICAgICAgICAgICAgIHEudGFza3MgPSBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhc2sgPSBxLnRhc2tzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxLmVtcHR5ICYmIHEudGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd29ya2VycyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4gJiYgcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IG9ubHlfb25jZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKHRhc2suZGF0YSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlkbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IHRydWUpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcbiAgICBcbiAgICBhc3luYy5wcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9jb21wYXJlVGFza3MoYSwgYil7XG4gICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xuICAgICAgICAgIHZhciBiZWcgPSAtMSxcbiAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGJlZyA9IG1pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiZWc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKCFxLnN0YXJ0ZWQpe1xuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3NcbiAgICAgICAgICAgICByZXR1cm4gYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbikge1xuICAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xuICAgICAgICBcbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICAgICAgcS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgd29ya2luZyAgICAgPSBmYWxzZSxcbiAgICAgICAgICAgIHRhc2tzICAgICAgID0gW107XG5cbiAgICAgICAgdmFyIGNhcmdvID0ge1xuICAgICAgICAgICAgdGFza3M6IHRhc2tzLFxuICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgIHNhdHVyYXRlZDogbnVsbCxcbiAgICAgICAgICAgIGVtcHR5OiBudWxsLFxuICAgICAgICAgICAgZHJhaW46IG51bGwsXG4gICAgICAgICAgICBkcmFpbmVkOiB0cnVlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcmdvLnNhdHVyYXRlZCAmJiB0YXNrcy5sZW5ndGggPT09IHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmdvLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGNhcmdvLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIHByb2Nlc3MoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGNhcmdvLmRyYWluICYmICFjYXJnby5kcmFpbmVkKSBjYXJnby5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cyA9IHR5cGVvZiBwYXlsb2FkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGFza3Muc3BsaWNlKDAsIHBheWxvYWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXNrcy5zcGxpY2UoMCwgdGFza3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIHZhciBkcyA9IF9tYXAodHMsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrLmRhdGE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZihjYXJnby5lbXB0eSkgY2FyZ28uZW1wdHkoKTtcbiAgICAgICAgICAgICAgICB3b3JraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3b3JrZXIoZHMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICBfZWFjaCh0cywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjay5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrcy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcnVubmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JraW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2FyZ287XG4gICAgfTtcblxuICAgIHZhciBfY29uc29sZV9mbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uc29sZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2VhY2goYXJncywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgYXN5bmMubG9nID0gX2NvbnNvbGVfZm4oJ2xvZycpO1xuICAgIGFzeW5jLmRpciA9IF9jb25zb2xlX2ZuKCdkaXInKTtcbiAgICAvKmFzeW5jLmluZm8gPSBfY29uc29sZV9mbignaW5mbycpO1xuICAgIGFzeW5jLndhcm4gPSBfY29uc29sZV9mbignd2FybicpO1xuICAgIGFzeW5jLmVycm9yID0gX2NvbnNvbGVfZm4oJ2Vycm9yJyk7Ki9cblxuICAgIGFzeW5jLm1lbW9pemUgPSBmdW5jdGlvbiAoZm4sIGhhc2hlcikge1xuICAgICAgICB2YXIgbWVtbyA9IHt9O1xuICAgICAgICB2YXIgcXVldWVzID0ge307XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBtZW1vKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5IGluIHF1ZXVlcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcChjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lc1NlcmllcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBTZXJpZXMoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9XSkpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgIHJldHVybiBhc3luYy5zZXEuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgdmFyIF9hcHBseUVhY2ggPSBmdW5jdGlvbiAoZWFjaGZuLCBmbnMgLyphcmdzLi4uKi8pIHtcbiAgICAgICAgdmFyIGdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmFwcGx5RWFjaCA9IGRvUGFyYWxsZWwoX2FwcGx5RWFjaCk7XG4gICAgYXN5bmMuYXBwbHlFYWNoU2VyaWVzID0gZG9TZXJpZXMoX2FwcGx5RWFjaCk7XG5cbiAgICBhc3luYy5mb3JldmVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBmdW5jdGlvbiBuZXh0KGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH07XG5cbiAgICAvLyBOb2RlLmpzXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gYXN5bmM7XG4gICAgfVxuICAgIC8vIEFNRCAvIFJlcXVpcmVKU1xuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpbmNsdWRlZCBkaXJlY3RseSB2aWEgPHNjcmlwdD4gdGFnXG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QuYXN5bmMgPSBhc3luYztcbiAgICB9XG5cbn0oKSk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtel0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NoYWknKTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbnZhciB1c2VkID0gW11cbiAgLCBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyohXG4gKiBDaGFpIHZlcnNpb25cbiAqL1xuXG5leHBvcnRzLnZlcnNpb24gPSAnMS45LjInO1xuXG4vKiFcbiAqIEFzc2VydGlvbiBFcnJvclxuICovXG5cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSByZXF1aXJlKCdhc3NlcnRpb24tZXJyb3InKTtcblxuLyohXG4gKiBVdGlscyBmb3IgcGx1Z2lucyAobm90IGV4cG9ydGVkKVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi9jaGFpL3V0aWxzJyk7XG5cbi8qKlxuICogIyAudXNlKGZ1bmN0aW9uKVxuICpcbiAqIFByb3ZpZGVzIGEgd2F5IHRvIGV4dGVuZCB0aGUgaW50ZXJuYWxzIG9mIENoYWlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufVxuICogQHJldHVybnMge3RoaXN9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICBpZiAoIX51c2VkLmluZGV4T2YoZm4pKSB7XG4gICAgZm4odGhpcywgdXRpbCk7XG4gICAgdXNlZC5wdXNoKGZuKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyohXG4gKiBDb25maWd1cmF0aW9uXG4gKi9cblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY2hhaS9jb25maWcnKTtcbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuXG4vKiFcbiAqIFByaW1hcnkgYEFzc2VydGlvbmAgcHJvdG90eXBlXG4gKi9cblxudmFyIGFzc2VydGlvbiA9IHJlcXVpcmUoJy4vY2hhaS9hc3NlcnRpb24nKTtcbmV4cG9ydHMudXNlKGFzc2VydGlvbik7XG5cbi8qIVxuICogQ29yZSBBc3NlcnRpb25zXG4gKi9cblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NoYWkvY29yZS9hc3NlcnRpb25zJyk7XG5leHBvcnRzLnVzZShjb3JlKTtcblxuLyohXG4gKiBFeHBlY3QgaW50ZXJmYWNlXG4gKi9cblxudmFyIGV4cGVjdCA9IHJlcXVpcmUoJy4vY2hhaS9pbnRlcmZhY2UvZXhwZWN0Jyk7XG5leHBvcnRzLnVzZShleHBlY3QpO1xuXG4vKiFcbiAqIFNob3VsZCBpbnRlcmZhY2VcbiAqL1xuXG52YXIgc2hvdWxkID0gcmVxdWlyZSgnLi9jaGFpL2ludGVyZmFjZS9zaG91bGQnKTtcbmV4cG9ydHMudXNlKHNob3VsZCk7XG5cbi8qIVxuICogQXNzZXJ0IGludGVyZmFjZVxuICovXG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuL2NoYWkvaW50ZXJmYWNlL2Fzc2VydCcpO1xuZXhwb3J0cy51c2UoYXNzZXJ0KTtcbiIsIi8qIVxuICogY2hhaVxuICogaHR0cDovL2NoYWlqcy5jb21cbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoX2NoYWksIHV0aWwpIHtcbiAgLyohXG4gICAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuXG4gIHZhciBBc3NlcnRpb25FcnJvciA9IF9jaGFpLkFzc2VydGlvbkVycm9yXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICBfY2hhaS5Bc3NlcnRpb24gPSBBc3NlcnRpb247XG5cbiAgLyohXG4gICAqIEFzc2VydGlvbiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBDcmVhdGVzIG9iamVjdCBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEBhcGkgcHJpdmF0ZVxuICAgKi9cblxuICBmdW5jdGlvbiBBc3NlcnRpb24gKG9iaiwgbXNnLCBzdGFjaykge1xuICAgIGZsYWcodGhpcywgJ3NzZmknLCBzdGFjayB8fCBhcmd1bWVudHMuY2FsbGVlKTtcbiAgICBmbGFnKHRoaXMsICdvYmplY3QnLCBvYmopO1xuICAgIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbiwgJ2luY2x1ZGVTdGFjaycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIHJldHVybiBjb25maWcuaW5jbHVkZVN0YWNrO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uaW5jbHVkZVN0YWNrIGlzIGRlcHJlY2F0ZWQsIHVzZSBjaGFpLmNvbmZpZy5pbmNsdWRlU3RhY2sgaW5zdGVhZC4nKTtcbiAgICAgIGNvbmZpZy5pbmNsdWRlU3RhY2sgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3NlcnRpb24sICdzaG93RGlmZicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICByZXR1cm4gY29uZmlnLnNob3dEaWZmO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc29sZS53YXJuKCdBc3NlcnRpb24uc2hvd0RpZmYgaXMgZGVwcmVjYXRlZCwgdXNlIGNoYWkuY29uZmlnLnNob3dEaWZmIGluc3RlYWQuJyk7XG4gICAgICBjb25maWcuc2hvd0RpZmYgPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwuYWRkUHJvcGVydHkodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XG4gICAgdXRpbC5hZGRNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gICAgdXRpbC5hZGRDaGFpbmFibGVNZXRob2QodGhpcy5wcm90b3R5cGUsIG5hbWUsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAgfTtcblxuICBBc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcbiAgICB1dGlsLm92ZXJ3cml0ZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgIHV0aWwub3ZlcndyaXRlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbik7XG4gIH07XG5cbiAgQXNzZXJ0aW9uLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcikge1xuICAgIHV0aWwub3ZlcndyaXRlQ2hhaW5hYmxlTWV0aG9kKHRoaXMucHJvdG90eXBlLCBuYW1lLCBmbiwgY2hhaW5pbmdCZWhhdmlvcik7XG4gIH07XG5cbiAgLyohXG4gICAqICMjIyAuYXNzZXJ0KGV4cHJlc3Npb24sIG1lc3NhZ2UsIG5lZ2F0ZU1lc3NhZ2UsIGV4cGVjdGVkLCBhY3R1YWwpXG4gICAqXG4gICAqIEV4ZWN1dGVzIGFuIGV4cHJlc3Npb24gYW5kIGNoZWNrIGV4cGVjdGF0aW9ucy4gVGhyb3dzIEFzc2VydGlvbkVycm9yIGZvciByZXBvcnRpbmcgaWYgdGVzdCBkb2Vzbid0IHBhc3MuXG4gICAqXG4gICAqIEBuYW1lIGFzc2VydFxuICAgKiBAcGFyYW0ge1BoaWxvc29waGljYWx9IGV4cHJlc3Npb24gdG8gYmUgdGVzdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nIG9yIEZ1bmN0aW9ufSBtZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBtZXNzYWdlIHRvIGRpc3BsYXkgaWYgZmFpbHNcbiAgICogQHBhcmFtIHtTdHJpbmcgb3IgRnVuY3Rpb259IG5lZ2F0ZWRNZXNzYWdlIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBuZWdhdGVkTWVzc2FnZSB0byBkaXNwbGF5IGlmIG5lZ2F0ZWQgZXhwcmVzc2lvbiBmYWlsc1xuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZCB2YWx1ZSAocmVtZW1iZXIgdG8gY2hlY2sgZm9yIG5lZ2F0aW9uKVxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWwgKG9wdGlvbmFsKSB3aWxsIGRlZmF1bHQgdG8gYHRoaXMub2JqYFxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgPSBmdW5jdGlvbiAoZXhwciwgbXNnLCBuZWdhdGVNc2csIGV4cGVjdGVkLCBfYWN0dWFsLCBzaG93RGlmZikge1xuICAgIHZhciBvayA9IHV0aWwudGVzdCh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh0cnVlICE9PSBzaG93RGlmZikgc2hvd0RpZmYgPSBmYWxzZTtcbiAgICBpZiAodHJ1ZSAhPT0gY29uZmlnLnNob3dEaWZmKSBzaG93RGlmZiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvaykge1xuICAgICAgdmFyIG1zZyA9IHV0aWwuZ2V0TWVzc2FnZSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICwgYWN0dWFsID0gdXRpbC5nZXRBY3R1YWwodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25FcnJvcihtc2csIHtcbiAgICAgICAgICBhY3R1YWw6IGFjdHVhbFxuICAgICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAsIHNob3dEaWZmOiBzaG93RGlmZlxuICAgICAgfSwgKGNvbmZpZy5pbmNsdWRlU3RhY2spID8gdGhpcy5hc3NlcnQgOiBmbGFnKHRoaXMsICdzc2ZpJykpO1xuICAgIH1cbiAgfTtcblxuICAvKiFcbiAgICogIyMjIC5fb2JqXG4gICAqXG4gICAqIFF1aWNrIHJlZmVyZW5jZSB0byBzdG9yZWQgYGFjdHVhbGAgdmFsdWUgZm9yIHBsdWdpbiBkZXZlbG9wZXJzLlxuICAgKlxuICAgKiBAYXBpIHByaXZhdGVcbiAgICovXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFzc2VydGlvbi5wcm90b3R5cGUsICdfb2JqJyxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgICB9XG4gICAgLCBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgdmFsKTtcbiAgICAgIH1cbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqICMjIyBjb25maWcuaW5jbHVkZVN0YWNrXG4gICAqXG4gICAqIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnR5LCBpbmZsdWVuY2VzIHdoZXRoZXIgc3RhY2sgdHJhY2VcbiAgICogaXMgaW5jbHVkZWQgaW4gQXNzZXJ0aW9uIGVycm9yIG1lc3NhZ2UuIERlZmF1bHQgb2YgZmFsc2VcbiAgICogc3VwcHJlc3NlcyBzdGFjayB0cmFjZSBpbiB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICpcbiAgICogICAgIGNoYWkuY29uZmlnLmluY2x1ZGVTdGFjayA9IHRydWU7ICAvLyBlbmFibGUgc3RhY2sgb24gZXJyb3JcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICAgaW5jbHVkZVN0YWNrOiBmYWxzZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy5zaG93RGlmZlxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgaW5mbHVlbmNlcyB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGUgYHNob3dEaWZmYCBmbGFnIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdGhyb3duXG4gICAqIEFzc2VydGlvbkVycm9ycy4gYGZhbHNlYCB3aWxsIGFsd2F5cyBiZSBgZmFsc2VgOyBgdHJ1ZWBcbiAgICogd2lsbCBiZSB0cnVlIHdoZW4gdGhlIGFzc2VydGlvbiBoYXMgcmVxdWVzdGVkIGEgZGlmZlxuICAgKiBiZSBzaG93bi5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBzaG93RGlmZjogdHJ1ZSxcblxuICAvKipcbiAgICogIyMjIGNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZFxuICAgKlxuICAgKiBVc2VyIGNvbmZpZ3VyYWJsZSBwcm9wZXJ0eSwgc2V0cyBsZW5ndGggdGhyZXNob2xkIGZvciBhY3R1YWwgYW5kXG4gICAqIGV4cGVjdGVkIHZhbHVlcyBpbiBhc3NlcnRpb24gZXJyb3JzLiBJZiB0aGlzIHRocmVzaG9sZCBpcyBleGNlZWRlZCxcbiAgICogdGhlIHZhbHVlIGlzIHRydW5jYXRlZC5cbiAgICpcbiAgICogU2V0IGl0IHRvIHplcm8gaWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0cnVuY2F0aW5nIGFsdG9nZXRoZXIuXG4gICAqXG4gICAqICAgICBjaGFpLmNvbmZpZy50cnVuY2F0ZVRocmVzaG9sZCA9IDA7ICAvLyBkaXNhYmxlIHRydW5jYXRpbmdcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIHRydW5jYXRlVGhyZXNob2xkOiA0MFxuXG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBodHRwOi8vY2hhaWpzLmNvbVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIF8pIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAsIGZsYWcgPSBfLmZsYWc7XG5cbiAgLyoqXG4gICAqICMjIyBMYW5ndWFnZSBDaGFpbnNcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBhcmUgcHJvdmlkZWQgYXMgY2hhaW5hYmxlIGdldHRlcnMgdG9cbiAgICogaW1wcm92ZSB0aGUgcmVhZGFiaWxpdHkgb2YgeW91ciBhc3NlcnRpb25zLiBUaGV5XG4gICAqIGRvIG5vdCBwcm92aWRlIHRlc3RpbmcgY2FwYWJpbGl0aWVzIHVubGVzcyB0aGV5XG4gICAqIGhhdmUgYmVlbiBvdmVyd3JpdHRlbiBieSBhIHBsdWdpbi5cbiAgICpcbiAgICogKipDaGFpbnMqKlxuICAgKlxuICAgKiAtIHRvXG4gICAqIC0gYmVcbiAgICogLSBiZWVuXG4gICAqIC0gaXNcbiAgICogLSB0aGF0XG4gICAqIC0gYW5kXG4gICAqIC0gaGFzXG4gICAqIC0gaGF2ZVxuICAgKiAtIHdpdGhcbiAgICogLSBhdFxuICAgKiAtIG9mXG4gICAqIC0gc2FtZVxuICAgKlxuICAgKiBAbmFtZSBsYW5ndWFnZSBjaGFpbnNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgWyAndG8nLCAnYmUnLCAnYmVlbidcbiAgLCAnaXMnLCAnYW5kJywgJ2hhcycsICdoYXZlJ1xuICAsICd3aXRoJywgJ3RoYXQnLCAnYXQnXG4gICwgJ29mJywgJ3NhbWUnIF0uZm9yRWFjaChmdW5jdGlvbiAoY2hhaW4pIHtcbiAgICBBc3NlcnRpb24uYWRkUHJvcGVydHkoY2hhaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5ub3RcbiAgICpcbiAgICogTmVnYXRlcyBhbnkgb2YgYXNzZXJ0aW9ucyBmb2xsb3dpbmcgaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KGZvbykudG8ubm90LmVxdWFsKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChnb29kRm4pLnRvLm5vdC50aHJvdyhFcnJvcik7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXonIH0pLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycpXG4gICAqICAgICAgIC5hbmQubm90LmVxdWFsKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgbm90XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnbm90JywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ25lZ2F0ZScsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwXG4gICAqXG4gICAqIFNldHMgdGhlIGBkZWVwYCBmbGFnLCBsYXRlciB1c2VkIGJ5IHRoZSBgZXF1YWxgIGFuZFxuICAgKiBgcHJvcGVydHlgIGFzc2VydGlvbnMuXG4gICAqXG4gICAqICAgICBleHBlY3QoZm9vKS50by5kZWVwLmVxdWFsKHsgYmFyOiAnYmF6JyB9KTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogeyBiYXI6IHsgYmF6OiAncXV1eCcgfSB9IH0pXG4gICAqICAgICAgIC50by5oYXZlLmRlZXAucHJvcGVydHkoJ2Zvby5iYXIuYmF6JywgJ3F1dXgnKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2RlZXAnLCBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZGVlcCcsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5hKHR5cGUpXG4gICAqXG4gICAqIFRoZSBgYWAgYW5kIGBhbmAgYXNzZXJ0aW9ucyBhcmUgYWxpYXNlcyB0aGF0IGNhbiBiZVxuICAgKiB1c2VkIGVpdGhlciBhcyBsYW5ndWFnZSBjaGFpbnMgb3IgdG8gYXNzZXJ0IGEgdmFsdWUnc1xuICAgKiB0eXBlLlxuICAgKlxuICAgKiAgICAgLy8gdHlwZW9mXG4gICAqICAgICBleHBlY3QoJ3Rlc3QnKS50by5iZS5hKCdzdHJpbmcnKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogJ2JhcicgfSkudG8uYmUuYW4oJ29iamVjdCcpO1xuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLmEoJ251bGwnKTtcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLmFuKCd1bmRlZmluZWQnKTtcbiAgICpcbiAgICogICAgIC8vIGxhbmd1YWdlIGNoYWluXG4gICAqICAgICBleHBlY3QoZm9vKS50by5iZS5hbi5pbnN0YW5jZW9mKEZvbyk7XG4gICAqXG4gICAqIEBuYW1lIGFcbiAgICogQGFsaWFzIGFuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYW4gKHR5cGUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGFydGljbGUgPSB+WyAnYScsICdlJywgJ2knLCAnbycsICd1JyBdLmluZGV4T2YodHlwZS5jaGFyQXQoMCkpID8gJ2FuICcgOiAnYSAnO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHR5cGUgPT09IF8udHlwZShvYmopXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlICcgKyBhcnRpY2xlICsgdHlwZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgJyArIGFydGljbGUgKyB0eXBlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2FuJywgYW4pO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdhJywgYW4pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmluY2x1ZGUodmFsdWUpXG4gICAqXG4gICAqIFRoZSBgaW5jbHVkZWAgYW5kIGBjb250YWluYCBhc3NlcnRpb25zIGNhbiBiZSB1c2VkIGFzIGVpdGhlciBwcm9wZXJ0eVxuICAgKiBiYXNlZCBsYW5ndWFnZSBjaGFpbnMgb3IgYXMgbWV0aG9kcyB0byBhc3NlcnQgdGhlIGluY2x1c2lvbiBvZiBhbiBvYmplY3RcbiAgICogaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgaW4gYSBzdHJpbmcuIFdoZW4gdXNlZCBhcyBsYW5ndWFnZSBjaGFpbnMsXG4gICAqIHRoZXkgdG9nZ2xlIHRoZSBgY29udGFpbmAgZmxhZyBmb3IgdGhlIGBrZXlzYCBhc3NlcnRpb24uXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsMiwzXSkudG8uaW5jbHVkZSgyKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uY29udGFpbignZm9vJyk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInLCBoZWxsbzogJ3VuaXZlcnNlJyB9KS50by5pbmNsdWRlLmtleXMoJ2ZvbycpO1xuICAgKlxuICAgKiBAbmFtZSBpbmNsdWRlXG4gICAqIEBhbGlhcyBjb250YWluXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xOdW1iZXJ9IG9ialxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGluY2x1ZGVDaGFpbmluZ0JlaGF2aW9yICgpIHtcbiAgICBmbGFnKHRoaXMsICdjb250YWlucycsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5jbHVkZSAodmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgdmFyIGV4cGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKF8udHlwZShvYmopID09PSAnYXJyYXknICYmIF8udHlwZSh2YWwpID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKF8uZXFsKG9ialtpXSwgdmFsKSkge1xuICAgICAgICAgIGV4cGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXy50eXBlKHZhbCkgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsKSBuZXcgQXNzZXJ0aW9uKG9iaikucHJvcGVydHkoaywgdmFsW2tdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN1YnNldCA9IHt9XG4gICAgICBmb3IgKHZhciBrIGluIHZhbCkgc3Vic2V0W2tdID0gb2JqW2tdXG4gICAgICBleHBlY3RlZCA9IF8uZXFsKHN1YnNldCwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwZWN0ZWQgPSBvYmogJiYgfm9iai5pbmRleE9mKHZhbClcbiAgICB9XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGV4cGVjdGVkXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGluY2x1ZGUgJyArIF8uaW5zcGVjdCh2YWwpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBpbmNsdWRlICcgKyBfLmluc3BlY3QodmFsKSk7XG4gIH1cblxuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdpbmNsdWRlJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuICBBc3NlcnRpb24uYWRkQ2hhaW5hYmxlTWV0aG9kKCdjb250YWluJywgaW5jbHVkZSwgaW5jbHVkZUNoYWluaW5nQmVoYXZpb3IpO1xuXG4gIC8qKlxuICAgKiAjIyMgLm9rXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIHRydXRoeS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZXZlcnRoaW5nJykudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoMSkudG8uYmUub2s7XG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLm5vdC5iZS5vaztcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUub2s7XG4gICAqXG4gICAqIEBuYW1lIG9rXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnb2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydXRoeSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgZmFsc3knKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAudHJ1ZVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QodHJ1ZSkudG8uYmUudHJ1ZTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuYmUudHJ1ZTtcbiAgICpcbiAgICogQG5hbWUgdHJ1ZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ3RydWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHRydWUgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIHRydWUnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IGZhbHNlIDogdHJ1ZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhbHNlXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGBmYWxzZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoZmFsc2UpLnRvLmJlLmZhbHNlO1xuICAgKiAgICAgZXhwZWN0KDApLnRvLm5vdC5iZS5mYWxzZTtcbiAgICpcbiAgICogQG5hbWUgZmFsc2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmYWxzZScsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmFsc2UgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGZhbHNlJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSB0cnVlJ1xuICAgICAgLCB0aGlzLm5lZ2F0ZSA/IHRydWUgOiBmYWxzZVxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLm51bGxcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYG51bGxgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG51bGwpLnRvLmJlLm51bGw7XG4gICAqICAgICBleHBlY3QodW5kZWZpbmVkKS5ub3QudG8uYmUubnVsbDtcbiAgICpcbiAgICogQG5hbWUgbnVsbFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ251bGwnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIG51bGwgPT09IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIG51bGwnXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBiZSBudWxsJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLnVuZGVmaW5lZFxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCh1bmRlZmluZWQpLnRvLmJlLnVuZGVmaW5lZDtcbiAgICogICAgIGV4cGVjdChudWxsKS50by5ub3QuYmUudW5kZWZpbmVkO1xuICAgKlxuICAgKiBAbmFtZSB1bmRlZmluZWRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCd1bmRlZmluZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHVuZGVmaW5lZCA9PT0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgdW5kZWZpbmVkJ1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSBub3QgdG8gYmUgdW5kZWZpbmVkJ1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmV4aXN0XG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIG5laXRoZXIgYG51bGxgIG5vciBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciBmb28gPSAnaGknXG4gICAqICAgICAgICwgYmFyID0gbnVsbFxuICAgKiAgICAgICAsIGJhejtcbiAgICpcbiAgICogICAgIGV4cGVjdChmb28pLnRvLmV4aXN0O1xuICAgKiAgICAgZXhwZWN0KGJhcikudG8ubm90LmV4aXN0O1xuICAgKiAgICAgZXhwZWN0KGJheikudG8ubm90LmV4aXN0O1xuICAgKlxuICAgKiBAbmFtZSBleGlzdFxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2V4aXN0JywgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBudWxsICE9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGV4aXN0J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXhpc3QnXG4gICAgKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5lbXB0eVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCdzIGxlbmd0aCBpcyBgMGAuIEZvciBhcnJheXMsIGl0IGNoZWNrc1xuICAgKiB0aGUgYGxlbmd0aGAgcHJvcGVydHkuIEZvciBvYmplY3RzLCBpdCBnZXRzIHRoZSBjb3VudCBvZlxuICAgKiBlbnVtZXJhYmxlIGtleXMuXG4gICAqXG4gICAqICAgICBleHBlY3QoW10pLnRvLmJlLmVtcHR5O1xuICAgKiAgICAgZXhwZWN0KCcnKS50by5iZS5lbXB0eTtcbiAgICogICAgIGV4cGVjdCh7fSkudG8uYmUuZW1wdHk7XG4gICAqXG4gICAqIEBuYW1lIGVtcHR5XG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnZW1wdHknLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIGV4cGVjdGVkID0gb2JqO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSB8fCAnc3RyaW5nJyA9PT0gdHlwZW9mIG9iamVjdCkge1xuICAgICAgZXhwZWN0ZWQgPSBvYmoubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGV4cGVjdGVkID0gT2JqZWN0LmtleXMob2JqKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICFleHBlY3RlZFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBlbXB0eSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGVtcHR5J1xuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFyZ3VtZW50c1xuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBhbiBhcmd1bWVudHMgb2JqZWN0LlxuICAgKlxuICAgKiAgICAgZnVuY3Rpb24gdGVzdCAoKSB7XG4gICAqICAgICAgIGV4cGVjdChhcmd1bWVudHMpLnRvLmJlLmFyZ3VtZW50cztcbiAgICogICAgIH1cbiAgICpcbiAgICogQG5hbWUgYXJndW1lbnRzXG4gICAqIEBhbGlhcyBBcmd1bWVudHNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2tBcmd1bWVudHMgKCkge1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICdbb2JqZWN0IEFyZ3VtZW50c10nID09PSB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBhcmd1bWVudHMnXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnYXJndW1lbnRzJywgY2hlY2tBcmd1bWVudHMpO1xuICBBc3NlcnRpb24uYWRkUHJvcGVydHkoJ0FyZ3VtZW50cycsIGNoZWNrQXJndW1lbnRzKTtcblxuICAvKipcbiAgICogIyMjIC5lcXVhbCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgc3RyaWN0bHkgZXF1YWwgKGA9PT1gKSB0byBgdmFsdWVgLlxuICAgKiBBbHRlcm5hdGVseSwgaWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgYXNzZXJ0cyB0aGF0XG4gICAqIHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2hlbGxvJykudG8uZXF1YWwoJ2hlbGxvJyk7XG4gICAqICAgICBleHBlY3QoNDIpLnRvLmVxdWFsKDQyKTtcbiAgICogICAgIGV4cGVjdCgxKS50by5ub3QuZXF1YWwodHJ1ZSk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLm5vdC5lcXVhbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmRlZXAuZXF1YWwoeyBmb286ICdiYXInIH0pO1xuICAgKlxuICAgKiBAbmFtZSBlcXVhbFxuICAgKiBAYWxpYXMgZXF1YWxzXG4gICAqIEBhbGlhcyBlcVxuICAgKiBAYWxpYXMgZGVlcC5lcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxdWFsICh2YWwsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZGVlcCcpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcWwodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdmFsID09PSBvYmpcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBlcXVhbCAje2V4cH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICAgLCB2YWxcbiAgICAgICAgLCB0aGlzLl9vYmpcbiAgICAgICAgLCB0cnVlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxdWFsJywgYXNzZXJ0RXF1YWwpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdlcXVhbHMnLCBhc3NlcnRFcXVhbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxJywgYXNzZXJ0RXF1YWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxbCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZGVlcGx5IGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoeyBmb286ICdiYXInIH0pLnRvLmVxbCh7IGZvbzogJ2JhcicgfSk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmVxbChbIDEsIDIsIDMgXSk7XG4gICAqXG4gICAqIEBuYW1lIGVxbFxuICAgKiBAYWxpYXMgZXFsc1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEVxbChvYmosIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBfLmVxbChvYmosIGZsYWcodGhpcywgJ29iamVjdCcpKVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBkZWVwbHkgZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZGVlcGx5IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgb2JqXG4gICAgICAsIHRoaXMuX29ialxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbCcsIGFzc2VydEVxbCk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2VxbHMnLCBhc3NlcnRFcWwpO1xuXG4gIC8qKlxuICAgKiAjIyMgLmFib3ZlKHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxMCkudG8uYmUuYWJvdmUoNSk7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgbGVuZ3RoYCB0b1xuICAgKiBhc3NlcnQgYSBtaW5pbXVtIGxlbmd0aC4gVGhlIGJlbmVmaXQgYmVpbmcgYVxuICAgKiBtb3JlIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2UgdGhhbiBpZiB0aGUgbGVuZ3RoXG4gICAqIHdhcyBzdXBwbGllZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLmFib3ZlKDIpO1xuICAgKlxuICAgKiBAbmFtZSBhYm92ZVxuICAgKiBAYWxpYXMgZ3RcbiAgICogQGFsaWFzIGdyZWF0ZXJUaGFuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFzc2VydEFib3ZlIChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPiBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSBsZW5ndGggYWJvdmUgI3tleHB9J1xuICAgICAgICAsIG5cbiAgICAgICAgLCBsZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhYm92ZSAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGF0IG1vc3QgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYWJvdmUnLCBhc3NlcnRBYm92ZSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2d0JywgYXNzZXJ0QWJvdmUpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdncmVhdGVyVGhhbicsIGFzc2VydEFib3ZlKTtcblxuICAvKipcbiAgICogIyMjIC5sZWFzdCh2YWx1ZSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqICAgICBleHBlY3QoMTApLnRvLmJlLmF0LmxlYXN0KDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1pbmltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5vZi5hdC5sZWFzdCgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgub2YuYXQubGVhc3QoMyk7XG4gICAqXG4gICAqIEBuYW1lIGxlYXN0XG4gICAqIEBhbGlhcyBndGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0TGVhc3QgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA+PSBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhdCBsZWFzdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqID49IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBsZWFzdCAnICsgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICcgKyBuXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2xlYXN0JywgYXNzZXJ0TGVhc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdndGUnLCBhc3NlcnRMZWFzdCk7XG5cbiAgLyoqXG4gICAqICMjIyAuYmVsb3codmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KDUpLnRvLmJlLmJlbG93KDEwKTtcbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGBsZW5ndGhgIHRvXG4gICAqIGFzc2VydCBhIG1heGltdW0gbGVuZ3RoLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYmVsb3coNCk7XG4gICAqXG4gICAqIEBuYW1lIGJlbG93XG4gICAqIEBhbGlhcyBsdFxuICAgKiBAYWxpYXMgbGVzc1RoYW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0QmVsb3cgKG4sIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBpZiAoZmxhZyh0aGlzLCAnZG9MZW5ndGgnKSkge1xuICAgICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gICAgICB2YXIgbGVuID0gb2JqLmxlbmd0aDtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGxlbiA8IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgbGVuZ3RoIGJlbG93ICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBiZWxvdyAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDwgblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGJlIGJlbG93ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYXQgbGVhc3QgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnYmVsb3cnLCBhc3NlcnRCZWxvdyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2x0JywgYXNzZXJ0QmVsb3cpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZXNzVGhhbicsIGFzc2VydEJlbG93KTtcblxuICAvKipcbiAgICogIyMjIC5tb3N0KHZhbHVlKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCg1KS50by5iZS5hdC5tb3N0KDUpO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbWF4aW11bSBsZW5ndGguIFRoZSBiZW5lZml0IGJlaW5nIGFcbiAgICogbW9yZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlIHRoYW4gaWYgdGhlIGxlbmd0aFxuICAgKiB3YXMgc3VwcGxpZWQgZGlyZWN0bHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLm9mLmF0Lm1vc3QoNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLm9mLmF0Lm1vc3QoMyk7XG4gICAqXG4gICAqIEBuYW1lIG1vc3RcbiAgICogQGFsaWFzIGx0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRNb3N0IChuLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPD0gblxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggYXQgbW9zdCAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gaGF2ZSBhIGxlbmd0aCBhYm92ZSAje2V4cH0nXG4gICAgICAgICwgblxuICAgICAgICAsIGxlblxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgb2JqIDw9IG5cbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhdCBtb3N0ICcgKyBuXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgYWJvdmUgJyArIG5cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbW9zdCcsIGFzc2VydE1vc3QpO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsdGUnLCBhc3NlcnRNb3N0KTtcblxuICAvKipcbiAgICogIyMjIC53aXRoaW4oc3RhcnQsIGZpbmlzaClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgd2l0aGluIGEgcmFuZ2UuXG4gICAqXG4gICAqICAgICBleHBlY3QoNykudG8uYmUud2l0aGluKDUsMTApO1xuICAgKlxuICAgKiBDYW4gYWxzbyBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYGxlbmd0aGAgdG9cbiAgICogYXNzZXJ0IGEgbGVuZ3RoIHJhbmdlLiBUaGUgYmVuZWZpdCBiZWluZyBhXG4gICAqIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgbWVzc2FnZSB0aGFuIGlmIHRoZSBsZW5ndGhcbiAgICogd2FzIHN1cHBsaWVkIGRpcmVjdGx5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC53aXRoaW4oMiw0KTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqXG4gICAqIEBuYW1lIHdpdGhpblxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgbG93ZXJib3VuZCBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZpbmlzaCB1cHBlcmJvdW5kIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3dpdGhpbicsIGZ1bmN0aW9uIChzdGFydCwgZmluaXNoLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0JylcbiAgICAgICwgcmFuZ2UgPSBzdGFydCArICcuLicgKyBmaW5pc2g7XG4gICAgaWYgKGZsYWcodGhpcywgJ2RvTGVuZ3RoJykpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgICAgdmFyIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICBsZW4gPj0gc3RhcnQgJiYgbGVuIDw9IGZpbmlzaFxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIGEgbGVuZ3RoIHdpdGhpbiAnICsgcmFuZ2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIG9iaiA+PSBzdGFydCAmJiBvYmogPD0gZmluaXNoXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gYmUgd2l0aGluICcgKyByYW5nZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSB3aXRoaW4gJyArIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VvZihjb25zdHJ1Y3RvcilcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYW4gaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYC5cbiAgICpcbiAgICogICAgIHZhciBUZWEgPSBmdW5jdGlvbiAobmFtZSkgeyB0aGlzLm5hbWUgPSBuYW1lOyB9XG4gICAqICAgICAgICwgQ2hhaSA9IG5ldyBUZWEoJ2NoYWknKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChDaGFpKS50by5iZS5hbi5pbnN0YW5jZW9mKFRlYSk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmJlLmluc3RhbmNlb2YoQXJyYXkpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZW9mXG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFsaWFzIGluc3RhbmNlT2ZcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0SW5zdGFuY2VPZiAoY29uc3RydWN0b3IsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBuYW1lID0gXy5nZXROYW1lKGNvbnN0cnVjdG9yKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JykgaW5zdGFuY2VvZiBjb25zdHJ1Y3RvclxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhbiBpbnN0YW5jZSBvZiAnICsgbmFtZVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYW4gaW5zdGFuY2Ugb2YgJyArIG5hbWVcbiAgICApO1xuICB9O1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2luc3RhbmNlb2YnLCBhc3NlcnRJbnN0YW5jZU9mKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnaW5zdGFuY2VPZicsIGFzc2VydEluc3RhbmNlT2YpO1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5KG5hbWUsIFt2YWx1ZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHByb3BlcnR5IGBuYW1lYCwgb3B0aW9uYWxseSBhc3NlcnRpbmcgdGhhdFxuICAgKiB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBpcyBzdHJpY3RseSBlcXVhbCB0byAgYHZhbHVlYC5cbiAgICogSWYgdGhlIGBkZWVwYCBmbGFnIGlzIHNldCwgeW91IGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcFxuICAgKiByZWZlcmVuY2VzIGludG8gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgLy8gc2ltcGxlIHJlZmVyZW5jaW5nXG4gICAqICAgICB2YXIgb2JqID0geyBmb286ICdiYXInIH07XG4gICAqICAgICBleHBlY3Qob2JqKS50by5oYXZlLnByb3BlcnR5KCdmb28nKTtcbiAgICogICAgIGV4cGVjdChvYmopLnRvLmhhdmUucHJvcGVydHkoJ2ZvbycsICdiYXInKTtcbiAgICpcbiAgICogICAgIC8vIGRlZXAgcmVmZXJlbmNpbmdcbiAgICogICAgIHZhciBkZWVwT2JqID0ge1xuICAgKiAgICAgICAgIGdyZWVuOiB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAsIHRlYXM6IFsgJ2NoYWknLCAnbWF0Y2hhJywgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIH07XG5cbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ2dyZWVuLnRlYScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChkZWVwT2JqKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ3RlYXNbMV0nLCAnbWF0Y2hhJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5kZWVwLnByb3BlcnR5KCd0ZWFzWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyB1c2UgYW4gYXJyYXkgYXMgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIGEgYGRlZXAucHJvcGVydHlgXG4gICAqIGFzc2VydGlvbiwgb3IgdHJhdmVyc2UgbmVzdGVkIGFycmF5cy5cbiAgICpcbiAgICogICAgIHZhciBhcnIgPSBbXG4gICAqICAgICAgICAgWyAnY2hhaScsICdtYXRjaGEnLCAna29uYWNoYScgXVxuICAgKiAgICAgICAsIFsgeyB0ZWE6ICdjaGFpJyB9XG4gICAqICAgICAgICAgLCB7IHRlYTogJ21hdGNoYScgfVxuICAgKiAgICAgICAgICwgeyB0ZWE6ICdrb25hY2hhJyB9IF1cbiAgICogICAgIF07XG4gICAqXG4gICAqICAgICBleHBlY3QoYXJyKS50by5oYXZlLmRlZXAucHJvcGVydHkoJ1swXVsxXScsICdtYXRjaGEnKTtcbiAgICogICAgIGV4cGVjdChhcnIpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eSgnWzFdWzJdLnRlYScsICdrb25hY2hhJyk7XG4gICAqXG4gICAqIEZ1cnRoZXJtb3JlLCBgcHJvcGVydHlgIGNoYW5nZXMgdGhlIHN1YmplY3Qgb2YgdGhlIGFzc2VydGlvblxuICAgKiB0byBiZSB0aGUgdmFsdWUgb2YgdGhhdCBwcm9wZXJ0eSBmcm9tIHRoZSBvcmlnaW5hbCBvYmplY3QuIFRoaXNcbiAgICogcGVybWl0cyBmb3IgZnVydGhlciBjaGFpbmFibGUgYXNzZXJ0aW9ucyBvbiB0aGF0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KG9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZm9vJylcbiAgICogICAgICAgLnRoYXQuaXMuYSgnc3RyaW5nJyk7XG4gICAqICAgICBleHBlY3QoZGVlcE9iaikudG8uaGF2ZS5wcm9wZXJ0eSgnZ3JlZW4nKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignb2JqZWN0JylcbiAgICogICAgICAgLnRoYXQuZGVlcC5lcXVhbHMoeyB0ZWE6ICdtYXRjaGEnIH0pO1xuICAgKiAgICAgZXhwZWN0KGRlZXBPYmopLnRvLmhhdmUucHJvcGVydHkoJ3RlYXMnKVxuICAgKiAgICAgICAudGhhdC5pcy5hbignYXJyYXknKVxuICAgKiAgICAgICAud2l0aC5kZWVwLnByb3BlcnR5KCdbMl0nKVxuICAgKiAgICAgICAgIC50aGF0LmRlZXAuZXF1YWxzKHsgdGVhOiAna29uYWNoYScgfSk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5XG4gICAqIEBhbGlhcyBkZWVwLnByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAcmV0dXJucyB2YWx1ZSBvZiBwcm9wZXJ0eSBmb3IgY2hhaW5pbmdcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgncHJvcGVydHknLCBmdW5jdGlvbiAobmFtZSwgdmFsLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcblxuICAgIHZhciBkZXNjcmlwdG9yID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gJ2RlZXAgcHJvcGVydHkgJyA6ICdwcm9wZXJ0eSAnXG4gICAgICAsIG5lZ2F0ZSA9IGZsYWcodGhpcywgJ25lZ2F0ZScpXG4gICAgICAsIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHZhbHVlID0gZmxhZyh0aGlzLCAnZGVlcCcpXG4gICAgICAgID8gXy5nZXRQYXRoVmFsdWUobmFtZSwgb2JqKVxuICAgICAgICA6IG9ialtuYW1lXTtcblxuICAgIGlmIChuZWdhdGUgJiYgdW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHZhbHVlKSB7XG4gICAgICAgIG1zZyA9IChtc2cgIT0gbnVsbCkgPyBtc2cgKyAnOiAnIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cgKyBfLmluc3BlY3Qob2JqKSArICcgaGFzIG5vICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgdW5kZWZpbmVkICE9PSB2YWx1ZVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKVxuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlICcgKyBkZXNjcmlwdG9yICsgXy5pbnNwZWN0KG5hbWUpKTtcbiAgICB9XG5cbiAgICBpZiAodW5kZWZpbmVkICE9PSB2YWwpIHtcbiAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIHZhbCA9PT0gdmFsdWVcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIGEgJyArIGRlc2NyaXB0b3IgKyBfLmluc3BlY3QobmFtZSkgKyAnIG9mICN7ZXhwfSwgYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgYSAnICsgZGVzY3JpcHRvciArIF8uaW5zcGVjdChuYW1lKSArICcgb2YgI3thY3R9J1xuICAgICAgICAsIHZhbFxuICAgICAgICAsIHZhbHVlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHZhbHVlKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5vd25Qcm9wZXJ0eShuYW1lKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBoYXMgYW4gb3duIHByb3BlcnR5IGBuYW1lYC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgndGVzdCcpLnRvLmhhdmUub3duUHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgKlxuICAgKiBAbmFtZSBvd25Qcm9wZXJ0eVxuICAgKiBAYWxpYXMgaGF2ZU93blByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgZnVuY3Rpb24gYXNzZXJ0T3duUHJvcGVydHkgKG5hbWUsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGhhdmUgb3duIHByb3BlcnR5ICcgKyBfLmluc3BlY3QobmFtZSlcbiAgICApO1xuICB9XG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnb3duUHJvcGVydHknLCBhc3NlcnRPd25Qcm9wZXJ0eSk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2hhdmVPd25Qcm9wZXJ0eScsIGFzc2VydE93blByb3BlcnR5KTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGgodmFsdWUpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0J3MgYGxlbmd0aGAgcHJvcGVydHkgaGFzXG4gICAqIHRoZSBleHBlY3RlZCB2YWx1ZS5cbiAgICpcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDNdKS50by5oYXZlLmxlbmd0aCgzKTtcbiAgICogICAgIGV4cGVjdCgnZm9vYmFyJykudG8uaGF2ZS5sZW5ndGgoNik7XG4gICAqXG4gICAqIENhbiBhbHNvIGJlIHVzZWQgYXMgYSBjaGFpbiBwcmVjdXJzb3IgdG8gYSB2YWx1ZVxuICAgKiBjb21wYXJpc29uIGZvciB0aGUgbGVuZ3RoIHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb28nKS50by5oYXZlLmxlbmd0aC5hYm92ZSgyKTtcbiAgICogICAgIGV4cGVjdChbIDEsIDIsIDMgXSkudG8uaGF2ZS5sZW5ndGguYWJvdmUoMik7XG4gICAqICAgICBleHBlY3QoJ2ZvbycpLnRvLmhhdmUubGVuZ3RoLmJlbG93KDQpO1xuICAgKiAgICAgZXhwZWN0KFsgMSwgMiwgMyBdKS50by5oYXZlLmxlbmd0aC5iZWxvdyg0KTtcbiAgICogICAgIGV4cGVjdCgnZm9vJykudG8uaGF2ZS5sZW5ndGgud2l0aGluKDIsNCk7XG4gICAqICAgICBleHBlY3QoWyAxLCAyLCAzIF0pLnRvLmhhdmUubGVuZ3RoLndpdGhpbigyLDQpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhcbiAgICogQGFsaWFzIGxlbmd0aE9mXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRMZW5ndGhDaGFpbiAoKSB7XG4gICAgZmxhZyh0aGlzLCAnZG9MZW5ndGgnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydExlbmd0aCAobiwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUucHJvcGVydHkoJ2xlbmd0aCcpO1xuICAgIHZhciBsZW4gPSBvYmoubGVuZ3RoO1xuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIGxlbiA9PSBuXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIGhhdmUgYSBsZW5ndGggb2YgI3tleHB9IGJ1dCBnb3QgI3thY3R9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgaGF2ZSBhIGxlbmd0aCBvZiAje2FjdH0nXG4gICAgICAsIG5cbiAgICAgICwgbGVuXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2xlbmd0aCcsIGFzc2VydExlbmd0aCwgYXNzZXJ0TGVuZ3RoQ2hhaW4pO1xuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdsZW5ndGhPZicsIGFzc2VydExlbmd0aCk7XG5cbiAgLyoqXG4gICAqICMjIyAubWF0Y2gocmVnZXhwKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KCdmb29iYXInKS50by5tYXRjaCgvXmZvby8pO1xuICAgKlxuICAgKiBAbmFtZSBtYXRjaFxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gUmVndWxhckV4cHJlc3Npb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdtYXRjaCcsIGZ1bmN0aW9uIChyZSwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICByZS5leGVjKG9iailcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbWF0Y2ggJyArIHJlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IG5vdCB0byBtYXRjaCAnICsgcmVcbiAgICApO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpbmcoc3RyaW5nKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHN0cmluZyB0YXJnZXQgY29udGFpbnMgYW5vdGhlciBzdHJpbmcuXG4gICAqXG4gICAqICAgICBleHBlY3QoJ2Zvb2JhcicpLnRvLmhhdmUuc3RyaW5nKCdiYXInKTtcbiAgICpcbiAgICogQG5hbWUgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgX29wdGlvbmFsX1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCdzdHJpbmcnLCBmdW5jdGlvbiAoc3RyLCBtc2cpIHtcbiAgICBpZiAobXNnKSBmbGFnKHRoaXMsICdtZXNzYWdlJywgbXNnKTtcbiAgICB2YXIgb2JqID0gZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykuaXMuYSgnc3RyaW5nJyk7XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgfm9iai5pbmRleE9mKHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gY29udGFpbiAnICsgXy5pbnNwZWN0KHN0cilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGNvbnRhaW4gJyArIF8uaW5zcGVjdChzdHIpXG4gICAgKTtcbiAgfSk7XG5cblxuICAvKipcbiAgICogIyMjIC5rZXlzKGtleTEsIFtrZXkyXSwgWy4uLl0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBleGFjdGx5IHRoZSBnaXZlbiBrZXlzLCBvclxuICAgKiBhc3NlcnRzIHRoZSBpbmNsdXNpb24gb2Ygc29tZSBrZXlzIHdoZW4gdXNpbmcgdGhlXG4gICAqIGBpbmNsdWRlYCBvciBgY29udGFpbmAgbW9kaWZpZXJzLlxuICAgKlxuICAgKiAgICAgZXhwZWN0KHsgZm9vOiAxLCBiYXI6IDIgfSkudG8uaGF2ZS5rZXlzKFsnZm9vJywgJ2JhciddKTtcbiAgICogICAgIGV4cGVjdCh7IGZvbzogMSwgYmFyOiAyLCBiYXo6IDMgfSkudG8uY29udGFpbi5rZXlzKCdmb28nLCAnYmFyJyk7XG4gICAqXG4gICAqIEBuYW1lIGtleXNcbiAgICogQGFsaWFzIGtleVxuICAgKiBAcGFyYW0ge1N0cmluZy4uLnxBcnJheX0ga2V5c1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRLZXlzIChrZXlzKSB7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpXG4gICAgICAsIHN0clxuICAgICAgLCBvayA9IHRydWU7XG5cbiAgICBrZXlzID0ga2V5cyBpbnN0YW5jZW9mIEFycmF5XG4gICAgICA/IGtleXNcbiAgICAgIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmICgha2V5cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcigna2V5cyByZXF1aXJlZCcpO1xuXG4gICAgdmFyIGFjdHVhbCA9IE9iamVjdC5rZXlzKG9iailcbiAgICAgICwgZXhwZWN0ZWQgPSBrZXlzXG4gICAgICAsIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gICAgLy8gSW5jbHVzaW9uXG4gICAgb2sgPSBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKGtleSl7XG4gICAgICByZXR1cm4gfmFjdHVhbC5pbmRleE9mKGtleSk7XG4gICAgfSk7XG5cbiAgICAvLyBTdHJpY3RcbiAgICBpZiAoIWZsYWcodGhpcywgJ25lZ2F0ZScpICYmICFmbGFnKHRoaXMsICdjb250YWlucycpKSB7XG4gICAgICBvayA9IG9rICYmIGtleXMubGVuZ3RoID09IGFjdHVhbC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gS2V5IHN0cmluZ1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgcmV0dXJuIF8uaW5zcGVjdChrZXkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdCA9IGtleXMucG9wKCk7XG4gICAgICBzdHIgPSBrZXlzLmpvaW4oJywgJykgKyAnLCBhbmQgJyArIGxhc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IF8uaW5zcGVjdChrZXlzWzBdKTtcbiAgICB9XG5cbiAgICAvLyBGb3JtXG4gICAgc3RyID0gKGxlbiA+IDEgPyAna2V5cyAnIDogJ2tleSAnKSArIHN0cjtcblxuICAgIC8vIEhhdmUgLyBpbmNsdWRlXG4gICAgc3RyID0gKGZsYWcodGhpcywgJ2NvbnRhaW5zJykgPyAnY29udGFpbiAnIDogJ2hhdmUgJykgKyBzdHI7XG5cbiAgICAvLyBBc3NlcnRpb25cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgb2tcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gJyArIHN0clxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgJyArIHN0clxuICAgICAgLCBleHBlY3RlZC5zb3J0KClcbiAgICAgICwgYWN0dWFsLnNvcnQoKVxuICAgICAgLCB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ2tleXMnLCBhc3NlcnRLZXlzKTtcbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgna2V5JywgYXNzZXJ0S2V5cyk7XG5cbiAgLyoqXG4gICAqICMjIyAudGhyb3coY29uc3RydWN0b3IpXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCB0aGUgZnVuY3Rpb24gdGFyZ2V0IHdpbGwgdGhyb3cgYSBzcGVjaWZpYyBlcnJvciwgb3Igc3BlY2lmaWMgdHlwZSBvZiBlcnJvclxuICAgKiAoYXMgZGV0ZXJtaW5lZCB1c2luZyBgaW5zdGFuY2VvZmApLCBvcHRpb25hbGx5IHdpdGggYSBSZWdFeHAgb3Igc3RyaW5nIGluY2x1c2lvbiB0ZXN0XG4gICAqIGZvciB0aGUgZXJyb3IncyBtZXNzYWdlLlxuICAgKlxuICAgKiAgICAgdmFyIGVyciA9IG5ldyBSZWZlcmVuY2VFcnJvcignVGhpcyBpcyBhIGJhZCBmdW5jdGlvbi4nKTtcbiAgICogICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9XG4gICAqICAgICBleHBlY3QoZm4pLnRvLnRocm93KFJlZmVyZW5jZUVycm9yKTtcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coRXJyb3IpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdygvYmFkIGZ1bmN0aW9uLyk7XG4gICAqICAgICBleHBlY3QoZm4pLnRvLm5vdC50aHJvdygnZ29vZCBmdW5jdGlvbicpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhSZWZlcmVuY2VFcnJvciwgL2JhZCBmdW5jdGlvbi8pO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by50aHJvdyhlcnIpO1xuICAgKiAgICAgZXhwZWN0KGZuKS50by5ub3QudGhyb3cobmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZS4nKSk7XG4gICAqXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgd2hlbiBhIHRocm93IGV4cGVjdGF0aW9uIGlzIG5lZ2F0ZWQsIGl0IHdpbGwgY2hlY2sgZWFjaFxuICAgKiBwYXJhbWV0ZXIgaW5kZXBlbmRlbnRseSwgc3RhcnRpbmcgd2l0aCBlcnJvciBjb25zdHJ1Y3RvciB0eXBlLiBUaGUgYXBwcm9wcmlhdGUgd2F5XG4gICAqIHRvIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGEgdHlwZSBvZiBlcnJvciBidXQgZm9yIGEgbWVzc2FnZSB0aGF0IGRvZXMgbm90IG1hdGNoXG4gICAqIGlzIHRvIHVzZSBgYW5kYC5cbiAgICpcbiAgICogICAgIGV4cGVjdChmbikudG8udGhyb3coUmVmZXJlbmNlRXJyb3IpXG4gICAqICAgICAgICAuYW5kLm5vdC50aHJvdygvZ29vZCBmdW5jdGlvbi8pO1xuICAgKlxuICAgKiBAbmFtZSB0aHJvd1xuICAgKiBAYWxpYXMgdGhyb3dzXG4gICAqIEBhbGlhcyBUaHJvd1xuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXhwZWN0ZWQgZXJyb3IgbWVzc2FnZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQHJldHVybnMgZXJyb3IgZm9yIGNoYWluaW5nIChudWxsIGlmIG5vIGVycm9yKVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBmdW5jdGlvbiBhc3NlcnRUaHJvd3MgKGNvbnN0cnVjdG9yLCBlcnJNc2csIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS5pcy5hKCdmdW5jdGlvbicpO1xuXG4gICAgdmFyIHRocm93biA9IGZhbHNlXG4gICAgICAsIGRlc2lyZWRFcnJvciA9IG51bGxcbiAgICAgICwgbmFtZSA9IG51bGxcbiAgICAgICwgdGhyb3duRXJyb3IgPSBudWxsO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGVyck1zZyA9IG51bGw7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBSZWdFeHAgfHwgJ3N0cmluZycgPT09IHR5cGVvZiBjb25zdHJ1Y3RvcikpIHtcbiAgICAgIGVyck1zZyA9IGNvbnN0cnVjdG9yO1xuICAgICAgY29uc3RydWN0b3IgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgZGVzaXJlZEVycm9yID0gY29uc3RydWN0b3I7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICBlcnJNc2cgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBuYW1lID0gY29uc3RydWN0b3IucHJvdG90eXBlLm5hbWUgfHwgY29uc3RydWN0b3IubmFtZTtcbiAgICAgIGlmIChuYW1lID09PSAnRXJyb3InICYmIGNvbnN0cnVjdG9yICE9PSBFcnJvcikge1xuICAgICAgICBuYW1lID0gKG5ldyBjb25zdHJ1Y3RvcigpKS5uYW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIG9iaigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZmlyc3QsIGNoZWNrIGRlc2lyZWQgZXJyb3JcbiAgICAgIGlmIChkZXNpcmVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5hc3NlcnQoXG4gICAgICAgICAgICBlcnIgPT09IGRlc2lyZWRFcnJvclxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAje2V4cH0nXG4gICAgICAgICAgLCAoZGVzaXJlZEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkZXNpcmVkRXJyb3IudG9TdHJpbmcoKSA6IGRlc2lyZWRFcnJvcilcbiAgICAgICAgICAsIChlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci50b1N0cmluZygpIDogZXJyKVxuICAgICAgICApO1xuXG4gICAgICAgIGZsYWcodGhpcywgJ29iamVjdCcsIGVycik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBuZXh0LCBjaGVjayBjb25zdHJ1Y3RvclxuICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgICAgZXJyIGluc3RhbmNlb2YgY29uc3RydWN0b3JcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICN7ZXhwfSBidXQgI3thY3R9IHdhcyB0aHJvd24nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgdGhyb3cgI3tleHB9IGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICAgICAgICAsIG5hbWVcbiAgICAgICAgICAsIChlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci50b1N0cmluZygpIDogZXJyKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmICghZXJyTXNnKSB7XG4gICAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBuZXh0LCBjaGVjayBtZXNzYWdlXG4gICAgICB2YXIgbWVzc2FnZSA9ICdvYmplY3QnID09PSBfLnR5cGUoZXJyKSAmJiBcIm1lc3NhZ2VcIiBpbiBlcnJcbiAgICAgICAgPyBlcnIubWVzc2FnZVxuICAgICAgICA6ICcnICsgZXJyO1xuXG4gICAgICBpZiAoKG1lc3NhZ2UgIT0gbnVsbCkgJiYgZXJyTXNnICYmIGVyck1zZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIGVyck1zZy5leGVjKG1lc3NhZ2UpXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBtYXRjaGluZyAje2V4cH0gYnV0IGdvdCAje2FjdH0nXG4gICAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byB0aHJvdyBlcnJvciBub3QgbWF0Y2hpbmcgI3tleHB9J1xuICAgICAgICAgICwgZXJyTXNnXG4gICAgICAgICAgLCBtZXNzYWdlXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKChtZXNzYWdlICE9IG51bGwpICYmIGVyck1zZyAmJiAnc3RyaW5nJyA9PT0gdHlwZW9mIGVyck1zZykge1xuICAgICAgICB0aGlzLmFzc2VydChcbiAgICAgICAgICAgIH5tZXNzYWdlLmluZGV4T2YoZXJyTXNnKVxuICAgICAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gdGhyb3cgZXJyb3IgaW5jbHVkaW5nICN7ZXhwfSBidXQgZ290ICN7YWN0fSdcbiAgICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93IGVycm9yIG5vdCBpbmNsdWRpbmcgI3thY3R9J1xuICAgICAgICAgICwgZXJyTXNnXG4gICAgICAgICAgLCBtZXNzYWdlXG4gICAgICAgICk7XG5cbiAgICAgICAgZmxhZyh0aGlzLCAnb2JqZWN0JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvd24gPSB0cnVlO1xuICAgICAgICB0aHJvd25FcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWN0dWFsbHlHb3QgPSAnJ1xuICAgICAgLCBleHBlY3RlZFRocm93biA9IG5hbWUgIT09IG51bGxcbiAgICAgICAgPyBuYW1lXG4gICAgICAgIDogZGVzaXJlZEVycm9yXG4gICAgICAgICAgPyAnI3tleHB9JyAvL18uaW5zcGVjdChkZXNpcmVkRXJyb3IpXG4gICAgICAgICAgOiAnYW4gZXJyb3InO1xuXG4gICAgaWYgKHRocm93bikge1xuICAgICAgYWN0dWFsbHlHb3QgPSAnIGJ1dCAje2FjdH0gd2FzIHRocm93bidcbiAgICB9XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgdGhyb3duID09PSB0cnVlXG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIHRocm93ICcgKyBleHBlY3RlZFRocm93biArIGFjdHVhbGx5R290XG4gICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCB0aHJvdyAnICsgZXhwZWN0ZWRUaHJvd24gKyBhY3R1YWxseUdvdFxuICAgICAgLCAoZGVzaXJlZEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkZXNpcmVkRXJyb3IudG9TdHJpbmcoKSA6IGRlc2lyZWRFcnJvcilcbiAgICAgICwgKHRocm93bkVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB0aHJvd25FcnJvci50b1N0cmluZygpIDogdGhyb3duRXJyb3IpXG4gICAgKTtcblxuICAgIGZsYWcodGhpcywgJ29iamVjdCcsIHRocm93bkVycm9yKTtcbiAgfTtcblxuICBBc3NlcnRpb24uYWRkTWV0aG9kKCd0aHJvdycsIGFzc2VydFRocm93cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Rocm93cycsIGFzc2VydFRocm93cyk7XG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ1Rocm93JywgYXNzZXJ0VGhyb3dzKTtcblxuICAvKipcbiAgICogIyMjIC5yZXNwb25kVG8obWV0aG9kKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIG9iamVjdCBvciBjbGFzcyB0YXJnZXQgd2lsbCByZXNwb25kIHRvIGEgbWV0aG9kLlxuICAgKlxuICAgKiAgICAgS2xhc3MucHJvdG90eXBlLmJhciA9IGZ1bmN0aW9uKCl7fTtcbiAgICogICAgIGV4cGVjdChLbGFzcykudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChvYmopLnRvLnJlc3BvbmRUbygnYmFyJyk7XG4gICAqXG4gICAqIFRvIGNoZWNrIGlmIGEgY29uc3RydWN0b3Igd2lsbCByZXNwb25kIHRvIGEgc3RhdGljIGZ1bmN0aW9uLFxuICAgKiBzZXQgdGhlIGBpdHNlbGZgIGZsYWcuXG4gICAqXG4gICAqICAgICBLbGFzcy5iYXogPSBmdW5jdGlvbigpe307XG4gICAqICAgICBleHBlY3QoS2xhc3MpLml0c2VsZi50by5yZXNwb25kVG8oJ2JheicpO1xuICAgKlxuICAgKiBAbmFtZSByZXNwb25kVG9cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3Jlc3BvbmRUbycsIGZ1bmN0aW9uIChtZXRob2QsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKVxuICAgICAgLCBpdHNlbGYgPSBmbGFnKHRoaXMsICdpdHNlbGYnKVxuICAgICAgLCBjb250ZXh0ID0gKCdmdW5jdGlvbicgPT09IF8udHlwZShvYmopICYmICFpdHNlbGYpXG4gICAgICAgID8gb2JqLnByb3RvdHlwZVttZXRob2RdXG4gICAgICAgIDogb2JqW21ldGhvZF07XG5cbiAgICB0aGlzLmFzc2VydChcbiAgICAgICAgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGNvbnRleHRcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gcmVzcG9uZCB0byAnICsgXy5pbnNwZWN0KG1ldGhvZClcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHJlc3BvbmQgdG8gJyArIF8uaW5zcGVjdChtZXRob2QpXG4gICAgKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqICMjIyAuaXRzZWxmXG4gICAqXG4gICAqIFNldHMgdGhlIGBpdHNlbGZgIGZsYWcsIGxhdGVyIHVzZWQgYnkgdGhlIGByZXNwb25kVG9gIGFzc2VydGlvbi5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIEZvbygpIHt9XG4gICAqICAgICBGb28uYmFyID0gZnVuY3Rpb24oKSB7fVxuICAgKiAgICAgRm9vLnByb3RvdHlwZS5iYXogPSBmdW5jdGlvbigpIHt9XG4gICAqXG4gICAqICAgICBleHBlY3QoRm9vKS5pdHNlbGYudG8ucmVzcG9uZFRvKCdiYXInKTtcbiAgICogICAgIGV4cGVjdChGb28pLml0c2VsZi5ub3QudG8ucmVzcG9uZFRvKCdiYXonKTtcbiAgICpcbiAgICogQG5hbWUgaXRzZWxmXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRQcm9wZXJ0eSgnaXRzZWxmJywgZnVuY3Rpb24gKCkge1xuICAgIGZsYWcodGhpcywgJ2l0c2VsZicsIHRydWUpO1xuICB9KTtcblxuICAvKipcbiAgICogIyMjIC5zYXRpc2Z5KG1ldGhvZClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgcGFzc2VzIGEgZ2l2ZW4gdHJ1dGggdGVzdC5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxKS50by5zYXRpc2Z5KGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtID4gMDsgfSk7XG4gICAqXG4gICAqIEBuYW1lIHNhdGlzZnlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWF0Y2hlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBfb3B0aW9uYWxfXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIEFzc2VydGlvbi5hZGRNZXRob2QoJ3NhdGlzZnknLCBmdW5jdGlvbiAobWF0Y2hlciwgbXNnKSB7XG4gICAgaWYgKG1zZykgZmxhZyh0aGlzLCAnbWVzc2FnZScsIG1zZyk7XG4gICAgdmFyIG9iaiA9IGZsYWcodGhpcywgJ29iamVjdCcpO1xuICAgIHZhciByZXN1bHQgPSBtYXRjaGVyKG9iaik7XG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIHJlc3VsdFxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBzYXRpc2Z5ICcgKyBfLm9iakRpc3BsYXkobWF0Y2hlcilcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IHNhdGlzZnknICsgXy5vYmpEaXNwbGF5KG1hdGNoZXIpXG4gICAgICAsIHRoaXMubmVnYXRlID8gZmFsc2UgOiB0cnVlXG4gICAgICAsIHJlc3VsdFxuICAgICk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oZXhwZWN0ZWQsIGRlbHRhKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgdGhlIHRhcmdldCBpcyBlcXVhbCBgZXhwZWN0ZWRgLCB0byB3aXRoaW4gYSArLy0gYGRlbHRhYCByYW5nZS5cbiAgICpcbiAgICogICAgIGV4cGVjdCgxLjUpLnRvLmJlLmNsb3NlVG8oMSwgMC41KTtcbiAgICpcbiAgICogQG5hbWUgY2xvc2VUb1xuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnY2xvc2VUbycsIGZ1bmN0aW9uIChleHBlY3RlZCwgZGVsdGEsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLmlzLmEoJ251bWJlcicpO1xuICAgIGlmIChfLnR5cGUoZXhwZWN0ZWQpICE9PSAnbnVtYmVyJyB8fCBfLnR5cGUoZGVsdGEpICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgYXJndW1lbnRzIHRvIGNsb3NlVG8gbXVzdCBiZSBudW1iZXJzJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hc3NlcnQoXG4gICAgICAgIE1hdGguYWJzKG9iaiAtIGV4cGVjdGVkKSA8PSBkZWx0YVxuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBjbG9zZSB0byAnICsgZXhwZWN0ZWQgKyAnICsvLSAnICsgZGVsdGFcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gbm90IHRvIGJlIGNsb3NlIHRvICcgKyBleHBlY3RlZCArICcgKy8tICcgKyBkZWx0YVxuICAgICk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGlzU3Vic2V0T2Yoc3Vic2V0LCBzdXBlcnNldCwgY21wKSB7XG4gICAgcmV0dXJuIHN1YnNldC5ldmVyeShmdW5jdGlvbihlbGVtKSB7XG4gICAgICBpZiAoIWNtcCkgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YoZWxlbSkgIT09IC0xO1xuXG4gICAgICByZXR1cm4gc3VwZXJzZXQuc29tZShmdW5jdGlvbihlbGVtMikge1xuICAgICAgICByZXR1cm4gY21wKGVsZW0sIGVsZW0yKTtcbiAgICAgIH0pO1xuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogIyMjIC5tZW1iZXJzKHNldClcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgYSBzdXBlcnNldCBvZiBgc2V0YCxcbiAgICogb3IgdGhhdCB0aGUgdGFyZ2V0IGFuZCBgc2V0YCBoYXZlIHRoZSBzYW1lIHN0cmljdGx5LWVxdWFsICg9PT0pIG1lbWJlcnMuXG4gICAqIEFsdGVybmF0ZWx5LCBpZiB0aGUgYGRlZXBgIGZsYWcgaXMgc2V0LCBzZXQgbWVtYmVycyBhcmUgY29tcGFyZWQgZm9yIGRlZXBcbiAgICogZXF1YWxpdHkuXG4gICAqXG4gICAqICAgICBleHBlY3QoWzEsIDIsIDNdKS50by5pbmNsdWRlLm1lbWJlcnMoWzMsIDJdKTtcbiAgICogICAgIGV4cGVjdChbMSwgMiwgM10pLnRvLm5vdC5pbmNsdWRlLm1lbWJlcnMoWzMsIDIsIDhdKTtcbiAgICpcbiAgICogICAgIGV4cGVjdChbNCwgMl0pLnRvLmhhdmUubWVtYmVycyhbMiwgNF0pO1xuICAgKiAgICAgZXhwZWN0KFs1LCAyXSkudG8ubm90LmhhdmUubWVtYmVycyhbNSwgMiwgMV0pO1xuICAgKlxuICAgKiAgICAgZXhwZWN0KFt7IGlkOiAxIH1dKS50by5kZWVwLmluY2x1ZGUubWVtYmVycyhbeyBpZDogMSB9XSk7XG4gICAqXG4gICAqIEBuYW1lIG1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIF9vcHRpb25hbF9cbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgQXNzZXJ0aW9uLmFkZE1ldGhvZCgnbWVtYmVycycsIGZ1bmN0aW9uIChzdWJzZXQsIG1zZykge1xuICAgIGlmIChtc2cpIGZsYWcodGhpcywgJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHZhciBvYmogPSBmbGFnKHRoaXMsICdvYmplY3QnKTtcblxuICAgIG5ldyBBc3NlcnRpb24ob2JqKS50by5iZS5hbignYXJyYXknKTtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1YnNldCkudG8uYmUuYW4oJ2FycmF5Jyk7XG5cbiAgICB2YXIgY21wID0gZmxhZyh0aGlzLCAnZGVlcCcpID8gXy5lcWwgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZmxhZyh0aGlzLCAnY29udGFpbnMnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0KFxuICAgICAgICAgIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmosIGNtcClcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBiZSBhIHN1cGVyc2V0IG9mICN7YWN0fSdcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgYmUgYSBzdXBlcnNldCBvZiAje2FjdH0nXG4gICAgICAgICwgb2JqXG4gICAgICAgICwgc3Vic2V0XG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0KFxuICAgICAgICBpc1N1YnNldE9mKG9iaiwgc3Vic2V0LCBjbXApICYmIGlzU3Vic2V0T2Yoc3Vic2V0LCBvYmosIGNtcClcbiAgICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgYXMgI3thY3R9J1xuICAgICAgICAsICdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMgYXMgI3thY3R9J1xuICAgICAgICAsIG9ialxuICAgICAgICAsIHN1YnNldFxuICAgICk7XG4gIH0pO1xufTtcbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hhaSwgdXRpbCkge1xuXG4gIC8qIVxuICAgKiBDaGFpIGRlcGVuZGVuY2llcy5cbiAgICovXG5cbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uXG4gICAgLCBmbGFnID0gdXRpbC5mbGFnO1xuXG4gIC8qIVxuICAgKiBNb2R1bGUgZXhwb3J0LlxuICAgKi9cblxuICAvKipcbiAgICogIyMjIGFzc2VydChleHByZXNzaW9uLCBtZXNzYWdlKVxuICAgKlxuICAgKiBXcml0ZSB5b3VyIG93biB0ZXN0IGV4cHJlc3Npb25zLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0KCdmb28nICE9PSAnYmFyJywgJ2ZvbyBpcyBub3QgYmFyJyk7XG4gICAqICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShbXSksICdlbXB0eSBhcnJheXMgYXJlIGFycmF5cycpO1xuICAgKlxuICAgKiBAcGFyYW0ge01peGVkfSBleHByZXNzaW9uIHRvIHRlc3QgZm9yIHRydXRoaW5lc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgdG8gZGlzcGxheSBvbiBlcnJvclxuICAgKiBAbmFtZSBhc3NlcnRcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgdmFyIGFzc2VydCA9IGNoYWkuYXNzZXJ0ID0gZnVuY3Rpb24gKGV4cHJlc3MsIGVycm1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihudWxsLCBudWxsLCBjaGFpLmFzc2VydCk7XG4gICAgdGVzdC5hc3NlcnQoXG4gICAgICAgIGV4cHJlc3NcbiAgICAgICwgZXJybXNnXG4gICAgICAsICdbIG5lZ2F0aW9uIG1lc3NhZ2UgdW5hdmFpbGFibGUgXSdcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmZhaWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdLCBbb3BlcmF0b3JdKVxuICAgKlxuICAgKiBUaHJvdyBhIGZhaWx1cmUuIE5vZGUuanMgYGFzc2VydGAgbW9kdWxlLWNvbXBhdGlibGUuXG4gICAqXG4gICAqIEBuYW1lIGZhaWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZmFpbCA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvcikge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdhc3NlcnQuZmFpbCgpJztcbiAgICB0aHJvdyBuZXcgY2hhaS5Bc3NlcnRpb25FcnJvcihtZXNzYWdlLCB7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsXG4gICAgICAsIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgLCBvcGVyYXRvcjogb3BlcmF0b3JcbiAgICB9LCBhc3NlcnQuZmFpbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyB0cnV0aHkuXG4gICAqXG4gICAqICAgICBhc3NlcnQub2soJ2V2ZXJ5dGhpbmcnLCAnZXZlcnl0aGluZyBpcyBvaycpO1xuICAgKiAgICAgYXNzZXJ0Lm9rKGZhbHNlLCAndGhpcyB3aWxsIGZhaWwnKTtcbiAgICpcbiAgICogQG5hbWUgb2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm9rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXMub2s7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90T2sob2JqZWN0LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBpcyBmYWxzeS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RPaygnZXZlcnl0aGluZycsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKiAgICAgYXNzZXJ0Lm5vdE9rKGZhbHNlLCAndGhpcyB3aWxsIHBhc3MnKTtcbiAgICpcbiAgICogQG5hbWUgbm90T2tcbiAgICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0IHRvIHRlc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE9rID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXMubm90Lm9rO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBub24tc3RyaWN0IGVxdWFsaXR5IChgPT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5lcXVhbCgzLCAnMycsICc9PSBjb2VyY2VzIHZhbHVlcyB0byBzdHJpbmdzJyk7XG4gICAqXG4gICAqIEBuYW1lIGVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0LmVxdWFsKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgPT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3tleHB9J1xuICAgICAgLCAnZXhwZWN0ZWQgI3t0aGlzfSB0byBub3QgZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgbm9uLXN0cmljdCBpbmVxdWFsaXR5IChgIT1gKSBvZiBgYWN0dWFsYCBhbmQgYGV4cGVjdGVkYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RFcXVhbCgzLCA0LCAndGhlc2UgbnVtYmVycyBhcmUgbm90IGVxdWFsJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiAoYWN0LCBleHAsIG1zZykge1xuICAgIHZhciB0ZXN0ID0gbmV3IEFzc2VydGlvbihhY3QsIG1zZywgYXNzZXJ0Lm5vdEVxdWFsKTtcblxuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICBleHAgIT0gZmxhZyh0ZXN0LCAnb2JqZWN0JylcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gbm90IGVxdWFsICN7ZXhwfSdcbiAgICAgICwgJ2V4cGVjdGVkICN7dGhpc30gdG8gZXF1YWwgI3thY3R9J1xuICAgICAgLCBleHBcbiAgICAgICwgYWN0XG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgc3RyaWN0IGVxdWFsaXR5IChgPT09YCkgb2YgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgdHJ1ZSwgJ3RoZXNlIGJvb2xlYW5zIGFyZSBzdHJpY3RseSBlcXVhbCcpO1xuICAgKlxuICAgKiBAbmFtZSBzdHJpY3RFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5lcXVhbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyBzdHJpY3QgaW5lcXVhbGl0eSAoYCE9PWApIG9mIGBhY3R1YWxgIGFuZCBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKDMsICczJywgJ25vIGNvZXJjaW9uIGZvciBzdHJpY3QgZXF1YWxpdHknKTtcbiAgICpcbiAgICogQG5hbWUgbm90U3RyaWN0RXF1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gYWN0dWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8ubm90LmVxdWFsKGV4cCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBhY3R1YWxgIGlzIGRlZXBseSBlcXVhbCB0byBgZXhwZWN0ZWRgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBFcXVhbCh7IHRlYTogJ2dyZWVuJyB9LCB7IHRlYTogJ2dyZWVuJyB9KTtcbiAgICpcbiAgICogQG5hbWUgZGVlcEVxdWFsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGFjdHVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBleHBlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGFjdCwgbXNnKS50by5lcWwoZXhwKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnQgdGhhdCBgYWN0dWFsYCBpcyBub3QgZGVlcGx5IGVxdWFsIHRvIGBleHBlY3RlZGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQubm90RGVlcEVxdWFsKHsgdGVhOiAnZ3JlZW4nIH0sIHsgdGVhOiAnamFzbWluZScgfSk7XG4gICAqXG4gICAqIEBuYW1lIG5vdERlZXBFcXVhbFxuICAgKiBAcGFyYW0ge01peGVkfSBhY3R1YWxcbiAgICogQHBhcmFtIHtNaXhlZH0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIChhY3QsIGV4cCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8ubm90LmVxbChleHApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzVHJ1ZSh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyB0cnVlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IHRydWU7XG4gICAqICAgICBhc3NlcnQuaXNUcnVlKHRlYVNlcnZlZCwgJ3RoZSB0ZWEgaGFzIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVHJ1ZVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykuaXNbJ3RydWUnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc0ZhbHNlKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGZhbHNlLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYVNlcnZlZCA9IGZhbHNlO1xuICAgKiAgICAgYXNzZXJ0LmlzRmFsc2UodGVhU2VydmVkLCAnbm8gdGVhIHlldD8gaG1tLi4uJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzRmFsc2VcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRmFsc2UgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS5pc1snZmFsc2UnXTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc051bGwodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgbnVsbC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pc051bGwoZXJyLCAndGhlcmUgd2FzIG5vIGVycm9yJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTnVsbFxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOdWxsID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3ROdWxsKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBudWxsLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYSA9ICd0YXN0eSBjaGFpJztcbiAgICogICAgIGFzc2VydC5pc05vdE51bGwodGVhLCAnZ3JlYXQsIHRpbWUgZm9yIHRlYSEnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdWxsXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdE51bGwgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuZXF1YWwobnVsbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNVbmRlZmluZWQodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqICAgICB2YXIgdGVhO1xuICAgKiAgICAgYXNzZXJ0LmlzVW5kZWZpbmVkKHRlYSwgJ25vIHRlYSBkZWZpbmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzVW5kZWZpbmVkXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmVxdWFsKHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNEZWZpbmVkKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogICAgIHZhciB0ZWEgPSAnY3VwIG9mIGNoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzRGVmaW5lZCh0ZWEsICd0ZWEgaGFzIGJlZW4gZGVmaW5lZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc0RlZmluZWRcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzRGVmaW5lZCA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5lcXVhbCh1bmRlZmluZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzRnVuY3Rpb24odmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogICAgIGZ1bmN0aW9uIHNlcnZlVGVhKCkgeyByZXR1cm4gJ2N1cCBvZiB0ZWEnOyB9O1xuICAgKiAgICAgYXNzZXJ0LmlzRnVuY3Rpb24oc2VydmVUZWEsICdncmVhdCwgd2UgY2FuIGhhdmUgdGVhIG5vdycpO1xuICAgKlxuICAgKiBAbmFtZSBpc0Z1bmN0aW9uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc05vdEZ1bmN0aW9uKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqICAgICB2YXIgc2VydmVUZWEgPSBbICdoZWF0JywgJ3BvdXInLCAnc2lwJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90RnVuY3Rpb24oc2VydmVUZWEsICdncmVhdCwgd2UgaGF2ZSBsaXN0ZWQgdGhlIHN0ZXBzJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzTm90RnVuY3Rpb25cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90RnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnZnVuY3Rpb24nKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5pc09iamVjdCh2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGFzIHJldmVhbGVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCkuXG4gICAqXG4gICAqICAgICB2YXIgc2VsZWN0aW9uID0geyBuYW1lOiAnQ2hhaScsIHNlcnZlOiAnd2l0aCBzcGljZXMnIH07XG4gICAqICAgICBhc3NlcnQuaXNPYmplY3Qoc2VsZWN0aW9uLCAndGVhIHNlbGVjdGlvbiBpcyBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOb3RPYmplY3QodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gb2JqZWN0LlxuICAgKlxuICAgKiAgICAgdmFyIHNlbGVjdGlvbiA9ICdjaGFpJ1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KHNlbGVjdGlvbiwgJ3RlYSBzZWxlY3Rpb24gaXMgbm90IGFuIG9iamVjdCcpO1xuICAgKiAgICAgYXNzZXJ0LmlzTm90T2JqZWN0KG51bGwsICdudWxsIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RPYmplY3RcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90T2JqZWN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ29iamVjdCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9IFsgJ2dyZWVuJywgJ2NoYWknLCAnb29sb25nJyBdO1xuICAgKiAgICAgYXNzZXJ0LmlzQXJyYXkobWVudSwgJ3doYXQga2luZCBvZiB0ZWEgZG8gd2Ugd2FudD8nKTtcbiAgICpcbiAgICogQG5hbWUgaXNBcnJheVxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90QXJyYXkodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgX25vdF8gYW4gYXJyYXkuXG4gICAqXG4gICAqICAgICB2YXIgbWVudSA9ICdncmVlbnxjaGFpfG9vbG9uZyc7XG4gICAqICAgICBhc3NlcnQuaXNOb3RBcnJheShtZW51LCAnd2hhdCBraW5kIG9mIHRlYSBkbyB3ZSB3YW50PycpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdEFycmF5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEFycmF5ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmFuKCdhcnJheScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzU3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gJ2NoYWknO1xuICAgKiAgICAgYXNzZXJ0LmlzU3RyaW5nKHRlYU9yZGVyLCAnb3JkZXIgcGxhY2VkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzU3RyaW5nXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ3N0cmluZycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90U3RyaW5nKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgc3RyaW5nLlxuICAgKlxuICAgKiAgICAgdmFyIHRlYU9yZGVyID0gNDtcbiAgICogICAgIGFzc2VydC5pc05vdFN0cmluZyh0ZWFPcmRlciwgJ29yZGVyIHBsYWNlZCcpO1xuICAgKlxuICAgKiBAbmFtZSBpc05vdFN0cmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNOb3RTdHJpbmcgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnc3RyaW5nJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaXNOdW1iZXIodmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIuXG4gICAqXG4gICAqICAgICB2YXIgY3VwcyA9IDI7XG4gICAqICAgICBhc3NlcnQuaXNOdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc051bWJlciA9IGZ1bmN0aW9uICh2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90TnVtYmVyKHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIF9ub3RfIGEgbnVtYmVyLlxuICAgKlxuICAgKiAgICAgdmFyIGN1cHMgPSAnMiBjdXBzIHBsZWFzZSc7XG4gICAqICAgICBhc3NlcnQuaXNOb3ROdW1iZXIoY3VwcywgJ2hvdyBtYW55IGN1cHMnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3ROdW1iZXJcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LmlzTm90TnVtYmVyID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEoJ251bWJlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzQm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSB0cnVlXG4gICAqICAgICAgICwgdGVhU2VydmVkID0gZmFsc2U7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaXNCb29sZWFuKHRlYVJlYWR5LCAnaXMgdGhlIHRlYSByZWFkeScpO1xuICAgKiAgICAgYXNzZXJ0LmlzQm9vbGVhbih0ZWFTZXJ2ZWQsICdoYXMgdGVhIGJlZW4gc2VydmVkJyk7XG4gICAqXG4gICAqIEBuYW1lIGlzQm9vbGVhblxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8uYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmlzTm90Qm9vbGVhbih2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCBpcyBfbm90XyBhIGJvb2xlYW4uXG4gICAqXG4gICAqICAgICB2YXIgdGVhUmVhZHkgPSAneWVwJ1xuICAgKiAgICAgICAsIHRlYVNlcnZlZCA9ICdub3BlJztcbiAgICpcbiAgICogICAgIGFzc2VydC5pc05vdEJvb2xlYW4odGVhUmVhZHksICdpcyB0aGUgdGVhIHJlYWR5Jyk7XG4gICAqICAgICBhc3NlcnQuaXNOb3RCb29sZWFuKHRlYVNlcnZlZCwgJ2hhcyB0ZWEgYmVlbiBzZXJ2ZWQnKTtcbiAgICpcbiAgICogQG5hbWUgaXNOb3RCb29sZWFuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pc05vdEJvb2xlYW4gPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5ub3QuYmUuYSgnYm9vbGVhbicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50eXBlT2YoeyB0ZWE6ICdjaGFpJyB9LCAnb2JqZWN0JywgJ3dlIGhhdmUgYW4gb2JqZWN0Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKFsnY2hhaScsICdqYXNtaW5lJ10sICdhcnJheScsICd3ZSBoYXZlIGFuIGFycmF5Jyk7XG4gICAqICAgICBhc3NlcnQudHlwZU9mKCd0ZWEnLCAnc3RyaW5nJywgJ3dlIGhhdmUgYSBzdHJpbmcnKTtcbiAgICogICAgIGFzc2VydC50eXBlT2YoL3RlYS8sICdyZWdleHAnLCAnd2UgaGF2ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbicpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZihudWxsLCAnbnVsbCcsICd3ZSBoYXZlIGEgbnVsbCcpO1xuICAgKiAgICAgYXNzZXJ0LnR5cGVPZih1bmRlZmluZWQsICd1bmRlZmluZWQnLCAnd2UgaGF2ZSBhbiB1bmRlZmluZWQnKTtcbiAgICpcbiAgICogQG5hbWUgdHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC50eXBlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5hKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdFR5cGVPZih2YWx1ZSwgbmFtZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHZhbHVlYCdzIHR5cGUgaXMgX25vdF8gYG5hbWVgLCBhcyBkZXRlcm1pbmVkIGJ5XG4gICAqIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RUeXBlT2YoJ3RlYScsICdudW1iZXInLCAnc3RyaW5ncyBhcmUgbm90IG51bWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgbm90VHlwZU9mXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlb2YgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90VHlwZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmEodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5zdGFuY2VPZihvYmplY3QsIGNvbnN0cnVjdG9yLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIGlzIGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgVGVhKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQuaW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIGFuIGluc3RhbmNlIG9mIHRlYScpO1xuICAgKlxuICAgKiBAbmFtZSBpbnN0YW5jZU9mXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtDb25zdHJ1Y3Rvcn0gY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lmluc3RhbmNlT2YgPSBmdW5jdGlvbiAodmFsLCB0eXBlLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5iZS5pbnN0YW5jZU9mKHR5cGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdEluc3RhbmNlT2Yob2JqZWN0LCBjb25zdHJ1Y3RvciwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIGB2YWx1ZWAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAuXG4gICAqXG4gICAqICAgICB2YXIgVGVhID0gZnVuY3Rpb24gKG5hbWUpIHsgdGhpcy5uYW1lID0gbmFtZTsgfVxuICAgKiAgICAgICAsIGNoYWkgPSBuZXcgU3RyaW5nKCdjaGFpJyk7XG4gICAqXG4gICAqICAgICBhc3NlcnQubm90SW5zdGFuY2VPZihjaGFpLCBUZWEsICdjaGFpIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5zdGFuY2VPZlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7Q29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbnN0YW5jZU9mID0gZnVuY3Rpb24gKHZhbCwgdHlwZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLmluc3RhbmNlT2YodHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZShoYXlzdGFjaywgbmVlZGxlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgaGF5c3RhY2tgIGluY2x1ZGVzIGBuZWVkbGVgLiBXb3Jrc1xuICAgKiBmb3Igc3RyaW5ncyBhbmQgYXJyYXlzLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmluY2x1ZGUoJ2Zvb2JhcicsICdiYXInLCAnZm9vYmFyIGNvbnRhaW5zIHN0cmluZyBcImJhclwiJyk7XG4gICAqICAgICBhc3NlcnQuaW5jbHVkZShbIDEsIDIsIDMgXSwgMywgJ2FycmF5IGNvbnRhaW5zIHZhbHVlJyk7XG4gICAqXG4gICAqIEBuYW1lIGluY2x1ZGVcbiAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGhheXN0YWNrXG4gICAqIEBwYXJhbSB7TWl4ZWR9IG5lZWRsZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuaW5jbHVkZSA9IGZ1bmN0aW9uIChleHAsIGluYywgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZywgYXNzZXJ0LmluY2x1ZGUpLmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RJbmNsdWRlKGhheXN0YWNrLCBuZWVkbGUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBoYXlzdGFja2AgZG9lcyBub3QgaW5jbHVkZSBgbmVlZGxlYC4gV29ya3NcbiAgICogZm9yIHN0cmluZ3MgYW5kIGFycmF5cy5cbiAgICppXG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZSgnZm9vYmFyJywgJ2JheicsICdzdHJpbmcgbm90IGluY2x1ZGUgc3Vic3RyaW5nJyk7XG4gICAqICAgICBhc3NlcnQubm90SW5jbHVkZShbIDEsIDIsIDMgXSwgNCwgJ2FycmF5IG5vdCBpbmNsdWRlIGNvbnRhaW4gdmFsdWUnKTtcbiAgICpcbiAgICogQG5hbWUgbm90SW5jbHVkZVxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gaGF5c3RhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gbmVlZGxlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5ub3RJbmNsdWRlID0gZnVuY3Rpb24gKGV4cCwgaW5jLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKGV4cCwgbXNnLCBhc3NlcnQubm90SW5jbHVkZSkubm90LmluY2x1ZGUoaW5jKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5tYXRjaCh2YWx1ZSwgcmVnZXhwLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgdmFsdWVgIG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5tYXRjaCgnZm9vYmFyJywgL15mb28vLCAncmVnZXhwIG1hdGNoZXMnKTtcbiAgICpcbiAgICogQG5hbWUgbWF0Y2hcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWdFeHB9IHJlZ2V4cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubWF0Y2ggPSBmdW5jdGlvbiAoZXhwLCByZSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihleHAsIG1zZykudG8ubWF0Y2gocmUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLm5vdE1hdGNoKHZhbHVlLCByZWdleHAsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGB2YWx1ZWAgZG9lcyBub3QgbWF0Y2ggdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3RNYXRjaCgnZm9vYmFyJywgL15mb28vLCAncmVnZXhwIGRvZXMgbm90IG1hdGNoJyk7XG4gICAqXG4gICAqIEBuYW1lIG5vdE1hdGNoXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdE1hdGNoID0gZnVuY3Rpb24gKGV4cCwgcmUsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2cpLnRvLm5vdC5tYXRjaChyZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEnKTtcbiAgICpcbiAgICogQG5hbWUgcHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LnByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwgcHJvcCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5ub3RQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBkb2VzIF9ub3RfIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm5vdFByb3BlcnR5KHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ2NvZmZlZScpO1xuICAgKlxuICAgKiBAbmFtZSBub3RQcm9wZXJ0eVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubm90UHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5ub3QuaGF2ZS5wcm9wZXJ0eShwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgd2hpY2ggY2FuIGJlIGFcbiAgICogc3RyaW5nIHVzaW5nIGRvdC0gYW5kIGJyYWNrZXQtbm90YXRpb24gZm9yIGRlZXAgcmVmZXJlbmNlLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LmRlZXBQcm9wZXJ0eSh7IHRlYTogeyBncmVlbjogJ21hdGNoYScgfX0sICd0ZWEuZ3JlZW4nKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFByb3BlcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKG9iaiwgbXNnKS50by5oYXZlLmRlZXAucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAubm90RGVlcFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGRvZXMgX25vdF8gaGF2ZSBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAsIHdoaWNoXG4gICAqIGNhbiBiZSBhIHN0cmluZyB1c2luZyBkb3QtIGFuZCBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5ub3REZWVwUHJvcGVydHkoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLm9vbG9uZycpO1xuICAgKlxuICAgKiBAbmFtZSBub3REZWVwUHJvcGVydHlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0Lm5vdERlZXBQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLmRlZXAucHJvcGVydHkocHJvcCk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAucHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlblxuICAgKiBieSBgdmFsdWVgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0LnByb3BlcnR5VmFsKHsgdGVhOiAnaXMgZ29vZCcgfSwgJ3RlYScsICdpcyBnb29kJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eVZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8uaGF2ZS5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLnByb3BlcnR5Tm90VmFsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgb2JqZWN0YCBoYXMgYSBwcm9wZXJ0eSBuYW1lZCBieSBgcHJvcGVydHlgLCBidXQgd2l0aCBhIHZhbHVlXG4gICAqIGRpZmZlcmVudCBmcm9tIHRoYXQgZ2l2ZW4gYnkgYHZhbHVlYC5cbiAgICpcbiAgICogICAgIGFzc2VydC5wcm9wZXJ0eU5vdFZhbCh7IHRlYTogJ2lzIGdvb2QnIH0sICd0ZWEnLCAnaXMgYmFkJyk7XG4gICAqXG4gICAqIEBuYW1lIHByb3BlcnR5Tm90VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5wcm9wZXJ0eU5vdFZhbCA9IGZ1bmN0aW9uIChvYmosIHByb3AsIHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihvYmosIG1zZykudG8ubm90LmhhdmUucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5kZWVwUHJvcGVydHlWYWwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IGBvYmplY3RgIGhhcyBhIHByb3BlcnR5IG5hbWVkIGJ5IGBwcm9wZXJ0eWAgd2l0aCB2YWx1ZSBnaXZlblxuICAgKiBieSBgdmFsdWVgLiBgcHJvcGVydHlgIGNhbiB1c2UgZG90LSBhbmQgYnJhY2tldC1ub3RhdGlvbiBmb3IgZGVlcFxuICAgKiByZWZlcmVuY2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZGVlcFByb3BlcnR5VmFsKHsgdGVhOiB7IGdyZWVuOiAnbWF0Y2hhJyB9fSwgJ3RlYS5ncmVlbicsICdtYXRjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFByb3BlcnR5VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwUHJvcGVydHlWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLmhhdmUuZGVlcC5wcm9wZXJ0eShwcm9wLCB2YWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmRlZXBQcm9wZXJ0eU5vdFZhbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgcHJvcGVydHkgbmFtZWQgYnkgYHByb3BlcnR5YCwgYnV0IHdpdGggYSB2YWx1ZVxuICAgKiBkaWZmZXJlbnQgZnJvbSB0aGF0IGdpdmVuIGJ5IGB2YWx1ZWAuIGBwcm9wZXJ0eWAgY2FuIHVzZSBkb3QtIGFuZFxuICAgKiBicmFja2V0LW5vdGF0aW9uIGZvciBkZWVwIHJlZmVyZW5jZS5cbiAgICpcbiAgICogICAgIGFzc2VydC5kZWVwUHJvcGVydHlOb3RWYWwoeyB0ZWE6IHsgZ3JlZW46ICdtYXRjaGEnIH19LCAndGVhLmdyZWVuJywgJ2tvbmFjaGEnKTtcbiAgICpcbiAgICogQG5hbWUgZGVlcFByb3BlcnR5Tm90VmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5kZWVwUHJvcGVydHlOb3RWYWwgPSBmdW5jdGlvbiAob2JqLCBwcm9wLCB2YWwsIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24ob2JqLCBtc2cpLnRvLm5vdC5oYXZlLmRlZXAucHJvcGVydHkocHJvcCwgdmFsKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5sZW5ndGhPZihvYmplY3QsIGxlbmd0aCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYG9iamVjdGAgaGFzIGEgYGxlbmd0aGAgcHJvcGVydHkgd2l0aCB0aGUgZXhwZWN0ZWQgdmFsdWUuXG4gICAqXG4gICAqICAgICBhc3NlcnQubGVuZ3RoT2YoWzEsMiwzXSwgMywgJ2FycmF5IGhhcyBsZW5ndGggb2YgMycpO1xuICAgKiAgICAgYXNzZXJ0Lmxlbmd0aE9mKCdmb29iYXInLCA1LCAnc3RyaW5nIGhhcyBsZW5ndGggb2YgNicpO1xuICAgKlxuICAgKiBAbmFtZSBsZW5ndGhPZlxuICAgKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQubGVuZ3RoT2YgPSBmdW5jdGlvbiAoZXhwLCBsZW4sIG1zZykge1xuICAgIG5ldyBBc3NlcnRpb24oZXhwLCBtc2cpLnRvLmhhdmUubGVuZ3RoKGxlbik7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAudGhyb3dzKGZ1bmN0aW9uLCBbY29uc3RydWN0b3Ivc3RyaW5nL3JlZ2V4cF0sIFtzdHJpbmcvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIHRocm93IGFuIGVycm9yIHdpdGggbWVzc2FnZVxuICAgKiBtYXRjaGluZyBgcmVnZXhwYC5cbiAgICpcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgJ2Z1bmN0aW9uIHRocm93cyBhIHJlZmVyZW5jZSBlcnJvcicpO1xuICAgKiAgICAgYXNzZXJ0LnRocm93KGZuLCAvZnVuY3Rpb24gdGhyb3dzIGEgcmVmZXJlbmNlIGVycm9yLyk7XG4gICAqICAgICBhc3NlcnQudGhyb3coZm4sIFJlZmVyZW5jZUVycm9yKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsICdmdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3InKTtcbiAgICogICAgIGFzc2VydC50aHJvdyhmbiwgUmVmZXJlbmNlRXJyb3IsIC9mdW5jdGlvbiB0aHJvd3MgYSByZWZlcmVuY2UgZXJyb3IvKTtcbiAgICpcbiAgICogQG5hbWUgdGhyb3dzXG4gICAqIEBhbGlhcyB0aHJvd1xuICAgKiBAYWxpYXMgVGhyb3dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFcnJvckNvbnN0cnVjdG9yfSBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhwXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjRXJyb3JfdHlwZXNcbiAgICogQGFwaSBwdWJsaWNcbiAgICovXG5cbiAgYXNzZXJ0LlRocm93ID0gZnVuY3Rpb24gKGZuLCBlcnJ0LCBlcnJzLCBtc2cpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBlcnJ0IHx8IGVycnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGVycnMgPSBlcnJ0O1xuICAgICAgZXJydCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFzc2VydEVyciA9IG5ldyBBc3NlcnRpb24oZm4sIG1zZykudG8uVGhyb3coZXJydCwgZXJycyk7XG4gICAgcmV0dXJuIGZsYWcoYXNzZXJ0RXJyLCAnb2JqZWN0Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAuZG9lc05vdFRocm93KGZ1bmN0aW9uLCBbY29uc3RydWN0b3IvcmVnZXhwXSwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYGZ1bmN0aW9uYCB3aWxsIF9ub3RfIHRocm93IGFuIGVycm9yIHRoYXQgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICogYGNvbnN0cnVjdG9yYCwgb3IgYWx0ZXJuYXRlbHkgdGhhdCBpdCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciB3aXRoIG1lc3NhZ2VcbiAgICogbWF0Y2hpbmcgYHJlZ2V4cGAuXG4gICAqXG4gICAqICAgICBhc3NlcnQuZG9lc05vdFRocm93KGZuLCBFcnJvciwgJ2Z1bmN0aW9uIGRvZXMgbm90IHRocm93Jyk7XG4gICAqXG4gICAqIEBuYW1lIGRvZXNOb3RUaHJvd1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yQ29uc3RydWN0b3J9IGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdleHBcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24gKGZuLCB0eXBlLCBtc2cpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICBtc2cgPSB0eXBlO1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5ub3QuVGhyb3codHlwZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqICMjIyAub3BlcmF0b3IodmFsMSwgb3BlcmF0b3IsIHZhbDIsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQ29tcGFyZXMgdHdvIHZhbHVlcyB1c2luZyBgb3BlcmF0b3JgLlxuICAgKlxuICAgKiAgICAgYXNzZXJ0Lm9wZXJhdG9yKDEsICc8JywgMiwgJ2V2ZXJ5dGhpbmcgaXMgb2snKTtcbiAgICogICAgIGFzc2VydC5vcGVyYXRvcigxLCAnPicsIDIsICd0aGlzIHdpbGwgZmFpbCcpO1xuICAgKlxuICAgKiBAbmFtZSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwxXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRvclxuICAgKiBAcGFyYW0ge01peGVkfSB2YWwyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5vcGVyYXRvciA9IGZ1bmN0aW9uICh2YWwsIG9wZXJhdG9yLCB2YWwyLCBtc2cpIHtcbiAgICBpZiAoIX5bJz09JywgJz09PScsICc+JywgJz49JywgJzwnLCAnPD0nLCAnIT0nLCAnIT09J10uaW5kZXhPZihvcGVyYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcGVyYXRvciBcIicgKyBvcGVyYXRvciArICdcIicpO1xuICAgIH1cbiAgICB2YXIgdGVzdCA9IG5ldyBBc3NlcnRpb24oZXZhbCh2YWwgKyBvcGVyYXRvciArIHZhbDIpLCBtc2cpO1xuICAgIHRlc3QuYXNzZXJ0KFxuICAgICAgICB0cnVlID09PSBmbGFnKHRlc3QsICdvYmplY3QnKVxuICAgICAgLCAnZXhwZWN0ZWQgJyArIHV0aWwuaW5zcGVjdCh2YWwpICsgJyB0byBiZSAnICsgb3BlcmF0b3IgKyAnICcgKyB1dGlsLmluc3BlY3QodmFsMilcbiAgICAgICwgJ2V4cGVjdGVkICcgKyB1dGlsLmluc3BlY3QodmFsKSArICcgdG8gbm90IGJlICcgKyBvcGVyYXRvciArICcgJyArIHV0aWwuaW5zcGVjdCh2YWwyKSApO1xuICB9O1xuXG4gIC8qKlxuICAgKiAjIyMgLmNsb3NlVG8oYWN0dWFsLCBleHBlY3RlZCwgZGVsdGEsIFttZXNzYWdlXSlcbiAgICpcbiAgICogQXNzZXJ0cyB0aGF0IHRoZSB0YXJnZXQgaXMgZXF1YWwgYGV4cGVjdGVkYCwgdG8gd2l0aGluIGEgKy8tIGBkZWx0YWAgcmFuZ2UuXG4gICAqXG4gICAqICAgICBhc3NlcnQuY2xvc2VUbygxLjUsIDEsIDAuNSwgJ251bWJlcnMgYXJlIGNsb3NlJyk7XG4gICAqXG4gICAqIEBuYW1lIGNsb3NlVG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFjdHVhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5jbG9zZVRvID0gZnVuY3Rpb24gKGFjdCwgZXhwLCBkZWx0YSwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihhY3QsIG1zZykudG8uYmUuY2xvc2VUbyhleHAsIGRlbHRhKTtcbiAgfTtcblxuICAvKipcbiAgICogIyMjIC5zYW1lTWVtYmVycyhzZXQxLCBzZXQyLCBbbWVzc2FnZV0pXG4gICAqXG4gICAqIEFzc2VydHMgdGhhdCBgc2V0MWAgYW5kIGBzZXQyYCBoYXZlIHRoZSBzYW1lIG1lbWJlcnMuXG4gICAqIE9yZGVyIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAqXG4gICAqICAgICBhc3NlcnQuc2FtZU1lbWJlcnMoWyAxLCAyLCAzIF0sIFsgMiwgMSwgMyBdLCAnc2FtZSBtZW1iZXJzJyk7XG4gICAqXG4gICAqIEBuYW1lIHNhbWVNZW1iZXJzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNldDFcbiAgICogQHBhcmFtIHtBcnJheX0gc2V0MlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAYXBpIHB1YmxpY1xuICAgKi9cblxuICBhc3NlcnQuc2FtZU1lbWJlcnMgPSBmdW5jdGlvbiAoc2V0MSwgc2V0MiwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbihzZXQxLCBtc2cpLnRvLmhhdmUuc2FtZS5tZW1iZXJzKHNldDIpO1xuICB9XG5cbiAgLyoqXG4gICAqICMjIyAuaW5jbHVkZU1lbWJlcnMoc3VwZXJzZXQsIHN1YnNldCwgW21lc3NhZ2VdKVxuICAgKlxuICAgKiBBc3NlcnRzIHRoYXQgYHN1YnNldGAgaXMgaW5jbHVkZWQgaW4gYHN1cGVyc2V0YC5cbiAgICogT3JkZXIgaXMgbm90IHRha2VuIGludG8gYWNjb3VudC5cbiAgICpcbiAgICogICAgIGFzc2VydC5pbmNsdWRlTWVtYmVycyhbIDEsIDIsIDMgXSwgWyAyLCAxIF0sICdpbmNsdWRlIG1lbWJlcnMnKTtcbiAgICpcbiAgICogQG5hbWUgaW5jbHVkZU1lbWJlcnNcbiAgICogQHBhcmFtIHtBcnJheX0gc3VwZXJzZXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3Vic2V0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuXG4gIGFzc2VydC5pbmNsdWRlTWVtYmVycyA9IGZ1bmN0aW9uIChzdXBlcnNldCwgc3Vic2V0LCBtc2cpIHtcbiAgICBuZXcgQXNzZXJ0aW9uKHN1cGVyc2V0LCBtc2cpLnRvLmluY2x1ZGUubWVtYmVycyhzdWJzZXQpO1xuICB9XG5cbiAgLyohXG4gICAqIFVuZG9jdW1lbnRlZCAvIHVudGVzdGVkXG4gICAqL1xuXG4gIGFzc2VydC5pZkVycm9yID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgbmV3IEFzc2VydGlvbih2YWwsIG1zZykudG8ubm90LmJlLm9rO1xuICB9O1xuXG4gIC8qIVxuICAgKiBBbGlhc2VzLlxuICAgKi9cblxuICAoZnVuY3Rpb24gYWxpYXMobmFtZSwgYXMpe1xuICAgIGFzc2VydFthc10gPSBhc3NlcnRbbmFtZV07XG4gICAgcmV0dXJuIGFsaWFzO1xuICB9KVxuICAoJ1Rocm93JywgJ3Rocm93JylcbiAgKCdUaHJvdycsICd0aHJvd3MnKTtcbn07XG4iLCIvKiFcbiAqIGNoYWlcbiAqIENvcHlyaWdodChjKSAyMDExLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjaGFpLCB1dGlsKSB7XG4gIGNoYWkuZXhwZWN0ID0gZnVuY3Rpb24gKHZhbCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgY2hhaS5Bc3NlcnRpb24odmFsLCBtZXNzYWdlKTtcbiAgfTtcbn07XG5cbiIsIi8qIVxuICogY2hhaVxuICogQ29weXJpZ2h0KGMpIDIwMTEtMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoYWksIHV0aWwpIHtcbiAgdmFyIEFzc2VydGlvbiA9IGNoYWkuQXNzZXJ0aW9uO1xuXG4gIGZ1bmN0aW9uIGxvYWRTaG91bGQgKCkge1xuICAgIC8vIGV4cGxpY2l0bHkgZGVmaW5lIHRoaXMgbWV0aG9kIGFzIGZ1bmN0aW9uIGFzIHRvIGhhdmUgaXQncyBuYW1lIHRvIGluY2x1ZGUgYXMgYHNzZmlgXG4gICAgZnVuY3Rpb24gc2hvdWxkR2V0dGVyKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdGhpcyBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzID09IHRydWUsIG51bGwsIHNob3VsZEdldHRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0aGlzLCBudWxsLCBzaG91bGRHZXR0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRTZXR0ZXIodmFsdWUpIHtcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2NoYWkvaXNzdWVzLzg2OiB0aGlzIG1ha2VzXG4gICAgICAvLyBgd2hhdGV2ZXIuc2hvdWxkID0gc29tZVZhbHVlYCBhY3R1YWxseSBzZXQgYHNvbWVWYWx1ZWAsIHdoaWNoIGlzXG4gICAgICAvLyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgYGdsb2JhbC5zaG91bGQgPSByZXF1aXJlKCdjaGFpJykuc2hvdWxkKClgLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB3ZSBoYXZlIHRvIHVzZSBbW0RlZmluZVByb3BlcnR5XV0gaW5zdGVhZCBvZiBbW1B1dF1dXG4gICAgICAvLyBzaW5jZSBvdGhlcndpc2Ugd2Ugd291bGQgdHJpZ2dlciB0aGlzIHZlcnkgc2V0dGVyIVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzaG91bGQnLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIG1vZGlmeSBPYmplY3QucHJvdG90eXBlIHRvIGhhdmUgYHNob3VsZGBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgJ3Nob3VsZCcsIHtcbiAgICAgIHNldDogc2hvdWxkU2V0dGVyXG4gICAgICAsIGdldDogc2hvdWxkR2V0dGVyXG4gICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIHNob3VsZCA9IHt9O1xuXG4gICAgc2hvdWxkLmVxdWFsID0gZnVuY3Rpb24gKHZhbDEsIHZhbDIsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbih2YWwxLCBtc2cpLnRvLmVxdWFsKHZhbDIpO1xuICAgIH07XG5cbiAgICBzaG91bGQuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5UaHJvdyhlcnJ0LCBlcnJzKTtcbiAgICB9O1xuXG4gICAgc2hvdWxkLmV4aXN0ID0gZnVuY3Rpb24gKHZhbCwgbXNnKSB7XG4gICAgICBuZXcgQXNzZXJ0aW9uKHZhbCwgbXNnKS50by5leGlzdDtcbiAgICB9XG5cbiAgICAvLyBuZWdhdGlvblxuICAgIHNob3VsZC5ub3QgPSB7fVxuXG4gICAgc2hvdWxkLm5vdC5lcXVhbCA9IGZ1bmN0aW9uICh2YWwxLCB2YWwyLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsMSwgbXNnKS50by5ub3QuZXF1YWwodmFsMik7XG4gICAgfTtcblxuICAgIHNob3VsZC5ub3QuVGhyb3cgPSBmdW5jdGlvbiAoZm4sIGVycnQsIGVycnMsIG1zZykge1xuICAgICAgbmV3IEFzc2VydGlvbihmbiwgbXNnKS50by5ub3QuVGhyb3coZXJydCwgZXJycyk7XG4gICAgfTtcblxuICAgIHNob3VsZC5ub3QuZXhpc3QgPSBmdW5jdGlvbiAodmFsLCBtc2cpIHtcbiAgICAgIG5ldyBBc3NlcnRpb24odmFsLCBtc2cpLnRvLm5vdC5leGlzdDtcbiAgICB9XG5cbiAgICBzaG91bGRbJ3Rocm93J10gPSBzaG91bGRbJ1Rocm93J107XG4gICAgc2hvdWxkLm5vdFsndGhyb3cnXSA9IHNob3VsZC5ub3RbJ1Rocm93J107XG5cbiAgICByZXR1cm4gc2hvdWxkO1xuICB9O1xuXG4gIGNoYWkuc2hvdWxkID0gbG9hZFNob3VsZDtcbiAgY2hhaS5TaG91bGQgPSBsb2FkU2hvdWxkO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGFkZENoYWluaW5nTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgdHJhbnNmZXJGbGFncyA9IHJlcXVpcmUoJy4vdHJhbnNmZXJGbGFncycpO1xudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKTtcblxuLyohXG4gKiBNb2R1bGUgdmFyaWFibGVzXG4gKi9cblxuLy8gQ2hlY2sgd2hldGhlciBgX19wcm90b19fYCBpcyBzdXBwb3J0ZWRcbnZhciBoYXNQcm90b1N1cHBvcnQgPSAnX19wcm90b19fJyBpbiBPYmplY3Q7XG5cbi8vIFdpdGhvdXQgYF9fcHJvdG9fX2Agc3VwcG9ydCwgdGhpcyBtb2R1bGUgd2lsbCBuZWVkIHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGEgZnVuY3Rpb24uXG4vLyBIb3dldmVyLCBzb21lIEZ1bmN0aW9uLnByb3RvdHlwZSBtZXRob2RzIGNhbm5vdCBiZSBvdmVyd3JpdHRlbixcbi8vIGFuZCB0aGVyZSBzZWVtcyBubyBlYXN5IGNyb3NzLXBsYXRmb3JtIHdheSB0byBkZXRlY3QgdGhlbSAoQHNlZSBjaGFpanMvY2hhaS9pc3N1ZXMvNjkpLlxudmFyIGV4Y2x1ZGVOYW1lcyA9IC9eKD86bGVuZ3RofG5hbWV8YXJndW1lbnRzfGNhbGxlcikkLztcblxuLy8gQ2FjaGUgYEZ1bmN0aW9uYCBwcm9wZXJ0aWVzXG52YXIgY2FsbCAgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbCxcbiAgICBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLyoqXG4gKiAjIyMgYWRkQ2hhaW5hYmxlTWV0aG9kIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcilcbiAqXG4gKiBBZGRzIGEgbWV0aG9kIHRvIGFuIG9iamVjdCwgc3VjaCB0aGF0IHRoZSBtZXRob2QgY2FuIGFsc28gYmUgY2hhaW5lZC5cbiAqXG4gKiAgICAgdXRpbHMuYWRkQ2hhaW5hYmxlTWV0aG9kKGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uIChzdHIpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmVxdWFsKHN0cik7XG4gKiAgICAgfSk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5hZGRDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBjaGFpbmluZ0JlaGF2aW9yKTtcbiAqXG4gKiBUaGUgcmVzdWx0IGNhbiB0aGVuIGJlIHVzZWQgYXMgYm90aCBhIG1ldGhvZCBhc3NlcnRpb24sIGV4ZWN1dGluZyBib3RoIGBtZXRob2RgIGFuZFxuICogYGNoYWluaW5nQmVoYXZpb3JgLCBvciBhcyBhIGxhbmd1YWdlIGNoYWluLCB3aGljaCBvbmx5IGV4ZWN1dGVzIGBjaGFpbmluZ0JlaGF2aW9yYC5cbiAqXG4gKiAgICAgZXhwZWN0KGZvb1N0cikudG8uYmUuZm9vKCdiYXInKTtcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28uZXF1YWwoJ2ZvbycpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBgbmFtZWAsIHdoZW4gY2FsbGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGFpbmluZ0JlaGF2aW9yIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBwcm9wZXJ0eSBpcyBhY2Nlc3NlZFxuICogQG5hbWUgYWRkQ2hhaW5hYmxlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kLCBjaGFpbmluZ0JlaGF2aW9yKSB7XG4gIGlmICh0eXBlb2YgY2hhaW5pbmdCZWhhdmlvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gIH1cblxuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSB7XG4gICAgICBtZXRob2Q6IG1ldGhvZFxuICAgICwgY2hhaW5pbmdCZWhhdmlvcjogY2hhaW5pbmdCZWhhdmlvclxuICB9O1xuXG4gIC8vIHNhdmUgdGhlIG1ldGhvZHMgc28gd2UgY2FuIG92ZXJ3cml0ZSB0aGVtIGxhdGVyLCBpZiB3ZSBuZWVkIHRvLlxuICBpZiAoIWN0eC5fX21ldGhvZHMpIHtcbiAgICBjdHguX19tZXRob2RzID0ge307XG4gIH1cbiAgY3R4Ll9fbWV0aG9kc1tuYW1lXSA9IGNoYWluYWJsZUJlaGF2aW9yO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhaW5hYmxlQmVoYXZpb3IuY2hhaW5pbmdCZWhhdmlvci5jYWxsKHRoaXMpO1xuXG4gICAgICAgIHZhciBhc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQoKSB7XG4gICAgICAgICAgdmFyIG9sZF9zc2ZpID0gZmxhZyh0aGlzLCAnc3NmaScpO1xuICAgICAgICAgIGlmIChvbGRfc3NmaSAmJiBjb25maWcuaW5jbHVkZVN0YWNrID09PSBmYWxzZSlcbiAgICAgICAgICAgIGZsYWcodGhpcywgJ3NzZmknLCBhc3NlcnQpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjaGFpbmFibGVCZWhhdmlvci5tZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVzZSBgX19wcm90b19fYCBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKGhhc1Byb3RvU3VwcG9ydCkge1xuICAgICAgICAgIC8vIEluaGVyaXQgYWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb2JqZWN0IGJ5IHJlcGxhY2luZyB0aGUgYEZ1bmN0aW9uYCBwcm90b3R5cGVcbiAgICAgICAgICB2YXIgcHJvdG90eXBlID0gYXNzZXJ0Ll9fcHJvdG9fXyA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICAgICAgLy8gUmVzdG9yZSB0aGUgYGNhbGxgIGFuZCBgYXBwbHlgIG1ldGhvZHMgZnJvbSBgRnVuY3Rpb25gXG4gICAgICAgICAgcHJvdG90eXBlLmNhbGwgPSBjYWxsO1xuICAgICAgICAgIHByb3RvdHlwZS5hcHBseSA9IGFwcGx5O1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmVkZWZpbmUgYWxsIHByb3BlcnRpZXMgKHNsb3chKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYXNzZXJ0ZXJOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN0eCk7XG4gICAgICAgICAgYXNzZXJ0ZXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChhc3NlcnRlck5hbWUpIHtcbiAgICAgICAgICAgIGlmICghZXhjbHVkZU5hbWVzLnRlc3QoYXNzZXJ0ZXJOYW1lKSkge1xuICAgICAgICAgICAgICB2YXIgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN0eCwgYXNzZXJ0ZXJOYW1lKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFzc2VydCwgYXNzZXJ0ZXJOYW1lLCBwZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2ZlckZsYWdzKHRoaXMsIGFzc2VydCk7XG4gICAgICAgIHJldHVybiBhc3NlcnQ7XG4gICAgICB9XG4gICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkTWV0aG9kIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qKlxuICogIyMjIC5hZGRNZXRob2QgKGN0eCwgbmFtZSwgbWV0aG9kKVxuICpcbiAqIEFkZHMgYSBtZXRob2QgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZE1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdmb28nLCBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICB2YXIgb2JqID0gdXRpbHMuZmxhZyh0aGlzLCAnb2JqZWN0Jyk7XG4gKiAgICAgICBuZXcgY2hhaS5Bc3NlcnRpb24ob2JqKS50by5iZS5lcXVhbChzdHIpO1xuICogICAgIH0pO1xuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24uYWRkTWV0aG9kKCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QoZm9vU3RyKS50by5iZS5mb28oJ2JhcicpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdHggb2JqZWN0IHRvIHdoaWNoIHRoZSBtZXRob2QgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZCBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBhZGRNZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbnZhciBmbGFnID0gcmVxdWlyZSgnLi9mbGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIGN0eFtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2xkX3NzZmkgPSBmbGFnKHRoaXMsICdzc2ZpJyk7XG4gICAgaWYgKG9sZF9zc2ZpICYmIGNvbmZpZy5pbmNsdWRlU3RhY2sgPT09IGZhbHNlKVxuICAgICAgZmxhZyh0aGlzLCAnc3NmaScsIGN0eFtuYW1lXSk7XG4gICAgdmFyIHJlc3VsdCA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gYWRkUHJvcGVydHkgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIGFkZFByb3BlcnR5IChjdHgsIG5hbWUsIGdldHRlcilcbiAqXG4gKiBBZGRzIGEgcHJvcGVydHkgdG8gdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogICAgIHV0aWxzLmFkZFByb3BlcnR5KGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZSwgJ2ZvbycsIGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmopLnRvLmJlLmluc3RhbmNlb2YoRm9vKTtcbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdmb28nLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmJlLmZvbztcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IG9iamVjdCB0byB3aGljaCB0aGUgcHJvcGVydHkgaXMgYWRkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBuYW1lIGFkZFByb3BlcnR5XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgZ2V0dGVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdHgsIG5hbWUsXG4gICAgeyBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgfVxuICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIGZsYWcob2JqZWN0ICxrZXksIFt2YWx1ZV0pXG4gKlxuICogR2V0IG9yIHNldCBhIGZsYWcgdmFsdWUgb24gYW4gb2JqZWN0LiBJZiBhXG4gKiB2YWx1ZSBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHNldCwgZWxzZSBpdCB3aWxsXG4gKiByZXR1cm4gdGhlIGN1cnJlbnRseSBzZXQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWZcbiAqIHRoZSB2YWx1ZSBpcyBub3Qgc2V0LlxuICpcbiAqICAgICB1dGlscy5mbGFnKHRoaXMsICdmb28nLCAnYmFyJyk7IC8vIHNldHRlclxuICogICAgIHV0aWxzLmZsYWcodGhpcywgJ2ZvbycpOyAvLyBnZXR0ZXIsIHJldHVybnMgYGJhcmBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IChjb25zdHJ1Y3RlZCBBc3NlcnRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIChvcHRpb25hbClcbiAqIEBuYW1lIGZsYWdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICB2YXIgZmxhZ3MgPSBvYmouX19mbGFncyB8fCAob2JqLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBmbGFnc1trZXldID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZsYWdzW2tleV07XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRBY3R1YWwgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyBnZXRBY3R1YWwob2JqZWN0LCBbYWN0dWFsXSlcbiAqXG4gKiBSZXR1cm5zIHRoZSBgYWN0dWFsYCB2YWx1ZSBmb3IgYW4gQXNzZXJ0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAoY29uc3RydWN0ZWQgQXNzZXJ0aW9uKVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGNoYWkuQXNzZXJ0aW9uLnByb3RvdHlwZS5hc3NlcnQgYXJndW1lbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBhcmdzKSB7XG4gIHJldHVybiBhcmdzLmxlbmd0aCA+IDQgPyBhcmdzWzRdIDogb2JqLl9vYmo7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRFbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpXG4gKlxuICogVGhpcyBhbGxvd3MgdGhlIHJldHJpZXZhbCBvZiBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCxcbiAqIGluaGVyaXRlZCBvciBub3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge0FycmF5fVxuICogQG5hbWUgZ2V0RW51bWVyYWJsZVByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gbWVzc2FnZSBjb21wb3NpdGlvbiB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBNb2R1bGUgZGVwZW5kYW5jaWVzXG4gKi9cblxudmFyIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKVxuICAsIGdldEFjdHVhbCA9IHJlcXVpcmUoJy4vZ2V0QWN0dWFsJylcbiAgLCBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0JylcbiAgLCBvYmpEaXNwbGF5ID0gcmVxdWlyZSgnLi9vYmpEaXNwbGF5Jyk7XG5cbi8qKlxuICogIyMjIC5nZXRNZXNzYWdlKG9iamVjdCwgbWVzc2FnZSwgbmVnYXRlTWVzc2FnZSlcbiAqXG4gKiBDb25zdHJ1Y3QgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZmxhZ3NcbiAqIGFuZCB0ZW1wbGF0ZSB0YWdzLiBUZW1wbGF0ZSB0YWdzIHdpbGwgcmV0dXJuXG4gKiBhIHN0cmluZ2lmaWVkIGluc3BlY3Rpb24gb2YgdGhlIG9iamVjdCByZWZlcmVuY2VkLlxuICpcbiAqIE1lc3NhZ2UgdGVtcGxhdGUgdGFnczpcbiAqIC0gYCN7dGhpc31gIGN1cnJlbnQgYXNzZXJ0ZWQgb2JqZWN0XG4gKiAtIGAje2FjdH1gIGFjdHVhbCB2YWx1ZVxuICogLSBgI3tleHB9YCBleHBlY3RlZCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICogQG5hbWUgZ2V0TWVzc2FnZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGFyZ3MpIHtcbiAgdmFyIG5lZ2F0ZSA9IGZsYWcob2JqLCAnbmVnYXRlJylcbiAgICAsIHZhbCA9IGZsYWcob2JqLCAnb2JqZWN0JylcbiAgICAsIGV4cGVjdGVkID0gYXJnc1szXVxuICAgICwgYWN0dWFsID0gZ2V0QWN0dWFsKG9iaiwgYXJncylcbiAgICAsIG1zZyA9IG5lZ2F0ZSA/IGFyZ3NbMl0gOiBhcmdzWzFdXG4gICAgLCBmbGFnTXNnID0gZmxhZyhvYmosICdtZXNzYWdlJyk7XG5cbiAgaWYodHlwZW9mIG1zZyA9PT0gXCJmdW5jdGlvblwiKSBtc2cgPSBtc2coKTtcbiAgbXNnID0gbXNnIHx8ICcnO1xuICBtc2cgPSBtc2dcbiAgICAucmVwbGFjZSgvI3t0aGlzfS9nLCBvYmpEaXNwbGF5KHZhbCkpXG4gICAgLnJlcGxhY2UoLyN7YWN0fS9nLCBvYmpEaXNwbGF5KGFjdHVhbCkpXG4gICAgLnJlcGxhY2UoLyN7ZXhwfS9nLCBvYmpEaXNwbGF5KGV4cGVjdGVkKSk7XG5cbiAgcmV0dXJuIGZsYWdNc2cgPyBmbGFnTXNnICsgJzogJyArIG1zZyA6IG1zZztcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXROYW1lIHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMgZ2V0TmFtZShmdW5jKVxuICpcbiAqIEdldHMgdGhlIG5hbWUgb2YgYSBmdW5jdGlvbiwgaW4gYSBjcm9zcy1icm93c2VyIHdheS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uICh1c3VhbGx5IGEgY29uc3RydWN0b3IpXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAoZnVuYy5uYW1lKSByZXR1cm4gZnVuYy5uYW1lO1xuXG4gIHZhciBtYXRjaCA9IC9eXFxzP2Z1bmN0aW9uIChbXihdKilcXCgvLmV4ZWMoZnVuYyk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXSA/IG1hdGNoWzFdIDogXCJcIjtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSBnZXRQYXRoVmFsdWUgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2xvZ2ljYWxwYXJhZG94L2ZpbHRyXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqICMjIyAuZ2V0UGF0aFZhbHVlKHBhdGgsIG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHZhbHVlcyBpbiBhblxuICogb2JqZWN0IGdpdmVuIGEgc3RyaW5nIHBhdGguXG4gKlxuICogICAgIHZhciBvYmogPSB7XG4gKiAgICAgICAgIHByb3AxOiB7XG4gKiAgICAgICAgICAgICBhcnI6IFsnYScsICdiJywgJ2MnXVxuICogICAgICAgICAgICwgc3RyOiAnSGVsbG8nXG4gKiAgICAgICAgIH1cbiAqICAgICAgICwgcHJvcDI6IHtcbiAqICAgICAgICAgICAgIGFycjogWyB7IG5lc3RlZDogJ1VuaXZlcnNlJyB9IF1cbiAqICAgICAgICAgICAsIHN0cjogJ0hlbGxvIGFnYWluISdcbiAqICAgICAgICAgfVxuICogICAgIH1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIHdvdWxkIGJlIHRoZSByZXN1bHRzLlxuICpcbiAqICAgICBnZXRQYXRoVmFsdWUoJ3Byb3AxLnN0cicsIG9iaik7IC8vIEhlbGxvXG4gKiAgICAgZ2V0UGF0aFZhbHVlKCdwcm9wMS5hdHRbMl0nLCBvYmopOyAvLyBiXG4gKiAgICAgZ2V0UGF0aFZhbHVlKCdwcm9wMi5hcnJbMF0ubmVzdGVkJywgb2JqKTsgLy8gVW5pdmVyc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdFxuICogQHJldHVybnMge09iamVjdH0gdmFsdWUgb3IgYHVuZGVmaW5lZGBcbiAqIEBuYW1lIGdldFBhdGhWYWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG52YXIgZ2V0UGF0aFZhbHVlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGF0aCwgb2JqKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgocGF0aCk7XG4gIHJldHVybiBfZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKTtcbn07XG5cbi8qIVxuICogIyMgcGFyc2VQYXRoKHBhdGgpXG4gKlxuICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgdG8gcGFyc2Ugc3RyaW5nIG9iamVjdFxuICogcGF0aHMuIFVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIGBfZ2V0UGF0aFZhbHVlYC5cbiAqXG4gKiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZVBhdGgoJ215b2JqZWN0LnByb3BlcnR5LnN1YnByb3AnKTtcbiAqXG4gKiAjIyMgUGF0aHM6XG4gKlxuICogKiBDYW4gYmUgYXMgbmVhciBpbmZpbml0ZWx5IGRlZXAgYW5kIG5lc3RlZFxuICogKiBBcnJheXMgYXJlIGFsc28gdmFsaWQgdXNpbmcgdGhlIGZvcm1hbCBgbXlvYmplY3QuZG9jdW1lbnRbM10ucHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwYXJzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgc3RyID0gcGF0aC5yZXBsYWNlKC9cXFsvZywgJy5bJylcbiAgICAsIHBhcnRzID0gc3RyLm1hdGNoKC8oXFxcXFxcLnxbXi5dKz8pKy9nKTtcbiAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmUgPSAvXFxbKFxcZCspXFxdJC9cbiAgICAgICwgbUFyciA9IHJlLmV4ZWModmFsdWUpXG4gICAgaWYgKG1BcnIpIHJldHVybiB7IGk6IHBhcnNlRmxvYXQobUFyclsxXSkgfTtcbiAgICBlbHNlIHJldHVybiB7IHA6IHZhbHVlIH07XG4gIH0pO1xufTtcblxuLyohXG4gKiAjIyBfZ2V0UGF0aFZhbHVlKHBhcnNlZCwgb2JqKVxuICpcbiAqIEhlbHBlciBjb21wYW5pb24gZnVuY3Rpb24gZm9yIGAucGFyc2VQYXRoYCB0aGF0IHJldHVybnNcbiAqIHRoZSB2YWx1ZSBsb2NhdGVkIGF0IHRoZSBwYXJzZWQgYWRkcmVzcy5cbiAqXG4gKiAgICAgIHZhciB2YWx1ZSA9IGdldFBhdGhWYWx1ZShwYXJzZWQsIG9iaik7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcnNlZCBkZWZpbml0aW9uIGZyb20gYHBhcnNlUGF0aGAuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IHRvIHNlYXJjaCBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fFVuZGVmaW5lZH0gdmFsdWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIF9nZXRQYXRoVmFsdWUgKHBhcnNlZCwgb2JqKSB7XG4gIHZhciB0bXAgPSBvYmpcbiAgICAsIHJlcztcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKHRtcCkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFydC5wKVxuICAgICAgICB0bXAgPSB0bXBbcGFydC5wXTtcbiAgICAgIGVsc2UgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgcGFydC5pKVxuICAgICAgICB0bXAgPSB0bXBbcGFydC5pXTtcbiAgICAgIGlmIChpID09IChsIC0gMSkpIHJlcyA9IHRtcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIGdldFByb3BlcnRpZXMgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIC5nZXRQcm9wZXJ0aWVzKG9iamVjdClcbiAqXG4gKiBUaGlzIGFsbG93cyB0aGUgcmV0cmlldmFsIG9mIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdCwgZW51bWVyYWJsZSBvciBub3QsXG4gKiBpbmhlcml0ZWQgb3Igbm90LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBuYW1lIGdldFByb3BlcnRpZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0aWVzKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3ViamVjdCk7XG5cbiAgZnVuY3Rpb24gYWRkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICBpZiAocmVzdWx0LmluZGV4T2YocHJvcGVydHkpID09PSAtMSkge1xuICAgICAgcmVzdWx0LnB1c2gocHJvcGVydHkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzdWJqZWN0KTtcbiAgd2hpbGUgKHByb3RvICE9PSBudWxsKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pLmZvckVhY2goYWRkUHJvcGVydHkpO1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyohXG4gKiBjaGFpXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTWFpbiBleHBvcnRzXG4gKi9cblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKiFcbiAqIHRlc3QgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudGVzdCA9IHJlcXVpcmUoJy4vdGVzdCcpO1xuXG4vKiFcbiAqIHR5cGUgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMudHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKiFcbiAqIG1lc3NhZ2UgdXRpbGl0eVxuICovXG5cbmV4cG9ydHMuZ2V0TWVzc2FnZSA9IHJlcXVpcmUoJy4vZ2V0TWVzc2FnZScpO1xuXG4vKiFcbiAqIGFjdHVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5nZXRBY3R1YWwgPSByZXF1aXJlKCcuL2dldEFjdHVhbCcpO1xuXG4vKiFcbiAqIEluc3BlY3QgdXRpbFxuICovXG5cbmV4cG9ydHMuaW5zcGVjdCA9IHJlcXVpcmUoJy4vaW5zcGVjdCcpO1xuXG4vKiFcbiAqIE9iamVjdCBEaXNwbGF5IHV0aWxcbiAqL1xuXG5leHBvcnRzLm9iakRpc3BsYXkgPSByZXF1aXJlKCcuL29iakRpc3BsYXknKTtcblxuLyohXG4gKiBGbGFnIHV0aWxpdHlcbiAqL1xuXG5leHBvcnRzLmZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKTtcblxuLyohXG4gKiBGbGFnIHRyYW5zZmVycmluZyB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy50cmFuc2ZlckZsYWdzID0gcmVxdWlyZSgnLi90cmFuc2ZlckZsYWdzJyk7XG5cbi8qIVxuICogRGVlcCBlcXVhbCB1dGlsaXR5XG4gKi9cblxuZXhwb3J0cy5lcWwgPSByZXF1aXJlKCdkZWVwLWVxbCcpO1xuXG4vKiFcbiAqIERlZXAgcGF0aCB2YWx1ZVxuICovXG5cbmV4cG9ydHMuZ2V0UGF0aFZhbHVlID0gcmVxdWlyZSgnLi9nZXRQYXRoVmFsdWUnKTtcblxuLyohXG4gKiBGdW5jdGlvbiBuYW1lXG4gKi9cblxuZXhwb3J0cy5nZXROYW1lID0gcmVxdWlyZSgnLi9nZXROYW1lJyk7XG5cbi8qIVxuICogYWRkIFByb3BlcnR5XG4gKi9cblxuZXhwb3J0cy5hZGRQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vYWRkUHJvcGVydHknKTtcblxuLyohXG4gKiBhZGQgTWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRNZXRob2QgPSByZXF1aXJlKCcuL2FkZE1ldGhvZCcpO1xuXG4vKiFcbiAqIG92ZXJ3cml0ZSBQcm9wZXJ0eVxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL292ZXJ3cml0ZVByb3BlcnR5Jyk7XG5cbi8qIVxuICogb3ZlcndyaXRlIE1ldGhvZFxuICovXG5cbmV4cG9ydHMub3ZlcndyaXRlTWV0aG9kID0gcmVxdWlyZSgnLi9vdmVyd3JpdGVNZXRob2QnKTtcblxuLyohXG4gKiBBZGQgYSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5hZGRDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL2FkZENoYWluYWJsZU1ldGhvZCcpO1xuXG4vKiFcbiAqIE92ZXJ3cml0ZSBjaGFpbmFibGUgbWV0aG9kXG4gKi9cblxuZXhwb3J0cy5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgPSByZXF1aXJlKCcuL292ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCcpO1xuXG4iLCIvLyBUaGlzIGlzIChhbG1vc3QpIGRpcmVjdGx5IGZyb20gTm9kZS5qcyB1dGlsc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2Jsb2IvZjhjMzM1ZDBjYWY0N2YxNmQzMTQxM2Y4OWFhMjhlZGEzODc4ZTNhYS9saWIvdXRpbC5qc1xuXG52YXIgZ2V0TmFtZSA9IHJlcXVpcmUoJy4vZ2V0TmFtZScpO1xudmFyIGdldFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2dldFByb3BlcnRpZXMnKTtcbnZhciBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZ2V0RW51bWVyYWJsZVByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnNwZWN0O1xuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3dIaWRkZW4gRmxhZyB0aGF0IHNob3dzIGhpZGRlbiAobm90IGVudW1lcmFibGUpXG4gKiAgICBwcm9wZXJ0aWVzIG9mIG9iamVjdHMuXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggRGVwdGggaW4gd2hpY2ggdG8gZGVzY2VuZCBpbiBvYmplY3QuIERlZmF1bHQgaXMgMi5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29sb3JzIEZsYWcgdG8gdHVybiBvbiBBTlNJIGVzY2FwZSBjb2RlcyB0byBjb2xvciB0aGVcbiAqICAgIG91dHB1dC4gRGVmYXVsdCBpcyBmYWxzZSAobm8gY29sb3JpbmcpLlxuICovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycykge1xuICB2YXIgY3R4ID0ge1xuICAgIHNob3dIaWRkZW46IHNob3dIaWRkZW4sXG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyOyB9XG4gIH07XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyAyIDogZGVwdGgpKTtcbn1cblxuLy8gUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhIERPTSBlbGVtZW50LlxudmFyIGlzRE9NRWxlbWVudCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdC5ub2RlVHlwZSA9PT0gMSAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLmluc3BlY3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMpO1xuICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIElmIHRoaXMgaXMgYSBET00gZWxlbWVudCwgdHJ5IHRvIGdldCB0aGUgb3V0ZXIgSFRNTC5cbiAgaWYgKGlzRE9NRWxlbWVudCh2YWx1ZSkpIHtcbiAgICBpZiAoJ291dGVySFRNTCcgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5vdXRlckhUTUw7XG4gICAgICAvLyBUaGlzIHZhbHVlIGRvZXMgbm90IGhhdmUgYW4gb3V0ZXJIVE1MIGF0dHJpYnV0ZSxcbiAgICAgIC8vICAgaXQgY291bGQgc3RpbGwgYmUgYW4gWE1MIGVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXR0ZW1wdCB0byBzZXJpYWxpemUgaXRcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChkb2N1bWVudC54bWxWZXJzaW9uKSB7XG4gICAgICAgICAgdmFyIHhtbFNlcmlhbGl6ZXIgPSBuZXcgWE1MU2VyaWFsaXplcigpO1xuICAgICAgICAgIHJldHVybiB4bWxTZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJlZm94IDExLSBkbyBub3Qgc3VwcG9ydCBvdXRlckhUTUxcbiAgICAgICAgICAvLyAgIEl0IGRvZXMsIGhvd2V2ZXIsIHN1cHBvcnQgaW5uZXJIVE1MXG4gICAgICAgICAgLy8gICBVc2UgdGhlIGZvbGxvd2luZyB0byByZW5kZXIgdGhlIGVsZW1lbnRcbiAgICAgICAgICB2YXIgbnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5zLCAnXycpO1xuXG4gICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZhbHVlLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgICAgIGh0bWwgPSBjb250YWluZXIuaW5uZXJIVE1MXG4gICAgICAgICAgICAucmVwbGFjZSgnPjwnLCAnPicgKyB2YWx1ZS5pbm5lckhUTUwgKyAnPCcpO1xuICAgICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRoaXMgY291bGQgYmUgYSBub24tbmF0aXZlIERPTSBpbXBsZW1lbnRhdGlvbixcbiAgICAgICAgLy8gICBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgZmxvdzpcbiAgICAgICAgLy8gICBwcmludGluZyB0aGUgZWxlbWVudCBhcyBpZiBpdCBpcyBhbiBvYmplY3QuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIgdmlzaWJsZUtleXMgPSBnZXRFbnVtZXJhYmxlUHJvcGVydGllcyh2YWx1ZSk7XG4gIHZhciBrZXlzID0gY3R4LnNob3dIaWRkZW4gPyBnZXRQcm9wZXJ0aWVzKHZhbHVlKSA6IHZpc2libGVLZXlzO1xuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgLy8gSW4gSUUsIGVycm9ycyBoYXZlIGEgc2luZ2xlIGBzdGFja2AgcHJvcGVydHksIG9yIGlmIHRoZXkgYXJlIHZhbmlsbGEgYEVycm9yYCxcbiAgLy8gYSBgc3RhY2tgIHBsdXMgYGRlc2NyaXB0aW9uYCBwcm9wZXJ0eTsgaWdub3JlIHRob3NlIGZvciBjb25zaXN0ZW5jeS5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IChpc0Vycm9yKHZhbHVlKSAmJiAoXG4gICAgICAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ3N0YWNrJykgfHxcbiAgICAgIChrZXlzLmxlbmd0aCA9PT0gMiAmJiBrZXlzWzBdID09PSAnZGVzY3JpcHRpb24nICYmIGtleXNbMV0gPT09ICdzdGFjaycpXG4gICAgICkpKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG5hbWUgPSBnZXROYW1lKHZhbHVlKTtcbiAgICAgIHZhciBuYW1lU3VmZml4ID0gbmFtZSA/ICc6ICcgKyBuYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lU3VmZml4ICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgbmFtZSA9IGdldE5hbWUodmFsdWUpO1xuICAgIHZhciBuYW1lU3VmZml4ID0gbmFtZSA/ICc6ICcgKyBuYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG5hbWVTdWZmaXggKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgfVxuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0cjtcbiAgaWYgKHZhbHVlLl9fbG9va3VwR2V0dGVyX18pIHtcbiAgICBpZiAodmFsdWUuX19sb29rdXBHZXR0ZXJfXyhrZXkpKSB7XG4gICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLl9fbG9va3VwU2V0dGVyX18oa2V5KSkge1xuICAgICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmlzaWJsZUtleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgIGlmIChyZWN1cnNlVGltZXMgPT09IG51bGwpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgdmFsdWVba2V5XSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcikgfHxcbiAgICAgICAgICh0eXBlb2YgYXIgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKGFyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiB0eXBlb2YgcmUgPT09ICdvYmplY3QnICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIi8qIVxuICogQ2hhaSAtIGZsYWcgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGFuY2llc1xuICovXG5cbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9pbnNwZWN0Jyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJyk7XG5cbi8qKlxuICogIyMjIC5vYmpEaXNwbGF5IChvYmplY3QpXG4gKlxuICogRGV0ZXJtaW5lcyBpZiBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgbWF0Y2hlc1xuICogY3JpdGVyaWEgdG8gYmUgaW5zcGVjdGVkIGluLWxpbmUgZm9yIGVycm9yXG4gKiBtZXNzYWdlcyBvciBzaG91bGQgYmUgdHJ1bmNhdGVkLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGphdmFzY3JpcHQgb2JqZWN0IHRvIGluc3BlY3RcbiAqIEBuYW1lIG9iakRpc3BsYXlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSBpbnNwZWN0KG9iailcbiAgICAsIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcblxuICBpZiAoY29uZmlnLnRydW5jYXRlVGhyZXNob2xkICYmIHN0ci5sZW5ndGggPj0gY29uZmlnLnRydW5jYXRlVGhyZXNob2xkKSB7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgIHJldHVybiAhb2JqLm5hbWUgfHwgb2JqLm5hbWUgPT09ICcnXG4gICAgICAgID8gJ1tGdW5jdGlvbl0nXG4gICAgICAgIDogJ1tGdW5jdGlvbjogJyArIG9iai5uYW1lICsgJ10nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgcmV0dXJuICdbIEFycmF5KCcgKyBvYmoubGVuZ3RoICsgJykgXSc7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopXG4gICAgICAgICwga3N0ciA9IGtleXMubGVuZ3RoID4gMlxuICAgICAgICAgID8ga2V5cy5zcGxpY2UoMCwgMikuam9pbignLCAnKSArICcsIC4uLidcbiAgICAgICAgICA6IGtleXMuam9pbignLCAnKTtcbiAgICAgIHJldHVybiAneyBPYmplY3QgKCcgKyBrc3RyICsgJykgfSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVDaGFpbmFibGVNZXRob2QgdXRpbGl0eVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogIyMjIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZCAoY3R4LCBuYW1lLCBmbilcbiAqXG4gKiBPdmVyd2l0ZXMgYW4gYWxyZWFkeSBleGlzdGluZyBjaGFpbmFibGUgbWV0aG9kXG4gKiBhbmQgcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBvclxuICogcHJvcGVydHkuICBNdXN0IHJldHVybiBmdW5jdGlvbnMgdG8gYmUgdXNlZCBmb3JcbiAqIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdsZW5ndGgnLFxuICogICAgICAgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICwgZnVuY3Rpb24gKF9zdXBlcikge1xuICogICAgICAgfVxuICogICAgICk7XG4gKlxuICogQ2FuIGFsc28gYmUgYWNjZXNzZWQgZGlyZWN0bHkgZnJvbSBgY2hhaS5Bc3NlcnRpb25gLlxuICpcbiAqICAgICBjaGFpLkFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QoJ2ZvbycsIGZuLCBmbik7XG4gKlxuICogVGhlbiBjYW4gYmUgdXNlZCBhcyBhbnkgb3RoZXIgYXNzZXJ0aW9uLlxuICpcbiAqICAgICBleHBlY3QobXlGb28pLnRvLmhhdmUubGVuZ3RoKDMpO1xuICogICAgIGV4cGVjdChteUZvbykudG8uaGF2ZS5sZW5ndGguYWJvdmUoMyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIC8gcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIG1ldGhvZCAvIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIGJlIHVzZWQgZm9yIG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoYWluaW5nQmVoYXZpb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgcHJvcGVydHlcbiAqIEBuYW1lIG92ZXJ3cml0ZUNoYWluYWJsZU1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIG1ldGhvZCwgY2hhaW5pbmdCZWhhdmlvcikge1xuICB2YXIgY2hhaW5hYmxlQmVoYXZpb3IgPSBjdHguX19tZXRob2RzW25hbWVdO1xuXG4gIHZhciBfY2hhaW5pbmdCZWhhdmlvciA9IGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3I7XG4gIGNoYWluYWJsZUJlaGF2aW9yLmNoYWluaW5nQmVoYXZpb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNoYWluaW5nQmVoYXZpb3IoX2NoYWluaW5nQmVoYXZpb3IpLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgfTtcblxuICB2YXIgX21ldGhvZCA9IGNoYWluYWJsZUJlaGF2aW9yLm1ldGhvZDtcbiAgY2hhaW5hYmxlQmVoYXZpb3IubWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX21ldGhvZCkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB0aGlzIDogcmVzdWx0O1xuICB9O1xufTtcbiIsIi8qIVxuICogQ2hhaSAtIG92ZXJ3cml0ZU1ldGhvZCB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlTWV0aG9kIChjdHgsIG5hbWUsIGZuKVxuICpcbiAqIE92ZXJ3aXRlcyBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZCBhbmQgcHJvdmlkZXNcbiAqIGFjY2VzcyB0byBwcmV2aW91cyBmdW5jdGlvbi4gTXVzdCByZXR1cm4gZnVuY3Rpb25cbiAqIHRvIGJlIHVzZWQgZm9yIG5hbWUuXG4gKlxuICogICAgIHV0aWxzLm92ZXJ3cml0ZU1ldGhvZChjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdlcXVhbCcsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoudmFsdWUpLnRvLmVxdWFsKHN0cik7XG4gKiAgICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBDYW4gYWxzbyBiZSBhY2Nlc3NlZCBkaXJlY3RseSBmcm9tIGBjaGFpLkFzc2VydGlvbmAuXG4gKlxuICogICAgIGNoYWkuQXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZm9vJywgZm4pO1xuICpcbiAqIFRoZW4gY2FuIGJlIHVzZWQgYXMgYW55IG90aGVyIGFzc2VydGlvbi5cbiAqXG4gKiAgICAgZXhwZWN0KG15Rm9vKS50by5lcXVhbCgnYmFyJyk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgbWV0aG9kIGlzIHRvIGJlIG92ZXJ3cml0dGVuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiBtZXRob2QgdG8gb3ZlcndyaXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2QgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgbmFtZVxuICogQG5hbWUgb3ZlcndyaXRlTWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGN0eCwgbmFtZSwgbWV0aG9kKSB7XG4gIHZhciBfbWV0aG9kID0gY3R4W25hbWVdXG4gICAgLCBfc3VwZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG4gIGlmIChfbWV0aG9kICYmICdmdW5jdGlvbicgPT09IHR5cGVvZiBfbWV0aG9kKVxuICAgIF9zdXBlciA9IF9tZXRob2Q7XG5cbiAgY3R4W25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBtZXRob2QoX3N1cGVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IHRoaXMgOiByZXN1bHQ7XG4gIH1cbn07XG4iLCIvKiFcbiAqIENoYWkgLSBvdmVyd3JpdGVQcm9wZXJ0eSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgb3ZlcndyaXRlUHJvcGVydHkgKGN0eCwgbmFtZSwgZm4pXG4gKlxuICogT3ZlcndpdGVzIGFuIGFscmVhZHkgZXhpc3RpbmcgcHJvcGVydHkgZ2V0dGVyIGFuZCBwcm92aWRlc1xuICogYWNjZXNzIHRvIHByZXZpb3VzIHZhbHVlLiBNdXN0IHJldHVybiBmdW5jdGlvbiB0byB1c2UgYXMgZ2V0dGVyLlxuICpcbiAqICAgICB1dGlscy5vdmVyd3JpdGVQcm9wZXJ0eShjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUsICdvaycsIGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAqICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIHZhciBvYmogPSB1dGlscy5mbGFnKHRoaXMsICdvYmplY3QnKTtcbiAqICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEZvbykge1xuICogICAgICAgICAgIG5ldyBjaGFpLkFzc2VydGlvbihvYmoubmFtZSkudG8uZXF1YWwoJ2JhcicpO1xuICogICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICogICAgICAgICB9XG4gKiAgICAgICB9XG4gKiAgICAgfSk7XG4gKlxuICpcbiAqIENhbiBhbHNvIGJlIGFjY2Vzc2VkIGRpcmVjdGx5IGZyb20gYGNoYWkuQXNzZXJ0aW9uYC5cbiAqXG4gKiAgICAgY2hhaS5Bc3NlcnRpb24ub3ZlcndyaXRlUHJvcGVydHkoJ2ZvbycsIGZuKTtcbiAqXG4gKiBUaGVuIGNhbiBiZSB1c2VkIGFzIGFueSBvdGhlciBhc3NlcnRpb24uXG4gKlxuICogICAgIGV4cGVjdChteUZvbykudG8uYmUub2s7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBvYmplY3Qgd2hvc2UgcHJvcGVydHkgaXMgdG8gYmUgb3ZlcndyaXR0ZW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHByb3BlcnR5IHRvIG92ZXJ3cml0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGdldHRlciBmdW5jdGlvbiB0byBiZSB1c2VkIGZvciBuYW1lXG4gKiBAbmFtZSBvdmVyd3JpdGVQcm9wZXJ0eVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjdHgsIG5hbWUsIGdldHRlcikge1xuICB2YXIgX2dldCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3R4LCBuYW1lKVxuICAgICwgX3N1cGVyID0gZnVuY3Rpb24gKCkge307XG5cbiAgaWYgKF9nZXQgJiYgJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIF9nZXQuZ2V0KVxuICAgIF9zdXBlciA9IF9nZXQuZ2V0XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgbmFtZSxcbiAgICB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0dGVyKF9zdXBlcikuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn07XG4iLCIvKiFcbiAqIENoYWkgLSB0ZXN0IHV0aWxpdHlcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSmFrZSBMdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIE1vZHVsZSBkZXBlbmRhbmNpZXNcbiAqL1xuXG52YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpO1xuXG4vKipcbiAqICMgdGVzdChvYmplY3QsIGV4cHJlc3Npb24pXG4gKlxuICogVGVzdCBhbmQgb2JqZWN0IGZvciBleHByZXNzaW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgKGNvbnN0cnVjdGVkIEFzc2VydGlvbilcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBjaGFpLkFzc2VydGlvbi5wcm90b3R5cGUuYXNzZXJ0IGFyZ3VtZW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgYXJncykge1xuICB2YXIgbmVnYXRlID0gZmxhZyhvYmosICduZWdhdGUnKVxuICAgICwgZXhwciA9IGFyZ3NbMF07XG4gIHJldHVybiBuZWdhdGUgPyAhZXhwciA6IGV4cHI7XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHJhbnNmZXJGbGFncyB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiAjIyMgdHJhbnNmZXJGbGFncyhhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCA9IHRydWUpXG4gKlxuICogVHJhbnNmZXIgYWxsIHRoZSBmbGFncyBmb3IgYGFzc2VydGlvbmAgdG8gYG9iamVjdGAuIElmXG4gKiBgaW5jbHVkZUFsbGAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoZW4gdGhlIGJhc2UgQ2hhaVxuICogYXNzZXJ0aW9uIGZsYWdzIChuYW1lbHkgYG9iamVjdGAsIGBzc2ZpYCwgYW5kIGBtZXNzYWdlYClcbiAqIHdpbGwgbm90IGJlIHRyYW5zZmVycmVkLlxuICpcbiAqXG4gKiAgICAgdmFyIG5ld0Fzc2VydGlvbiA9IG5ldyBBc3NlcnRpb24oKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgbmV3QXNzZXJ0aW9uKTtcbiAqXG4gKiAgICAgdmFyIGFub3RoZXJBc3Nlcml0b24gPSBuZXcgQXNzZXJ0aW9uKG15T2JqKTtcbiAqICAgICB1dGlscy50cmFuc2ZlckZsYWdzKGFzc2VydGlvbiwgYW5vdGhlckFzc2VydGlvbiwgZmFsc2UpO1xuICpcbiAqIEBwYXJhbSB7QXNzZXJ0aW9ufSBhc3NlcnRpb24gdGhlIGFzc2VydGlvbiB0byB0cmFuc2ZlciB0aGUgZmxhZ3MgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0IHRvIHRyYW5zZmVyIHRoZSBmbGFncyB0b287IHVzdWFsbHkgYSBuZXcgYXNzZXJ0aW9uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGluY2x1ZGVBbGxcbiAqIEBuYW1lIGdldEFsbEZsYWdzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhc3NlcnRpb24sIG9iamVjdCwgaW5jbHVkZUFsbCkge1xuICB2YXIgZmxhZ3MgPSBhc3NlcnRpb24uX19mbGFncyB8fCAoYXNzZXJ0aW9uLl9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICBpZiAoIW9iamVjdC5fX2ZsYWdzKSB7XG4gICAgb2JqZWN0Ll9fZmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaW5jbHVkZUFsbCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDMgPyBpbmNsdWRlQWxsIDogdHJ1ZTtcblxuICBmb3IgKHZhciBmbGFnIGluIGZsYWdzKSB7XG4gICAgaWYgKGluY2x1ZGVBbGwgfHxcbiAgICAgICAgKGZsYWcgIT09ICdvYmplY3QnICYmIGZsYWcgIT09ICdzc2ZpJyAmJiBmbGFnICE9ICdtZXNzYWdlJykpIHtcbiAgICAgIG9iamVjdC5fX2ZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XG4gICAgfVxuICB9XG59O1xuIiwiLyohXG4gKiBDaGFpIC0gdHlwZSB1dGlsaXR5XG4gKiBDb3B5cmlnaHQoYykgMjAxMi0yMDE0IEpha2UgTHVlciA8amFrZUBhbG9naWNhbHBhcmFkb3guY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyohXG4gKiBEZXRlY3RhYmxlIGphdmFzY3JpcHQgbmF0aXZlc1xuICovXG5cbnZhciBuYXRpdmVzID0ge1xuICAgICdbb2JqZWN0IEFyZ3VtZW50c10nOiAnYXJndW1lbnRzJ1xuICAsICdbb2JqZWN0IEFycmF5XSc6ICdhcnJheSdcbiAgLCAnW29iamVjdCBEYXRlXSc6ICdkYXRlJ1xuICAsICdbb2JqZWN0IEZ1bmN0aW9uXSc6ICdmdW5jdGlvbidcbiAgLCAnW29iamVjdCBOdW1iZXJdJzogJ251bWJlcidcbiAgLCAnW29iamVjdCBSZWdFeHBdJzogJ3JlZ2V4cCdcbiAgLCAnW29iamVjdCBTdHJpbmddJzogJ3N0cmluZydcbn07XG5cbi8qKlxuICogIyMjIHR5cGUob2JqZWN0KVxuICpcbiAqIEJldHRlciBpbXBsZW1lbnRhdGlvbiBvZiBgdHlwZW9mYCBkZXRlY3Rpb24gdGhhdCBjYW5cbiAqIGJlIHVzZWQgY3Jvc3MtYnJvd3Nlci4gSGFuZGxlcyB0aGUgaW5jb25zaXN0ZW5jaWVzIG9mXG4gKiBBcnJheSwgYG51bGxgLCBhbmQgYHVuZGVmaW5lZGAgZGV0ZWN0aW9uLlxuICpcbiAqICAgICB1dGlscy50eXBlKHt9KSAvLyAnb2JqZWN0J1xuICogICAgIHV0aWxzLnR5cGUobnVsbCkgLy8gYG51bGwnXG4gKiAgICAgdXRpbHMudHlwZSh1bmRlZmluZWQpIC8vIGB1bmRlZmluZWRgXG4gKiAgICAgdXRpbHMudHlwZShbXSkgLy8gYGFycmF5YFxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IG9iamVjdCB0byBkZXRlY3QgdHlwZSBvZlxuICogQG5hbWUgdHlwZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgaWYgKG5hdGl2ZXNbc3RyXSkgcmV0dXJuIG5hdGl2ZXNbc3RyXTtcbiAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmIChvYmogPT09IE9iamVjdChvYmopKSByZXR1cm4gJ29iamVjdCc7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufTtcbiIsIi8qIVxuICogYXNzZXJ0aW9uLWVycm9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAcXVhbGlhbmN5LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBvbmUgb2JqZWN0IHRvIGFub3RoZXIgZXhjbHVkaW5nIGFueSBvcmlnaW5hbGx5XG4gKiBsaXN0ZWQuIFJldHVybmVkIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgbmV3IGB7fWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2x1ZGVkIHByb3BlcnRpZXMgLi4uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5mdW5jdGlvbiBleGNsdWRlICgpIHtcbiAgdmFyIGV4Y2x1ZGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gIGZ1bmN0aW9uIGV4Y2x1ZGVQcm9wcyAocmVzLCBvYmopIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCF+ZXhjbHVkZXMuaW5kZXhPZihrZXkpKSByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGV4dGVuZEV4Y2x1ZGUgKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgICAsIGkgPSAwXG4gICAgICAsIHJlcyA9IHt9O1xuXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleGNsdWRlUHJvcHMocmVzLCBhcmdzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xufTtcblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqICMjIyBBc3NlcnRpb25FcnJvclxuICpcbiAqIEFuIGV4dGVuc2lvbiBvZiB0aGUgSmF2YVNjcmlwdCBgRXJyb3JgIGNvbnN0cnVjdG9yIGZvclxuICogYXNzZXJ0aW9uIGFuZCB2YWxpZGF0aW9uIHNjZW5hcmlvcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgdG8gaW5jbHVkZSAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge2NhbGxlZX0gc3RhcnQgc3RhY2sgZnVuY3Rpb24gKG9wdGlvbmFsKVxuICovXG5cbmZ1bmN0aW9uIEFzc2VydGlvbkVycm9yIChtZXNzYWdlLCBfcHJvcHMsIHNzZikge1xuICB2YXIgZXh0ZW5kID0gZXhjbHVkZSgnbmFtZScsICdtZXNzYWdlJywgJ3N0YWNrJywgJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicpXG4gICAgLCBwcm9wcyA9IGV4dGVuZChfcHJvcHMgfHwge30pO1xuXG4gIC8vIGRlZmF1bHQgdmFsdWVzXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Vuc3BlY2lmaWVkIEFzc2VydGlvbkVycm9yJztcbiAgdGhpcy5zaG93RGlmZiA9IGZhbHNlO1xuXG4gIC8vIGNvcHkgZnJvbSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHRoaXNba2V5XSA9IHByb3BzW2tleV07XG4gIH1cblxuICAvLyBjYXB0dXJlIHN0YWNrIHRyYWNlXG4gIHNzZiA9IHNzZiB8fCBhcmd1bWVudHMuY2FsbGVlO1xuICBpZiAoc3NmICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgfVxufVxuXG4vKiFcbiAqIEluaGVyaXQgZnJvbSBFcnJvci5wcm90b3R5cGVcbiAqL1xuXG5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbi8qIVxuICogU3RhdGljYWxseSBzZXQgbmFtZVxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxuLyohXG4gKiBFbnN1cmUgY29ycmVjdCBjb25zdHJ1Y3RvclxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VydGlvbkVycm9yO1xuXG4vKipcbiAqIEFsbG93IGVycm9ycyB0byBiZSBjb252ZXJ0ZWQgdG8gSlNPTiBmb3Igc3RhdGljIHRyYW5zZmVyLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkZSBzdGFjayAoZGVmYXVsdDogYHRydWVgKVxuICogQHJldHVybiB7T2JqZWN0fSBvYmplY3QgdGhhdCBjYW4gYmUgYEpTT04uc3RyaW5naWZ5YFxuICovXG5cbkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgdmFyIGV4dGVuZCA9IGV4Y2x1ZGUoJ2NvbnN0cnVjdG9yJywgJ3RvSlNPTicsICdzdGFjaycpXG4gICAgLCBwcm9wcyA9IGV4dGVuZCh7IG5hbWU6IHRoaXMubmFtZSB9LCB0aGlzKTtcblxuICAvLyBpbmNsdWRlIHN0YWNrIGlmIGV4aXN0cyBhbmQgbm90IHR1cm5lZCBvZmZcbiAgaWYgKGZhbHNlICE9PSBzdGFjayAmJiB0aGlzLnN0YWNrKSB7XG4gICAgcHJvcHMuc3RhY2sgPSB0aGlzLnN0YWNrO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZXFsJyk7XG4iLCIvKiFcbiAqIGRlZXAtZXFsXG4gKiBDb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIgPGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qIVxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZS1kZXRlY3QnKTtcblxuLyohXG4gKiBCdWZmZXIuaXNCdWZmZXIgYnJvd3NlciBzaGltXG4gKi9cblxudmFyIEJ1ZmZlcjtcbnRyeSB7IEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjsgfVxuY2F0Y2goZXgpIHtcbiAgQnVmZmVyID0ge307XG4gIEJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cblxuLyohXG4gKiBQcmltYXJ5IEV4cG9ydFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcEVxdWFsO1xuXG4vKipcbiAqIEFzc2VydCBzdXBlci1zdHJpY3QgKGVnYWwpIGVxdWFsaXR5IGJldHdlZW5cbiAqIHR3byBvYmplY3RzIG9mIGFueSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEBwYXJhbSB7QXJyYXl9IG1lbW9pc2VkIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4gKi9cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKHNhbWVWYWx1ZShhLCBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKCdkYXRlJyA9PT0gdHlwZShhKSkge1xuICAgIHJldHVybiBkYXRlRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoJ3JlZ2V4cCcgPT09IHR5cGUoYSkpIHtcbiAgICByZXR1cm4gcmVnZXhwRXF1YWwoYSwgYik7XG4gIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGEpKSB7XG4gICAgcmV0dXJuIGJ1ZmZlckVxdWFsKGEsIGIpO1xuICB9IGVsc2UgaWYgKCdhcmd1bWVudHMnID09PSB0eXBlKGEpKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50c0VxdWFsKGEsIGIsIG0pO1xuICB9IGVsc2UgaWYgKCF0eXBlRXF1YWwoYSwgYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoKCdvYmplY3QnICE9PSB0eXBlKGEpICYmICdvYmplY3QnICE9PSB0eXBlKGIpKVxuICAmJiAoJ2FycmF5JyAhPT0gdHlwZShhKSAmJiAnYXJyYXknICE9PSB0eXBlKGIpKSkge1xuICAgIHJldHVybiBzYW1lVmFsdWUoYSwgYik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iamVjdEVxdWFsKGEsIGIsIG0pO1xuICB9XG59XG5cbi8qIVxuICogU3RyaWN0IChlZ2FsKSBlcXVhbGl0eSB0ZXN0LiBFbnN1cmVzIHRoYXQgTmFOIGFsd2F5c1xuICogZXF1YWxzIE5hTiBhbmQgYC0wYCBkb2VzIG5vdCBlcXVhbCBgKzBgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGFcbiAqIEBwYXJhbSB7TWl4ZWR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGVxdWFsIG1hdGNoXG4gKi9cblxuZnVuY3Rpb24gc2FtZVZhbHVlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuLyohXG4gKiBDb21wYXJlIHRoZSB0eXBlcyBvZiB0d28gZ2l2ZW4gb2JqZWN0cyBhbmRcbiAqIHJldHVybiBpZiB0aGV5IGFyZSBlcXVhbC4gTm90ZSB0aGF0IGFuIEFycmF5XG4gKiBoYXMgYSB0eXBlIG9mIGBhcnJheWAgKG5vdCBgb2JqZWN0YCkgYW5kIGFyZ3VtZW50c1xuICogaGF2ZSBhIHR5cGUgb2YgYGFyZ3VtZW50c2AgKG5vdCBgYXJyYXlgL2BvYmplY3RgKS5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhXG4gKiBAcGFyYW0ge01peGVkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiB0eXBlRXF1YWwoYSwgYikge1xuICByZXR1cm4gdHlwZShhKSA9PT0gdHlwZShiKTtcbn1cblxuLyohXG4gKiBDb21wYXJlIHR3byBEYXRlIG9iamVjdHMgYnkgYXNzZXJ0aW5nIHRoYXRcbiAqIHRoZSB0aW1lIHZhbHVlcyBhcmUgZXF1YWwgdXNpbmcgYHNhdmVWYWx1ZWAuXG4gKlxuICogQHBhcmFtIHtEYXRlfSBhXG4gKiBAcGFyYW0ge0RhdGV9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGRhdGVFcXVhbChhLCBiKSB7XG4gIGlmICgnZGF0ZScgIT09IHR5cGUoYikpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNhbWVWYWx1ZShhLmdldFRpbWUoKSwgYi5nZXRUaW1lKCkpO1xufVxuXG4vKiFcbiAqIENvbXBhcmUgdHdvIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYnkgY29udmVydGluZyB0aGVtXG4gKiB0byBzdHJpbmcgYW5kIGNoZWNraW5nIGZvciBgc2FtZVZhbHVlYC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYVxuICogQHBhcmFtIHtSZWdFeHB9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cEVxdWFsKGEsIGIpIHtcbiAgaWYgKCdyZWdleHAnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzYW1lVmFsdWUoYS50b1N0cmluZygpLCBiLnRvU3RyaW5nKCkpO1xufVxuXG4vKiFcbiAqIEFzc2VydCBkZWVwIGVxdWFsaXR5IG9mIHR3byBgYXJndW1lbnRzYCBvYmplY3RzLlxuICogVW5mb3J0dW5hdGVseSwgdGhlc2UgbXVzdCBiZSBzbGljZWQgdG8gYXJyYXlzXG4gKiBwcmlvciB0byB0ZXN0IHRvIGVuc3VyZSBubyBiYWQgYmVoYXZpb3IuXG4gKlxuICogQHBhcmFtIHtBcmd1bWVudHN9IGFcbiAqIEBwYXJhbSB7QXJndW1lbnRzfSBiXG4gKiBAcGFyYW0ge0FycmF5fSBtZW1vaXplIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGFyZ3VtZW50c0VxdWFsKGEsIGIsIG0pIHtcbiAgaWYgKCdhcmd1bWVudHMnICE9PSB0eXBlKGIpKSByZXR1cm4gZmFsc2U7XG4gIGEgPSBbXS5zbGljZS5jYWxsKGEpO1xuICBiID0gW10uc2xpY2UuY2FsbChiKTtcbiAgcmV0dXJuIGRlZXBFcXVhbChhLCBiLCBtKTtcbn1cblxuLyohXG4gKiBHZXQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcmV0dXJuIHtBcnJheX0gcHJvcGVydHkgbmFtZXNcbiAqL1xuXG5mdW5jdGlvbiBlbnVtZXJhYmxlKGEpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gYSkgcmVzLnB1c2goa2V5KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyohXG4gKiBTaW1wbGUgZXF1YWxpdHkgZm9yIGZsYXQgaXRlcmFibGUgb2JqZWN0c1xuICogc3VjaCBhcyBBcnJheXMgb3IgTm9kZS5qcyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGFcbiAqIEBwYXJhbSB7SXRlcmFibGV9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJlc3VsdFxuICovXG5cbmZ1bmN0aW9uIGl0ZXJhYmxlRXF1YWwoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09ICBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpID0gMDtcbiAgdmFyIG1hdGNoID0gdHJ1ZTtcblxuICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLyohXG4gKiBFeHRlbnNpb24gdG8gYGl0ZXJhYmxlRXF1YWxgIHNwZWNpZmljYWxseVxuICogZm9yIE5vZGUuanMgQnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gYnVmZmVyRXF1YWwoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlcmFibGVFcXVhbChhLCBiKTtcbn1cblxuLyohXG4gKiBCbG9jayBmb3IgYG9iamVjdEVxdWFsYCBlbnN1cmluZyBub24tZXhpc3RpbmdcbiAqIHZhbHVlcyBkb24ndCBnZXQgaW4uXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbHVlKGEpIHtcbiAgcmV0dXJuIGEgIT09IG51bGwgJiYgYSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKiFcbiAqIFJlY3Vyc2l2ZWx5IGNoZWNrIHRoZSBlcXVhbGl0eSBvZiB0d28gb2JqZWN0cy5cbiAqIE9uY2UgYmFzaWMgc2FtZW5lc3MgaGFzIGJlZW4gZXN0YWJsaXNoZWQgaXQgd2lsbFxuICogZGVmZXIgdG8gYGRlZXBFcXVhbGAgZm9yIGVhY2ggZW51bWVyYWJsZSBrZXlcbiAqIGluIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYVxuICogQHBhcmFtIHtNaXhlZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0RXF1YWwoYSwgYiwgbSkge1xuICBpZiAoIWlzVmFsdWUoYSkgfHwgIWlzVmFsdWUoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5wcm90b3R5cGUgIT09IGIucHJvdG90eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChtKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgobVtpXVswXSA9PT0gYSAmJiBtW2ldWzFdID09PSBiKVxuICAgICAgfHwgIChtW2ldWzBdID09PSBiICYmIG1baV1bMV0gPT09IGEpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtID0gW107XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBrYSA9IGVudW1lcmFibGUoYSk7XG4gICAgdmFyIGtiID0gZW51bWVyYWJsZShiKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcblxuICBpZiAoIWl0ZXJhYmxlRXF1YWwoa2EsIGtiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG0ucHVzaChbIGEsIGIgXSk7XG5cbiAgdmFyIGtleTtcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvdHlwZScpO1xuIiwiLyohXG4gKiB0eXBlLWRldGVjdFxuICogQ29weXJpZ2h0KGMpIDIwMTMgamFrZSBsdWVyIDxqYWtlQGFsb2dpY2FscGFyYWRveC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKiFcbiAqIFByaW1hcnkgRXhwb3J0c1xuICovXG5cbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRUeXBlO1xuXG4vKiFcbiAqIERldGVjdGFibGUgamF2YXNjcmlwdCBuYXRpdmVzXG4gKi9cblxudmFyIG5hdGl2ZXMgPSB7XG4gICAgJ1tvYmplY3QgQXJyYXldJzogJ2FycmF5J1xuICAsICdbb2JqZWN0IFJlZ0V4cF0nOiAncmVnZXhwJ1xuICAsICdbb2JqZWN0IEZ1bmN0aW9uXSc6ICdmdW5jdGlvbidcbiAgLCAnW29iamVjdCBBcmd1bWVudHNdJzogJ2FyZ3VtZW50cydcbiAgLCAnW29iamVjdCBEYXRlXSc6ICdkYXRlJ1xufTtcblxuLyoqXG4gKiAjIyMgdHlwZU9mIChvYmopXG4gKlxuICogVXNlIHNldmVyYWwgZGlmZmVyZW50IHRlY2huaXF1ZXMgdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdHlwZSBvZiBvYmplY3QgYmVpbmcgdGVzdGVkLlxuICpcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEByZXR1cm4ge1N0cmluZ30gb2JqZWN0IHR5cGVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZ2V0VHlwZSAob2JqKSB7XG4gIHZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgaWYgKG5hdGl2ZXNbc3RyXSkgcmV0dXJuIG5hdGl2ZXNbc3RyXTtcbiAgaWYgKG9iaiA9PT0gbnVsbCkgcmV0dXJuICdudWxsJztcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmIChvYmogPT09IE9iamVjdChvYmopKSByZXR1cm4gJ29iamVjdCc7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufVxuXG5leHBvcnRzLkxpYnJhcnkgPSBMaWJyYXJ5O1xuXG4vKipcbiAqICMjIyBMaWJyYXJ5XG4gKlxuICogQ3JlYXRlIGEgcmVwb3NpdG9yeSBmb3IgY3VzdG9tIHR5cGUgZGV0ZWN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgbGliID0gbmV3IHR5cGUuTGlicmFyeTtcbiAqIGBgYFxuICpcbiAqL1xuXG5mdW5jdGlvbiBMaWJyYXJ5ICgpIHtcbiAgdGhpcy50ZXN0cyA9IHt9O1xufVxuXG4vKipcbiAqICMjIyMgLm9mIChvYmopXG4gKlxuICogRXhwb3NlIHJlcGxhY2VtZW50IGB0eXBlb2ZgIGRldGVjdGlvbiB0byB0aGUgbGlicmFyeS5cbiAqXG4gKiBgYGBqc1xuICogaWYgKCdzdHJpbmcnID09PSBsaWIub2YoJ2hlbGxvIHdvcmxkJykpIHtcbiAqICAgLy8gLi4uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybiB7U3RyaW5nfSB0eXBlXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUub2YgPSBnZXRUeXBlO1xuXG4vKipcbiAqICMjIyMgLmRlZmluZSAodHlwZSwgdGVzdClcbiAqXG4gKiBBZGQgYSB0ZXN0IHRvIGZvciB0aGUgYC50ZXN0KClgIGFzc2VydGlvbi5cbiAqXG4gKiBDYW4gYmUgZGVmaW5lZCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbjpcbiAqXG4gKiBgYGBqc1xuICogbGliLmRlZmluZSgnaW50JywgL15bMC05XSskLyk7XG4gKiBgYGBcbiAqXG4gKiAuLi4gb3IgYXMgYSBmdW5jdGlvbjpcbiAqXG4gKiBgYGBqc1xuICogbGliLmRlZmluZSgnYmxuJywgZnVuY3Rpb24gKG9iaikge1xuICogICBpZiAoJ2Jvb2xlYW4nID09PSBsaWIub2Yob2JqKSkgcmV0dXJuIHRydWU7XG4gKiAgIHZhciBibG5zID0gWyAneWVzJywgJ25vJywgJ3RydWUnLCAnZmFsc2UnLCAxLCAwIF07XG4gKiAgIGlmICgnc3RyaW5nJyA9PT0gbGliLm9mKG9iaikpIG9iaiA9IG9iai50b0xvd2VyQ2FzZSgpO1xuICogICByZXR1cm4gISEgfmJsbnMuaW5kZXhPZihvYmopO1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtSZWdFeHB8RnVuY3Rpb259IHRlc3RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKHR5cGUsIHRlc3QpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLnRlc3RzW3R5cGVdO1xuICB0aGlzLnRlc3RzW3R5cGVdID0gdGVzdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqICMjIyMgLnRlc3QgKG9iaiwgdGVzdClcbiAqXG4gKiBBc3NlcnQgdGhhdCBhbiBvYmplY3QgaXMgb2YgdHlwZS4gV2lsbCBmaXJzdFxuICogY2hlY2sgbmF0aXZlcywgYW5kIGlmIHRoYXQgZG9lcyBub3QgcGFzcyBpdCB3aWxsXG4gKiB1c2UgdGhlIHVzZXIgZGVmaW5lZCBjdXN0b20gdGVzdHMuXG4gKlxuICogYGBganNcbiAqIGFzc2VydChsaWIudGVzdCgnMScsICdpbnQnKSk7XG4gKiBhc3NlcnQobGliLnRlc3QoJ3llcycsICdibG4nKSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge01peGVkfSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtCb29sZWFufSByZXN1bHRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlicmFyeS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT09IGdldFR5cGUob2JqKSkgcmV0dXJuIHRydWU7XG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0c1t0eXBlXTtcblxuICBpZiAodGVzdCAmJiAncmVnZXhwJyA9PT0gZ2V0VHlwZSh0ZXN0KSkge1xuICAgIHJldHVybiB0ZXN0LnRlc3Qob2JqKTtcbiAgfSBlbHNlIGlmICh0ZXN0ICYmICdmdW5jdGlvbicgPT09IGdldFR5cGUodGVzdCkpIHtcbiAgICByZXR1cm4gdGVzdChvYmopO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignVHlwZSB0ZXN0IFwiJyArIHR5cGUgKyAnXCIgbm90IGRlZmluZWQgb3IgaW52YWxpZC4nKTtcbiAgfVxufTtcbiIsInZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciB1bmRlZmluZWQ7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdGlmICghb2JqIHx8IHRvU3RyaW5nLmNhbGwob2JqKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScgfHwgb2JqLm5vZGVUeXBlIHx8IG9iai5zZXRJbnRlcnZhbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBoYXNfb3duX2NvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAnY29uc3RydWN0b3InKTtcblx0dmFyIGhhc19pc19wcm9wZXJ0eV9vZl9tZXRob2QgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSAmJiBoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAnaXNQcm90b3R5cGVPZicpO1xuXHQvLyBOb3Qgb3duIGNvbnN0cnVjdG9yIHByb3BlcnR5IG11c3QgYmUgT2JqZWN0XG5cdGlmIChvYmouY29uc3RydWN0b3IgJiYgIWhhc19vd25fY29uc3RydWN0b3IgJiYgIWhhc19pc19wcm9wZXJ0eV9vZl9tZXRob2QpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoa2V5IGluIG9iaikge31cblxuXHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzBdLFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG5cdFx0Ly8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdGkgPSAyO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiIHx8IHRhcmdldCA9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Zm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoKG9wdGlvbnMgPSBhcmd1bWVudHNbaV0pICE9IG51bGwpIHtcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFtuYW1lXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbbmFtZV07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAodGFyZ2V0ID09PSBjb3B5KSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKGRlZXAgJiYgY29weSAmJiAoaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRpZiAoY29weUlzQXJyYXkpIHtcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBBcnJheS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gdmltOnRzPTQ6c3RzPTQ6c3c9NDpcbi8qIVxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTIgS3JpcyBLb3dhbCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVFxuICogbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9yYXcvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IFR5bGVyIENsb3NlXG4gKiBDb3B5cmlnaHQgMjAwNy0yMDA5IFR5bGVyIENsb3NlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIFggbGljZW5zZSBmb3VuZFxuICogYXQgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5odG1sXG4gKiBGb3JrZWQgYXQgcmVmX3NlbmQuanMgdmVyc2lvbjogMjAwOS0wNS0xMVxuICpcbiAqIFdpdGggcGFydHMgYnkgTWFyayBNaWxsZXJcbiAqIENvcHlyaWdodCAoQykgMjAxMSBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4oZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAvLyBUdXJuIG9mZiBzdHJpY3QgbW9kZSBmb3IgdGhpcyBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzaWduIHRvIGdsb2JhbC5RXG4gICAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi9cblxuICAgIC8vIFRoaXMgZmlsZSB3aWxsIGZ1bmN0aW9uIHByb3Blcmx5IGFzIGEgPHNjcmlwdD4gdGFnLCBvciBhIG1vZHVsZVxuICAgIC8vIHVzaW5nIENvbW1vbkpTIGFuZCBOb2RlSlMgb3IgUmVxdWlyZUpTIG1vZHVsZSBmb3JtYXRzLiAgSW5cbiAgICAvLyBDb21tb24vTm9kZS9SZXF1aXJlSlMsIHRoZSBtb2R1bGUgZXhwb3J0cyB0aGUgUSBBUEkgYW5kIHdoZW5cbiAgICAvLyBleGVjdXRlZCBhcyBhIHNpbXBsZSA8c2NyaXB0PiwgaXQgY3JlYXRlcyBhIFEgZ2xvYmFsIGluc3RlYWQuXG5cbiAgICAvLyBNb250YWdlIFJlcXVpcmVcbiAgICBpZiAodHlwZW9mIGJvb3RzdHJhcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGJvb3RzdHJhcChcInByb21pc2VcIiwgZGVmaW5pdGlvbik7XG5cbiAgICAvLyBDb21tb25KU1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAvLyBSZXF1aXJlSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcblxuICAgIC8vIFNFUyAoU2VjdXJlIEVjbWFTY3JpcHQpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICghc2VzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcy5tYWtlUSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cblxuICAgIC8vIDxzY3JpcHQ+XG4gICAgfSBlbHNlIHtcbiAgICAgICAgUSA9IGRlZmluaXRpb24oKTtcbiAgICB9XG5cbn0pKGZ1bmN0aW9uICgpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgaGFzU3RhY2tzID0gZmFsc2U7XG50cnkge1xuICAgIHRocm93IG5ldyBFcnJvcigpO1xufSBjYXRjaCAoZSkge1xuICAgIGhhc1N0YWNrcyA9ICEhZS5zdGFjaztcbn1cblxuLy8gQWxsIGNvZGUgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzIHJlcG9ydGVkXG4vLyBieSBRLlxudmFyIHFTdGFydGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xudmFyIHFGaWxlTmFtZTtcblxuLy8gc2hpbXNcblxuLy8gdXNlZCBmb3IgZmFsbGJhY2sgaW4gXCJhbGxSZXNvbHZlZFwiXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG52YXIgbmV4dFRpY2sgPShmdW5jdGlvbiAoKSB7XG4gICAgLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG4gICAgdmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbiAgICB2YXIgdGFpbCA9IGhlYWQ7XG4gICAgdmFyIGZsdXNoaW5nID0gZmFsc2U7XG4gICAgdmFyIHJlcXVlc3RUaWNrID0gdm9pZCAwO1xuICAgIHZhciBpc05vZGVKUyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG4gICAgICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIHZhciBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZXh0VGljayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgICAgIC8vIE5vZGUuanMgYmVmb3JlIDAuOS4gTm90ZSB0aGF0IHNvbWUgZmFrZS1Ob2RlIGVudmlyb25tZW50cywgbGlrZSB0aGVcbiAgICAgICAgLy8gTW9jaGEgdGVzdCBydW5uZXIsIGludHJvZHVjZSBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2AuXG4gICAgICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIC8vIEF0IGxlYXN0IFNhZmFyaSBWZXJzaW9uIDYuMC41ICg4NTM2LjMwLjEpIGludGVybWl0dGVudGx5IGNhbm5vdCBjcmVhdGVcbiAgICAgICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHJlcXVlc3RQb3J0VGljaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdFBvcnRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT3BlcmEgcmVxdWlyZXMgdXMgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgcGF5bG9hZCwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB1c2UgaXQuXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgcmVxdWVzdFBvcnRUaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFRpY2s7XG59KSgpO1xuXG4vLyBBdHRlbXB0IHRvIG1ha2UgZ2VuZXJpY3Mgc2FmZSBpbiB0aGUgZmFjZSBvZiBkb3duc3RyZWFtXG4vLyBtb2RpZmljYXRpb25zLlxuLy8gVGhlcmUgaXMgbm8gc2l0dWF0aW9uIHdoZXJlIHRoaXMgaXMgbmVjZXNzYXJ5LlxuLy8gSWYgeW91IG5lZWQgYSBzZWN1cml0eSBndWFyYW50ZWUsIHRoZXNlIHByaW1vcmRpYWxzIG5lZWQgdG8gYmVcbi8vIGRlZXBseSBmcm96ZW4gYW55d2F5LCBhbmQgaWYgeW91IGRvbuKAmXQgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSxcbi8vIHRoaXMgaXMganVzdCBwbGFpbiBwYXJhbm9pZC5cbi8vIEhvd2V2ZXIsIHRoaXMgKiptaWdodCoqIGhhdmUgdGhlIG5pY2Ugc2lkZS1lZmZlY3Qgb2YgcmVkdWNpbmcgdGhlIHNpemUgb2Zcbi8vIHRoZSBtaW5pZmllZCBjb2RlIGJ5IHJlZHVjaW5nIHguY2FsbCgpIHRvIG1lcmVseSB4KClcbi8vIFNlZSBNYXJrIE1pbGxlcuKAmXMgZXhwbGFuYXRpb24gb2Ygd2hhdCB0aGlzIGRvZXMuXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1jb252ZW50aW9uczpzYWZlX21ldGFfcHJvZ3JhbW1pbmdcbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY2FsbC5hcHBseShmLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQsIGJ1dCBzbG93ZXI6XG4vLyB1bmN1cnJ5VGhpcyA9IEZ1bmN0aW9uX2JpbmQuYmluZChGdW5jdGlvbl9iaW5kLmNhbGwpO1xuLy8gaHR0cDovL2pzcGVyZi5jb20vdW5jdXJyeXRoaXNcblxudmFyIGFycmF5X3NsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcblxudmFyIGFycmF5X3JlZHVjZSA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCBiYXNpcykge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIC8vIGNvbmNlcm5pbmcgdGhlIGluaXRpYWwgdmFsdWUsIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIHNlZWsgdG8gdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBhcnJheSwgYWNjb3VudGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGlzIGlzIGEgc3BhcnNlIGFycmF5XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IGluIHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzaXMgPSB0aGlzW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWR1Y2VcbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgYXJyYXkgaXMgc3BhcnNlXG4gICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGJhc2lzID0gY2FsbGJhY2soYmFzaXMsIHRoaXNbaW5kZXhdLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2lzO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9pbmRleE9mID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5vdCBhIHZlcnkgZ29vZCBzaGltLCBidXQgZ29vZCBlbm91Z2ggZm9yIG91ciBvbmUgdXNlIG9mIGl0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbik7XG5cbnZhciBhcnJheV9tYXAgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUubWFwIHx8IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3ApIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgY29sbGVjdCA9IFtdO1xuICAgICAgICBhcnJheV9yZWR1Y2Uoc2VsZiwgZnVuY3Rpb24gKHVuZGVmaW5lZCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICBjb2xsZWN0LnB1c2goY2FsbGJhY2suY2FsbCh0aGlzcCwgdmFsdWUsIGluZGV4LCBzZWxmKSk7XG4gICAgICAgIH0sIHZvaWQgMCk7XG4gICAgICAgIHJldHVybiBjb2xsZWN0O1xuICAgIH1cbik7XG5cbnZhciBvYmplY3RfY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiAocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gVHlwZSgpIHsgfVxuICAgIFR5cGUucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBuZXcgVHlwZSgpO1xufTtcblxudmFyIG9iamVjdF9oYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG52YXIgb2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3RfaGFzT3duUHJvcGVydHkob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBvYmplY3RfdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE9iamVjdCh2YWx1ZSk7XG59XG5cbi8vIGdlbmVyYXRvciByZWxhdGVkIHNoaW1zXG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBmdW5jdGlvbiBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG5mdW5jdGlvbiBpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgb2JqZWN0X3RvU3RyaW5nKGV4Y2VwdGlvbikgPT09IFwiW29iamVjdCBTdG9wSXRlcmF0aW9uXVwiIHx8XG4gICAgICAgIGV4Y2VwdGlvbiBpbnN0YW5jZW9mIFFSZXR1cm5WYWx1ZVxuICAgICk7XG59XG5cbi8vIEZJWE1FOiBSZW1vdmUgdGhpcyBoZWxwZXIgYW5kIFEucmV0dXJuIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluXG4vLyBTcGlkZXJNb25rZXkuXG52YXIgUVJldHVyblZhbHVlO1xuaWYgKHR5cGVvZiBSZXR1cm5WYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIFFSZXR1cm5WYWx1ZSA9IFJldHVyblZhbHVlO1xufSBlbHNlIHtcbiAgICBRUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH07XG59XG5cbi8vIGxvbmcgc3RhY2sgdHJhY2VzXG5cbnZhciBTVEFDS19KVU1QX1NFUEFSQVRPUiA9IFwiRnJvbSBwcmV2aW91cyBldmVudDpcIjtcblxuZnVuY3Rpb24gbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIHRyYW5zZm9ybSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgYnkgcmVtb3ZpbmcgTm9kZSBhbmQgUVxuICAgIC8vIGNydWZ0LCB0aGVuIGNvbmNhdGVuYXRpbmcgd2l0aCB0aGUgc3RhY2sgdHJhY2Ugb2YgYHByb21pc2VgLiBTZWUgIzU3LlxuICAgIGlmIChoYXNTdGFja3MgJiZcbiAgICAgICAgcHJvbWlzZS5zdGFjayAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZXJyb3IgIT09IG51bGwgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2sgJiZcbiAgICAgICAgZXJyb3Iuc3RhY2suaW5kZXhPZihTVEFDS19KVU1QX1NFUEFSQVRPUikgPT09IC0xXG4gICAgKSB7XG4gICAgICAgIHZhciBzdGFja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgcCA9IHByb21pc2U7ICEhcDsgcCA9IHAuc291cmNlKSB7XG4gICAgICAgICAgICBpZiAocC5zdGFjaykge1xuICAgICAgICAgICAgICAgIHN0YWNrcy51bnNoaWZ0KHAuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy51bnNoaWZ0KGVycm9yLnN0YWNrKTtcblxuICAgICAgICB2YXIgY29uY2F0ZWRTdGFja3MgPSBzdGFja3Muam9pbihcIlxcblwiICsgU1RBQ0tfSlVNUF9TRVBBUkFUT1IgKyBcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBmaWx0ZXJTdGFja1N0cmluZyhjb25jYXRlZFN0YWNrcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJTdGFja1N0cmluZyhzdGFja1N0cmluZykge1xuICAgIHZhciBsaW5lcyA9IHN0YWNrU3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIHZhciBkZXNpcmVkTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG5cbiAgICAgICAgaWYgKCFpc0ludGVybmFsRnJhbWUobGluZSkgJiYgIWlzTm9kZUZyYW1lKGxpbmUpICYmIGxpbmUpIHtcbiAgICAgICAgICAgIGRlc2lyZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXNpcmVkTGluZXMuam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgcmV0dXJuIHN0YWNrTGluZS5pbmRleE9mKFwiKG1vZHVsZS5qczpcIikgIT09IC0xIHx8XG4gICAgICAgICAgIHN0YWNrTGluZS5pbmRleE9mKFwiKG5vZGUuanM6XCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSkge1xuICAgIC8vIE5hbWVkIGZ1bmN0aW9uczogXCJhdCBmdW5jdGlvbk5hbWUgKGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyKVwiXG4gICAgLy8gSW4gSUUxMCBmdW5jdGlvbiBuYW1lIGNhbiBoYXZlIHNwYWNlcyAoXCJBbm9ueW1vdXMgZnVuY3Rpb25cIikgT19vXG4gICAgdmFyIGF0dGVtcHQxID0gL2F0IC4rIFxcKCguKyk6KFxcZCspOig/OlxcZCspXFwpJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0MSkge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQxWzFdLCBOdW1iZXIoYXR0ZW1wdDFbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb25zOiBcImF0IGZpbGVuYW1lOmxpbmVOdW1iZXI6Y29sdW1uTnVtYmVyXCJcbiAgICB2YXIgYXR0ZW1wdDIgPSAvYXQgKFteIF0rKTooXFxkKyk6KD86XFxkKykkLy5leGVjKHN0YWNrTGluZSk7XG4gICAgaWYgKGF0dGVtcHQyKSB7XG4gICAgICAgIHJldHVybiBbYXR0ZW1wdDJbMV0sIE51bWJlcihhdHRlbXB0MlsyXSldO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggc3R5bGU6IFwiZnVuY3Rpb25AZmlsZW5hbWU6bGluZU51bWJlciBvciBAZmlsZW5hbWU6bGluZU51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQzID0gLy4qQCguKyk6KFxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mykge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQzWzFdLCBOdW1iZXIoYXR0ZW1wdDNbMl0pXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJuYWxGcmFtZShzdGFja0xpbmUpIHtcbiAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKHN0YWNrTGluZSk7XG5cbiAgICBpZiAoIWZpbGVOYW1lQW5kTGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVOYW1lID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzBdO1xuICAgIHZhciBsaW5lTnVtYmVyID0gZmlsZU5hbWVBbmRMaW5lTnVtYmVyWzFdO1xuXG4gICAgcmV0dXJuIGZpbGVOYW1lID09PSBxRmlsZU5hbWUgJiZcbiAgICAgICAgbGluZU51bWJlciA+PSBxU3RhcnRpbmdMaW5lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPD0gcUVuZGluZ0xpbmU7XG59XG5cbi8vIGRpc2NvdmVyIG93biBmaWxlIG5hbWUgYW5kIGxpbmUgbnVtYmVyIHJhbmdlIGZvciBmaWx0ZXJpbmcgc3RhY2tcbi8vIHRyYWNlc1xuZnVuY3Rpb24gY2FwdHVyZUxpbmUoKSB7XG4gICAgaWYgKCFoYXNTdGFja3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgdmFyIGZpcnN0TGluZSA9IGxpbmVzWzBdLmluZGV4T2YoXCJAXCIpID4gMCA/IGxpbmVzWzFdIDogbGluZXNbMl07XG4gICAgICAgIHZhciBmaWxlTmFtZUFuZExpbmVOdW1iZXIgPSBnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIoZmlyc3RMaW5lKTtcbiAgICAgICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHFGaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICAgICAgcmV0dXJuIGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZShjYWxsYmFjaywgbmFtZSwgYWx0ZXJuYXRpdmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlLndhcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG5hbWUgKyBcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCIgKyBhbHRlcm5hdGl2ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW5zdGVhZC5cIiwgbmV3IEVycm9yKFwiXCIpLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuLy8gZW5kIG9mIHNoaW1zXG4vLyBiZWdpbm5pbmcgb2YgcmVhbCB3b3JrXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIHByb21pc2UgZm9yIGFuIGltbWVkaWF0ZSByZWZlcmVuY2UsIHBhc3NlcyBwcm9taXNlcyB0aHJvdWdoLCBvclxuICogY29lcmNlcyBwcm9taXNlcyBmcm9tIGRpZmZlcmVudCBzeXN0ZW1zLlxuICogQHBhcmFtIHZhbHVlIGltbWVkaWF0ZSByZWZlcmVuY2Ugb3IgcHJvbWlzZVxuICovXG5mdW5jdGlvbiBRKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhlIG9iamVjdCBpcyBhbHJlYWR5IGEgUHJvbWlzZSwgcmV0dXJuIGl0IGRpcmVjdGx5LiAgVGhpcyBlbmFibGVzXG4gICAgLy8gdGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gYm90aCBiZSB1c2VkIHRvIGNyZWF0ZWQgcmVmZXJlbmNlcyBmcm9tIG9iamVjdHMsXG4gICAgLy8gYnV0IHRvIHRvbGVyYWJseSBjb2VyY2Ugbm9uLXByb21pc2VzIHRvIHByb21pc2VzLlxuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBhc3NpbWlsYXRlIHRoZW5hYmxlc1xuICAgIGlmIChpc1Byb21pc2VBbGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGwodmFsdWUpO1xuICAgIH1cbn1cblEucmVzb2x2ZSA9IFE7XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrXG4gKi9cblEubmV4dFRpY2sgPSBuZXh0VGljaztcblxuLyoqXG4gKiBDb250cm9scyB3aGV0aGVyIG9yIG5vdCBsb25nIHN0YWNrIHRyYWNlcyB3aWxsIGJlIG9uXG4gKi9cblEubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSB7cHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0fSBvYmplY3QuXG4gKlxuICogYHJlc29sdmVgIGlzIGEgY2FsbGJhY2sgdG8gaW52b2tlIHdpdGggYSBtb3JlIHJlc29sdmVkIHZhbHVlIGZvciB0aGVcbiAqIHByb21pc2UuIFRvIGZ1bGZpbGwgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhbnkgdmFsdWUgdGhhdCBpc1xuICogbm90IGEgdGhlbmFibGUuIFRvIHJlamVjdCB0aGUgcHJvbWlzZSwgaW52b2tlIGByZXNvbHZlYCB3aXRoIGEgcmVqZWN0ZWRcbiAqIHRoZW5hYmxlLCBvciBpbnZva2UgYHJlamVjdGAgd2l0aCB0aGUgcmVhc29uIGRpcmVjdGx5LiBUbyByZXNvbHZlIHRoZVxuICogcHJvbWlzZSB0byBhbm90aGVyIHRoZW5hYmxlLCB0aHVzIHB1dHRpbmcgaXQgaW4gdGhlIHNhbWUgc3RhdGUsIGludm9rZVxuICogYHJlc29sdmVgIHdpdGggdGhhdCBvdGhlciB0aGVuYWJsZS5cbiAqL1xuUS5kZWZlciA9IGRlZmVyO1xuZnVuY3Rpb24gZGVmZXIoKSB7XG4gICAgLy8gaWYgXCJtZXNzYWdlc1wiIGlzIGFuIFwiQXJyYXlcIiwgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvbWlzZSBoYXMgbm90IHlldFxuICAgIC8vIGJlZW4gcmVzb2x2ZWQuICBJZiBpdCBpcyBcInVuZGVmaW5lZFwiLCBpdCBoYXMgYmVlbiByZXNvbHZlZC4gIEVhY2hcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBtZXNzYWdlcyBhcnJheSBpcyBpdHNlbGYgYW4gYXJyYXkgb2YgY29tcGxldGUgYXJndW1lbnRzIHRvXG4gICAgLy8gZm9yd2FyZCB0byB0aGUgcmVzb2x2ZWQgcHJvbWlzZS4gIFdlIGNvZXJjZSB0aGUgcmVzb2x1dGlvbiB2YWx1ZSB0byBhXG4gICAgLy8gcHJvbWlzZSB1c2luZyB0aGUgYHJlc29sdmVgIGZ1bmN0aW9uIGJlY2F1c2UgaXQgaGFuZGxlcyBib3RoIGZ1bGx5XG4gICAgLy8gbm9uLXRoZW5hYmxlIHZhbHVlcyBhbmQgb3RoZXIgdGhlbmFibGVzIGdyYWNlZnVsbHkuXG4gICAgdmFyIG1lc3NhZ2VzID0gW10sIHByb2dyZXNzTGlzdGVuZXJzID0gW10sIHJlc29sdmVkUHJvbWlzZTtcblxuICAgIHZhciBkZWZlcnJlZCA9IG9iamVjdF9jcmVhdGUoZGVmZXIucHJvdG90eXBlKTtcbiAgICB2YXIgcHJvbWlzZSA9IG9iamVjdF9jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuXG4gICAgcHJvbWlzZS5wcm9taXNlRGlzcGF0Y2ggPSBmdW5jdGlvbiAocmVzb2x2ZSwgb3AsIG9wZXJhbmRzKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBcIndoZW5cIiAmJiBvcGVyYW5kc1sxXSkgeyAvLyBwcm9ncmVzcyBvcGVyYW5kXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMucHVzaChvcGVyYW5kc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShyZXNvbHZlZFByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWRcbiAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJlclZhbHVlID0gbmVhcmVyKHJlc29sdmVkUHJvbWlzZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2UobmVhcmVyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZWFyZXJWYWx1ZTsgLy8gc2hvcnRlbiBjaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXJWYWx1ZTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicGVuZGluZ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTk9URTogZG9uJ3QgdHJ5IHRvIHVzZSBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgIG9yIHRyYW5zZmVyIHRoZVxuICAgICAgICAgICAgLy8gYWNjZXNzb3IgYXJvdW5kOyB0aGF0IGNhdXNlcyBtZW1vcnkgbGVha3MgYXMgcGVyIEdILTExMS4gSnVzdFxuICAgICAgICAgICAgLy8gcmVpZnkgdGhlIHN0YWNrIHRyYWNlIGFzIGEgc3RyaW5nIEFTQVAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZTsgaXQncyBhbHdheXMganVzdFxuICAgICAgICAgICAgLy8gXCJbb2JqZWN0IFByb21pc2VdXFxuXCIsIGFzIHBlciB0aGUgYHRvU3RyaW5nYC5cbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IHdlIGRvIHRoZSBjaGVja3MgZm9yIGByZXNvbHZlZFByb21pc2VgIGluIGVhY2ggbWV0aG9kLCBpbnN0ZWFkIG9mXG4gICAgLy8gY29uc29saWRhdGluZyB0aGVtIGludG8gYGJlY29tZWAsIHNpbmNlIG90aGVyd2lzZSB3ZSdkIGNyZWF0ZSBuZXdcbiAgICAvLyBwcm9taXNlcyB3aXRoIHRoZSBsaW5lcyBgYmVjb21lKHdoYXRldmVyKHZhbHVlKSlgLiBTZWUgZS5nLiBHSC0yNTIuXG5cbiAgICBmdW5jdGlvbiBiZWNvbWUobmV3UHJvbWlzZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZXdQcm9taXNlO1xuICAgICAgICBwcm9taXNlLnNvdXJjZSA9IG5ld1Byb21pc2U7XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKG1lc3NhZ2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcihwcm9ncmVzcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmVycmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBOb2RlLXN0eWxlIGNhbGxiYWNrIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAqIHByb21pc2UuXG4gKiBAcmV0dXJucyBhIG5vZGViYWNrXG4gKi9cbmRlZmVyLnByb3RvdHlwZS5tYWtlTm9kZVJlc29sdmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycm9yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNlbGYucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSByZXNvbHZlciB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vdGhpbmcgYW5kIGFjY2VwdHNcbiAqIHRoZSByZXNvbHZlLCByZWplY3QsIGFuZCBub3RpZnkgZnVuY3Rpb25zIGZvciBhIGRlZmVycmVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgbWF5IGJlIHJlc29sdmVkIHdpdGggdGhlIGdpdmVuIHJlc29sdmUgYW5kIHJlamVjdFxuICogZnVuY3Rpb25zLCBvciByZWplY3RlZCBieSBhIHRocm93biBleGNlcHRpb24gaW4gcmVzb2x2ZXJcbiAqL1xuUS5Qcm9taXNlID0gcHJvbWlzZTsgLy8gRVM2XG5RLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gcHJvbWlzZShyZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbiAgICB9XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgfSBjYXRjaCAocmVhc29uKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxucHJvbWlzZS5yYWNlID0gcmFjZTsgLy8gRVM2XG5wcm9taXNlLmFsbCA9IGFsbDsgLy8gRVM2XG5wcm9taXNlLnJlamVjdCA9IHJlamVjdDsgLy8gRVM2XG5wcm9taXNlLnJlc29sdmUgPSBROyAvLyBFUzZcblxuLy8gWFhYIGV4cGVyaW1lbnRhbC4gIFRoaXMgbWV0aG9kIGlzIGEgd2F5IHRvIGRlbm90ZSB0aGF0IGEgbG9jYWwgdmFsdWUgaXNcbi8vIHNlcmlhbGl6YWJsZSBhbmQgc2hvdWxkIGJlIGltbWVkaWF0ZWx5IGRpc3BhdGNoZWQgdG8gYSByZW1vdGUgdXBvbiByZXF1ZXN0LFxuLy8gaW5zdGVhZCBvZiBwYXNzaW5nIGEgcmVmZXJlbmNlLlxuUS5wYXNzQnlDb3B5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIC8vZnJlZXplKG9iamVjdCk7XG4gICAgLy9wYXNzQnlDb3BpZXMuc2V0KG9iamVjdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSWYgdHdvIHByb21pc2VzIGV2ZW50dWFsbHkgZnVsZmlsbCB0byB0aGUgc2FtZSB2YWx1ZSwgcHJvbWlzZXMgdGhhdCB2YWx1ZSxcbiAqIGJ1dCBvdGhlcndpc2UgcmVqZWN0cy5cbiAqIEBwYXJhbSB4IHtBbnkqfVxuICogQHBhcmFtIHkge0FueSp9XG4gKiBAcmV0dXJucyB7QW55Kn0gYSBwcm9taXNlIGZvciB4IGFuZCB5IGlmIHRoZXkgYXJlIHRoZSBzYW1lLCBidXQgYSByZWplY3Rpb25cbiAqIG90aGVyd2lzZS5cbiAqXG4gKi9cblEuam9pbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgcmV0dXJuIFEoeCkuam9pbih5KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiAodGhhdCkge1xuICAgIHJldHVybiBRKFt0aGlzLCB0aGF0XSkuc3ByZWFkKGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBcIj09PVwiIHNob3VsZCBiZSBPYmplY3QuaXMgb3IgZXF1aXZcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgam9pbjogbm90IHRoZSBzYW1lOiBcIiArIHggKyBcIiBcIiArIHkpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmlyc3Qgb2YgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdG8gYmVjb21lIGZ1bGZpbGxlZC5cbiAqIEBwYXJhbSBhbnN3ZXJzIHtBcnJheVtBbnkqXX0gcHJvbWlzZXMgdG8gcmFjZVxuICogQHJldHVybnMge0FueSp9IHRoZSBmaXJzdCBwcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdGhpcyBvbmNlIHdlIGNhbiBhc3N1bWUgYXQgbGVhc3QgRVM1XG4gICAgICAgIC8vIGFuc3dlclBzLmZvckVhY2goZnVuY3Rpb24oYW5zd2VyUCkge1xuICAgICAgICAvLyAgICAgUShhbnN3ZXJQKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBVc2UgdGhpcyBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFuc3dlclBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBRKGFuc3dlclBzW2ldKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUucmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKFEucmFjZSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBQcm9taXNlIHdpdGggYSBwcm9taXNlIGRlc2NyaXB0b3Igb2JqZWN0IGFuZCBvcHRpb25hbCBmYWxsYmFja1xuICogZnVuY3Rpb24uICBUaGUgZGVzY3JpcHRvciBjb250YWlucyBtZXRob2RzIGxpa2Ugd2hlbihyZWplY3RlZCksIGdldChuYW1lKSxcbiAqIHNldChuYW1lLCB2YWx1ZSksIHBvc3QobmFtZSwgYXJncyksIGFuZCBkZWxldGUobmFtZSksIHdoaWNoIGFsbFxuICogcmV0dXJuIGVpdGhlciBhIHZhbHVlLCBhIHByb21pc2UgZm9yIGEgdmFsdWUsIG9yIGEgcmVqZWN0aW9uLiAgVGhlIGZhbGxiYWNrXG4gKiBhY2NlcHRzIHRoZSBvcGVyYXRpb24gbmFtZSwgYSByZXNvbHZlciwgYW5kIGFueSBmdXJ0aGVyIGFyZ3VtZW50cyB0aGF0IHdvdWxkXG4gKiBoYXZlIGJlZW4gZm9yd2FyZGVkIHRvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgYWJvdmUgaGFkIGEgbWV0aG9kIGJlZW5cbiAqIHByb3ZpZGVkIHdpdGggdGhlIHByb3BlciBuYW1lLiAgVGhlIEFQSSBtYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IHRoZSBuYXR1cmVcbiAqIG9mIHRoZSByZXR1cm5lZCBvYmplY3QsIGFwYXJ0IGZyb20gdGhhdCBpdCBpcyB1c2FibGUgd2hlcmVldmVyIHByb21pc2VzIGFyZVxuICogYm91Z2h0IGFuZCBzb2xkLlxuICovXG5RLm1ha2VQcm9taXNlID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZGVzY3JpcHRvciwgZmFsbGJhY2ssIGluc3BlY3QpIHtcbiAgICBpZiAoZmFsbGJhY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBmYWxsYmFjayA9IGZ1bmN0aW9uIChvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJQcm9taXNlIGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uOiBcIiArIG9wXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGluc3BlY3QgPT09IHZvaWQgMCkge1xuICAgICAgICBpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGF0ZTogXCJ1bmtub3duXCJ9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gb2JqZWN0X2NyZWF0ZShQcm9taXNlLnByb3RvdHlwZSk7XG5cbiAgICBwcm9taXNlLnByb21pc2VEaXNwYXRjaCA9IGZ1bmN0aW9uIChyZXNvbHZlLCBvcCwgYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3Jbb3BdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVzY3JpcHRvcltvcF0uYXBwbHkocHJvbWlzZSwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbGxiYWNrLmNhbGwocHJvbWlzZSwgb3AsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gaW5zcGVjdDtcblxuICAgIC8vIFhYWCBkZXByZWNhdGVkIGB2YWx1ZU9mYCBhbmQgYGV4Y2VwdGlvbmAgc3VwcG9ydFxuICAgIGlmIChpbnNwZWN0KSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSBpbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgcHJvbWlzZS5leGNlcHRpb24gPSBpbnNwZWN0ZWQucmVhc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvbWlzZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwicGVuZGluZ1wiIHx8XG4gICAgICAgICAgICAgICAgaW5zcGVjdGVkLnN0YXRlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgUHJvbWlzZV1cIjtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciBkb25lID0gZmFsc2U7ICAgLy8gZW5zdXJlIHRoZSB1bnRydXN0ZWQgcHJvbWlzZSBtYWtlcyBhdCBtb3N0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjYWxsIHRvIG9uZSBvZiB0aGUgY2FsbGJhY2tzXG5cbiAgICBmdW5jdGlvbiBfZnVsZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGZ1bGZpbGxlZCA9PT0gXCJmdW5jdGlvblwiID8gZnVsZmlsbGVkKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yZWplY3RlZChleGNlcHRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWplY3RlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYWtlU3RhY2tUcmFjZUxvbmcoZXhjZXB0aW9uLCBzZWxmKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKGV4Y2VwdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChuZXdFeGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ld0V4Y2VwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9wcm9ncmVzc2VkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcHJvZ3Jlc3NlZCA9PT0gXCJmdW5jdGlvblwiID8gcHJvZ3Jlc3NlZCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfZnVsZmlsbGVkKHZhbHVlKSk7XG4gICAgICAgIH0sIFwid2hlblwiLCBbZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShfcmVqZWN0ZWQoZXhjZXB0aW9uKSk7XG4gICAgICAgIH1dKTtcbiAgICB9KTtcblxuICAgIC8vIFByb2dyZXNzIHByb3BhZ2F0b3IgbmVlZCB0byBiZSBhdHRhY2hlZCBpbiB0aGUgY3VycmVudCB0aWNrLlxuICAgIHNlbGYucHJvbWlzZURpc3BhdGNoKHZvaWQgMCwgXCJ3aGVuXCIsIFt2b2lkIDAsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbmV3VmFsdWU7XG4gICAgICAgIHZhciB0aHJldyA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBfcHJvZ3Jlc3NlZCh2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRocmV3KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBvYnNlcnZlciBvbiBhIHByb21pc2UuXG4gKlxuICogR3VhcmFudGVlczpcbiAqXG4gKiAxLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlLlxuICogMi4gdGhhdCBlaXRoZXIgdGhlIGZ1bGZpbGxlZCBjYWxsYmFjayBvciB0aGUgcmVqZWN0ZWQgY2FsbGJhY2sgd2lsbCBiZVxuICogICAgY2FsbGVkLCBidXQgbm90IGJvdGguXG4gKiAzLiB0aGF0IGZ1bGZpbGxlZCBhbmQgcmVqZWN0ZWQgd2lsbCBub3QgYmUgY2FsbGVkIGluIHRoaXMgdHVybi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgICAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgdG8gb2JzZXJ2ZVxuICogQHBhcmFtIGZ1bGZpbGxlZCAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogQHBhcmFtIHJlamVjdGVkICAgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggdGhlIHJlamVjdGlvbiBleGNlcHRpb25cbiAqIEBwYXJhbSBwcm9ncmVzc2VkIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBhbnkgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uc1xuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGludm9rZWQgY2FsbGJhY2tcbiAqL1xuUS53aGVuID0gd2hlbjtcbmZ1bmN0aW9uIHdoZW4odmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbHVlOyB9KTtcbn07XG5cblEudGhlblJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyByZWFzb247IH0pO1xufTtcblxuUS50aGVuUmVqZWN0ID0gZnVuY3Rpb24gKHByb21pc2UsIHJlYXNvbikge1xuICAgIHJldHVybiBRKHByb21pc2UpLnRoZW5SZWplY3QocmVhc29uKTtcbn07XG5cbi8qKlxuICogSWYgYW4gb2JqZWN0IGlzIG5vdCBhIHByb21pc2UsIGl0IGlzIGFzIFwibmVhclwiIGFzIHBvc3NpYmxlLlxuICogSWYgYSBwcm9taXNlIGlzIHJlamVjdGVkLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZSB0b28uXG4gKiBJZiBpdOKAmXMgYSBmdWxmaWxsZWQgcHJvbWlzZSwgdGhlIGZ1bGZpbGxtZW50IHZhbHVlIGlzIG5lYXJlci5cbiAqIElmIGl04oCZcyBhIGRlZmVycmVkIHByb21pc2UgYW5kIHRoZSBkZWZlcnJlZCBoYXMgYmVlbiByZXNvbHZlZCwgdGhlXG4gKiByZXNvbHV0aW9uIGlzIFwibmVhcmVyXCIuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBtb3N0IHJlc29sdmVkIChuZWFyZXN0KSBmb3JtIG9mIHRoZSBvYmplY3RcbiAqL1xuXG4vLyBYWFggc2hvdWxkIHdlIHJlLWRvIHRoaXM/XG5RLm5lYXJlciA9IG5lYXJlcjtcbmZ1bmN0aW9uIG5lYXJlcih2YWx1ZSkge1xuICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XG4gICAgICAgIHZhciBpbnNwZWN0ZWQgPSB2YWx1ZS5pbnNwZWN0KCk7XG4gICAgICAgIGlmIChpbnNwZWN0ZWQuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNwZWN0ZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHByb21pc2UuXG4gKiBPdGhlcndpc2UgaXQgaXMgYSBmdWxmaWxsZWQgdmFsdWUuXG4gKi9cblEuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZnVuY3Rpb24gaXNQcm9taXNlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QucHJvbWlzZURpc3BhdGNoID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgdHlwZW9mIG9iamVjdC5pbnNwZWN0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5cblEuaXNQcm9taXNlQWxpa2UgPSBpc1Byb21pc2VBbGlrZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZUFsaWtlKG9iamVjdCkge1xuICAgIHJldHVybiBpc09iamVjdChvYmplY3QpICYmIHR5cGVvZiBvYmplY3QudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHBlbmRpbmcgcHJvbWlzZSwgbWVhbmluZyBub3RcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cbiAqL1xuUS5pc1BlbmRpbmcgPSBpc1BlbmRpbmc7XG5mdW5jdGlvbiBpc1BlbmRpbmcob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcInBlbmRpbmdcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgdmFsdWUgb3IgZnVsZmlsbGVkXG4gKiBwcm9taXNlLlxuICovXG5RLmlzRnVsZmlsbGVkID0gaXNGdWxmaWxsZWQ7XG5mdW5jdGlvbiBpc0Z1bGZpbGxlZChvYmplY3QpIHtcbiAgICByZXR1cm4gIWlzUHJvbWlzZShvYmplY3QpIHx8IG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwiZnVsZmlsbGVkXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzRnVsZmlsbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn07XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuUS5pc1JlamVjdGVkID0gaXNSZWplY3RlZDtcbmZ1bmN0aW9uIGlzUmVqZWN0ZWQob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzUHJvbWlzZShvYmplY3QpICYmIG9iamVjdC5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicmVqZWN0ZWRcIjtcbn07XG5cbi8vLy8gQkVHSU4gVU5IQU5ETEVEIFJFSkVDVElPTiBUUkFDS0lOR1xuXG4vLyBUaGlzIHByb21pc2UgbGlicmFyeSBjb25zdW1lcyBleGNlcHRpb25zIHRocm93biBpbiBoYW5kbGVycyBzbyB0aGV5IGNhbiBiZVxuLy8gaGFuZGxlZCBieSBhIHN1YnNlcXVlbnQgcHJvbWlzZS4gIFRoZSBleGNlcHRpb25zIGdldCBhZGRlZCB0byB0aGlzIGFycmF5IHdoZW5cbi8vIHRoZXkgYXJlIGNyZWF0ZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhleSBhcmUgaGFuZGxlZC4gIE5vdGUgdGhhdCBpbiBFUzYgb3Jcbi8vIHNoaW1tZWQgZW52aXJvbm1lbnRzLCB0aGlzIHdvdWxkIG5hdHVyYWxseSBiZSBhIGBTZXRgLlxudmFyIHVuaGFuZGxlZFJlYXNvbnMgPSBbXTtcbnZhciB1bmhhbmRsZWRSZWplY3Rpb25zID0gW107XG52YXIgdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zID0gdHJ1ZTtcblxuZnVuY3Rpb24gcmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCkge1xuICAgIHVuaGFuZGxlZFJlYXNvbnMubGVuZ3RoID0gMDtcbiAgICB1bmhhbmRsZWRSZWplY3Rpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tSZWplY3Rpb24ocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgaWYgKCF0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICBpZiAocmVhc29uICYmIHR5cGVvZiByZWFzb24uc3RhY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKHJlYXNvbi5zdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5wdXNoKFwiKG5vIHN0YWNrKSBcIiArIHJlYXNvbik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1bnRyYWNrUmVqZWN0aW9uKHByb21pc2UpIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0ID0gYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKTtcbiAgICBpZiAoYXQgIT09IC0xKSB7XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZhbHNlO1xufTtcblxucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG5cbi8vLy8gRU5EIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqIEBwYXJhbSByZWFzb24gdmFsdWUgZGVzY3JpYmluZyB0aGUgZmFpbHVyZVxuICovXG5RLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcmVqZWN0aW9uID0gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgZXJyb3IgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdW50cmFja1JlamVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkKHJlYXNvbikgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIHJlYXNvbiBoYXMgbm90IGJlZW4gaGFuZGxlZC5cbiAgICB0cmFja1JlamVjdGlvbihyZWplY3Rpb24sIHJlYXNvbik7XG5cbiAgICByZXR1cm4gcmVqZWN0aW9uO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBmdWxmaWxsZWQgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlXG4gKi9cblEuZnVsZmlsbCA9IGZ1bGZpbGw7XG5mdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcImdldFwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInNldFwiOiBmdW5jdGlvbiAobmFtZSwgcmhzKSB7XG4gICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHJocztcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3N0XCI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAvLyBNYXJrIE1pbGxlciBwcm9wb3NlcyB0aGF0IHBvc3Qgd2l0aCBubyBuYW1lIHNob3VsZCBhcHBseSBhXG4gICAgICAgICAgICAvLyBwcm9taXNlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBudWxsIHx8IG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImFwcGx5XCI6IGZ1bmN0aW9uICh0aGlzcCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXNwLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJrZXlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGVuYWJsZXMgdG8gUSBwcm9taXNlcy5cbiAqIEBwYXJhbSBwcm9taXNlIHRoZW5hYmxlIHByb21pc2VcbiAqIEByZXR1cm5zIGEgUSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShwcm9taXNlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0LCBkZWZlcnJlZC5ub3RpZnkpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbi8qKlxuICogQW5ub3RhdGVzIGFuIG9iamVjdCBzdWNoIHRoYXQgaXQgd2lsbCBuZXZlciBiZVxuICogdHJhbnNmZXJyZWQgYXdheSBmcm9tIHRoaXMgcHJvY2VzcyBvdmVyIGFueSBwcm9taXNlXG4gKiBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJucyBwcm9taXNlIGEgd3JhcHBpbmcgb2YgdGhhdCBvYmplY3QgdGhhdFxuICogYWRkaXRpb25hbGx5IHJlc3BvbmRzIHRvIHRoZSBcImlzRGVmXCIgbWVzc2FnZVxuICogd2l0aG91dCBhIHJlamVjdGlvbi5cbiAqL1xuUS5tYXN0ZXIgPSBtYXN0ZXI7XG5mdW5jdGlvbiBtYXN0ZXIob2JqZWN0KSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcImlzRGVmXCI6IGZ1bmN0aW9uICgpIHt9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2sob3AsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFEob2JqZWN0KS5pbnNwZWN0KCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3ByZWFkcyB0aGUgdmFsdWVzIG9mIGEgcHJvbWlzZWQgYXJyYXkgb2YgYXJndW1lbnRzIGludG8gdGhlXG4gKiBmdWxmaWxsbWVudCBjYWxsYmFjay5cbiAqIEBwYXJhbSBmdWxmaWxsZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB2YXJpYWRpYyBhcmd1bWVudHMgZnJvbSB0aGVcbiAqIHByb21pc2VkIGFycmF5XG4gKiBAcGFyYW0gcmVqZWN0ZWQgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUgZXhjZXB0aW9uIGlmIHRoZSBwcm9taXNlXG4gKiBpcyByZWplY3RlZC5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBvciB0aHJvd24gZXhjZXB0aW9uIG9mXG4gKiBlaXRoZXIgY2FsbGJhY2suXG4gKi9cblEuc3ByZWFkID0gc3ByZWFkO1xuZnVuY3Rpb24gc3ByZWFkKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnNwcmVhZChmdWxmaWxsZWQsIHJlamVjdGVkKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuc3ByZWFkID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5hbGwoKS50aGVuKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkLmFwcGx5KHZvaWQgMCwgYXJyYXkpO1xuICAgIH0sIHJlamVjdGVkKTtcbn07XG5cbi8qKlxuICogVGhlIGFzeW5jIGZ1bmN0aW9uIGlzIGEgZGVjb3JhdG9yIGZvciBnZW5lcmF0b3IgZnVuY3Rpb25zLCB0dXJuaW5nXG4gKiB0aGVtIGludG8gYXN5bmNocm9ub3VzIGdlbmVyYXRvcnMuICBBbHRob3VnaCBnZW5lcmF0b3JzIGFyZSBvbmx5IHBhcnRcbiAqIG9mIHRoZSBuZXdlc3QgRUNNQVNjcmlwdCA2IGRyYWZ0cywgdGhpcyBjb2RlIGRvZXMgbm90IGNhdXNlIHN5bnRheFxuICogZXJyb3JzIGluIG9sZGVyIGVuZ2luZXMuICBUaGlzIGNvZGUgc2hvdWxkIGNvbnRpbnVlIHRvIHdvcmsgYW5kIHdpbGxcbiAqIGluIGZhY3QgaW1wcm92ZSBvdmVyIHRpbWUgYXMgdGhlIGxhbmd1YWdlIGltcHJvdmVzLlxuICpcbiAqIEVTNiBnZW5lcmF0b3JzIGFyZSBjdXJyZW50bHkgcGFydCBvZiBWOCB2ZXJzaW9uIDMuMTkgd2l0aCB0aGVcbiAqIC0taGFybW9ueS1nZW5lcmF0b3JzIHJ1bnRpbWUgZmxhZyBlbmFibGVkLiAgU3BpZGVyTW9ua2V5IGhhcyBoYWQgdGhlbVxuICogZm9yIGxvbmdlciwgYnV0IHVuZGVyIGFuIG9sZGVyIFB5dGhvbi1pbnNwaXJlZCBmb3JtLiAgVGhpcyBmdW5jdGlvblxuICogd29ya3Mgb24gYm90aCBraW5kcyBvZiBnZW5lcmF0b3JzLlxuICpcbiAqIERlY29yYXRlcyBhIGdlbmVyYXRvciBmdW5jdGlvbiBzdWNoIHRoYXQ6XG4gKiAgLSBpdCBtYXkgeWllbGQgcHJvbWlzZXNcbiAqICAtIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHdoZW4gdGhhdCBwcm9taXNlIGlzIGZ1bGZpbGxlZFxuICogIC0gdGhlIHZhbHVlIG9mIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpbGwgYmUgdGhlIGZ1bGZpbGxlZCB2YWx1ZVxuICogIC0gaXQgcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgKHdoZW4gdGhlIGdlbmVyYXRvclxuICogICAgc3RvcHMgaXRlcmF0aW5nKVxuICogIC0gdGhlIGRlY29yYXRlZCBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICogICAgb2YgdGhlIGdlbmVyYXRvciBvciB0aGUgZmlyc3QgcmVqZWN0ZWQgcHJvbWlzZSBhbW9uZyB0aG9zZVxuICogICAgeWllbGRlZC5cbiAqICAtIGlmIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgZ2VuZXJhdG9yLCBpdCBwcm9wYWdhdGVzIHRocm91Z2hcbiAqICAgIGV2ZXJ5IGZvbGxvd2luZyB5aWVsZCB1bnRpbCBpdCBpcyBjYXVnaHQsIG9yIHVudGlsIGl0IGVzY2FwZXNcbiAqICAgIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24gYWx0b2dldGhlciwgYW5kIGlzIHRyYW5zbGF0ZWQgaW50byBhXG4gKiAgICByZWplY3Rpb24gZm9yIHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHRoZSBkZWNvcmF0ZWQgZ2VuZXJhdG9yLlxuICovXG5RLmFzeW5jID0gYXN5bmM7XG5mdW5jdGlvbiBhc3luYyhtYWtlR2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gd2hlbiB2ZXJiIGlzIFwic2VuZFwiLCBhcmcgaXMgYSB2YWx1ZVxuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJ0aHJvd1wiLCBhcmcgaXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRpbnVlcih2ZXJiLCBhcmcpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8vIFVudGlsIFY4IDMuMTkgLyBDaHJvbWl1bSAyOSBpcyByZWxlYXNlZCwgU3BpZGVyTW9ua2V5IGlzIHRoZSBvbmx5XG4gICAgICAgICAgICAvLyBlbmdpbmUgdGhhdCBoYXMgYSBkZXBsb3llZCBiYXNlIG9mIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgU00ncyBnZW5lcmF0b3JzIHVzZSB0aGUgUHl0aG9uLWluc3BpcmVkIHNlbWFudGljcyBvZlxuICAgICAgICAgICAgLy8gb3V0ZGF0ZWQgRVM2IGRyYWZ0cy4gIFdlIHdvdWxkIGxpa2UgdG8gc3VwcG9ydCBFUzYsIGJ1dCB3ZSdkIGFsc29cbiAgICAgICAgICAgIC8vIGxpa2UgdG8gbWFrZSBpdCBwb3NzaWJsZSB0byB1c2UgZ2VuZXJhdG9ycyBpbiBkZXBsb3llZCBicm93c2Vycywgc29cbiAgICAgICAgICAgIC8vIHdlIGFsc28gc3VwcG9ydCBQeXRob24tc3R5bGUgZ2VuZXJhdG9ycy4gIEF0IHNvbWUgcG9pbnQgd2UgY2FuIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhpcyBibG9jay5cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTdG9wSXRlcmF0aW9uID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRVM2IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZW5lcmF0b3JbdmVyYl0oYXJnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQudmFsdWUsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNwaWRlck1vbmtleSBHZW5lcmF0b3JzXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFJlbW92ZSB0aGlzIGNhc2Ugd2hlbiBTTSBkb2VzIEVTNiBnZW5lcmF0b3JzLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdG9wSXRlcmF0aW9uKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleGNlcHRpb24udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW4ocmVzdWx0LCBjYWxsYmFjaywgZXJyYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IG1ha2VHZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcIm5leHRcIik7XG4gICAgICAgIHZhciBlcnJiYWNrID0gY29udGludWVyLmJpbmQoY29udGludWVyLCBcInRocm93XCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBzcGF3biBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIGFzeW5jIHRoYXQgaW1tZWRpYXRlbHlcbiAqIGNhbGxzIHRoZSBnZW5lcmF0b3IgYW5kIGFsc28gZW5kcyB0aGUgcHJvbWlzZSBjaGFpbiwgc28gdGhhdCBhbnlcbiAqIHVuaGFuZGxlZCBlcnJvcnMgYXJlIHRocm93biBpbnN0ZWFkIG9mIGZvcndhcmRlZCB0byB0aGUgZXJyb3JcbiAqIGhhbmRsZXIuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2UgaXQncyBleHRyZW1lbHkgY29tbW9uIHRvIHJ1blxuICogZ2VuZXJhdG9ycyBhdCB0aGUgdG9wLWxldmVsIHRvIHdvcmsgd2l0aCBsaWJyYXJpZXMuXG4gKi9cblEuc3Bhd24gPSBzcGF3bjtcbmZ1bmN0aW9uIHNwYXduKG1ha2VHZW5lcmF0b3IpIHtcbiAgICBRLmRvbmUoUS5hc3luYyhtYWtlR2VuZXJhdG9yKSgpKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGludGVyZmFjZSBvbmNlIEVTNiBnZW5lcmF0b3JzIGFyZSBpbiBTcGlkZXJNb25rZXkuXG4vKipcbiAqIFRocm93cyBhIFJldHVyblZhbHVlIGV4Y2VwdGlvbiB0byBzdG9wIGFuIGFzeW5jaHJvbm91cyBnZW5lcmF0b3IuXG4gKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgYSBzdG9wLWdhcCBtZWFzdXJlIHRvIHN1cHBvcnQgZ2VuZXJhdG9yIHJldHVyblxuICogdmFsdWVzIGluIG9sZGVyIEZpcmVmb3gvU3BpZGVyTW9ua2V5LiAgSW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEVTNlxuICogZ2VuZXJhdG9ycyBsaWtlIENocm9taXVtIDI5LCBqdXN0IHVzZSBcInJldHVyblwiIGluIHlvdXIgZ2VuZXJhdG9yXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHZhbHVlIHRoZSByZXR1cm4gdmFsdWUgZm9yIHRoZSBzdXJyb3VuZGluZyBnZW5lcmF0b3JcbiAqIEB0aHJvd3MgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHdpdGggdGhlIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqIC8vIEVTNiBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiogKCkge1xuICogICAgICB2YXIgZm9vID0geWllbGQgZ2V0Rm9vUHJvbWlzZSgpO1xuICogICAgICB2YXIgYmFyID0geWllbGQgZ2V0QmFyUHJvbWlzZSgpO1xuICogICAgICByZXR1cm4gZm9vICsgYmFyO1xuICogfSlcbiAqIC8vIE9sZGVyIFNwaWRlck1vbmtleSBzdHlsZVxuICogUS5hc3luYyhmdW5jdGlvbiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIFEucmV0dXJuKGZvbyArIGJhcik7XG4gKiB9KVxuICovXG5RW1wicmV0dXJuXCJdID0gX3JldHVybjtcbmZ1bmN0aW9uIF9yZXR1cm4odmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgUVJldHVyblZhbHVlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgcHJvbWlzZWQgZnVuY3Rpb24gZGVjb3JhdG9yIGVuc3VyZXMgdGhhdCBhbnkgcHJvbWlzZSBhcmd1bWVudHNcbiAqIGFyZSBzZXR0bGVkIGFuZCBwYXNzZWQgYXMgdmFsdWVzIChgdGhpc2AgaXMgYWxzbyBzZXR0bGVkIGFuZCBwYXNzZWRcbiAqIGFzIGEgdmFsdWUpLiAgSXQgd2lsbCBhbHNvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHQgb2YgYSBmdW5jdGlvbiBpc1xuICogYWx3YXlzIGEgcHJvbWlzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGFkZCA9IFEucHJvbWlzZWQoZnVuY3Rpb24gKGEsIGIpIHtcbiAqICAgICByZXR1cm4gYSArIGI7XG4gKiB9KTtcbiAqIGFkZChRKGEpLCBRKEIpKTtcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gZGVjb3JhdGVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGhhcyBiZWVuIGRlY29yYXRlZC5cbiAqL1xuUS5wcm9taXNlZCA9IHByb21pc2VkO1xuZnVuY3Rpb24gcHJvbWlzZWQoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc3ByZWFkKFt0aGlzLCBhbGwoYXJndW1lbnRzKV0sIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbi8qKlxuICogc2VuZHMgYSBtZXNzYWdlIHRvIGEgdmFsdWUgaW4gYSBmdXR1cmUgdHVyblxuICogQHBhcmFtIG9iamVjdCogdGhlIHJlY2lwaWVudFxuICogQHBhcmFtIG9wIHRoZSBuYW1lIG9mIHRoZSBtZXNzYWdlIG9wZXJhdGlvbiwgZS5nLiwgXCJ3aGVuXCIsXG4gKiBAcGFyYW0gYXJncyBmdXJ0aGVyIGFyZ3VtZW50cyB0byBiZSBmb3J3YXJkZWQgdG8gdGhlIG9wZXJhdGlvblxuICogQHJldHVybnMgcmVzdWx0IHtQcm9taXNlfSBhIHByb21pc2UgZm9yIHRoZSByZXN1bHQgb2YgdGhlIG9wZXJhdGlvblxuICovXG5RLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5mdW5jdGlvbiBkaXNwYXRjaChvYmplY3QsIG9wLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChvcCwgYXJncyk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKG9wLCBhcmdzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChkZWZlcnJlZC5yZXNvbHZlLCBvcCwgYXJncyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZ2V0XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICovXG5RLmdldCA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJnZXRcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIG9iamVjdCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB2YWx1ZSAgICAgbmV3IHZhbHVlIG9mIHByb3BlcnR5XG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInNldFwiLCBba2V5LCB2YWx1ZV0pO1xufTtcblxuLyoqXG4gKiBEZWxldGVzIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gZGVsZXRlXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5kZWwgPSAvLyBYWFggbGVnYWN5XG5RW1wiZGVsZXRlXCJdID0gZnVuY3Rpb24gKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWwgPSAvLyBYWFggbGVnYWN5XG5Qcm9taXNlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIEludm9rZXMgYSBtZXRob2QgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgbWV0aG9kIHRvIGludm9rZVxuICogQHBhcmFtIHZhbHVlICAgICBhIHZhbHVlIHRvIHBvc3QsIHR5cGljYWxseSBhbiBhcnJheSBvZlxuICogICAgICAgICAgICAgICAgICBpbnZvY2F0aW9uIGFyZ3VtZW50cyBmb3IgcHJvbWlzZXMgdGhhdFxuICogICAgICAgICAgICAgICAgICBhcmUgdWx0aW1hdGVseSBiYWNrZWQgd2l0aCBgcmVzb2x2ZWAgdmFsdWVzLFxuICogICAgICAgICAgICAgICAgICBhcyBvcHBvc2VkIHRvIHRob3NlIGJhY2tlZCB3aXRoIFVSTHNcbiAqICAgICAgICAgICAgICAgICAgd2hlcmVpbiB0aGUgcG9zdGVkIHZhbHVlIGNhbiBiZSBhbnlcbiAqICAgICAgICAgICAgICAgICAgSlNPTiBzZXJpYWxpemFibGUgb2JqZWN0LlxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cbi8vIGJvdW5kIGxvY2FsbHkgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IG90aGVyIG1ldGhvZHNcblEubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblEucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgaW52b2NhdGlvbiBhcmd1bWVudHNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG5RLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAyKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuc2VuZCA9IC8vIFhYWCBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIHBhcmxhbmNlXG5Qcm9taXNlLnByb3RvdHlwZS5tY2FsbCA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIGFyZ3MgICAgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYXBwbHkgPSBmdW5jdGlvbiAob2JqZWN0LCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUVtcInRyeVwiXSA9XG5RLmZjYWxsID0gZnVuY3Rpb24gKG9iamVjdCAvKiAuLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmNhbGwgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cyldKTtcbn07XG5cbi8qKlxuICogQmluZHMgdGhlIHByb21pc2VkIGZ1bmN0aW9uLCB0cmFuc2Zvcm1pbmcgcmV0dXJuIHZhbHVlcyBpbnRvIGEgZnVsZmlsbGVkXG4gKiBwcm9taXNlIGFuZCB0aHJvd24gZXJyb3JzIGludG8gYSByZWplY3RlZCBvbmUuXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IGZ1bmN0aW9uXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGFwcGxpY2F0aW9uIGFyZ3VtZW50c1xuICovXG5RLmZiaW5kID0gZnVuY3Rpb24gKG9iamVjdCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gUShvYmplY3QpO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblByb21pc2UucHJvdG90eXBlLmZiaW5kID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIHByb21pc2UgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gZmJvdW5kKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZS5kaXNwYXRjaChcImFwcGx5XCIsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKVxuICAgICAgICBdKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0cyB0aGUgbmFtZXMgb2YgdGhlIG93bmVkIHByb3BlcnRpZXMgb2YgYSBwcm9taXNlZFxuICogb2JqZWN0IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUga2V5cyBvZiB0aGUgZXZlbnR1YWxseSBzZXR0bGVkIG9iamVjdFxuICovXG5RLmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImtleXNcIiwgW10pO1xufTtcblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkuICBJZiBhbnkgb2ZcbiAqIHRoZSBwcm9taXNlcyBnZXRzIHJlamVjdGVkLCB0aGUgd2hvbGUgYXJyYXkgaXMgcmVqZWN0ZWQgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FycmF5Kn0gYW4gYXJyYXkgKG9yIHByb21pc2UgZm9yIGFuIGFycmF5KSBvZiB2YWx1ZXMgKG9yXG4gKiBwcm9taXNlcyBmb3IgdmFsdWVzKVxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAqL1xuLy8gQnkgTWFyayBNaWxsZXJcbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPXN0cmF3bWFuOmNvbmN1cnJlbmN5JnJldj0xMzA4Nzc2NTIxI2FsbGZ1bGZpbGxlZFxuUS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gd2hlbihwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2VzKSB7XG4gICAgICAgIHZhciBjb3VudERvd24gPSAwO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBhcnJheV9yZWR1Y2UocHJvbWlzZXMsIGZ1bmN0aW9uICh1bmRlZmluZWQsIHByb21pc2UsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgc25hcHNob3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaXNQcm9taXNlKHByb21pc2UpICYmXG4gICAgICAgICAgICAgICAgKHNuYXBzaG90ID0gcHJvbWlzZS5pbnNwZWN0KCkpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSBzbmFwc2hvdC52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytjb3VudERvd247XG4gICAgICAgICAgICAgICAgd2hlbihcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgtLWNvdW50RG93biA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocHJvbWlzZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHsgaW5kZXg6IGluZGV4LCB2YWx1ZTogcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB2b2lkIDApO1xuICAgICAgICBpZiAoY291bnREb3duID09PSAwKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9KTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgdG8gYmUgc2V0dGxlZCwgZWl0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuICBUaGlzIGlzIGRpc3RpbmN0IGZyb20gYGFsbGAgc2luY2UgdGhhdCB3b3VsZCBzdG9wXG4gKiB3YWl0aW5nIGF0IHRoZSBmaXJzdCByZWplY3Rpb24uICBUaGUgcHJvbWlzZSByZXR1cm5lZCBieVxuICogYGFsbFJlc29sdmVkYCB3aWxsIG5ldmVyIGJlIHJlamVjdGVkLlxuICogQHBhcmFtIHByb21pc2VzIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgKG9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuICogKG9yIHZhbHVlcylcbiAqIEByZXR1cm4gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBwcm9taXNlc1xuICovXG5RLmFsbFJlc29sdmVkID0gZGVwcmVjYXRlKGFsbFJlc29sdmVkLCBcImFsbFJlc29sdmVkXCIsIFwiYWxsU2V0dGxlZFwiKTtcbmZ1bmN0aW9uIGFsbFJlc29sdmVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICBwcm9taXNlcyA9IGFycmF5X21hcChwcm9taXNlcywgUSk7XG4gICAgICAgIHJldHVybiB3aGVuKGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBub29wLCBub29wKTtcbiAgICAgICAgfSkpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsUmVzb2x2ZWQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBzZWUgUHJvbWlzZSNhbGxTZXR0bGVkXG4gKi9cblEuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG5mdW5jdGlvbiBhbGxTZXR0bGVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZXMpLmFsbFNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlaXIgc3RhdGVzIChhc1xuICogcmV0dXJuZWQgYnkgYGluc3BlY3RgKSB3aGVuIHRoZXkgaGF2ZSBhbGwgc2V0dGxlZC5cbiAqIEBwYXJhbSB7QXJyYXlbQW55Kl19IHZhbHVlcyBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyB7QXJyYXlbU3RhdGVdfSBhbiBhcnJheSBvZiBzdGF0ZXMgZm9yIHRoZSByZXNwZWN0aXZlIHZhbHVlcy5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYWxsU2V0dGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBRKHByb21pc2UpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnYXJkbGVzcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlZ2FyZGxlc3MsIHJlZ2FyZGxlc3MpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBmYWlsdXJlIG9mIGEgcHJvbWlzZSwgZ2l2aW5nIGFuIG9wb3J0dW5pdHkgdG8gcmVjb3ZlclxuICogd2l0aCBhIGNhbGxiYWNrLiAgSWYgdGhlIGdpdmVuIHByb21pc2UgaXMgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAqIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGZ1bGZpbGwgdGhlIHJldHVybmVkIHByb21pc2UgaWYgdGhlXG4gKiBnaXZlbiBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrXG4gKi9cblEuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGxpc3RlbmVyIHRoYXQgY2FuIHJlc3BvbmQgdG8gcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBmcm9tIGFcbiAqIHByb21pc2UncyBvcmlnaW5hdGluZyBkZWZlcnJlZC4gVGhpcyBsaXN0ZW5lciByZWNlaXZlcyB0aGUgZXhhY3QgYXJndW1lbnRzXG4gKiBwYXNzZWQgdG8gYGBkZWZlcnJlZC5ub3RpZnlgYC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byByZWNlaXZlIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJucyB0aGUgZ2l2ZW4gcHJvbWlzZSwgdW5jaGFuZ2VkXG4gKi9cblEucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmZ1bmN0aW9uIHByb2dyZXNzKG9iamVjdCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gb2JzZXJ2ZSB0aGUgc2V0dGxpbmcgb2YgYSBwcm9taXNlLFxuICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIEZvcndhcmRzXG4gKiB0aGUgcmVzb2x1dGlvbiB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aGVuIHRoZSBjYWxsYmFjayBpcyBkb25lLlxuICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBwcm9taXNlIHRvIGRlZmVyIGNvbXBsZXRpb24uXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIG9ic2VydmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuXG4gKiBwcm9taXNlLCB0YWtlcyBubyBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIHdoZW5cbiAqIGBgZmluYGAgaXMgZG9uZS5cbiAqL1xuUS5maW4gPSAvLyBYWFggbGVnYWN5XG5RW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KVtcImZpbmFsbHlcIl0oY2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmluID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBUT0RPIGF0dGVtcHQgdG8gcmVjeWNsZSB0aGUgcmVqZWN0aW9uIHdpdGggXCJ0aGlzXCIuXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGVybWluYXRlcyBhIGNoYWluIG9mIHByb21pc2VzLCBmb3JjaW5nIHJlamVjdGlvbnMgdG8gYmVcbiAqIHRocm93biBhcyBleGNlcHRpb25zLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGF0IHRoZSBlbmQgb2YgYSBjaGFpbiBvZiBwcm9taXNlc1xuICogQHJldHVybnMgbm90aGluZ1xuICovXG5RLmRvbmUgPSBmdW5jdGlvbiAob2JqZWN0LCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZG9uZShmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIHByb2dyZXNzKSB7XG4gICAgdmFyIG9uVW5oYW5kbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gZm9yd2FyZCB0byBhIGZ1dHVyZSB0dXJuIHNvIHRoYXQgYGB3aGVuYGBcbiAgICAgICAgLy8gZG9lcyBub3QgY2F0Y2ggaXQgYW5kIHR1cm4gaXQgaW50byBhIHJlamVjdGlvbi5cbiAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IGBuZXh0VGlja2BpbmcgdmlhIGFuIHVubmVjZXNzYXJ5IGB3aGVuYC5cbiAgICB2YXIgcHJvbWlzZSA9IGZ1bGZpbGxlZCB8fCByZWplY3RlZCB8fCBwcm9ncmVzcyA/XG4gICAgICAgIHRoaXMudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykgOlxuICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvciA9IHByb2Nlc3MuZG9tYWluLmJpbmQob25VbmhhbmRsZWRFcnJvcik7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHZvaWQgMCwgb25VbmhhbmRsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjdXN0b20gZXJyb3IgbWVzc2FnZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIGlmIGl0IGlzXG4gKiBmdWxmaWxsZWQgYmVmb3JlIHRoZSB0aW1lb3V0LCBvdGhlcndpc2UgcmVqZWN0ZWQuXG4gKi9cblEudGltZW91dCA9IGZ1bmN0aW9uIChvYmplY3QsIG1zLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBtZXNzYWdlKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMsIG1lc3NhZ2UpIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHZhciB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihtZXNzYWdlIHx8IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgbXMgKyBcIiBtc1wiKSk7XG4gICAgfSwgbXMpO1xuXG4gICAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfSwgZGVmZXJyZWQubm90aWZ5KTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGdpdmVuIHZhbHVlIChvciBwcm9taXNlZCB2YWx1ZSksIHNvbWVcbiAqIG1pbGxpc2Vjb25kcyBhZnRlciBpdCByZXNvbHZlZC4gUGFzc2VzIHJlamVjdGlvbnMgaW1tZWRpYXRlbHkuXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgYWZ0ZXIgbWlsbGlzZWNvbmRzXG4gKiB0aW1lIGhhcyBlbGFwc2VkIHNpbmNlIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlLlxuICogSWYgdGhlIGdpdmVuIHByb21pc2UgcmVqZWN0cywgdGhhdCBpcyBwYXNzZWQgaW1tZWRpYXRlbHkuXG4gKi9cblEuZGVsYXkgPSBmdW5jdGlvbiAob2JqZWN0LCB0aW1lb3V0KSB7XG4gICAgaWYgKHRpbWVvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lb3V0ID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBRKG9iamVjdCkuZGVsYXkodGltZW91dCk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5kZWxheSA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBQYXNzZXMgYSBjb250aW51YXRpb24gdG8gYSBOb2RlIGZ1bmN0aW9uLCB3aGljaCBpcyBjYWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAqIGFyZ3VtZW50cyBwcm92aWRlZCBhcyBhbiBhcnJheSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICpcbiAqICAgICAgUS5uZmFwcGx5KEZTLnJlYWRGaWxlLCBbX19maWxlbmFtZV0pXG4gKiAgICAgIC50aGVuKGZ1bmN0aW9uIChjb250ZW50KSB7XG4gKiAgICAgIH0pXG4gKlxuICovXG5RLm5mYXBwbHkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZ3MpIHtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZmFwcGx5KG5vZGVBcmdzKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGluZGl2aWR1YWxseSwgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZjYWxsKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKVxuICogLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqIH0pXG4gKlxuICovXG5RLm5mY2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gUShjYWxsYmFjaykubmZhcHBseShhcmdzKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mY2FsbCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogV3JhcHMgYSBOb2RlSlMgY29udGludWF0aW9uIHBhc3NpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudFxuICogdmVyc2lvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICogQGV4YW1wbGVcbiAqIFEubmZiaW5kKEZTLnJlYWRGaWxlLCBfX2ZpbGVuYW1lKShcInV0Zi04XCIpXG4gKiAudGhlbihjb25zb2xlLmxvZylcbiAqIC5kb25lKClcbiAqL1xuUS5uZmJpbmQgPVxuUS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2sgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBRKGNhbGxiYWNrKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5mYmluZCA9XG5Qcm9taXNlLnByb3RvdHlwZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIHJldHVybiBRLmRlbm9kZWlmeS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuUS5uYmluZCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgdGhpc3AgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgYmFzZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlQXJncyA9IGJhc2VBcmdzLmNvbmNhdChhcnJheV9zbGljZShhcmd1bWVudHMpKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgICAgICBmdW5jdGlvbiBib3VuZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzcCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBRKGJvdW5kKS5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm5iaW5kID0gZnVuY3Rpb24gKC8qdGhpc3AsIC4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEubmJpbmQuYXBwbHkodm9pZCAwLCBhcmdzKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgYSBtZXRob2Qgb2YgYSBOb2RlLXN0eWxlIG9iamVjdCB0aGF0IGFjY2VwdHMgYSBOb2RlLXN0eWxlXG4gKiBjYWxsYmFjayB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYXJndW1lbnRzLCBwbHVzIGEgcHJvdmlkZWQgY2FsbGJhY2suXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFja1xuICogd2lsbCBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5tYXBwbHkgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5ucG9zdCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5wb3N0KG5hbWUsIGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5ucG9zdCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJncyB8fCBbXSk7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrLCBmb3J3YXJkaW5nIHRoZSBnaXZlbiB2YXJpYWRpYyBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZFxuICogY2FsbGJhY2sgYXJndW1lbnQuXG4gKiBAcGFyYW0gb2JqZWN0IGFuIG9iamVjdCB0aGF0IGhhcyB0aGUgbmFtZWQgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBtZXRob2Qgb2Ygb2JqZWN0XG4gKiBAcGFyYW0gLi4uYXJncyBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbWV0aG9kOyB0aGUgY2FsbGJhY2sgd2lsbFxuICogYmUgcHJvdmlkZWQgYnkgUSBhbmQgYXBwZW5kZWQgdG8gdGhlc2UgYXJndW1lbnRzLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgdmFsdWUgb3IgZXJyb3JcbiAqL1xuUS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5RLm5tY2FsbCA9IC8vIFhYWCBCYXNlZCBvbiBcIlJlZHNhbmRybydzXCIgcHJvcG9zYWxcblEubmludm9rZSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDIpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIG5vZGVBcmdzXSkuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubnNlbmQgPSAvLyBYWFggQmFzZWQgb24gTWFyayBNaWxsZXIncyBwcm9wb3NlZCBcInNlbmRcIlxuUHJvbWlzZS5wcm90b3R5cGUubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUHJvbWlzZS5wcm90b3R5cGUubmludm9rZSA9IGZ1bmN0aW9uIChuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIElmIGEgZnVuY3Rpb24gd291bGQgbGlrZSB0byBzdXBwb3J0IGJvdGggTm9kZSBjb250aW51YXRpb24tcGFzc2luZy1zdHlsZSBhbmRcbiAqIHByb21pc2UtcmV0dXJuaW5nLXN0eWxlLCBpdCBjYW4gZW5kIGl0cyBpbnRlcm5hbCBwcm9taXNlIGNoYWluIHdpdGhcbiAqIGBub2RlaWZ5KG5vZGViYWNrKWAsIGZvcndhcmRpbmcgdGhlIG9wdGlvbmFsIG5vZGViYWNrIGFyZ3VtZW50LiAgSWYgdGhlIHVzZXJcbiAqIGVsZWN0cyB0byB1c2UgYSBub2RlYmFjaywgdGhlIHJlc3VsdCB3aWxsIGJlIHNlbnQgdGhlcmUuICBJZiB0aGV5IGRvIG5vdFxuICogcGFzcyBhIG5vZGViYWNrLCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGUgcmVzdWx0IHByb21pc2UuXG4gKiBAcGFyYW0gb2JqZWN0IGEgcmVzdWx0IChvciBhIHByb21pc2UgZm9yIGEgcmVzdWx0KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbm9kZWJhY2sgYSBOb2RlLmpzLXN0eWxlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyBlaXRoZXIgdGhlIHByb21pc2Ugb3Igbm90aGluZ1xuICovXG5RLm5vZGVpZnkgPSBub2RlaWZ5O1xuZnVuY3Rpb24gbm9kZWlmeShvYmplY3QsIG5vZGViYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5ub2RlaWZ5KG5vZGViYWNrKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChub2RlYmFjaykge1xuICAgIGlmIChub2RlYmFjaykge1xuICAgICAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbm9kZWJhY2sobnVsbCwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG4vLyBBbGwgY29kZSBiZWZvcmUgdGhpcyBwb2ludCB3aWxsIGJlIGZpbHRlcmVkIGZyb20gc3RhY2sgdHJhY2VzLlxudmFyIHFFbmRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcblxucmV0dXJuIFE7XG5cbn0pO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIFRoaXMgaXMgYW4gaW4tbWVtb3J5IGNhY2hlIGZvciBtb2RlbHMuIE1vZGVscyBhcmUgY2FjaGVkIGJ5IGxvY2FsIGlkIChfaWQpIGFuZCByZW1vdGUgaWQgKGRlZmluZWQgYnkgdGhlIG1hcHBpbmcpLlxuICogTG9va3VwcyBhcmUgcGVyZm9ybWVkIGFnYWluc3QgdGhlIGNhY2hlIHdoZW4gbWFwcGluZy5cbiAqIEBtb2R1bGUgY2FjaGVcbiAqL1xudmFyIGxvZyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9sb2cnKTtcbnZhciBMb2NhbENhY2hlTG9nZ2VyID0gbG9nLmxvZ2dlcldpdGhOYW1lKCdMb2NhbENhY2hlJyk7XG5Mb2NhbENhY2hlTG9nZ2VyLnNldExldmVsKGxvZy5MZXZlbC53YXJuKTtcbnZhciBSZW1vdGVDYWNoZUxvZ2dlciA9IGxvZy5sb2dnZXJXaXRoTmFtZSgnUmVtb3RlQ2FjaGUnKTtcblJlbW90ZUNhY2hlTG9nZ2VyLnNldExldmVsKGxvZy5MZXZlbC53YXJuKTtcbnZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5cbnZhciBsb2NhbENhY2hlQnlJZCA9IHt9O1xudmFyIGxvY2FsQ2FjaGUgPSB7fTtcblxuXG52YXIgcmVtb3RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgcmVtb3RlQ2FjaGUgPSB7fTtcbiAgICBsb2NhbENhY2hlQnlJZCA9IHt9O1xuICAgIGxvY2FsQ2FjaGUgPSB7fTtcbn1cblxucmVzZXQoKTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG9iamVjdCBpbiB0aGUgY2FjaGUgZ2l2ZW4gYSBsb2NhbCBpZCAoX2lkKVxuICogQHBhcmFtICB7U3RyaW5nfSBsb2NhbElkXG4gKiBAcmV0dXJuIHtTaWVzdGFNb2RlbH1cbiAqL1xuZnVuY3Rpb24gZ2V0VmlhTG9jYWxJZChsb2NhbElkKSB7XG4gICAgdmFyIG9iaiA9IGxvY2FsQ2FjaGVCeUlkW2xvY2FsSWRdO1xuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKExvY2FsQ2FjaGVMb2dnZXIuZGVidWcuaXNFbmFibGVkKVxuICAgICAgICAgICAgTG9jYWxDYWNoZUxvZ2dlci5kZWJ1ZygnTG9jYWwgY2FjaGUgaGl0OiAnICsgb2JqLl9kdW1wKHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoTG9jYWxDYWNoZUxvZ2dlci5kZWJ1Zy5pc0VuYWJsZWQpXG4gICAgICAgICAgICBMb2NhbENhY2hlTG9nZ2VyLmRlYnVnKCdMb2NhbCBjYWNoZSBtaXNzOiAnICsgbG9jYWxJZCk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzaW5nbGV0b24gb2JqZWN0IGdpdmVuIGEgc2luZ2xldG9uIG1hcHBpbmcuXG4gKiBAcGFyYW0gIHtNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtTaWVzdGFNb2RlbH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2luZ2xldG9uKG1hcHBpbmcpIHtcbiAgICB2YXIgbWFwcGluZ05hbWUgPSBtYXBwaW5nLnR5cGU7XG4gICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gbWFwcGluZy5jb2xsZWN0aW9uO1xuICAgIHZhciBjb2xsZWN0aW9uQ2FjaGUgPSBsb2NhbENhY2hlW2NvbGxlY3Rpb25OYW1lXTtcbiAgICBpZiAoY29sbGVjdGlvbkNhY2hlKSB7XG4gICAgICAgIHZhciB0eXBlQ2FjaGUgPSBjb2xsZWN0aW9uQ2FjaGVbbWFwcGluZ05hbWVdO1xuICAgICAgICBpZiAodHlwZUNhY2hlKSB7XG4gICAgICAgICAgICB2YXIgb2JqcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0eXBlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUNhY2hlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ianMucHVzaCh0eXBlQ2FjaGVbcHJvcF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmpzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignQSBzaW5nbGV0b24gbWFwcGluZyBoYXMgbW9yZSB0aGFuIDEgb2JqZWN0IGluIHRoZSBjYWNoZSEgVGhpcyBpcyBhIHNlcmlvdXMgZXJyb3IuICcgK1xuICAgICAgICAgICAgICAgICAgICAnRWl0aGVyIGEgbWFwcGluZyBoYXMgYmVlbiBtb2RpZmllZCBhZnRlciBvYmplY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWQsIG9yIHNvbWV0aGluZyBoYXMgZ29uZScgK1xuICAgICAgICAgICAgICAgICAgICAndmVyeSB3cm9uZy4gUGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0IGlmIHRoZSBsYXR0ZXIuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ianNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSByZW1vdGUgaWRlbnRpZmllciBhbmQgYW4gb3B0aW9ucyBvYmplY3QgdGhhdCBkZXNjcmliZXMgbWFwcGluZy9jb2xsZWN0aW9uLFxuICogcmV0dXJuIHRoZSBtb2RlbCBpZiBjYWNoZWQuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHJlbW90ZUlkXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHNcbiAqIEByZXR1cm4ge1NpZXN0YU1vZGVsfVxuICovXG5mdW5jdGlvbiBnZXRWaWFSZW1vdGVJZChyZW1vdGVJZCwgb3B0cykge1xuICAgIHZhciB0eXBlID0gb3B0cy5tYXBwaW5nLnR5cGU7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBvcHRzLm1hcHBpbmcuY29sbGVjdGlvbjtcbiAgICB2YXIgY29sbGVjdGlvbkNhY2hlID0gcmVtb3RlQ2FjaGVbY29sbGVjdGlvbl07XG4gICAgaWYgKGNvbGxlY3Rpb25DYWNoZSkge1xuICAgICAgICB2YXIgdHlwZUNhY2hlID0gcmVtb3RlQ2FjaGVbY29sbGVjdGlvbl1bdHlwZV07XG4gICAgICAgIGlmICh0eXBlQ2FjaGUpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSB0eXBlQ2FjaGVbcmVtb3RlSWRdO1xuICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChSZW1vdGVDYWNoZUxvZ2dlci5kZWJ1Zy5pc0VuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIFJlbW90ZUNhY2hlTG9nZ2VyLmRlYnVnKCdSZW1vdGUgY2FjaGUgaGl0OiAnICsgb2JqLl9kdW1wKHRydWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKFJlbW90ZUNhY2hlTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgUmVtb3RlQ2FjaGVMb2dnZXIuZGVidWcoJ1JlbW90ZSBjYWNoZSBtaXNzOiAnICsgcmVtb3RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoUmVtb3RlQ2FjaGVMb2dnZXIuZGVidWcuaXNFbmFibGVkKVxuICAgICAgICBSZW1vdGVDYWNoZUxvZ2dlci5kZWJ1ZygnUmVtb3RlIGNhY2hlIG1pc3M6ICcgKyByZW1vdGVJZCk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogSW5zZXJ0IGFuIG9iamV0IGludG8gdGhlIGNhY2hlIHVzaW5nIGEgcmVtb3RlIGlkZW50aWZpZXIgZGVmaW5lZCBieSB0aGUgbWFwcGluZy5cbiAqIEBwYXJhbSAge1NpZXN0YU1vZGVsfSBvYmpcbiAqIEBwYXJhbSAge1N0cmluZ30gcmVtb3RlSWRcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJldmlvdXNSZW1vdGVJZCBJZiByZW1vdGUgaWQgaGFzIGJlZW4gY2hhbmdlZCwgdGhpcyBpcyB0aGUgb2xkIHJlbW90ZSBpZGVudGlmaWVyXG4gKi9cbmZ1bmN0aW9uIHJlbW90ZUluc2VydChvYmosIHJlbW90ZUlkLCBwcmV2aW91c1JlbW90ZUlkKSB7XG4gICAgaWYgKG9iaikge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG9iai5tYXBwaW5nLmNvbGxlY3Rpb247XG4gICAgICAgIGlmIChjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXJlbW90ZUNhY2hlW2NvbGxlY3Rpb25dKSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2FjaGVbY29sbGVjdGlvbl0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlID0gb2JqLm1hcHBpbmcudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdGVDYWNoZVtjb2xsZWN0aW9uXVt0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVDYWNoZVtjb2xsZWN0aW9uXVt0eXBlXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNSZW1vdGVJZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdGVDYWNoZVtjb2xsZWN0aW9uXVt0eXBlXVtwcmV2aW91c1JlbW90ZUlkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYWNoZWRPYmplY3QgPSByZW1vdGVDYWNoZVtjb2xsZWN0aW9uXVt0eXBlXVtyZW1vdGVJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlQ2FjaGVbY29sbGVjdGlvbl1bdHlwZV1bcmVtb3RlSWRdID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUmVtb3RlQ2FjaGVMb2dnZXIuZGVidWcuaXNFbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgUmVtb3RlQ2FjaGVMb2dnZXIuZGVidWcoJ1JlbW90ZSBjYWNoZSBpbnNlcnQ6ICcgKyBvYmouX2R1bXAodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoUmVtb3RlQ2FjaGVMb2dnZXIudHJhY2UuaXNFbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgUmVtb3RlQ2FjaGVMb2dnZXIudHJhY2UoJ1JlbW90ZSBjYWNoZSBub3cgbG9va3MgbGlrZTogJyArIHJlbW90ZUR1bXAodHJ1ZSkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIGhhcyBnb25lIHJlYWxseSB3cm9uZy4gT25seSBvbmUgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXIgY29sbGVjdGlvbi90eXBlL3JlbW90ZWlkIGNvbWJvXG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBldmVyIGV4aXN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqICE9IGNhY2hlZE9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnT2JqZWN0ICcgKyBjb2xsZWN0aW9uLnRvU3RyaW5nKCkgKyAnOicgKyB0eXBlLnRvU3RyaW5nKCkgKyAnWycgKyBvYmoubWFwcGluZy5pZCArICc9XCInICsgcmVtb3RlSWQgKyAnXCJdIGFscmVhZHkgZXhpc3RzIGluIHRoZSBjYWNoZS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIFRoaXMgaXMgYSBzZXJpb3VzIGVycm9yLCBwbGVhc2UgZmlsZSBhIGJ1ZyByZXBvcnQgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgdGhpcyBvdXQgaW4gdGhlIHdpbGQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVtb3RlQ2FjaGVMb2dnZXIuZXJyb3IobWVzc2FnZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iajogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZE9iamVjdDogY2FjaGVkT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSZW1vdGVDYWNoZUxvZ2dlci5kZWJ1Zy5pc0VuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVtb3RlQ2FjaGVMb2dnZXIuZGVidWcoJ09iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGluc2VydGVkOiAnICsgb2JqLl9kdW1wKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignTWFwcGluZyBoYXMgbm8gdHlwZScsIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogb2JqLm1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIG9iajogb2JqXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignTWFwcGluZyBoYXMgbm8gY29sbGVjdGlvbicsIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiBvYmoubWFwcGluZyxcbiAgICAgICAgICAgICAgICBvYmo6IG9ialxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbXNnID0gJ011c3QgcGFzcyBhbiBvYmplY3Qgd2hlbiBpbnNlcnRpbmcgdG8gY2FjaGUnO1xuICAgICAgICBSZW1vdGVDYWNoZUxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcihtc2cpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEdW1wIHRoZSByZW1vdGUgaWQgY2FjaGVcbiAqIEBwYXJhbSAge2Jvb2xlYW59IGFzSnNvbiBXaGV0aGVyIG9yIG5vdCB0byBhcHBseSBKU09OLnN0cmluZ2lmeVxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcmVtb3RlRHVtcChhc0pzb24pIHtcbiAgICB2YXIgZHVtcGVkUmVzdENhY2hlID0ge307XG4gICAgZm9yICh2YXIgY29sbCBpbiByZW1vdGVDYWNoZSkge1xuICAgICAgICBpZiAocmVtb3RlQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sbCkpIHtcbiAgICAgICAgICAgIHZhciBkdW1wZWRDb2xsQ2FjaGUgPSB7fTtcbiAgICAgICAgICAgIGR1bXBlZFJlc3RDYWNoZVtjb2xsXSA9IGR1bXBlZENvbGxDYWNoZTtcbiAgICAgICAgICAgIHZhciBjb2xsQ2FjaGUgPSByZW1vdGVDYWNoZVtjb2xsXTtcbiAgICAgICAgICAgIGZvciAodmFyIG1hcHBpbmcgaW4gY29sbENhY2hlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxDYWNoZS5oYXNPd25Qcm9wZXJ0eShtYXBwaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHVtcGVkTWFwcGluZ0NhY2hlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGR1bXBlZENvbGxDYWNoZVttYXBwaW5nXSA9IGR1bXBlZE1hcHBpbmdDYWNoZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBpbmdDYWNoZSA9IGNvbGxDYWNoZVttYXBwaW5nXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmVtb3RlSWQgaW4gbWFwcGluZ0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwcGluZ0NhY2hlLmhhc093blByb3BlcnR5KHJlbW90ZUlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nQ2FjaGVbcmVtb3RlSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bXBlZE1hcHBpbmdDYWNoZVtyZW1vdGVJZF0gPSBtYXBwaW5nQ2FjaGVbcmVtb3RlSWRdLl9kdW1wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhc0pzb24gPyBKU09OLnN0cmluZ2lmeShkdW1wZWRSZXN0Q2FjaGUsIG51bGwsIDQpIDogZHVtcGVkUmVzdENhY2hlO1xuXG59XG5cbi8qKlxuICogRHVtcCB0aGUgbG9jYWwgaWQgKF9pZCkgY2FjaGVcbiAqIEBwYXJhbSAge2Jvb2xlYW59IGFzSnNvbiBXaGV0aGVyIG9yIG5vdCB0byBhcHBseSBKU09OLnN0cmluZ2lmeVxuICogQHJldHVybiB7U3RyaW5nfE9iamVjdH1cbiAqL1xuZnVuY3Rpb24gbG9jYWxEdW1wKGFzSnNvbikge1xuICAgIHZhciBkdW1wZWRJZENhY2hlID0ge307XG4gICAgZm9yICh2YXIgaWQgaW4gbG9jYWxDYWNoZUJ5SWQpIHtcbiAgICAgICAgaWYgKGxvY2FsQ2FjaGVCeUlkLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgZHVtcGVkSWRDYWNoZVtpZF0gPSBsb2NhbENhY2hlQnlJZFtpZF0uX2R1bXAoKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhc0pzb24gPyBKU09OLnN0cmluZ2lmeShkdW1wZWRJZENhY2hlLCBudWxsLCA0KSA6IGR1bXBlZElkQ2FjaGU7XG59XG5cbi8qKlxuICogRHVtcCB0byB0aGUgY2FjaGUuXG4gKiBAcGFyYW0gIHtib29sZWFufSBhc0pzb24gV2hldGhlciBvciBub3QgdG8gYXBwbHkgSlNPTi5zdHJpbmdpZnlcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGR1bXAoYXNKc29uKSB7XG4gICAgdmFyIGR1bXBlZCA9IHtcbiAgICAgICAgbG9jYWxDYWNoZTogbG9jYWxEdW1wKCksXG4gICAgICAgIHJlbW90ZUNhY2hlOiByZW1vdGVEdW1wKClcbiAgICB9O1xuICAgIHJldHVybiBhc0pzb24gPyBKU09OLnN0cmluZ2lmeShkdW1wZWQsIG51bGwsIDQpIDogZHVtcGVkO1xufVxuXG5mdW5jdGlvbiBfcmVtb3RlQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHJlbW90ZUNhY2hlXG59XG5cbmZ1bmN0aW9uIF9sb2NhbENhY2hlKCkge1xuICAgIHJldHVybiBsb2NhbENhY2hlQnlJZDtcbn1cblxuLyoqXG4gKiBRdWVyeSB0aGUgY2FjaGVcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBPYmplY3QgZGVzY3JpYmluZyB0aGUgcXVlcnlcbiAqIEByZXR1cm4ge1NpZXN0YU1vZGVsfVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjYWNoZS5nZXQoe19pZDogJzUnfSk7IC8vIFF1ZXJ5IGJ5IGxvY2FsIGlkXG4gKiBjYWNoZS5nZXQoe3JlbW90ZUlkOiAnNScsIG1hcHBpbmc6IG15TWFwcGluZ30pOyAvLyBRdWVyeSBieSByZW1vdGUgaWRcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZXQob3B0cykge1xuICAgIGlmIChMb2NhbENhY2hlTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZCkgTG9jYWxDYWNoZUxvZ2dlci5kZWJ1ZygnZ2V0Jywgb3B0cyk7XG4gICAgdmFyIG9iaiwgaWRGaWVsZCwgcmVtb3RlSWQ7XG4gICAgdmFyIGxvY2FsSWQgPSBvcHRzLl9pZDtcbiAgICBpZiAobG9jYWxJZCkge1xuICAgICAgICBvYmogPSBnZXRWaWFMb2NhbElkKGxvY2FsSWQpO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMubWFwcGluZykge1xuICAgICAgICAgICAgICAgIGlkRmllbGQgPSBvcHRzLm1hcHBpbmcuaWQ7XG4gICAgICAgICAgICAgICAgcmVtb3RlSWQgPSBvcHRzW2lkRmllbGRdO1xuICAgICAgICAgICAgICAgIGlmIChMb2NhbENhY2hlTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZCkgTG9jYWxDYWNoZUxvZ2dlci5kZWJ1ZyhpZEZpZWxkICsgJz0nICsgcmVtb3RlSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRWaWFSZW1vdGVJZChyZW1vdGVJZCwgb3B0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLm1hcHBpbmcpIHtcbiAgICAgICAgaWRGaWVsZCA9IG9wdHMubWFwcGluZy5pZDtcbiAgICAgICAgcmVtb3RlSWQgPSBvcHRzW2lkRmllbGRdO1xuICAgICAgICBpZiAocmVtb3RlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRWaWFSZW1vdGVJZChyZW1vdGVJZCwgb3B0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy5tYXBwaW5nLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgcmV0dXJuIGdldFNpbmdsZXRvbihvcHRzLm1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgTG9jYWxDYWNoZUxvZ2dlci53YXJuKCdJbnZhbGlkIG9wdHMgdG8gY2FjaGUnLCB7XG4gICAgICAgICAgICBvcHRzOiBvcHRzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBJbnNlcnQgYW4gb2JqZXQgaW50byB0aGUgY2FjaGUuXG4gKiBAcGFyYW0gIHtTaWVzdGFNb2RlbH0gb2JqXG4gKiBAdGhyb3dzIHtJbnRlcm5hbFNpZXN0YUVycm9yfSBBbiBvYmplY3Qgd2l0aCBfaWQvcmVtb3RlSWQgYWxyZWFkeSBleGlzdHMuIE5vdCB0aHJvd24gaWYgc2FtZSBvYmhlY3QuXG4gKi9cbmZ1bmN0aW9uIGluc2VydChvYmopIHtcbiAgICB2YXIgbG9jYWxJZCA9IG9iai5faWQ7XG4gICAgaWYgKGxvY2FsSWQpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gb2JqLm1hcHBpbmcuY29sbGVjdGlvbjtcbiAgICAgICAgdmFyIG1hcHBpbmdOYW1lID0gb2JqLm1hcHBpbmcudHlwZTtcbiAgICAgICAgaWYgKCFsb2NhbENhY2hlQnlJZFtsb2NhbElkXSkge1xuICAgICAgICAgICAgaWYgKExvY2FsQ2FjaGVMb2dnZXIuZGVidWcuaXNFbmFibGVkKVxuICAgICAgICAgICAgICAgIExvY2FsQ2FjaGVMb2dnZXIuZGVidWcoJ0xvY2FsIGNhY2hlIGluc2VydDogJyArIG9iai5fZHVtcCh0cnVlKSk7XG4gICAgICAgICAgICBsb2NhbENhY2hlQnlJZFtsb2NhbElkXSA9IG9iajtcbiAgICAgICAgICAgIGlmIChMb2NhbENhY2hlTG9nZ2VyLnRyYWNlLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICBMb2NhbENhY2hlTG9nZ2VyLnRyYWNlKCdMb2NhbCBjYWNoZSBub3cgbG9va3MgbGlrZTogJyArIGxvY2FsRHVtcCh0cnVlKSk7XG4gICAgICAgICAgICBpZiAoIWxvY2FsQ2FjaGVbY29sbGVjdGlvbk5hbWVdKSBsb2NhbENhY2hlW2NvbGxlY3Rpb25OYW1lXSA9IHt9O1xuICAgICAgICAgICAgaWYgKCFsb2NhbENhY2hlW2NvbGxlY3Rpb25OYW1lXVttYXBwaW5nTmFtZV0pIGxvY2FsQ2FjaGVbY29sbGVjdGlvbk5hbWVdW21hcHBpbmdOYW1lXSA9IHt9O1xuICAgICAgICAgICAgbG9jYWxDYWNoZVtjb2xsZWN0aW9uTmFtZV1bb2JqLnR5cGVdW2xvY2FsSWRdID0gb2JqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGhhcyBnb25lIGJhZGx5IHdyb25nIGhlcmUuIFR3byBvYmplY3RzIHNob3VsZCBuZXZlciBleGlzdCB3aXRoIHRoZSBzYW1lIF9pZFxuICAgICAgICAgICAgaWYgKGxvY2FsQ2FjaGVCeUlkW2xvY2FsSWRdICE9IG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gJ09iamVjdCB3aXRoIF9pZD1cIicgKyBsb2NhbElkLnRvU3RyaW5nKCkgKyAnXCIgaXMgYWxyZWFkeSBpbiB0aGUgY2FjaGUuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVGhpcyBpcyBhIHNlcmlvdXMgZXJyb3IuIFBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydCBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyB0aGlzIG91dCBpbiB0aGUgd2lsZCc7XG4gICAgICAgICAgICAgICAgTG9jYWxDYWNoZUxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaWRGaWVsZCA9IG9iai5pZEZpZWxkO1xuICAgIHZhciByZW1vdGVJZCA9IG9ialtpZEZpZWxkXTtcbiAgICBpZiAocmVtb3RlSWQpIHtcbiAgICAgICAgcmVtb3RlSW5zZXJ0KG9iaiwgcmVtb3RlSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChSZW1vdGVDYWNoZUxvZ2dlci5kZWJ1Zy5pc0VuYWJsZWQpXG4gICAgICAgICAgICBSZW1vdGVDYWNoZUxvZ2dlci5kZWJ1ZygnTm8gcmVtb3RlIGlkIChcIicgKyBpZEZpZWxkICsgJ1wiKSBzbyB3b250IGJlIHBsYWNpbmcgaW4gdGhlIHJlbW90ZSBjYWNoZScsIG9iaik7XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgaW4gdGhlIGNhY2hlXG4gKiBAcGFyYW0gIHtTaWVzdGFNb2RlbH0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWlucyhvYmopIHtcbiAgICB2YXIgcSA9IHtcbiAgICAgICAgX2lkOiBvYmouX2lkXG4gICAgfTtcbiAgICB2YXIgbWFwcGluZyA9IG9iai5tYXBwaW5nO1xuICAgIGlmIChtYXBwaW5nLmlkKSB7XG4gICAgICAgIGlmIChvYmpbbWFwcGluZy5pZF0pIHtcbiAgICAgICAgICAgIHEubWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgICBxW21hcHBpbmcuaWRdID0gb2JqW21hcHBpbmcuaWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWdldChxKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBvYmplY3QgZnJvbSB0aGUgY2FjaGUgKGlmIGl0J3MgYWN0dWFsbHkgaW4gdGhlIGNhY2hlKSBvdGhlcndpc2VzIHRocm93cyBhbiBlcnJvci5cbiAqIEBwYXJhbSAge1NpZXN0YU1vZGVsfSBvYmpcbiAqIEB0aHJvd3Mge0ludGVybmFsU2llc3RhRXJyb3J9IElmIG9iamVjdCBhbHJlYWR5IGluIHRoZSBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKG9iaikge1xuICAgIGlmIChjb250YWlucyhvYmopKSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uTmFtZSA9IG9iai5tYXBwaW5nLmNvbGxlY3Rpb247XG4gICAgICAgIHZhciBtYXBwaW5nTmFtZSA9IG9iai5tYXBwaW5nLnR5cGU7XG4gICAgICAgIHZhciBfaWQgPSBvYmouX2lkO1xuICAgICAgICBpZiAoIW1hcHBpbmdOYW1lKSB0aHJvdyBJbnRlcm5hbFNpZXN0YUVycm9yKCdObyBtYXBwaW5nIG5hbWUnKTtcbiAgICAgICAgaWYgKCFjb2xsZWN0aW9uTmFtZSkgdGhyb3cgSW50ZXJuYWxTaWVzdGFFcnJvcignTm8gY29sbGVjdGlvbiBuYW1lJyk7XG4gICAgICAgIGlmICghX2lkKSB0aHJvdyBJbnRlcm5hbFNpZXN0YUVycm9yKCdObyBfaWQnKTtcbiAgICAgICAgZGVsZXRlIGxvY2FsQ2FjaGVbY29sbGVjdGlvbk5hbWVdW21hcHBpbmdOYW1lXVtfaWRdO1xuICAgICAgICBkZWxldGUgbG9jYWxDYWNoZUJ5SWRbX2lkXTtcbiAgICAgICAgaWYgKG9iai5tYXBwaW5nLmlkKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3RlSWQgPSBvYmpbb2JqLm1hcHBpbmcuaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHJlbW90ZUNhY2hlW2NvbGxlY3Rpb25OYW1lXVttYXBwaW5nTmFtZV1bcmVtb3RlSWRdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ09iamVjdCB3YXMgbm90IGluIGNhY2hlLicpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBkdW1wKGFzSnNvbikge1xuICAgIHZhciBkdW1wZWQgPSB7XG4gICAgICAgIGxvY2FsQ2FjaGU6IGxvY2FsRHVtcCgpLFxuICAgICAgICByZW1vdGVDYWNoZTogcmVtb3RlRHVtcCgpXG4gICAgfTtcbiAgICByZXR1cm4gYXNKc29uID8gSlNPTi5zdHJpbmdpZnkoZHVtcGVkLCBudWxsLCA0KSA6IGR1bXBlZDtcbn1cblxuZXhwb3J0cy5fcmVtb3RlQ2FjaGUgPSBfcmVtb3RlQ2FjaGU7XG5leHBvcnRzLl9sb2NhbENhY2hlID0gX2xvY2FsQ2FjaGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19sb2NhbENhY2hlQnlUeXBlJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsb2NhbENhY2hlO1xuICAgIH1cbn0pO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLmluc2VydCA9IGluc2VydDtcbmV4cG9ydHMucmVtb3RlSW5zZXJ0ID0gcmVtb3RlSW5zZXJ0O1xuZXhwb3J0cy5yZXNldCA9IHJlc2V0O1xuZXhwb3J0cy5fZHVtcCA9IGR1bXA7XG5leHBvcnRzLmNvbnRhaW5zID0gY29udGFpbnM7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTsiLCIvKipcbiAqIFRoZSBjaGFuZ2VzIG1vZHVsZSBkZWFscyB3aXRoIGNoYW5nZXMgdG8gU2llc3RhTW9kZWwgaW5zdGFuY2VzLiBJbiB0aGUgaW4tbWVtb3J5IGNhc2UgdGhpcyBcbiAqIGp1c3QgbWVhbnMgdGhhdCBub3RpZmljYXRpb25zIGFyZSBzZW50IG9uIGFueSBjaGFuZ2UuIElmIHRoZSBzdG9yYWdlIG1vZHVsZSBpcyBiZWluZyB1c2VkLFxuICogdGhlIGNoYW5nZXMgbW9kdWxlIGlzIGV4dGVuZGVkIHRvIGRlYWwgd2l0aCBtZXJnaW5nIGNoYW5nZXMgaW50byB3aGF0ZXZlciBwZXJzaXN0YW50IHN0b3JhZ2VcbiAqIG1ldGhvZCBpcyBiZWluZyB1c2VkLlxuICogQG1vZHVsZSBjaGFuZ2VzXG4gKi9cblxudmFyIGRlZmluZVN1YlByb3BlcnR5ID0gcmVxdWlyZSgnLi9taXNjJykuZGVmaW5lU3ViUHJvcGVydHk7XG52YXIgbm90aWZpY2F0aW9uQ2VudHJlID0gcmVxdWlyZSgnLi9ub3RpZmljYXRpb25DZW50cmUnKS5ub3RpZmljYXRpb25DZW50cmU7XG52YXIgSW50ZXJuYWxTaWVzdGFFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3InKS5JbnRlcm5hbFNpZXN0YUVycm9yO1xudmFyIGxvZyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9sb2cnKTtcbnZhciBjb2xsZWN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuL2NvbGxlY3Rpb25SZWdpc3RyeScpLkNvbGxlY3Rpb25SZWdpc3RyeTtcblxudmFyIExvZ2dlciA9IGxvZy5sb2dnZXJXaXRoTmFtZSgnY2hhbmdlcycpO1xuTG9nZ2VyLnNldExldmVsKGxvZy5MZXZlbC53YXJuKTtcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBkZXNjcmliZSBjaGFuZ2UgZXZlbnRzLlxuICogU2V0ID0+IEEgbmV3IHZhbHVlIGlzIGFzc2lnbmVkIHRvIGFuIGF0dHJpYnV0ZS9yZWxhdGlvbnNoaXBcbiAqIFNwbGljZSA9PiBBbGwgamF2YXNjcmlwdCBhcnJheSBvcGVyYXRpb25zIGFyZSBkZXNjcmliZWQgYXMgc3BsaWNlcy5cbiAqIERlbGV0ZSA9PiBVc2VkIGluIHRoZSBjYXNlIHdoZXJlIG9iamVjdHMgYXJlIHJlbW92ZWQgZnJvbSBhbiBhcnJheSwgYnV0IGFycmF5IG9yZGVyIGlzIG5vdCBrbm93biBpbiBhZHZhbmNlLlxuICogUmVtb3ZlID0+IE9iamVjdCBkZWxldGlvbiBldmVudHNcbiAqIE5ldyA9PiBPYmplY3QgY3JlYXRpb24gZXZlbnRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgQ2hhbmdlVHlwZSA9IHtcbiAgICBTZXQ6ICdTZXQnLFxuICAgIFNwbGljZTogJ1NwbGljZScsXG4gICAgRGVsZXRlOiAnRGVsZXRlJyxcbiAgICBOZXc6ICdOZXcnLFxuICAgIFJlbW92ZTogJ1JlbW92ZSdcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBpbmRpdmlkdWFsIGNoYW5nZS5cbiAqIEBwYXJhbSBvcHRzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2hhbmdlKG9wdHMpIHtcbiAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICBpZiAoIXRoaXMuX29wdHMpIHtcbiAgICAgICAgdGhpcy5fb3B0cyA9IHt9O1xuICAgIH1cbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdjb2xsZWN0aW9uJywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnbWFwcGluZycsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ19pZCcsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ2ZpZWxkJywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAndHlwZScsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ2luZGV4JywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnYWRkZWQnLCB0aGlzLl9vcHRzKTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdhZGRlZElkJywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAncmVtb3ZlZCcsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ3JlbW92ZWRJZCcsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ25ldycsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ25ld0lkJywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnb2xkJywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnb2xkSWQnLCB0aGlzLl9vcHRzKTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdvYmonLCB0aGlzLl9vcHRzKTtcbn1cblxuQ2hhbmdlLnByb3RvdHlwZS5fZHVtcCA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIGR1bXBlZCA9IHt9O1xuICAgIGR1bXBlZC5jb2xsZWN0aW9uID0gKHR5cGVvZiB0aGlzLmNvbGxlY3Rpb24pID09ICdzdHJpbmcnID8gdGhpcy5jb2xsZWN0aW9uIDogdGhpcy5jb2xsZWN0aW9uLl9kdW1wKCk7XG4gICAgZHVtcGVkLm1hcHBpbmcgPSAodHlwZW9mIHRoaXMubWFwcGluZykgPT0gJ3N0cmluZycgPyB0aGlzLm1hcHBpbmcgOiB0aGlzLm1hcHBpbmcudHlwZTtcbiAgICBkdW1wZWQuX2lkID0gdGhpcy5faWQ7XG4gICAgZHVtcGVkLmZpZWxkID0gdGhpcy5maWVsZDtcbiAgICBkdW1wZWQudHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAodGhpcy5pbmRleCkgZHVtcGVkLmluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBpZiAodGhpcy5hZGRlZCkgZHVtcGVkLmFkZGVkID0gXy5tYXAodGhpcy5hZGRlZCwgZnVuY3Rpb24gKHgpIHtyZXR1cm4geC5fZHVtcCgpfSk7XG4gICAgaWYgKHRoaXMucmVtb3ZlZCkgZHVtcGVkLnJlbW92ZWQgPSBfLm1hcCh0aGlzLnJlbW92ZWQsIGZ1bmN0aW9uICh4KSB7cmV0dXJuIHguX2R1bXAoKX0pO1xuICAgIGlmICh0aGlzLm9sZCkgZHVtcGVkLm9sZCA9IHRoaXMub2xkO1xuICAgIGlmICh0aGlzLm5ldykgZHVtcGVkLm5ldyA9IHRoaXMubmV3O1xuICAgIHJldHVybiBqc29uID8gSlNPTi5zdHJpbmdpZnkoZHVtcGVkLCBudWxsLCA0KSA6IGR1bXBlZDtcbn07XG5cbi8qKlxuICogQnJvYWRjYXNcbiAqIEBwYXJhbSAge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSAge1N0cmluZ30gbWFwcGluZ05hbWVcbiAqIEBwYXJhbSAge09iamVjdH0gYyBhbiBvcHRpb25zIGRpY3Rpb25hcnkgcmVwcmVzZW50aW5nIHRoZSBjaGFuZ2VcbiAqIEByZXR1cm4ge1t0eXBlXX1cbiAqL1xuZnVuY3Rpb24gYnJvYWRjYXN0KGNvbGxlY3Rpb25OYW1lLCBtYXBwaW5nTmFtZSwgYykge1xuICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKSBMb2dnZXIudHJhY2UoJ1NlbmRpbmcgbm90aWZpY2F0aW9uIFwiJyArIGNvbGxlY3Rpb25OYW1lICsgJ1wiIG9mIHR5cGUgJyArIGMudHlwZSk7XG4gICAgbm90aWZpY2F0aW9uQ2VudHJlLmVtaXQoY29sbGVjdGlvbk5hbWUsIGMpO1xuICAgIHZhciBtYXBwaW5nTm90aWYgPSBjb2xsZWN0aW9uTmFtZSArICc6JyArIG1hcHBpbmdOYW1lO1xuICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKSBMb2dnZXIudHJhY2UoJ1NlbmRpbmcgbm90aWZpY2F0aW9uIFwiJyArIG1hcHBpbmdOb3RpZiArICdcIiBvZiB0eXBlICcgKyBjLnR5cGUpO1xuICAgIG5vdGlmaWNhdGlvbkNlbnRyZS5lbWl0KG1hcHBpbmdOb3RpZiwgYyk7XG4gICAgdmFyIGdlbmVyaWNOb3RpZiA9ICdTaWVzdGEnO1xuICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKSBMb2dnZXIudHJhY2UoJ1NlbmRpbmcgbm90aWZpY2F0aW9uIFwiJyArIGdlbmVyaWNOb3RpZiArICdcIiBvZiB0eXBlICcgKyBjLnR5cGUpO1xuICAgIG5vdGlmaWNhdGlvbkNlbnRyZS5lbWl0KGdlbmVyaWNOb3RpZiwgYyk7XG4gICAgdmFyIGxvY2FsSWROb3RpZiA9IGMuX2lkO1xuICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKSBMb2dnZXIudHJhY2UoJ1NlbmRpbmcgbm90aWZpY2F0aW9uIFwiJyArIGxvY2FsSWROb3RpZiArICdcIiBvZiB0eXBlICcgKyBjLnR5cGUpO1xuICAgIG5vdGlmaWNhdGlvbkNlbnRyZS5lbWl0KGxvY2FsSWROb3RpZiwgYyk7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uUmVnaXN0cnlbY29sbGVjdGlvbk5hbWVdO1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgZXJyID0gJ05vIHN1Y2ggY29sbGVjdGlvbiBcIicgKyBjb2xsZWN0aW9uTmFtZSArICdcIic7XG4gICAgICAgIExvZ2dlci5lcnJvcihlcnIsIGNvbGxlY3Rpb25SZWdpc3RyeSk7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKGVycik7XG4gICAgfVxuICAgIHZhciBtYXBwaW5nID0gY29sbGVjdGlvblttYXBwaW5nTmFtZV07XG4gICAgaWYgKCFtYXBwaW5nKSB7XG4gICAgICAgIHZhciBlcnIgPSAnTm8gc3VjaCBtYXBwaW5nIFwiJyArIG1hcHBpbmdOYW1lICsgJ1wiJztcbiAgICAgICAgTG9nZ2VyLmVycm9yKGVyciwgY29sbGVjdGlvblJlZ2lzdHJ5KTtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgaWYgKG1hcHBpbmcuaWQgJiYgYy5vYmpbbWFwcGluZy5pZF0pIHtcbiAgICAgICAgdmFyIHJlbW90ZUlkTm90aWYgPSBjb2xsZWN0aW9uTmFtZSArICc6JyArIG1hcHBpbmdOYW1lICsgJzonICsgYy5vYmpbbWFwcGluZy5pZF07XG4gICAgICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKSBMb2dnZXIudHJhY2UoJ1NlbmRpbmcgbm90aWZpY2F0aW9uIFwiJyArIHJlbW90ZUlkTm90aWYgKyAnXCIgb2YgdHlwZSAnICsgYy50eXBlKTtcbiAgICAgICAgbm90aWZpY2F0aW9uQ2VudHJlLmVtaXQocmVtb3RlSWROb3RpZiwgYyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93IGFuIGVycm9yIGlmIHRoZSBjaGFuZ2UgaXMgaW5jb3JyZWN0LlxuICogQHBhcmFtIGNoYW5nZU9wdHNcbiAqIEB0aHJvd3Mge0ludGVybmFsU2llc3RhRXJyb3J9IElmIGNoYW5nZSBvcHRpb25zIGFyZSBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbmdlKGNoYW5nZU9wdHMpIHtcbiAgICBpZiAoIWNoYW5nZU9wdHMubWFwcGluZykgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ011c3QgcGFzcyBhIG1hcHBpbmcnKTtcbiAgICBpZiAoIWNoYW5nZU9wdHMuY29sbGVjdGlvbikgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ011c3QgcGFzcyBhIGNvbGxlY3Rpb24nKTtcbiAgICBpZiAoIWNoYW5nZU9wdHMuX2lkKSB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignTXVzdCBwYXNzIGEgbG9jYWwgaWRlbnRpZmllcicpO1xuICAgIGlmICghY2hhbmdlT3B0cy5vYmopIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdNdXN0IHBhc3MgdGhlIG9iamVjdCcpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHRoYXQgYSBjaGFuZ2UgaGFzIGJlZW4gbWFkZS5cbiAqIEBwYXJhbSBvcHRzXG4gKiBAcmV0dXJuIHtDaGFuZ2V9IFRoZSBjb25zdHJ1Y3RlZCBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFuZ2Uob3B0cykge1xuICAgIHZhbGlkYXRlQ2hhbmdlKG9wdHMpO1xuICAgIHZhciBjb2xsZWN0aW9uID0gb3B0cy5jb2xsZWN0aW9uO1xuICAgIHZhciBtYXBwaW5nID0gb3B0cy5tYXBwaW5nO1xuICAgIHZhciBjID0gbmV3IENoYW5nZShvcHRzKTtcbiAgICBicm9hZGNhc3QoY29sbGVjdGlvbiwgbWFwcGluZywgYyk7XG4gICAgcmV0dXJuIGM7XG59XG5cbmV4cG9ydHMuQ2hhbmdlID0gQ2hhbmdlO1xuZXhwb3J0cy5yZWdpc3RlckNoYW5nZSA9IHJlZ2lzdGVyQ2hhbmdlO1xuZXhwb3J0cy52YWxpZGF0ZUNoYW5nZSA9IHZhbGlkYXRlQ2hhbmdlO1xuZXhwb3J0cy5DaGFuZ2VUeXBlID0gQ2hhbmdlVHlwZTsiLCIvKipcbiAqIEBtb2R1bGUgY29sbGVjdGlvblxuICovXG5cbnZhciBsb2cgPSByZXF1aXJlKCcuLi92ZW5kb3Ivb3BlcmF0aW9ucy5qcy9zcmMvbG9nJyk7XG52YXIgTG9nZ2VyID0gbG9nLmxvZ2dlcldpdGhOYW1lKCdDb2xsZWN0aW9uJyk7XG5Mb2dnZXIuc2V0TGV2ZWwobG9nLkxldmVsLndhcm4pO1xuXG52YXIgQ29sbGVjdGlvblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9jb2xsZWN0aW9uUmVnaXN0cnknKS5Db2xsZWN0aW9uUmVnaXN0cnk7XG52YXIgT3BlcmF0aW9uID0gcmVxdWlyZSgnLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL29wZXJhdGlvbicpLk9wZXJhdGlvbjtcbnZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3I7XG52YXIgTWFwcGluZyA9IHJlcXVpcmUoJy4vbWFwcGluZycpLk1hcHBpbmc7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJyk7XG52YXIgb2JzZXJ2ZSA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vYnNlcnZlLWpzL3NyYy9vYnNlcnZlJykuUGxhdGZvcm07XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgXyA9IHV0aWwuXztcblxudmFyIHEgPSByZXF1aXJlKCdxJyk7XG5cbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcblxudmFyIFNBRkVfTUVUSE9EUyA9IFsnR0VUJywgJ0hFQUQnLCAnVFJBQ0UnLCAnT1BUSU9OUycsICdDT05ORUNUJ107XG52YXIgVU5TQUZFX01FVEhPRFMgPSBbJ1BVVCcsICdQQVRDSCcsICdQT1NUJywgJ0RFTEVURSddO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBkZXNjcmliZXMgYSBzZXQgb2YgbW9kZWxzIGFuZCBvcHRpb25hbGx5IGEgUkVTVCBBUEkgd2hpY2ggd2Ugd291bGRcbiAqIGxpa2UgdG8gbW9kZWwuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBjb25zdHJ1Y3RvclxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBHaXRIdWIgPSBuZXcgc2llc3RhLkNvbGxlY3Rpb24oJ0dpdEh1YicpXG4gKiAvLyAuLi4gY29uZmlndXJlIG1hcHBpbmdzLCBkZXNjcmlwdG9ycyBldGMgLi4uXG4gKiBHaXRIdWIuaW5zdGFsbChmdW5jdGlvbiAoKSB7XG4gKiAgICAgLy8gLi4uIGNhcnJ5IG9uLlxuICogfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gQ29sbGVjdGlvbihuYW1lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghdGhpcykgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKG5hbWUpO1xuICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ0NvbGxlY3Rpb24gbXVzdCBoYXZlIGEgbmFtZScpO1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuX2RvY0lkID0gJ0NvbGxlY3Rpb25fJyArIHRoaXMuX25hbWU7XG4gICAgdGhpcy5fcmF3TWFwcGluZ3MgPSB7fTtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IHt9O1xuICAgIC8qKlxuICAgICAqIFRoZSBVUkwgb2YgdGhlIEFQSSBlLmcuIGh0dHA6Ly9hcGkuZ2l0aHViLmNvbVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5iYXNlVVJMID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiBpbnN0YWxsYXRpb24gaGFzIHN1Y2NlZWRlZC4gWW91IGNhbm5vdCB1c2UgdGhlIGNvbGxlY3Rpb1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaW5zdGFsbGVkID0gZmFsc2U7XG4gICAgQ29sbGVjdGlvblJlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbmFtZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9uYW1lO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogRW5zdXJlIG1hcHBpbmdzIGFyZSBpbnN0YWxsZWQuXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXRoaXMuaW5zdGFsbGVkKSB7XG4gICAgICAgIHZhciBtYXBwaW5nc1RvSW5zdGFsbCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX21hcHBpbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwcGluZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX21hcHBpbmdzW25hbWVdO1xuICAgICAgICAgICAgICAgIG1hcHBpbmdzVG9JbnN0YWxsLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKExvZ2dlci5pbmZvLmlzRW5hYmxlZClcbiAgICAgICAgICAgIExvZ2dlci5pbmZvKCdUaGVyZSBhcmUgJyArIG1hcHBpbmdzVG9JbnN0YWxsLmxlbmd0aC50b1N0cmluZygpICsgJyBtYXBwaW5ncyB0byBpbnN0YWxsJyk7XG4gICAgICAgIGlmIChtYXBwaW5nc1RvSW5zdGFsbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gXy5tYXAobWFwcGluZ3NUb0luc3RhbGwsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbignSW5zdGFsbCBNYXBwaW5nJywgXy5iaW5kKG0uaW5zdGFsbCwgbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgT3BlcmF0aW9uKCdJbnN0YWxsIE1hcHBpbmdzJywgb3BlcmF0aW9ucyk7XG4gICAgICAgICAgICBvcC5jb21wbGV0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wLmZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBpbnN0YWxsIGNvbGxlY3Rpb24nLCBvcC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbmFsaXNlSW5zdGFsbGF0aW9uKG9wLmVycm9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChtYXBwaW5nc1RvSW5zdGFsbCwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExvZ2dlci5pbmZvLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnSW5zdGFsbGluZyByZWxhdGlvbnNoaXBzIGZvciBtYXBwaW5nIHdpdGggbmFtZSBcIicgKyBtLnR5cGUgKyAnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBtLmluc3RhbGxSZWxhdGlvbnNoaXBzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gobWFwcGluZ3NUb0luc3RhbGwsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoTG9nZ2VyLmluZm8uaXNFbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnSW5zdGFsbGluZyByZXZlcnNlIHJlbGF0aW9uc2hpcHMgZm9yIG1hcHBpbmcgd2l0aCBuYW1lIFwiJyArIG0udHlwZSArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBtLmluc3RhbGxSZXZlcnNlUmVsYXRpb25zaGlwcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnJvcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2ZpbmFsaXNlSW5zdGFsbGF0aW9uKGVyciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcC5zdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5fZmluYWxpc2VJbnN0YWxsYXRpb24obnVsbCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdDb2xsZWN0aW9uIFwiJyArIHRoaXMuX25hbWUgKyAnXCIgaGFzIGFscmVhZHkgYmVlbiBpbnN0YWxsZWQnKTtcbiAgICAgICAgc2VsZi5fZmluYWxpc2VJbnN0YWxsYXRpb24oZXJyLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBNYXJrIHRoaXMgY29sbGVjdGlvbiBhcyBpbnN0YWxsZWQsIGFuZCBwbGFjZSB0aGUgY29sbGVjdGlvbiBvbiB0aGUgZ2xvYmFsIFNpZXN0YSBvYmplY3QuXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgZXJyXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuX2ZpbmFsaXNlSW5zdGFsbGF0aW9uID0gZnVuY3Rpb24oZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICghZXJyKSB7XG4gICAgICAgIHRoaXMuaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVxdWlyZSgnLi4vaW5kZXgnKTtcbiAgICAgICAgaW5kZXhbdGhpcy5fbmFtZV0gPSB0aGlzO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG59O1xuXG4vKipcbiAqIEdpdmVuIHRoZSBuYW1lIG9mIGEgbWFwcGluZyBhbmQgYW4gb3B0aW9ucyBvYmplY3QgZGVzY3JpYmluZyB0aGUgbWFwcGluZywgY3JlYXRpbmcgYSBNYXBwaW5nXG4gKiBvYmplY3QsIGluc3RhbGwgaXQgYW5kIHJldHVybiBpdC5cbiAqIEBwYXJhbSAge1N0cmluZ30gbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fSBtYXBwaW5nXG4gKiBAcmV0dXJuIHtNYXBwaW5nfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5fbWFwcGluZyA9IGZ1bmN0aW9uKG5hbWUsIG9wdHMpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICB0aGlzLl9yYXdNYXBwaW5nc1tuYW1lXSA9IG9wdHM7XG4gICAgICAgIHZhciBvcHRzID0gZXh0ZW5kKHRydWUsIHt9LCBvcHRzKTtcbiAgICAgICAgb3B0cy50eXBlID0gbmFtZTtcbiAgICAgICAgb3B0cy5jb2xsZWN0aW9uID0gdGhpcy5fbmFtZTtcbiAgICAgICAgdmFyIG1hcHBpbmdPYmplY3QgPSBuZXcgTWFwcGluZyhvcHRzKTtcbiAgICAgICAgdGhpcy5fbWFwcGluZ3NbbmFtZV0gPSBtYXBwaW5nT2JqZWN0O1xuICAgICAgICB0aGlzW25hbWVdID0gbWFwcGluZ09iamVjdDtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ05vIG5hbWUgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgbWFwcGluZycpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbWFwcGluZyB3aXRoIHRoaXMgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0c09yTmFtZSBBbiBvcHRpb25zIG9iamVjdCBvciB0aGUgbmFtZSBvZiB0aGUgbWFwcGluZy4gTXVzdCBwYXNzIG9wdGlvbnMgYXMgc2Vjb25kIHBhcmFtIGlmIHNwZWNpZnkgbmFtZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbnMgaWYgbmFtZSBhbHJlYWR5IHNwZWNpZmllZC5cbiAqIEByZXR1cm4ge01hcHBpbmd9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLm1hcHBpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ubWFwKGFyZ3VtZW50c1swXSwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFwcGluZyhtLm5hbWUsIG0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwcGluZyhhcmd1bWVudHNbMF0ubmFtZSwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcHBpbmcoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXy5tYXAoYXJndW1lbnRzLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9tYXBwaW5nKG0ubmFtZSwgbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5kZXNjcmlwdG9yID0gZnVuY3Rpb24ob3B0cykge1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IFtdO1xuICAgIGlmIChzaWVzdGEuZXh0Lmh0dHBFbmFibGVkKSB7XG4gICAgICAgIHZhciBtZXRob2RzID0gc2llc3RhLmV4dC5odHRwLl9yZXNvbHZlTWV0aG9kKG9wdHMubWV0aG9kKTtcbiAgICAgICAgdmFyIHVuc2FmZSA9IFtdO1xuICAgICAgICB2YXIgc2FmZSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtID0gbWV0aG9kc1tpXTtcbiAgICAgICAgICAgIGlmIChVTlNBRkVfTUVUSE9EUy5pbmRleE9mKG0pID4gLTEpIHtcbiAgICAgICAgICAgICAgICB1bnNhZmUucHVzaChtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2FmZS5wdXNoKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1bnNhZmUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3IgPSBleHRlbmQoe30sIG9wdHMpO1xuICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IubWV0aG9kID0gdW5zYWZlO1xuICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKHJlcXVlc3REZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXF1ZXN0RGVzY3JpcHRvcihyZXF1ZXN0RGVzY3JpcHRvcik7XG4gICAgICAgICAgICBkZXNjcmlwdG9ycy5wdXNoKHJlcXVlc3REZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2FmZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZURlc2NyaXB0b3IgPSBleHRlbmQoe30sIG9wdHMpO1xuICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yLm1ldGhvZCA9IHNhZmU7XG4gICAgICAgICAgICByZXNwb25zZURlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcihyZXNwb25zZURlc2NyaXB0b3IpO1xuICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZWdpc3RlclJlc3BvbnNlRGVzY3JpcHRvcihyZXNwb25zZURlc2NyaXB0b3IpO1xuICAgICAgICAgICAgZGVzY3JpcHRvcnMucHVzaChyZXNwb25zZURlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ0hUVFAgbW9kdWxlIG5vdCBpbnN0YWxsZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xufTtcblxuLyoqXG4gKiBEdW1wIHRoaXMgY29sbGVjdGlvbiBhcyBKU09OXG4gKiBAcGFyYW0gIHtCb29sZWFufSBhc0pzb24gV2hldGhlciBvciBub3QgdG8gYXBwbHkgSlNPTi5zdHJpbmdpZnlcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLl9kdW1wID0gZnVuY3Rpb24oYXNKc29uKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIG9iai5pbnN0YWxsZWQgPSB0aGlzLmluc3RhbGxlZDtcbiAgICBvYmouZG9jSWQgPSB0aGlzLl9kb2NJZDtcbiAgICBvYmoubmFtZSA9IHRoaXMuX25hbWU7XG4gICAgb2JqLmJhc2VVUkwgPSB0aGlzLmJhc2VVUkw7XG4gICAgcmV0dXJuIGFzSnNvbiA/IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgNCkgOiBvYmo7XG59O1xuXG5cbi8vIC8qKlxuLy8gICogUGVyc2lzdCBhbGwgY2hhbmdlcyB0byBQb3VjaERCLlxuLy8gICogTm90ZTogU3RvcmFnZSBleHRlbnNpb24gbXVzdCBiZSBpbnN0YWxsZWQuXG4vLyAgKiBAcGFyYW0gY2FsbGJhY2tcbi8vICAqIEByZXR1cm5zIHtQcm9taXNlfVxuLy8gICovXG4vLyBDb2xsZWN0aW9uLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbi8vICAgICB2YXIgZGVmZXJyZWQgPSBxLmRlZmVyKCk7XG4vLyAgICAgY2FsbGJhY2sgPSB1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIoY2FsbGJhY2ssIGRlZmVycmVkKTtcbi8vICAgICBpZiAoc2llc3RhLmV4dC5zdG9yYWdlRW5hYmxlZCkge1xuLy8gICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICB2YXIgbWVyZ2VDaGFuZ2VzID0gc2llc3RhLmV4dC5zdG9yYWdlLmNoYW5nZXMubWVyZ2VDaGFuZ2VzO1xuLy8gICAgICAgICAgICAgbWVyZ2VDaGFuZ2VzKGNhbGxiYWNrKTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgY2FsbGJhY2soJ1N0b3JhZ2UgbW9kdWxlIG5vdCBpbnN0YWxsZWQnKTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4vLyB9O1xuXG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLl9odHRwID0gZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgaWYgKHNpZXN0YS5leHQuaHR0cEVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgIHZhciBmID0gc2llc3RhLmV4dC5odHRwW21ldGhvZF07XG4gICAgICAgIGYuYXBwbHkoZiwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgSW50ZXJuYWxTaWVzdGFFcnJvcignSFRUUCBtb2R1bGUgbm90IGVuYWJsZWQnKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2VuZCBhIEdFVCByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgcmVzb3VyY2Ugd2Ugd2FudCB0byBHRVRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBvcHRzT3JDYWxsYmFjayBFaXRoZXIgYW4gb3B0aW9ucyBvYmplY3Qgb3IgYSBjYWxsYmFjayBpZiBjYW4gdXNlIGRlZmF1bHRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpZiBvcHRzIHNwZWNpZmllZC5cbiAqIEBwYWNrYWdlIEhUVFBcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5HRVQgPSBmdW5jdGlvbigpIHtcbiAgICBfLnBhcnRpYWwodGhpcy5faHR0cCwgJ0dFVCcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBPUFRJT05TIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSByZXNvdXJjZSB0byB3aGljaCB3ZSB3YW50IHRvIHNlbmQgYW4gT1BUSU9OUyByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gb3B0c09yQ2FsbGJhY2sgRWl0aGVyIGFuIG9wdGlvbnMgb2JqZWN0IG9yIGEgY2FsbGJhY2sgaWYgY2FuIHVzZSBkZWZhdWx0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgaWYgb3B0cyBzcGVjaWZpZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuT1BUSU9OUyA9IGZ1bmN0aW9uKCkge1xuICAgIF8ucGFydGlhbCh0aGlzLl9odHRwLCAnT1BUSU9OUycpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBUUkFDRSByZXF1ZXN0XG4gKiBAcGFyYW0ge3BhdGh9IHBhdGggVGhlIHBhdGggdG8gdGhlIHJlc291cmNlIHRvIHdoaWNoIHdlIHdhbnQgdG8gc2VuZCBhIFRSQUNFIHJlcXVlc3RcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBvcHRzT3JDYWxsYmFjayBFaXRoZXIgYW4gb3B0aW9ucyBvYmplY3Qgb3IgYSBjYWxsYmFjayBpZiBjYW4gdXNlIGRlZmF1bHRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpZiBvcHRzIHNwZWNpZmllZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5UUkFDRSA9IGZ1bmN0aW9uKCkge1xuICAgIF8ucGFydGlhbCh0aGlzLl9odHRwLCAnVFJBQ0UnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBTZW5kIGEgSEVBRCByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgcmVzb3VyY2UgdG8gd2hpY2ggd2Ugd2FudCB0byBzZW5kIGEgSEVBRCByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gb3B0c09yQ2FsbGJhY2sgRWl0aGVyIGFuIG9wdGlvbnMgb2JqZWN0IG9yIGEgY2FsbGJhY2sgaWYgY2FuIHVzZSBkZWZhdWx0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgaWYgb3B0cyBzcGVjaWZpZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuSEVBRCA9IGZ1bmN0aW9uKCkge1xuICAgIF8ucGFydGlhbCh0aGlzLl9odHRwLCAnSEVBRCcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBQT1NUIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSByZXNvdXJjZSB0byB3aGljaCB3ZSB3YW50IHRvIHNlbmQgYSBQT1NUIHJlcXVlc3RcbiAqIEBwYXJhbSB7U2llc3RhTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0aGF0IHdlIHdvdWxkIGxpa2UgdG8gUE9TVFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IG9wdHNPckNhbGxiYWNrIEVpdGhlciBhbiBvcHRpb25zIG9iamVjdCBvciBhIGNhbGxiYWNrIGlmIGNhbiB1c2UgZGVmYXVsdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlmIG9wdHMgc3BlY2lmaWVkLlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLlBPU1QgPSBmdW5jdGlvbigpIHtcbiAgICBfLnBhcnRpYWwodGhpcy5faHR0cCwgJ1BPU1QnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBTZW5kIGEgUFVUIHJlcXVlc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSByZXNvdXJjZSB0byB3aGljaCB3ZSB3YW50IHRvIHNlbmQgYSBQVVQgcmVxdWVzdFxuICogQHBhcmFtIHtTaWVzdGFNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRoYXQgd2Ugd291bGQgbGlrZSB0byBQVVRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBvcHRzT3JDYWxsYmFjayBFaXRoZXIgYW4gb3B0aW9ucyBvYmplY3Qgb3IgYSBjYWxsYmFjayBpZiBjYW4gdXNlIGRlZmF1bHRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpZiBvcHRzIHNwZWNpZmllZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5QVVQgPSBmdW5jdGlvbigpIHtcbiAgICBfLnBhcnRpYWwodGhpcy5faHR0cCwgJ1BVVCcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBQQVRDSCByZXF1ZXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgcmVzb3VyY2UgdG8gd2hpY2ggd2Ugd2FudCB0byBzZW5kIGEgUEFUQ0ggcmVxdWVzdFxuICogQHBhcmFtIHtTaWVzdGFNb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRoYXQgd2Ugd291bGQgbGlrZSB0byBQQVRDSFxuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IG9wdHNPckNhbGxiYWNrIEVpdGhlciBhbiBvcHRpb25zIG9iamVjdCBvciBhIGNhbGxiYWNrIGlmIGNhbiB1c2UgZGVmYXVsdHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGlmIG9wdHMgc3BlY2lmaWVkLlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLlBBVENIID0gZnVuY3Rpb24oKSB7XG4gICAgXy5wYXJ0aWFsKHRoaXMuX2h0dHAsICdQQVRDSCcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFNlbmQgYSBERUxFVEUgcmVxdWVzdC4gQWxzbyByZW1vdmVzIHRoZSBvYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgcmVzb3VyY2UgdG8gd2hpY2ggd2Ugd2FudCB0byBERUxFVEVcbiAqIEBwYXJhbSB7U2llc3RhTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0aGF0IHdlIHdvdWxkIGxpa2UgdG8gUEFUQ0hcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBvcHRzT3JDYWxsYmFjayBFaXRoZXIgYW4gb3B0aW9ucyBvYmplY3Qgb3IgYSBjYWxsYmFjayBpZiBjYW4gdXNlIGRlZmF1bHRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBpZiBvcHRzIHNwZWNpZmllZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5ERUxFVEUgPSBmdW5jdGlvbihwYXRoLCBvYmplY3QpIHtcbiAgICBfLnBhcnRpYWwodGhpcy5faHR0cCwgJ0RFTEVURScpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBvYmplY3RzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgdmFyIHRhc2tzID0gXy5tYXAodGhpcy5fbWFwcGluZ3MsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIF8uYmluZChtLmNvdW50LCBtKTtcbiAgICB9KTtcbiAgICB1dGlsLnBhcmFsbGVsKHRhc2tzLCBmdW5jdGlvbihlcnIsIG5zKSB7XG4gICAgICAgIHZhciBuO1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgbiA9IF8ucmVkdWNlKG5zLCBmdW5jdGlvbihtLCByKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0gKyByXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIsIG4pO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjsiLCIvKipcbiAqIEBtb2R1bGUgY29sbGVjdGlvbiBcbiAqL1xudmFyIF8gPSByZXF1aXJlKCcuL3V0aWwnKS5fO1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uUmVnaXN0cnkoKSB7XG4gICAgaWYgKCF0aGlzKSByZXR1cm4gbmV3IENvbGxlY3Rpb25SZWdpc3RyeSgpO1xuICAgIHRoaXMuY29sbGVjdGlvbk5hbWVzID0gW107XG59XG5cbkNvbGxlY3Rpb25SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciBuYW1lID0gY29sbGVjdGlvbi5fbmFtZTtcbiAgICB0aGlzW25hbWVdID0gY29sbGVjdGlvbjtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lcy5wdXNoKG5hbWUpO1xufTtcblxuQ29sbGVjdGlvblJlZ2lzdHJ5LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXy5lYWNoKHRoaXMuY29sbGVjdGlvbk5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBkZWxldGUgc2VsZltuYW1lXTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lcyA9IFtdO1xufTtcblxuZXhwb3J0cy5Db2xsZWN0aW9uUmVnaXN0cnkgPSBuZXcgQ29sbGVjdGlvblJlZ2lzdHJ5KCk7IiwiLyoqXG4gKiBAbW9kdWxlIGVycm9yXG4gKi9cblxuZnVuY3Rpb24gSW50ZXJuYWxTaWVzdGFFcnJvcihtZXNzYWdlLCBjb250ZXh0LCBzc2YpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICAgIHNzZiA9IHNzZiB8fCBhcmd1bWVudHMuY2FsbGVlO1xuICAgIGlmIChzc2YgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3NmKTtcbiAgICB9XG59XG5cbkludGVybmFsU2llc3RhRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuSW50ZXJuYWxTaWVzdGFFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnRlcm5hbFNpZXN0YUVycm9yJztcbkludGVybmFsU2llc3RhRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJuYWxTaWVzdGFFcnJvcjtcblxuZXhwb3J0cy5JbnRlcm5hbFNpZXN0YUVycm9yID0gSW50ZXJuYWxTaWVzdGFFcnJvcjtcbiIsIi8qKlxuICogQG1vZHVsZSByZWxhdGlvbnNoaXBzXG4gKi9cblxudmFyIHByb3h5ID0gcmVxdWlyZSgnLi9wcm94eScpXG4gICAgLCBSZWxhdGlvbnNoaXBQcm94eSA9IHByb3h5LlJlbGF0aW9uc2hpcFByb3h5XG4gICAgLCBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKVxuICAgICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG4gICAgLCBfID0gdXRpbC5fXG4gICAgLCBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3JcbiAgICAsIGNvcmVDaGFuZ2VzID0gcmVxdWlyZSgnLi9jaGFuZ2VzJylcbiAgICAsIG5vdGlmaWNhdGlvbkNlbnRyZSA9IHJlcXVpcmUoJy4vbm90aWZpY2F0aW9uQ2VudHJlJylcbiAgICAsIHdyYXBBcnJheUZvckF0dHJpYnV0ZXMgPSBub3RpZmljYXRpb25DZW50cmUud3JhcEFycmF5XG4gICAgLCBTaWVzdGFNb2RlbCA9IHJlcXVpcmUoJy4vb2JqZWN0JykuU2llc3RhTW9kZWxcbiAgICAsIEFycmF5T2JzZXJ2ZXIgPSByZXF1aXJlKCcuLi92ZW5kb3Ivb2JzZXJ2ZS1qcy9zcmMvb2JzZXJ2ZScpLkFycmF5T2JzZXJ2ZXJcbiAgICAsIENoYW5nZVR5cGUgPSByZXF1aXJlKCcuL2NoYW5nZXMnKS5DaGFuZ2VUeXBlXG4gICAgLCBxID0gcmVxdWlyZSgncScpXG47XG5cbi8qKlxuICogW01hbnlUb01hbnlQcm94eSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIE1hbnlUb01hbnlQcm94eShvcHRzKSB7XG4gICAgUmVsYXRpb25zaGlwUHJveHkuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpc0ZhdWx0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc2VsZi5yZWxhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWxhdGVkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWxhdGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgIHdyYXBBcnJheS5jYWxsKHNlbGYsIHNlbGYucmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmV2ZXJzZUlzQXJyYXkgPSB0cnVlO1xufVxuXG5cbmZ1bmN0aW9uIGNsZWFyUmV2ZXJzZShyZW1vdmVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIF8uZWFjaChyZW1vdmVkLCBmdW5jdGlvbiAocmVtb3ZlZE9iamVjdCkge1xuICAgICAgICB2YXIgcmV2ZXJzZVByb3h5ID0gcHJveHkuZ2V0UmV2ZXJzZVByb3h5Rm9yT2JqZWN0LmNhbGwoc2VsZiwgcmVtb3ZlZE9iamVjdCk7XG4gICAgICAgIHZhciBpZHggPSByZXZlcnNlUHJveHkuX2lkLmluZGV4T2Yoc2VsZi5vYmplY3QuX2lkKTtcbiAgICAgICAgcHJveHkubWFrZUNoYW5nZXNUb1JlbGF0ZWRXaXRob3V0T2JzZXJ2YXRpb25zLmNhbGwocmV2ZXJzZVByb3h5LCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHByb3h5LnNwbGljZS5jYWxsKHJldmVyc2VQcm94eSwgaWR4LCAxKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFJldmVyc2UoYWRkZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXy5lYWNoKGFkZGVkLCBmdW5jdGlvbiAoYWRkZWRPYmplY3QpIHtcbiAgICAgICAgdmFyIHJldmVyc2VQcm94eSA9IHByb3h5LmdldFJldmVyc2VQcm94eUZvck9iamVjdC5jYWxsKHNlbGYsIGFkZGVkT2JqZWN0KTtcbiAgICAgICAgcHJveHkubWFrZUNoYW5nZXNUb1JlbGF0ZWRXaXRob3V0T2JzZXJ2YXRpb25zLmNhbGwocmV2ZXJzZVByb3h5LCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHByb3h5LnNwbGljZS5jYWxsKHJldmVyc2VQcm94eSwgMCwgMCwgc2VsZi5vYmplY3QpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcEFycmF5KGFycikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB3cmFwQXJyYXlGb3JBdHRyaWJ1dGVzKGFyciwgdGhpcy5yZXZlcnNlTmFtZSwgdGhpcy5vYmplY3QpO1xuICAgIGlmICghYXJyLm9uZVRvTWFueU9ic2VydmVyKSB7XG4gICAgICAgIGFyci5vbmVUb01hbnlPYnNlcnZlciA9IG5ldyBBcnJheU9ic2VydmVyKGFycik7XG4gICAgICAgIHZhciBvYnNlcnZlckZ1bmN0aW9uID0gZnVuY3Rpb24gKHNwbGljZXMpIHtcbiAgICAgICAgICAgIHNwbGljZXMuZm9yRWFjaChmdW5jdGlvbiAoc3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGVkID0gc3BsaWNlLmFkZGVkQ291bnQgPyBhcnIuc2xpY2Uoc3BsaWNlLmluZGV4LCBzcGxpY2UuaW5kZXggKyBzcGxpY2UuYWRkZWRDb3VudCkgOiBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHNwbGljZS5yZW1vdmVkO1xuICAgICAgICAgICAgICAgIGNsZWFyUmV2ZXJzZS5jYWxsKHNlbGYsIHJlbW92ZWQpO1xuICAgICAgICAgICAgICAgIHNldFJldmVyc2UuY2FsbChzZWxmLCBhZGRlZCk7XG4gICAgICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSBwcm94eS5nZXRGb3J3YXJkTWFwcGluZy5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogbWFwcGluZy5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBtYXBwaW5nLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIF9pZDogc2VsZi5vYmplY3QuX2lkLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogcHJveHkuZ2V0Rm9yd2FyZE5hbWUuY2FsbChzZWxmKSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkSWQ6IF8ucGx1Y2socmVtb3ZlZCwgJ19pZCcpLFxuICAgICAgICAgICAgICAgICAgICBhZGRlZElkOiBfLnBsdWNrKGFkZGVkLCAnX2lkJyksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU3BsaWNlLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogc3BsaWNlLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBvYmo6IHNlbGYub2JqZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJyLm9uZVRvTWFueU9ic2VydmVyLm9wZW4ob2JzZXJ2ZXJGdW5jdGlvbik7XG4gICAgfVxufVxuXG5NYW55VG9NYW55UHJveHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWxhdGlvbnNoaXBQcm94eS5wcm90b3R5cGUpO1xuXG5NYW55VG9NYW55UHJveHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5pc0ZhdWx0KSB7XG4gICAgICAgIFN0b3JlLmdldCh7X2lkOiB0aGlzLl9pZH0sIGZ1bmN0aW9uIChlcnIsIHN0b3JlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYucmVsYXRlZCA9IHN0b3JlZDtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIHN0b3JlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIHRoaXMucmVsYXRlZCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGUob2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2Fubm90IGFzc2lnbiBzY2FsYXIgdG8gbWFueSB0byBtYW55JztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5NYW55VG9NYW55UHJveHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBwcm94eS5jaGVja0luc3RhbGxlZC5jYWxsKHRoaXMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAob2JqKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2U7XG4gICAgICAgIGlmIChlcnJvck1lc3NhZ2UgPSB2YWxpZGF0ZS5jYWxsKHRoaXMsIG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvck1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm94eS5jbGVhclJldmVyc2VSZWxhdGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBwcm94eS5zZXQuY2FsbChzZWxmLCBvYmopO1xuICAgICAgICAgICAgd3JhcEFycmF5LmNhbGwoc2VsZiwgb2JqKTtcbiAgICAgICAgICAgIHByb3h5LnNldFJldmVyc2UuY2FsbChzZWxmLCBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm94eS5jbGVhclJldmVyc2VSZWxhdGVkLmNhbGwodGhpcyk7XG4gICAgICAgIHByb3h5LnNldC5jYWxsKHNlbGYsIG9iaik7XG4gICAgfVxufTtcblxuTWFueVRvTWFueVByb3h5LnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKG9iaikge1xuICAgIFJlbGF0aW9uc2hpcFByb3h5LnByb3RvdHlwZS5pbnN0YWxsLmNhbGwodGhpcywgb2JqKTtcbiAgICBvYmpbICgnc3BsaWNlJyArIHV0aWwuY2FwaXRhbGlzZUZpcnN0TGV0dGVyKHRoaXMucmV2ZXJzZU5hbWUpKV0gPSBfLmJpbmQocHJveHkuc3BsaWNlLCB0aGlzKTtcbn07XG5cbmV4cG9ydHMuTWFueVRvTWFueVByb3h5ID0gTWFueVRvTWFueVByb3h5OyIsIi8qKlxuICogQG1vZHVsZSBtYXBwaW5nXG4gKi9cblxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9sb2cnKTtcbnZhciBMb2dnZXIgPSBsb2cubG9nZ2VyV2l0aE5hbWUoJ01hcHBpbmcnKTtcbkxvZ2dlci5zZXRMZXZlbChsb2cuTGV2ZWwud2Fybik7XG5cbnZhciBkZWZpbmVTdWJQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vbWlzYycpLmRlZmluZVN1YlByb3BlcnR5O1xudmFyIENvbGxlY3Rpb25SZWdpc3RyeSA9IHJlcXVpcmUoJy4vY29sbGVjdGlvblJlZ2lzdHJ5JykuQ29sbGVjdGlvblJlZ2lzdHJ5O1xudmFyIEludGVybmFsU2llc3RhRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcjtcbnZhciByZWxhdGlvbnNoaXAgPSByZXF1aXJlKCcuL3JlbGF0aW9uc2hpcCcpO1xudmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZWxhdGlvbnNoaXAuUmVsYXRpb25zaGlwVHlwZTtcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKS5RdWVyeTtcbnZhciBPcGVyYXRpb24gPSByZXF1aXJlKCcuLi92ZW5kb3Ivb3BlcmF0aW9ucy5qcy9zcmMvb3BlcmF0aW9uJykuT3BlcmF0aW9uO1xudmFyIEJ1bGtNYXBwaW5nT3BlcmF0aW9uID0gcmVxdWlyZSgnLi9tYXBwaW5nT3BlcmF0aW9uJykuQnVsa01hcHBpbmdPcGVyYXRpb247XG52YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuL29iamVjdCcpLlNpZXN0YU1vZGVsO1xudmFyIGd1aWQgPSByZXF1aXJlKCcuL21pc2MnKS5ndWlkO1xudmFyIGNhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xudmFyIHN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJ2V4dGVuZCcpO1xuXG52YXIgY29yZUNoYW5nZXMgPSByZXF1aXJlKCcuL2NoYW5nZXMnKTtcbnZhciBDaGFuZ2VUeXBlID0gY29yZUNoYW5nZXMuQ2hhbmdlVHlwZTtcbnZhciB3cmFwQXJyYXkgPSByZXF1aXJlKCcuL25vdGlmaWNhdGlvbkNlbnRyZScpLndyYXBBcnJheTtcblxudmFyIE9uZVRvTWFueVByb3h5ID0gcmVxdWlyZSgnLi9vbmVUb01hbnlQcm94eScpLk9uZVRvTWFueVByb3h5O1xudmFyIE9uZVRvT25lUHJveHkgPSByZXF1aXJlKCcuL29uZVRvT25lUHJveHknKS5PbmVUb09uZVByb3h5O1xudmFyIE1hbnlUb01hbnlQcm94eSA9IHJlcXVpcmUoJy4vbWFueVRvTWFueVByb3h5JykuTWFueVRvTWFueVByb3h5O1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIF8gPSB1dGlsLl87XG52YXIgcSA9IHJlcXVpcmUoJ3EnKTtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcob3B0cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9vcHRzID0gb3B0cztcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2ZpZWxkcycsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9vcHRzLmlkKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnB1c2goc2VsZi5fb3B0cy5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5fb3B0cy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHNlbGYuX29wdHMuYXR0cmlidXRlcywgZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCh4KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSB0eXBlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICd0eXBlJywgc2VsZi5fb3B0cyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpZFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnaWQnLCBzZWxmLl9vcHRzKTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdjb2xsZWN0aW9uJywgc2VsZi5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnYXR0cmlidXRlcycsIHNlbGYuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ3JlbGF0aW9uc2hpcHMnLCBzZWxmLl9vcHRzKTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdpbmRleGVzJywgc2VsZi5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnc3ViY2xhc3MnLCBzZWxmLl9vcHRzKTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdzaW5nbGV0b24nLCBzZWxmLl9vcHRzKTtcblxuICAgIGlmICghdGhpcy5yZWxhdGlvbnNoaXBzKSB7XG4gICAgICAgIHRoaXMucmVsYXRpb25zaGlwcyA9IFtdO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pbmRleGVzKSB7XG4gICAgICAgIHRoaXMuaW5kZXhlcyA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbGlkYXRlU3ViY2xhc3MoKTtcblxuICAgIHRoaXMuX2luc3RhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbGF0aW9uc2hpcHNJbnN0YWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXZlcnNlUmVsYXRpb25zaGlwc0luc3RhbGxlZCA9IGZhbHNlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpbnN0YWxsZWQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5faW5zdGFsbGVkICYmIHNlbGYuX3JlbGF0aW9uc2hpcHNJbnN0YWxsZWQgJiYgc2VsZi5fcmV2ZXJzZVJlbGF0aW9uc2hpcHNJbnN0YWxsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHN1YmNsYXNzZXMgcGFzc2VkIHRvIHRoZSBtYXBwaW5nIGFyZSB2YWxpZCBhbmQgd29ya2luZyBjb3JyZWN0bHkuXG4gKiBAcHJpdmF0ZVxuICovXG5NYXBwaW5nLnByb3RvdHlwZS5fdmFsaWRhdGVTdWJjbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnN1YmNsYXNzICYmIHRoaXMuc3ViY2xhc3MgIT09IFNpZXN0YU1vZGVsKSB7XG4gICAgICAgIHZhciBvYmogPSBuZXcgdGhpcy5zdWJjbGFzcyh0aGlzKTtcbiAgICAgICAgaWYgKCFvYmoubWFwcGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ1N1YmNsYXNzIGZvciBtYXBwaW5nIFwiJyArIHRoaXMudHlwZSArICdcIiBoYXMgbm90IGJlZW4gY29uZmlndXJlZCBjb3JyZWN0bHkuICcgK1xuICAgICAgICAgICAgICAgICdEaWQgeW91IGNhbGwgc3VwZXI/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3ViY2xhc3MucHJvdG90eXBlID09IFNpZXN0YU1vZGVsLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ1N1YmNsYXNzIGZvciBtYXBwaW5nIFwiJyArIHRoaXMudHlwZSArICdcIiBoYXMgbm90IGJlZW4gY29uZmlndXJlZCBjb3JyZWN0bHkuICcgK1xuICAgICAgICAgICAgICAgICdZb3Ugc2hvdWxkIHVzZSBPYmplY3QuY3JlYXRlIG9uIFNpZXN0YU1vZGVsIHByb3RvdHlwZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuTWFwcGluZy5wcm90b3R5cGUuaW5zdGFsbFJlbGF0aW9uc2hpcHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3JlbGF0aW9uc2hpcHNJbnN0YWxsZWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLl9yZWxhdGlvbnNoaXBzID0gW107XG4gICAgICAgIGlmIChzZWxmLl9vcHRzLnJlbGF0aW9uc2hpcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc2VsZi5fb3B0cy5yZWxhdGlvbnNoaXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKExvZ2dlci5kZWJ1Zy5pc0VuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5kZWJ1ZyhzZWxmLnR5cGUgKyAnOiBjb25maWd1cmluZyByZWxhdGlvbnNoaXAgJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9vcHRzLnJlbGF0aW9uc2hpcHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcCA9IHNlbGYuX29wdHMucmVsYXRpb25zaGlwc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc2hpcC50eXBlID09IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAudHlwZSA9PSBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvT25lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAudHlwZSA9PSBSZWxhdGlvbnNoaXBUeXBlLk1hbnlUb01hbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nTmFtZSA9IHJlbGF0aW9uc2hpcC5tYXBwaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExvZ2dlci5kZWJ1Zy5pc0VuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmRlYnVnKCdyZXZlcnNlTWFwcGluZ05hbWUnLCBtYXBwaW5nTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuY29sbGVjdGlvbikgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ01hcHBpbmcgbXVzdCBoYXZlIGNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gQ29sbGVjdGlvblJlZ2lzdHJ5W3NlbGYuY29sbGVjdGlvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignQ29sbGVjdGlvbiAnICsgc2VsZi5jb2xsZWN0aW9uICsgJyBub3QgcmVnaXN0ZXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldmVyc2VNYXBwaW5nID0gY29sbGVjdGlvblttYXBwaW5nTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IG1hcHBpbmdOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyci5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBhcnJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmdOYW1lID0gYXJyWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb2xsZWN0aW9uID0gQ29sbGVjdGlvblJlZ2lzdHJ5W2NvbGxlY3Rpb25OYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSAnQ29sbGVjdGlvbiB3aXRoIG5hbWUgXCInICsgY29sbGVjdGlvbk5hbWUgKyAnXCIgZG9lcyBub3QgZXhpc3QuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0cnk6IENvbGxlY3Rpb25SZWdpc3RyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nID0gb3RoZXJDb2xsZWN0aW9uW21hcHBpbmdOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZGVidWcoJ3JldmVyc2VNYXBwaW5nJywgcmV2ZXJzZU1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVyc2VNYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwLnJldmVyc2VNYXBwaW5nID0gcmV2ZXJzZU1hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwLmZvcndhcmRNYXBwaW5nID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAuZm9yd2FyZE5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcC5yZXZlcnNlTmFtZSA9IHJlbGF0aW9uc2hpcC5yZXZlcnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcC5pc1JldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdNYXBwaW5nIHdpdGggbmFtZSBcIicgKyBtYXBwaW5nTmFtZS50b1N0cmluZygpICsgJ1wiIGRvZXMgbm90IGV4aXN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnUmVsYXRpb25zaGlwIHR5cGUgJyArIHJlbGF0aW9uc2hpcC50eXBlICsgJyBkb2VzIG5vdCBleGlzdCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVsYXRpb25zaGlwc0luc3RhbGxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ1JlbGF0aW9uc2hpcHMgZm9yIFwiJyArIHRoaXMudHlwZSArICdcIiBoYXZlIGFscmVhZHkgYmVlbiBpbnN0YWxsZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5pbnN0YWxsUmV2ZXJzZVJlbGF0aW9uc2hpcHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX3JldmVyc2VSZWxhdGlvbnNoaXBzSW5zdGFsbGVkKSB7XG4gICAgICAgIGZvciAodmFyIGZvcndhcmROYW1lIGluIHRoaXMucmVsYXRpb25zaGlwcykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpb25zaGlwcy5oYXNPd25Qcm9wZXJ0eShmb3J3YXJkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb25zaGlwID0gdGhpcy5yZWxhdGlvbnNoaXBzW2ZvcndhcmROYW1lXTtcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXAgPSBleHRlbmQodHJ1ZSwge30sIHJlbGF0aW9uc2hpcCk7XG4gICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwLmlzUmV2ZXJzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VNYXBwaW5nID0gcmVsYXRpb25zaGlwLnJldmVyc2VNYXBwaW5nO1xuICAgICAgICAgICAgICAgIHZhciByZXZlcnNlTmFtZSA9IHJlbGF0aW9uc2hpcC5yZXZlcnNlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmRlYnVnKHNlbGYudHlwZSArICc6IGNvbmZpZ3VyaW5nICByZXZlcnNlIHJlbGF0aW9uc2hpcCAnICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmcucmVsYXRpb25zaGlwc1tyZXZlcnNlTmFtZV0gPSByZWxhdGlvbnNoaXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmV2ZXJzZVJlbGF0aW9uc2hpcHNJbnN0YWxsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdSZXZlcnNlIHJlbGF0aW9uc2hpcHMgZm9yIFwiJyArIHRoaXMudHlwZSArICdcIiBoYXZlIGFscmVhZHkgYmVlbiBpbnN0YWxsZWQuJyk7XG4gICAgfVxufTtcblxuTWFwcGluZy5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBxLmRlZmVyKCk7XG4gICAgY2FsbGJhY2sgPSB1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIoY2FsbGJhY2ssIGRlZmVycmVkKTtcbiAgICB2YXIgX3F1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMsIHF1ZXJ5KTtcbiAgICBfcXVlcnkuZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpZE9yQ2FsbGJhY2ssIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG5cbiAgICBmdW5jdGlvbiBmaW5pc2goZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2luZ2xldG9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaWRPckNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gaWRPckNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsKGZ1bmN0aW9uKGVyciwgb2Jqcykge1xuICAgICAgICAgICAgaWYgKGVycikgZmluaXNoKGVycik7XG4gICAgICAgICAgICBpZiAob2Jqcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ1NvbWVob3cgbW9yZSB0aGFuIG9uZSBvYmplY3QgaGFzIGJlZW4gY3JlYXRlZCBmb3IgYSBzaW5nbGV0b24gbWFwcGluZyEgJyArXG4gICAgICAgICAgICAgICAgICAgICdUaGlzIGlzIGEgc2VyaW91cyBlcnJvciwgcGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0LicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmpzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpbmlzaChudWxsLCBvYmpzWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluaXNoKG51bGwsIG9ianNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICBvcHRzW3RoaXMuaWRdID0gaWRPckNhbGxiYWNrO1xuICAgICAgICBvcHRzLm1hcHBpbmcgPSB0aGlzO1xuICAgICAgICB2YXIgb2JqID0gY2FjaGUuZ2V0KG9wdHMpO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBmaW5pc2gobnVsbCwgb2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRzLm1hcHBpbmc7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgb3B0cyk7XG4gICAgICAgICAgICBxdWVyeS5leGVjdXRlKGZ1bmN0aW9uKGVyciwgcm93cykge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZXJyICYmIHJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9ICdNb3JlIHRoYW4gb25lIG9iamVjdCB3aXRoIGlkPScgKyBpZE9yQ2FsbGJhY2sudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IHJvd3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluaXNoKGVyciwgb2JqKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzLCB7fSk7XG4gICAgcXVlcnkuZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoTG9nZ2VyLmluZm8uaXNFbmFibGVkKSBMb2dnZXIuaW5mbygnSW5zdGFsbGluZyBtYXBwaW5nICcgKyB0aGlzLnR5cGUpO1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIGlmICghdGhpcy5faW5zdGFsbGVkKSB7XG4gICAgICAgIHZhciBlcnJvcnMgPSB0aGlzLl92YWxpZGF0ZSgpO1xuICAgICAgICB0aGlzLl9pbnN0YWxsZWQgPSB0cnVlO1xuICAgICAgICBpZiAoTG9nZ2VyLmluZm8uaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkgTG9nZ2VyLmVycm9yKCdFcnJvcnMgaW5zdGFsbGluZyBtYXBwaW5nICcgKyB0aGlzLnR5cGUgKyAnOiAnICsgZXJyb3JzKTtcbiAgICAgICAgICAgIGVsc2UgTG9nZ2VyLmluZm8oJ0luc3RhbGxlZCBtYXBwaW5nICcgKyB0aGlzLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdNYXBwaW5nIFwiJyArIHRoaXMudHlwZSArICdcIiBoYXMgYWxyZWFkeSBiZWVuIGluc3RhbGxlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbk1hcHBpbmcucHJvdG90eXBlLl92YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBpZiAoIXRoaXMudHlwZSkge1xuICAgICAgICBlcnJvcnMucHVzaCgnTXVzdCBzcGVjaWZ5IGEgdHlwZScpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29sbGVjdGlvbikge1xuICAgICAgICBlcnJvcnMucHVzaCgnQSBtYXBwaW5nIG11c3QgYmVsb25nIHRvIGFuIGNvbGxlY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG5cblxuLyoqXG4gKiBNYXAgZGF0YSBpbnRvIFNpZXN0YS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBSYXcgZGF0YSByZWNlaXZlZCByZW1vdGVseSBvciBvdGhlcndpc2VcbiAqIEBwYXJhbSBjYWxsYmFjayBDYWxsZWQgb25jZSBwb3VjaCBwZXJzaXN0ZW5jZSByZXR1cm5zLlxuICogQHBhcmFtIG92ZXJyaWRlIEZvcmNlIG1hcHBpbmcgdG8gdGhpcyBvYmplY3RcbiAqL1xuTWFwcGluZy5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2ssIG92ZXJyaWRlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgaWYgKHRoaXMuaW5zdGFsbGVkKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEJ1bGsoZGF0YSwgY2FsbGJhY2ssIG92ZXJyaWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hcEJ1bGsoW2RhdGFdLCBmdW5jdGlvbihlcnIsIG9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iajtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iamVjdHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyID8gZXJyWzBdIDogbnVsbCwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBvdmVycmlkZSA/IFtvdmVycmlkZV0gOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ01hcHBpbmcgbXVzdCBiZSBmdWxseSBpbnN0YWxsZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBtb2RlbHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS5fbWFwQnVsayA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrLCBvdmVycmlkZSkge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgICBtYXBwaW5nOiB0aGlzLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbiAgICBpZiAob3ZlcnJpZGUpIG9wdHMub2JqZWN0cyA9IG92ZXJyaWRlO1xuICAgIHZhciBvcCA9IG5ldyBCdWxrTWFwcGluZ09wZXJhdGlvbihvcHRzKTtcbiAgICBvcC5vbkNvbXBsZXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlcnIgPSBvcC5lcnJvcjtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9iamVjdHMgPSBvcC5yZXN1bHQ7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBvYmplY3RzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG9wLnN0YXJ0KCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5mdW5jdGlvbiBfY291bnRDYWNoZSgpIHtcbiAgICB2YXIgY29sbENhY2hlID0gY2FjaGUuX2xvY2FsQ2FjaGVCeVR5cGVbdGhpcy5jb2xsZWN0aW9uXSB8fCB7fTtcbiAgICB2YXIgbWFwcGluZ0NhY2hlID0gY29sbENhY2hlW3RoaXMudHlwZV0gfHwge307XG4gICAgcmV0dXJuIF8ucmVkdWNlKE9iamVjdC5rZXlzKG1hcHBpbmdDYWNoZSksIGZ1bmN0aW9uKG0sIF9pZCkge1xuICAgICAgICBtW19pZF0gPSB7fTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSwge30pO1xufVxuXG5NYXBwaW5nLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgdmFyIGhhc2ggPSBfY291bnRDYWNoZS5jYWxsKHRoaXMpO1xuICAgIGlmIChzaWVzdGEuZXh0LnN0b3JhZ2VFbmFibGVkKSB7XG4gICAgICAgIHZhciBwb3VjaCA9IHNpZXN0YS5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpO1xuICAgICAgICB2YXIgaW5kZXhOYW1lID0gKG5ldyBzaWVzdGEuZXh0LnN0b3JhZ2UuSW5kZXgodGhpcy5jb2xsZWN0aW9uLCB0aGlzLnR5cGUpKS5fZ2V0TmFtZSgpICsgJ18nO1xuICAgICAgICBwb3VjaC5xdWVyeShpbmRleE5hbWUsIHtcbiAgICAgICAgICAgIGluY2x1ZGVfZG9jczogZmFsc2VcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCByZXNwKSB7XG4gICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKF8ucGx1Y2socmVzcC5yb3dzLCAnaWQnKSwgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFtpZF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuID0gT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBuKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgT2JqZWN0LmtleXMoaGFzaCkubGVuZ3RoKVxuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ29udmVydCByYXcgZGF0YSBpbnRvIGEgU2llc3RhTW9kZWxcbiAqIEByZXR1cm5zIHtTaWVzdGFNb2RlbH1cbiAqIEBwcml2YXRlXG4gKi9cbk1hcHBpbmcucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFsbGVkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIF9pZDtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIF9pZCA9IGRhdGEuX2lkID8gZGF0YS5faWQgOiBndWlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaWQgPSBndWlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld01vZGVsO1xuICAgICAgICBpZiAodGhpcy5zdWJjbGFzcykge1xuICAgICAgICAgICAgbmV3TW9kZWwgPSBuZXcgdGhpcy5zdWJjbGFzcyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld01vZGVsID0gbmV3IFNpZXN0YU1vZGVsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMb2dnZXIuaW5mby5pc0VuYWJsZWQpXG4gICAgICAgICAgICBMb2dnZXIuaW5mbygnTmV3IG9iamVjdCBjcmVhdGVkIF9pZD1cIicgKyBfaWQudG9TdHJpbmcoKSArICdcIiwgdHlwZT0nICsgdGhpcy50eXBlLCBkYXRhKTtcbiAgICAgICAgbmV3TW9kZWwuX2lkID0gX2lkO1xuICAgICAgICAvLyBQbGFjZSBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QuXG4gICAgICAgIG5ld01vZGVsLl9fdmFsdWVzID0gZGF0YSB8fCB7fTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuX2ZpZWxkcztcbiAgICAgICAgdmFyIGlkeCA9IGZpZWxkcy5pbmRleE9mKHRoaXMuaWQpO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIGZpZWxkcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBfLmVhY2goZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld01vZGVsLCBmaWVsZCwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdNb2RlbC5fX3ZhbHVlc1tmaWVsZF0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gbmV3TW9kZWwuX192YWx1ZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBuZXdNb2RlbC5fX3ZhbHVlc1tmaWVsZF0gPSB2O1xuICAgICAgICAgICAgICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBzZWxmLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBzZWxmLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IG5ld01vZGVsLl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogdixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZDogb2xkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmo6IG5ld01vZGVsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwQXJyYXkodiwgZmllbGQsIG5ld01vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3TW9kZWwsIHRoaXMuaWQsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld01vZGVsLl9fdmFsdWVzW3NlbGYuaWRdIHx8IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZCA9IG5ld01vZGVsW3NlbGYuaWRdO1xuICAgICAgICAgICAgICAgIG5ld01vZGVsLl9fdmFsdWVzW3NlbGYuaWRdID0gdjtcbiAgICAgICAgICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IHNlbGYuY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogc2VsZi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBfaWQ6IG5ld01vZGVsLl9pZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3OiB2LFxuICAgICAgICAgICAgICAgICAgICBvbGQ6IG9sZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzZWxmLmlkLFxuICAgICAgICAgICAgICAgICAgICBvYmo6IG5ld01vZGVsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FjaGUucmVtb3RlSW5zZXJ0KG5ld01vZGVsLCB2LCBvbGQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMucmVsYXRpb25zaGlwcykge1xuICAgICAgICAgICAgdmFyIHByb3h5O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVsYXRpb25zaGlwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGlvbnNoaXAgPSB0aGlzLnJlbGF0aW9uc2hpcHNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc2hpcC50eXBlID09IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gbmV3IE9uZVRvTWFueVByb3h5KHJlbGF0aW9uc2hpcCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWxhdGlvbnNoaXAudHlwZSA9PSBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvT25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gbmV3IE9uZVRvT25lUHJveHkocmVsYXRpb25zaGlwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbGF0aW9uc2hpcC50eXBlID09IFJlbGF0aW9uc2hpcFR5cGUuTWFueVRvTWFueSkge1xuICAgICAgICAgICAgICAgICAgICBwcm94eSA9IG5ldyBNYW55VG9NYW55UHJveHkocmVsYXRpb25zaGlwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignTm8gc3VjaCByZWxhdGlvbnNoaXAgdHlwZTogJyArIHJlbGF0aW9uc2hpcC50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm94eS5pbnN0YWxsKG5ld01vZGVsKTtcbiAgICAgICAgICAgIHByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5pbnNlcnQobmV3TW9kZWwpO1xuICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICBtYXBwaW5nOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBfaWQ6IG5ld01vZGVsLl9pZCxcbiAgICAgICAgICAgIG5ld0lkOiBuZXdNb2RlbC5faWQsXG4gICAgICAgICAgICBuZXc6IG5ld01vZGVsLFxuICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5OZXcsXG4gICAgICAgICAgICBvYmo6IG5ld01vZGVsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3TW9kZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5wcmludFN0YWNrVHJhY2UoKTtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ01hcHBpbmcgbXVzdCBiZSBmdWxseSBpbnN0YWxsZWQgYmVmb3JlIGNyZWF0aW5nIGFueSBtb2RlbHMnKTtcbiAgICB9XG5cbn07XG5cbk1hcHBpbmcucHJvdG90eXBlLl9kdW1wID0gZnVuY3Rpb24oYXNKU09OKSB7XG4gICAgdmFyIGR1bXBlZCA9IHt9O1xuICAgIGR1bXBlZC5uYW1lID0gdGhpcy50eXBlO1xuICAgIGR1bXBlZC5hdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIGR1bXBlZC5pZCA9IHRoaXMuaWQ7XG4gICAgZHVtcGVkLmNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XG4gICAgZHVtcGVkLnJlbGF0aW9uc2hpcHMgPSBfLm1hcCh0aGlzLnJlbGF0aW9uc2hpcHMsIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIHIuaXNGb3J3YXJkID8gci5mb3J3YXJkTmFtZSA6IHIucmV2ZXJzZU5hbWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFzSlNPTiA/IEpTT04uc3RyaW5naWZ5KGR1bXBlZCwgbnVsbCwgNCkgOiBkdW1wZWQ7XG59O1xuXG5NYXBwaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnTWFwcGluZ1snICsgdGhpcy50eXBlICsgJ10nO1xufTtcblxuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIEludGVybmFsU2llc3RhRXJyb3Igc3BlY2lmY2FsbHkgZm9yIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBtYXBwaW5nLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcGFyYW0gc3NmXG4gKiBAcmV0dXJucyB7TWFwcGluZ0Vycm9yfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdFcnJvcihtZXNzYWdlLCBjb250ZXh0LCBzc2YpIHtcbiAgICBpZiAoIXRoaXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nRXJyb3IobWVzc2FnZSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgLy8gY2FwdHVyZSBzdGFjayB0cmFjZVxuICAgIHNzZiA9IHNzZiB8fCBhcmd1bWVudHMuY2FsbGVlO1xuICAgIGlmIChzc2YgJiYgSW50ZXJuYWxTaWVzdGFFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICBJbnRlcm5hbFNpZXN0YUVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHNzZik7XG4gICAgfVxufVxuXG5NYXBwaW5nRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJbnRlcm5hbFNpZXN0YUVycm9yLnByb3RvdHlwZSk7XG5NYXBwaW5nRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnTWFwcGluZ0Vycm9yJztcbk1hcHBpbmdFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXBwaW5nRXJyb3I7XG5cbmZ1bmN0aW9uIGFycmF5QXNTdHJpbmcoYXJyKSB7XG4gICAgdmFyIGFyckNvbnRlbnRzID0gXy5yZWR1Y2UoYXJyLCBmdW5jdGlvbihtZW1vLCBmKSB7XG4gICAgICAgIHJldHVybiBtZW1vICsgJ1wiJyArIGYgKyAnXCIsJ1xuICAgIH0sICcnKTtcbiAgICBhcnJDb250ZW50cyA9IGFyckNvbnRlbnRzLnN1YnN0cmluZygwLCBhcnJDb250ZW50cy5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gJ1snICsgYXJyQ29udGVudHMgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gY29uc3RydWN0TWFwRnVuY3Rpb24oY29sbGVjdGlvbiwgdHlwZSwgZmllbGRzKSB7XG4gICAgdmFyIG1hcEZ1bmM7XG4gICAgdmFyIG9ubHlFbXB0eUZpZWxkU2V0U3BlY2lmaWVkID0gKGZpZWxkcy5sZW5ndGggPT0gMSAmJiAhZmllbGRzWzBdLmxlbmd0aCk7XG4gICAgdmFyIG5vRmllbGRTZXRzU3BlY2lmaWVkID0gIWZpZWxkcy5sZW5ndGggfHwgb25seUVtcHR5RmllbGRTZXRTcGVjaWZpZWQ7XG5cbiAgICB2YXIgYXJyID0gYXJyYXlBc1N0cmluZyhmaWVsZHMpO1xuICAgIGlmIChub0ZpZWxkU2V0c1NwZWNpZmllZCkge1xuICAgICAgICBtYXBGdW5jID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IFwiJDJcIjtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gXCIkM1wiO1xuICAgICAgICAgICAgaWYgKGRvYy50eXBlID09IHR5cGUgJiYgZG9jLmNvbGxlY3Rpb24gPT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGVtaXQoZG9jLnR5cGUsIGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0udG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYXBGdW5jID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IFwiJDJcIjtcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gXCIkM1wiO1xuICAgICAgICAgICAgaWYgKGRvYy50eXBlID09IHR5cGUgJiYgZG9jLmNvbGxlY3Rpb24gPT0gY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTVW5yZXNvbHZlZFZhcmlhYmxlXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9ICQxO1xuICAgICAgICAgICAgICAgIHZhciBhZ2dGaWVsZCA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCBpbiBmaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNVbmZpbHRlcmVkRm9ySW5Mb29wXG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpZHhdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkb2NbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdnRmllbGQgKz0gdmFsdWUudG9TdHJpbmcoKSArICdfJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdnRmllbGQgKz0gJ251bGxfJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ0ZpZWxkICs9ICd1bmRlZmluZWRfJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZ2dGaWVsZCA9IGFnZ0ZpZWxkLnN1YnN0cmluZygwLCBhZ2dGaWVsZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICBlbWl0KGFnZ0ZpZWxkLCBkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LnRvU3RyaW5nKCk7XG4gICAgICAgIG1hcEZ1bmMgPSBtYXBGdW5jLnJlcGxhY2UoJyQxJywgYXJyKTtcbiAgICB9XG4gICAgbWFwRnVuYyA9IG1hcEZ1bmMucmVwbGFjZSgnJDInLCB0eXBlKTtcbiAgICBtYXBGdW5jID0gbWFwRnVuYy5yZXBsYWNlKCckMycsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiBtYXBGdW5jO1xufVxuXG5cbmZ1bmN0aW9uIGNvbnN0cnVjdE1hcEZ1bmN0aW9uMihjb2xsZWN0aW9uLCB0eXBlLCBmaWVsZHMpIHtcbiAgICB2YXIgbWFwRnVuYztcbiAgICB2YXIgb25seUVtcHR5RmllbGRTZXRTcGVjaWZpZWQgPSAoZmllbGRzLmxlbmd0aCA9PSAxICYmICFmaWVsZHNbMF0ubGVuZ3RoKTtcbiAgICB2YXIgbm9GaWVsZFNldHNTcGVjaWZpZWQgPSAhZmllbGRzLmxlbmd0aCB8fCBvbmx5RW1wdHlGaWVsZFNldFNwZWNpZmllZDtcblxuICAgIGlmIChub0ZpZWxkU2V0c1NwZWNpZmllZCkge1xuICAgICAgICBtYXBGdW5jID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jLnR5cGUgPT0gdHlwZSAmJiBkb2MuY29sbGVjdGlvbiA9PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZW1pdChkb2MudHlwZSwgZG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtYXBGdW5jID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgICBpZiAoZG9jLnR5cGUgPT0gdHlwZSAmJiBkb2MuY29sbGVjdGlvbiA9PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFnZ0ZpZWxkID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWR4IGluIGZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAvL25vaW5zcGVjdGlvbiBKU1VuZmlsdGVyZWRGb3JJbkxvb3BcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2lkeF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvY1tmaWVsZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dGaWVsZCArPSB2YWx1ZS50b1N0cmluZygpICsgJ18nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2dGaWVsZCArPSAnbnVsbF8nO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdnRmllbGQgKz0gJ3VuZGVmaW5lZF8nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFnZ0ZpZWxkID0gYWdnRmllbGQuc3Vic3RyaW5nKDAsIGFnZ0ZpZWxkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIGVtaXQoYWdnRmllbGQsIGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtYXBGdW5jO1xufVxuXG5leHBvcnRzLk1hcHBpbmcgPSBNYXBwaW5nO1xuZXhwb3J0cy5NYXBwaW5nRXJyb3IgPSBNYXBwaW5nRXJyb3I7XG5leHBvcnRzLmNvbnN0cnVjdE1hcEZ1bmN0aW9uMiA9IGNvbnN0cnVjdE1hcEZ1bmN0aW9uMjtcbmV4cG9ydHMuY29uc3RydWN0TWFwRnVuY3Rpb24gPSBjb25zdHJ1Y3RNYXBGdW5jdGlvbjsiLCIvKipcbiAqIEBtb2R1bGUgbWFwcGluZ1xuICovXG5cbnZhciBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKTtcbnZhciBTaWVzdGFNb2RlbCA9IHJlcXVpcmUoJy4vb2JqZWN0JykuU2llc3RhTW9kZWw7XG52YXIgbG9nID0gcmVxdWlyZSgnLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL2xvZycpO1xudmFyIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9vcGVyYXRpb24nKS5PcGVyYXRpb247XG52YXIgSW50ZXJuYWxTaWVzdGFFcnJvciA9IHJlcXVpcmUoJy4uL3NyYy9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3I7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5JykuUXVlcnk7XG5cbnZhciBMb2dnZXIgPSBsb2cubG9nZ2VyV2l0aE5hbWUoJ01hcHBpbmdPcGVyYXRpb24nKTtcbkxvZ2dlci5zZXRMZXZlbChsb2cuTGV2ZWwud2Fybik7XG5cbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgXyA9IHV0aWwuXztcbnZhciBkZWZpbmVTdWJQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vbWlzYycpLmRlZmluZVN1YlByb3BlcnR5O1xudmFyIENoYW5nZVR5cGUgPSByZXF1aXJlKCcuL2NoYW5nZXMnKS5DaGFuZ2VUeXBlO1xudmFyIHEgPSByZXF1aXJlKCdxJyk7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheShhcnIpIHtcbiAgICByZXR1cm4gXy5yZWR1Y2UoYXJyLCBmdW5jdGlvbihtZW1vLCBlKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgIG1lbW8gPSBtZW1vLmNvbmNhdChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIHVuZmxhdHRlbkFycmF5KGFyciwgbW9kZWxBcnIpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgdmFyIHVuZmxhdHRlbmVkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlbEFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodXRpbC5pc0FycmF5KG1vZGVsQXJyW2ldKSkge1xuICAgICAgICAgICAgdmFyIG5ld0FyciA9IFtdO1xuICAgICAgICAgICAgdW5mbGF0dGVuZWRbaV0gPSBuZXdBcnI7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGVsQXJyW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbmV3QXJyLnB1c2goYXJyW25dKTtcbiAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmZsYXR0ZW5lZFtpXSA9IGFycltuXTtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5mbGF0dGVuZWQ7XG59XG5cbi8qKlxuICogRGVmaW5lcyBhbiBlbmNhcHN1bGF0ZWQgbWFwcGluZyBvcGVyYXRpb24gd2hlcmUgb3B0cyB0YWtlcyBhIG1hcHBpblxuICogQHBhcmFtIHtPYmplY3RzfSBvcHRzXG4gKi9cbmZ1bmN0aW9uIEJ1bGtNYXBwaW5nT3BlcmF0aW9uKG9wdHMpIHtcbiAgICBPcGVyYXRpb24uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgbWFwcGluZ1xuICAgICAqIEB0eXBlIHtNYXBwaW5nfVxuICAgICAqL1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ21hcHBpbmcnLCB0aGlzLl9vcHRzKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGRhdGFcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnZGF0YScsIHRoaXMuX29wdHMpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgb2JqZWN0c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdvYmplY3RzJywgdGhpcy5fb3B0cyk7XG5cbiAgICBpZiAoIXRoaXMub2JqZWN0cykgdGhpcy5vYmplY3RzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBlcnJvcnMgd2hlcmUgaW5kZXhlcyBtYXAgb250byBzYW1lIGluZGV4IGFzIHRoZSBkYXR1bSB0aGF0IGNhdXNlZCBhbiBlcnJvci5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcblxuICAgIHRoaXMubmFtZSA9ICdNYXBwaW5nIE9wZXJhdGlvbic7XG4gICAgdGhpcy53b3JrID0gXy5iaW5kKHRoaXMuX3N0YXJ0LCB0aGlzKTtcbiAgICB0aGlzLnN1Yk9wcyA9IHt9O1xufVxuXG5CdWxrTWFwcGluZ09wZXJhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wZXJhdGlvbi5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBtYXBBdHRyaWJ1dGVzKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkYXR1bSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0c1tpXTtcbiAgICAgICAgLy8gTm8gcG9pbnQgbWFwcGluZyBvYmplY3Qgb250byBpdHNlbGYuIFRoaXMgaGFwcGVucyBpZiBhIFNpZXN0YU1vZGVsIGlzIHBhc3NlZCBhcyBhIHJlbGF0aW9uc2hpcC5cbiAgICAgICAgaWYgKGRhdHVtICE9IG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCkgeyAvLyBJZiBvYmplY3QgaXMgZmFsc3ksIHRoZW4gdGhlcmUgd2FzIGFuIGVycm9yIGxvb2tpbmcgdXAgdGhhdCBvYmplY3QvY3JlYXRpbmcgaXQuXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMubWFwcGluZy5fZmllbGRzO1xuICAgICAgICAgICAgICAgIF8uZWFjaChmaWVsZHMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdHVtW2ZdICE9PSB1bmRlZmluZWQpIHsgLy8gbnVsbCBpcyBmaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RbZl0gPSBkYXR1bVtmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbkJ1bGtNYXBwaW5nT3BlcmF0aW9uLnByb3RvdHlwZS5fbWFwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBudW1IaXRzID0gbWFwQXR0cmlidXRlcy5jYWxsKHRoaXMpO1xuICAgIHZhciByZWxhdGlvbnNoaXBGaWVsZHMgPSBfLmtleXMoc2VsZi5zdWJPcHMpO1xuICAgIF8uZWFjaChyZWxhdGlvbnNoaXBGaWVsZHMsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5zdWJPcHNbZl0ub3A7XG4gICAgICAgIHZhciBpbmRleGVzID0gc2VsZi5zdWJPcHNbZl0uaW5kZXhlcztcbiAgICAgICAgdmFyIHJlbGF0ZWREYXRhID0gZ2V0UmVsYXRlZERhdGEuY2FsbChzZWxmLCBmKS5yZWxhdGVkRGF0YTtcbiAgICAgICAgdmFyIHVuZmxhdHRlbmVkT2JqZWN0cyA9IHVuZmxhdHRlbkFycmF5KG9wLm9iamVjdHMsIHJlbGF0ZWREYXRhKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmZsYXR0ZW5lZE9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBpbmRleGVzW2ldO1xuICAgICAgICAgICAgLy8gRXJyb3JzIGFyZSBwbHVja2VkIGZyb20gdGhlIHN1Ym9wZXJhdGlvbnMuXG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBzZWxmLmVycm9yc1tpZHhdO1xuICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yID8gZXJyb3JbZl0gOiBudWxsO1xuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRlZCA9IHVuZmxhdHRlbmVkT2JqZWN0c1tpXTsgLy8gQ2FuIGJlIGFycmF5IG9yIHNjYWxhci5cbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gc2VsZi5vYmplY3RzW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gb2JqZWN0W2YgKyAnUHJveHknXS5zZXQocmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5lcnJvcnNbaWR4XSkgc2VsZi5lcnJvcnNbaWR4XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcnNbaWR4XVtmXSA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBGb3IgaW5kaWNlcyB3aGVyZSBubyBvYmplY3QgaXMgcHJlc2VudCwgcGVyZm9ybSBsb29rdXBzLCBjcmVhdGluZyBhIG5ldyBvYmplY3QgaWYgbmVjZXNzYXJ5LlxuICogQHByaXZhdGVcbiAqL1xuQnVsa01hcHBpbmdPcGVyYXRpb24ucHJvdG90eXBlLl9sb29rdXAgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVtb3RlTG9va3VwcyA9IFtdO1xuICAgIHZhciBsb2NhbExvb2t1cHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMub2JqZWN0c1tpXSkge1xuICAgICAgICAgICAgdmFyIGxvb2t1cDtcbiAgICAgICAgICAgIHZhciBkYXR1bSA9IHRoaXMuZGF0YVtpXTtcbiAgICAgICAgICAgIHZhciBpc1NjYWxhciA9IHR5cGVvZiBkYXR1bSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0dW0gPT0gJ251bWJlcicgfHwgZGF0dW0gaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgICAgICAgICBpZiAoZGF0dW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXR1bToge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwLmRhdHVtW3NlbGYubWFwcGluZy5pZF0gPSBkYXR1bTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlTG9va3Vwcy5wdXNoKGxvb2t1cCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXR1bSBpbnN0YW5jZW9mIFNpZXN0YU1vZGVsKSB7IC8vIFdlIHdvbid0IG5lZWQgdG8gcGVyZm9ybSBhbnkgbWFwcGluZy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzW2ldID0gZGF0dW07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXR1bS5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxMb29rdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXR1bTogZGF0dW1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXR1bVtzZWxmLm1hcHBpbmcuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUxvb2t1cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdHVtOiBkYXR1bVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IGlmIGFuZCBvbmx5IGlmIHRoZSBkYXRhIGhhcyBhbnkgZmllbGRzIHRoYXQgd2lsbCBhY3R1YWxseVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0dW1GaWVsZHMgPSBPYmplY3Qua2V5cyhkYXR1bSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RGaWVsZHMgPSBfLnJlZHVjZShPYmplY3Qua2V5cyhzZWxmLm1hcHBpbmcucmVsYXRpb25zaGlwcykuY29uY2F0KHNlbGYubWFwcGluZy5fZmllbGRzKSwgZnVuY3Rpb24obSwgeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbVt4XSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3VsZENyZWF0ZU5ld09iamVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdHVtRmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0RmllbGRzW2RhdHVtRmllbGRzW2pdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZENyZWF0ZU5ld09iamVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZENyZWF0ZU5ld09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzW2ldID0gc2VsZi5tYXBwaW5nLl9uZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1dGlsLnBhcmFsbGVsKFtcbiAgICAgICAgICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsSWRlbnRpZmllcnMgPSBfLnBsdWNrKF8ucGx1Y2sobG9jYWxMb29rdXBzLCAnZGF0dW0nKSwgJ19pZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbElkZW50aWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBTdG9yZS5nZXRNdWx0aXBsZUxvY2FsKGxvY2FsSWRlbnRpZmllcnMsIGZ1bmN0aW9uKGVyciwgb2JqZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY2FsSWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaWQgPSBsb2NhbElkZW50aWZpZXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9va3VwID0gbG9jYWxMb29rdXBzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lcnJvcnNbbG9va3VwLmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6ICdObyBvYmplY3Qgd2l0aCBfaWQ9XCInICsgX2lkLnRvU3RyaW5nKCkgKyAnXCInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vYmplY3RzW2xvb2t1cC5pbmRleF0gPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciByZW1vdGVJZGVudGlmaWVycyA9IF8ucGx1Y2soXy5wbHVjayhyZW1vdGVMb29rdXBzLCAnZGF0dW0nKSwgc2VsZi5tYXBwaW5nLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3RlSWRlbnRpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLnRyYWNlKCdMb29raW5nIHVwIHJlbW90ZUlkZW50aWZpZXJzOiAnICsgSlNPTi5zdHJpbmdpZnkocmVtb3RlSWRlbnRpZmllcnMsIG51bGwsIDQpKTtcbiAgICAgICAgICAgICAgICAgICAgU3RvcmUuZ2V0TXVsdGlwbGVSZW1vdGUocmVtb3RlSWRlbnRpZmllcnMsIHNlbGYubWFwcGluZywgZnVuY3Rpb24oZXJyLCBvYmplY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMb2dnZXIudHJhY2UuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3JlbW90ZUlkZW50aWZpZXJzW2ldXSA9IG9iamVjdHNbaV0gPyBvYmplY3RzW2ldLl9pZCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLnRyYWNlKCdSZXN1bHRzIGZvciByZW1vdGVJZGVudGlmaWVyczogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMsIG51bGwsIDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb29rdXAgPSByZW1vdGVMb29rdXBzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdHNbbG9va3VwLmluZGV4XSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3RlSWQgPSByZW1vdGVJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbc2VsZi5tYXBwaW5nLmlkXSA9IHJlbW90ZUlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlUXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogc2VsZi5tYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVRdWVyeVtzZWxmLm1hcHBpbmcuaWRdID0gcmVtb3RlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0c1tsb29rdXAuaW5kZXhdID0gY2FjaGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdHNbbG9va3VwLmluZGV4XSA9IHNlbGYubWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBtYXAgdGhlIHJlbW90ZSBpZGVudGlmaWVyIGhlcmUgdG8gZW5zdXJlIHRoYXQgaXQgZW5kc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwIGluIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9iamVjdHNbbG9va3VwLmluZGV4XVtzZWxmLm1hcHBpbmcuaWRdID0gcmVtb3RlSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgY2FsbGJhY2spO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuQnVsa01hcHBpbmdPcGVyYXRpb24ucHJvdG90eXBlLl9sb29rdXBTaW5nbGV0b24gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FjaGVkU2luZ2xldG9uID0gY2FjaGUuZ2V0KHtcbiAgICAgICAgbWFwcGluZzogdGhpcy5tYXBwaW5nXG4gICAgfSk7XG4gICAgaWYgKCFjYWNoZWRTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHRoaXMubWFwcGluZyk7XG4gICAgICAgIHF1ZXJ5LmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIHZhciBvYmo7XG4gICAgICAgICAgICAgICAgaWYgKG9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IHNlbGYubWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0c1tpXSA9IG9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5vYmplY3RzW2ldID0gY2FjaGVkU2luZ2xldG9uO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuQnVsa01hcHBpbmdPcGVyYXRpb24ucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB0YXNrcyA9IFtdO1xuICAgICAgICB2YXIgbG9va3VwRnVuYyA9IHRoaXMubWFwcGluZy5zaW5nbGV0b24gPyB0aGlzLl9sb29rdXBTaW5nbGV0b24gOiB0aGlzLl9sb29rdXA7XG4gICAgICAgIHRhc2tzLnB1c2goXy5iaW5kKGxvb2t1cEZ1bmMsIHRoaXMpKTtcbiAgICAgICAgdGFza3MucHVzaChfLmJpbmQodGhpcy5fZXhlY3V0ZVN1Yk9wZXJhdGlvbnMsIHRoaXMpKTtcbiAgICAgICAgdXRpbC5wYXJhbGxlbCh0YXNrcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9tYXAoKTtcbiAgICAgICAgICAgIGRvbmUoc2VsZi5lcnJvcnMubGVuZ3RoID8gc2VsZi5lcnJvcnMgOiBudWxsLCBzZWxmLm9iamVjdHMpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb25lKG51bGwsIFtdKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnZXRSZWxhdGVkRGF0YShuYW1lKSB7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICB2YXIgcmVsYXRlZERhdGEgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGF0dW0gPSB0aGlzLmRhdGFbaV07XG4gICAgICAgIGlmIChkYXR1bSkge1xuICAgICAgICAgICAgaWYgKGRhdHVtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIHJlbGF0ZWREYXRhLnB1c2goZGF0dW1bbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGluZGV4ZXM6IGluZGV4ZXMsXG4gICAgICAgIHJlbGF0ZWREYXRhOiByZWxhdGVkRGF0YVxuICAgIH07XG59XG5cbkJ1bGtNYXBwaW5nT3BlcmF0aW9uLnByb3RvdHlwZS5fY29uc3RydWN0U3ViT3BlcmF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdWJPcHMgPSB0aGlzLnN1Yk9wcztcbiAgICB2YXIgcmVsYXRpb25zaGlwcyA9IHRoaXMubWFwcGluZy5yZWxhdGlvbnNoaXBzO1xuICAgIGZvciAodmFyIG5hbWUgaW4gcmVsYXRpb25zaGlwcykge1xuICAgICAgICBpZiAocmVsYXRpb25zaGlwcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcCA9IHJlbGF0aW9uc2hpcHNbbmFtZV07XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcHBpbmcgPSByZWxhdGlvbnNoaXAuZm9yd2FyZE5hbWUgPT0gbmFtZSA/IHJlbGF0aW9uc2hpcC5yZXZlcnNlTWFwcGluZyA6IHJlbGF0aW9uc2hpcC5mb3J3YXJkTWFwcGluZztcbiAgICAgICAgICAgIHZhciBfX3JldCA9IGdldFJlbGF0ZWREYXRhLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IF9fcmV0LmluZGV4ZXM7XG4gICAgICAgICAgICB2YXIgcmVsYXRlZERhdGEgPSBfX3JldC5yZWxhdGVkRGF0YTtcbiAgICAgICAgICAgIGlmIChyZWxhdGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxhdFJlbGF0ZWREYXRhID0gZmxhdHRlbkFycmF5KHJlbGF0ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgQnVsa01hcHBpbmdPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiByZXZlcnNlTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmxhdFJlbGF0ZWREYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3AuX19yZWxhdGlvbnNoaXBOYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBzdWJPcHNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBvcCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogaW5kZXhlc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mdW5jdGlvbiBnYXRoZXJFcnJvcnNGcm9tU3ViT3BlcmF0aW9ucygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlbGF0aW9uc2hpcE5hbWVzID0gXy5rZXlzKHRoaXMuc3ViT3BzKTtcbiAgICBfLmVhY2gocmVsYXRpb25zaGlwTmFtZXMsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5zdWJPcHNbbmFtZV0ub3A7XG4gICAgICAgIHZhciBpbmRleGVzID0gc2VsZi5zdWJPcHNbbmFtZV0uaW5kZXhlcztcbiAgICAgICAgdmFyIGVycm9ycyA9IG9wLmVycm9ycztcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGVkRGF0YSA9IGdldFJlbGF0ZWREYXRhLmNhbGwoc2VsZiwgbmFtZSkucmVsYXRlZERhdGE7XG4gICAgICAgICAgICB2YXIgdW5mbGF0dGVuZWRFcnJvcnMgPSB1bmZsYXR0ZW5BcnJheShlcnJvcnMsIHJlbGF0ZWREYXRhKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5mbGF0dGVuZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gaW5kZXhlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gdW5mbGF0dGVuZWRFcnJvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGlzRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNBcnJheShlcnIpKSBpc0Vycm9yID0gXy5yZWR1Y2UoZXJyLCBmdW5jdGlvbihtZW1vLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vIHx8IHhcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxmLmVycm9yc1tpZHhdKSBzZWxmLmVycm9yc1tpZHhdID0ge307XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXJyb3JzW2lkeF1bbmFtZV0gPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkJ1bGtNYXBwaW5nT3BlcmF0aW9uLnByb3RvdHlwZS5fZXhlY3V0ZVN1Yk9wZXJhdGlvbnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9jb25zdHJ1Y3RTdWJPcGVyYXRpb25zKCk7XG4gICAgdmFyIHJlbGF0aW9uc2hpcE5hbWVzID0gXy5rZXlzKHRoaXMuc3ViT3BzKTtcbiAgICBpZiAocmVsYXRpb25zaGlwTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzdWJPcGVyYXRpb25zID0gXy5tYXAocmVsYXRpb25zaGlwTmFtZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLnN1Yk9wc1trXS5vcFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbXBvc2l0ZU9wZXJhdGlvbiA9IG5ldyBPcGVyYXRpb24oc3ViT3BlcmF0aW9ucyk7XG4gICAgICAgIGNvbXBvc2l0ZU9wZXJhdGlvbi5vbkNvbXBsZXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBnYXRoZXJFcnJvcnNGcm9tU3ViT3BlcmF0aW9ucy5jYWxsKHNlbGYsIHJlbGF0aW9uc2hpcE5hbWVzKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb21wb3NpdGVPcGVyYXRpb24uc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuQnVsa01hcHBpbmdPcGVyYXRpb24gPSBCdWxrTWFwcGluZ09wZXJhdGlvbjtcbmV4cG9ydHMuZmxhdHRlbkFycmF5ID0gZmxhdHRlbkFycmF5O1xuZXhwb3J0cy51bmZsYXR0ZW5BcnJheSA9IHVuZmxhdHRlbkFycmF5OyIsInZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3I7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UsIGNvbnRleHQpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBcIkFzc2VydGlvbiBmYWlsZWRcIjtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwge307XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKG1lc3NhZ2UsIGNvbnRleHQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lU3ViUHJvcGVydHkgKHByb3BlcnR5LCBzdWJPYmosIGlubmVyUHJvcGVydHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlubmVyUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViT2JqW2lubmVyUHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Yk9ialtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaW5uZXJQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHN1Yk9ialtpbm5lclByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViT2JqW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cblxudmFyIGd1aWQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHM0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMClcbiAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHM0KCkgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgK1xuICAgICAgICAgICAgczQoKSArICctJyArIHM0KCkgKyBzNCgpICsgczQoKTtcbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrIChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfVxufVxuXG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuZGVmaW5lU3ViUHJvcGVydHkgPSBkZWZpbmVTdWJQcm9wZXJ0eTtcbmV4cG9ydHMuZ3VpZCA9IGd1aWQ7XG5leHBvcnRzLndyYXBwZWRDYWxsYmFjayA9IHdyYXBwZWRDYWxsYmFjazsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIG5vdGlmaWNhdGlvbkNlbnRyZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbm5vdGlmaWNhdGlvbkNlbnRyZS5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbnZhciBBcnJheU9ic2VydmVyID0gcmVxdWlyZSgnLi4vdmVuZG9yL29ic2VydmUtanMvc3JjL29ic2VydmUnKS5BcnJheU9ic2VydmVyO1xudmFyIGNvcmVDaGFuZ2VzID0gcmVxdWlyZSgnLi9jaGFuZ2VzJyk7XG52YXIgQ2hhbmdlVHlwZSA9IGNvcmVDaGFuZ2VzLkNoYW5nZVR5cGU7XG52YXIgbG9nID0gcmVxdWlyZSgnLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL2xvZycpO1xuXG4vKipcbiogV3JhcHMgdGhlIG1ldGhvZHMgb2YgYSBqYXZhc2NyaXB0IGFycmF5IG9iamVjdCBzbyB0aGF0IG5vdGlmaWNhdGlvbnMgYXJlIHNlbnRcbiogb24gY2FsbHMuXG4qXG4qIEBwYXJhbSBhcnJheSB0aGUgYXJyYXkgd2UgaGF2ZSB3cmFwcGluZ1xuKiBAcGFyYW0gZmllbGQgbmFtZSBvZiB0aGUgZmllbGRcbiogQHBhcmFtIHJlc3RPYmplY3QgdGhlIG9iamVjdCB0byB3aGljaCB0aGlzIGFycmF5IGlzIGEgcHJvcGVydHlcbiovXG5mdW5jdGlvbiB3cmFwQXJyYXkoYXJyYXksIGZpZWxkLCBzaWVzdGFNb2RlbCkge1xuICAgIGlmICghYXJyYXkub2JzZXJ2ZXIpIHtcbiAgICAgICAgYXJyYXkub2JzZXJ2ZXIgPSBuZXcgQXJyYXlPYnNlcnZlcihhcnJheSk7XG4gICAgICAgIGFycmF5Lm9ic2VydmVyLm9wZW4oZnVuY3Rpb24gKHNwbGljZXMpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZElzQXR0cmlidXRlID0gc2llc3RhTW9kZWwuX2ZpZWxkcy5pbmRleE9mKGZpZWxkKSA+IC0xO1xuICAgICAgICAgICAgaWYgKGZpZWxkSXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBzcGxpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNwbGljZSkge1xuICAgICAgICAgICAgICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBzaWVzdGFNb2RlbC5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogc2llc3RhTW9kZWwubWFwcGluZy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBzaWVzdGFNb2RlbC5faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogc3BsaWNlLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZDogc3BsaWNlLnJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRlZDogc3BsaWNlLmFkZGVkQ291bnQgPyBhcnJheS5zbGljZShzcGxpY2UuaW5kZXgsIHNwbGljZS5pbmRleCtzcGxpY2UuYWRkZWRDb3VudCkgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvcmVDaGFuZ2VzLkNoYW5nZVR5cGUuU3BsaWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqOiBzaWVzdGFNb2RlbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGFycmF5LmlzRmF1bHQgPSBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydHMubm90aWZpY2F0aW9uQ2VudHJlID0gbm90aWZpY2F0aW9uQ2VudHJlO1xuZXhwb3J0cy53cmFwQXJyYXkgPSB3cmFwQXJyYXk7IiwidmFyIGxvZyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9sb2cnKTtcbnZhciBMb2dnZXIgPSBsb2cubG9nZ2VyV2l0aE5hbWUoJ1NpZXN0YU1vZGVsJyk7XG5Mb2dnZXIuc2V0TGV2ZWwobG9nLkxldmVsLndhcm4pO1xuXG52YXIgZGVmaW5lU3ViUHJvcGVydHkgPSByZXF1aXJlKCcuL21pc2MnKS5kZWZpbmVTdWJQcm9wZXJ0eTtcbi8vdmFyIE9wZXJhdGlvblF1ZXVlID0gcmVxdWlyZSgnLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL3F1ZXVlJykuT3BlcmF0aW9uUXVldWU7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIF8gPSB1dGlsLl87XG52YXIgZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG52YXIgSW50ZXJuYWxTaWVzdGFFcnJvciA9IGVycm9yLkludGVybmFsU2llc3RhRXJyb3I7XG52YXIgY29yZUNoYW5nZXMgPSByZXF1aXJlKCcuL2NoYW5nZXMnKTtcblxudmFyIHEgPSByZXF1aXJlKCdxJyk7XG5cbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcblxuLy92YXIgcXVldWVzID0ge307XG5cbmZ1bmN0aW9uIFNpZXN0YU1vZGVsKG1hcHBpbmcpIHtcblxuICAgIGlmICghdGhpcykge1xuICAgICAgICByZXR1cm4gbmV3IFNpZXN0YU1vZGVsKG1hcHBpbmcpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5tYXBwaW5nID0gbWFwcGluZztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lkRmllbGQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5tYXBwaW5nLmlkID8gc2VsZi5tYXBwaW5nLmlkIDogJ2lkJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAndHlwZScsIHRoaXMubWFwcGluZyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnY29sbGVjdGlvbicsIHRoaXMubWFwcGluZyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnX2ZpZWxkcycsIHRoaXMubWFwcGluZyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfcmVsYXRpb25zaGlwRmllbGRzJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF8ubWFwKHNlbGYuX3Byb3hpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocC5pc0ZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuZm9yd2FyZE5hbWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAucmV2ZXJzZU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG5cbiAgICB0aGlzLmlzRmF1bHQgPSBmYWxzZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNTYXZlZCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXNlbGYuX3JldjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXYgPSBudWxsO1xuXG4gICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7XG59XG5cbi8qKlxuICogSHVtYW4gcmVhZGFibGUgZHVtcCBvZiB0aGlzIG9iamVjdFxuICogQHJldHVybnMgeyp9XG4gKiBAcHJpdmF0ZVxuICovXG5TaWVzdGFNb2RlbC5wcm90b3R5cGUuX2R1bXAgPSBmdW5jdGlvbihhc0pzb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsZWFuT2JqID0ge307XG4gICAgY2xlYW5PYmoubWFwcGluZyA9IHRoaXMubWFwcGluZy50eXBlO1xuICAgIGNsZWFuT2JqLmNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XG4gICAgY2xlYW5PYmouX2lkID0gdGhpcy5faWQ7XG4gICAgY2xlYW5PYmogPSBfLnJlZHVjZSh0aGlzLl9maWVsZHMsIGZ1bmN0aW9uKG1lbW8sIGYpIHtcbiAgICAgICAgaWYgKHNlbGZbZl0pIHtcbiAgICAgICAgICAgIG1lbW9bZl0gPSBzZWxmW2ZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIGNsZWFuT2JqKTtcbiAgICBjbGVhbk9iaiA9IF8ucmVkdWNlKHRoaXMuX3JlbGF0aW9uc2hpcEZpZWxkcywgZnVuY3Rpb24obWVtbywgZikge1xuICAgICAgICBpZiAoc2VsZltmICsgJ1Byb3h5J10pIHtcbiAgICAgICAgICAgIGlmIChzZWxmW2YgKyAnUHJveHknXS5oYXNPd25Qcm9wZXJ0eSgnX2lkJykpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KHNlbGZbZiArICdQcm94eSddLl9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGZbZl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vW2ZdID0gc2VsZltmICsgJ1Byb3h5J10uX2lkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmW2YgKyAnUHJveHknXS5faWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1tmXSA9IHNlbGZbZiArICdQcm94eSddLl9pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lbW9bZl0gPSBzZWxmW2ZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIGNsZWFuT2JqKTtcblxuICAgIHJldHVybiBhc0pzb24gPyBKU09OLnN0cmluZ2lmeShjbGVhbk9iaiwgbnVsbCwgNCkgOiBjbGVhbk9iajtcbn07XG5cblxuU2llc3RhTW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5TaWVzdGFNb2RlbC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBxLmRlZmVyKCk7XG4gICAgY2FsbGJhY2sgPSB1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIoY2FsbGJhY2ssIGRlZmVycmVkKTtcbiAgICBjYWNoZS5yZW1vdmUodGhpcyk7XG4gICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgIGNvbGxlY3Rpb246IHRoaXMuY29sbGVjdGlvbixcbiAgICAgICAgbWFwcGluZzogdGhpcy5tYXBwaW5nLnR5cGUsXG4gICAgICAgIF9pZDogdGhpcy5faWQsXG4gICAgICAgIG9sZElkOiB0aGlzLl9pZCxcbiAgICAgICAgb2xkOiB0aGlzLFxuICAgICAgICB0eXBlOiBjb3JlQ2hhbmdlcy5DaGFuZ2VUeXBlLlJlbW92ZSxcbiAgICAgICAgb2JqOiB0aGlzXG4gICAgfSk7XG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcyk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cblNpZXN0YU1vZGVsLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBxLmRlZmVyKCk7XG4gICAgY2FsbGJhY2sgPSB1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIoY2FsbGJhY2ssIGRlZmVycmVkKTtcbiAgICBpZiAodGhpcy5yZW1vdmVkKSB7XG4gICAgICAgIGNhY2hlLmluc2VydCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbiAgICAgICAgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uLFxuICAgICAgICBtYXBwaW5nOiB0aGlzLm1hcHBpbmcudHlwZSxcbiAgICAgICAgX2lkOiB0aGlzLl9pZCxcbiAgICAgICAgbmV3SWQ6IHRoaXMuX2lkLFxuICAgICAgICBuZXc6IHRoaXMsXG4gICAgICAgIHR5cGU6IGNvcmVDaGFuZ2VzLkNoYW5nZVR5cGUuTmV3LFxuICAgICAgICBvYmo6IHRoaXNcbiAgICB9KTtcbiAgICBjYWxsYmFjayhudWxsLCB0aGlzKTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuZXhwb3J0cy5TaWVzdGFNb2RlbCA9IFNpZXN0YU1vZGVsO1xuZXhwb3J0cy5kdW1wU2F2ZVF1ZXVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkdW1wZWQgPSB7fTtcbiAgICBmb3IgKHZhciBpZCBpbiBxdWV1ZXMpIHtcbiAgICAgICAgaWYgKHF1ZXVlcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHZhciBxdWV1ZSA9IHF1ZXVlc1tpZF07XG4gICAgICAgICAgICBkdW1wZWRbaWRdID0ge1xuICAgICAgICAgICAgICAgIG51bVJ1bm5pbmc6IHF1ZXVlLm51bVJ1bm5pbmdPcGVyYXRpb25zLFxuICAgICAgICAgICAgICAgIHF1ZXVlZDogcXVldWUuX3F1ZXVlZE9wZXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkdW1wZWQ7XG59OyIsIi8qKlxuICogQG1vZHVsZSByZWxhdGlvbnNoaXBzXG4gKi9cblxudmFyIHByb3h5ID0gcmVxdWlyZSgnLi9wcm94eScpXG4gICAgLCBSZWxhdGlvbnNoaXBQcm94eSA9IHByb3h5LlJlbGF0aW9uc2hpcFByb3h5XG4gICAgLCBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKVxuICAgICwgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG4gICAgLCBfID0gdXRpbC5fXG4gICAgLCBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3JcbiAgICAsIGNvcmVDaGFuZ2VzID0gcmVxdWlyZSgnLi9jaGFuZ2VzJylcbiAgICAsIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi9vYmplY3QnKS5TaWVzdGFNb2RlbFxuICAgICwgbm90aWZpY2F0aW9uQ2VudHJlID0gcmVxdWlyZSgnLi9ub3RpZmljYXRpb25DZW50cmUnKVxuICAgICwgd3JhcEFycmF5Rm9yQXR0cmlidXRlcyA9IG5vdGlmaWNhdGlvbkNlbnRyZS53cmFwQXJyYXlcbiAgICAsIEFycmF5T2JzZXJ2ZXIgPSByZXF1aXJlKCcuLi92ZW5kb3Ivb2JzZXJ2ZS1qcy9zcmMvb2JzZXJ2ZScpLkFycmF5T2JzZXJ2ZXJcbiAgICAsIENoYW5nZVR5cGUgPSByZXF1aXJlKCcuL2NoYW5nZXMnKS5DaGFuZ2VUeXBlXG4gICAgLCBxID0gcmVxdWlyZSgncScpXG4gICAgO1xuXG4vKipcbiAqIEBjbGFzcyAgW09uZVRvTWFueVByb3h5IGRlc2NyaXB0aW9uXVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1t0eXBlXX0gb3B0c1xuICovXG5mdW5jdGlvbiBPbmVUb01hbnlQcm94eShvcHRzKSB7XG4gICAgUmVsYXRpb25zaGlwUHJveHkuY2FsbCh0aGlzLCBvcHRzKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzRmF1bHQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNGb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VsZi5yZWxhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLl9pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLnJlbGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9pZC5sZW5ndGggIT0gc2VsZi5yZWxhdGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlUmVsYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbGF0ZWQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0ZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbGF0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBBcnJheS5jYWxsKHNlbGYsIHNlbGYucmVsYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9yZXZlcnNlSXNBcnJheSA9IHRydWU7XG4gICAgdGhpcy5fZm9yd2FyZElzQXJyYXkgPSBmYWxzZTtcbn1cblxuT25lVG9NYW55UHJveHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWxhdGlvbnNoaXBQcm94eS5wcm90b3R5cGUpO1xuXG5cbmZ1bmN0aW9uIGNsZWFyUmV2ZXJzZShyZW1vdmVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIF8uZWFjaChyZW1vdmVkLCBmdW5jdGlvbiAocmVtb3ZlZE9iamVjdCkge1xuICAgICAgICB2YXIgcmV2ZXJzZVByb3h5ID0gcHJveHkuZ2V0UmV2ZXJzZVByb3h5Rm9yT2JqZWN0LmNhbGwoc2VsZiwgcmVtb3ZlZE9iamVjdCk7XG4gICAgICAgIHByb3h5LnNldC5jYWxsKHJldmVyc2VQcm94eSwgbnVsbCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldFJldmVyc2UoYWRkZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXy5lYWNoKGFkZGVkLCBmdW5jdGlvbiAoYWRkZWQpIHtcbiAgICAgICAgdmFyIGZvcndhcmRQcm94eSA9IHByb3h5LmdldFJldmVyc2VQcm94eUZvck9iamVjdC5jYWxsKHNlbGYsIGFkZGVkKTtcbiAgICAgICAgcHJveHkuc2V0LmNhbGwoZm9yd2FyZFByb3h5LCBzZWxmLm9iamVjdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBcnJheShhcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgd3JhcEFycmF5Rm9yQXR0cmlidXRlcyhhcnIsIHRoaXMucmV2ZXJzZU5hbWUsIHRoaXMub2JqZWN0KTtcbiAgICBpZiAoIWFyci5vbmVUb01hbnlPYnNlcnZlcikge1xuICAgICAgICBhcnIub25lVG9NYW55T2JzZXJ2ZXIgPSBuZXcgQXJyYXlPYnNlcnZlcihhcnIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChzcGxpY2VzKSB7XG4gICAgICAgICAgICBzcGxpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNwbGljZSkge1xuICAgICAgICAgICAgICAgIHZhciBhZGRlZCA9IHNwbGljZS5hZGRlZENvdW50ID8gYXJyLnNsaWNlKHNwbGljZS5pbmRleCwgc3BsaWNlLmluZGV4ICsgc3BsaWNlLmFkZGVkQ291bnQpIDogW107XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWQgPSBzcGxpY2UucmVtb3ZlZDtcbiAgICAgICAgICAgICAgICBjbGVhclJldmVyc2UuY2FsbChzZWxmLCByZW1vdmVkKTtcbiAgICAgICAgICAgICAgICBzZXRSZXZlcnNlLmNhbGwoc2VsZiwgYWRkZWQpO1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0gcHJveHkuZ2V0Rm9yd2FyZE1hcHBpbmcuY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IG1hcHBpbmcuY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogbWFwcGluZy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBfaWQ6IHNlbGYub2JqZWN0Ll9pZCxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHByb3h5LmdldEZvcndhcmROYW1lLmNhbGwoc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZElkOiBfLnBsdWNrKHJlbW92ZWQsICdfaWQnKSxcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJZDogXy5wbHVjayhhZGRlZCwgJ19pZCcpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNwbGljZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHNwbGljZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgb2JqOiBzZWxmLm9iamVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGFyci5vbmVUb01hbnlPYnNlcnZlci5vcGVuKG9ic2VydmVyRnVuY3Rpb24pO1xuICAgIH1cbn1cblxuXG5PbmVUb01hbnlQcm94eS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLmlzRmF1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lkLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHN0b3JlT3B0cyA9IHtfaWQ6IHRoaXMuX2lkfTtcbiAgICAgICAgICAgIFN0b3JlLmdldChzdG9yZU9wdHMsIGZ1bmN0aW9uIChlcnIsIHN0b3JlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWxhdGVkID0gc3RvcmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIHN0b3JlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRoaXMucmVsYXRlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgdGhpcy5yZWxhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBvYmplY3QgdGhhdCB3ZSdyZSBzZXR0aW5nXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IEFuIGVycm9yIG1lc3NhZ2Ugb3IgbnVsbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShvYmopIHtcbiAgICB2YXIgc3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgaWYgKHRoaXMuaXNGb3J3YXJkKSB7XG4gICAgICAgIGlmIChzdHIgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgcmV0dXJuICdDYW5ub3QgYXNzaWduIGFycmF5IGZvcndhcmQgb25lVG9NYW55ICgnICsgc3RyICsgJyk6ICcgKyB0aGlzLmZvcndhcmROYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3RyICE9ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2Fubm90IHNjYWxhciB0byByZXZlcnNlIG9uZVRvTWFueSAoJyArIHN0ciArICcpOiAnICsgdGhpcy5yZXZlcnNlTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZWxhdGVkKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5faWQpIHtcbiAgICAgICAgaWYgKHNlbGYucmVsYXRlZCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuX2lkLmxlbmd0aCAhPSBzZWxmLnJlbGF0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucmVsYXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdfaWQgYW5kIHJlbGF0ZWQgYXJlIHNvbWVob3cgb3V0IG9mIHN5bmMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk9uZVRvTWFueVByb3h5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcHJveHkuY2hlY2tJbnN0YWxsZWQuY2FsbCh0aGlzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKG9iaikge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlO1xuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlID0gdmFsaWRhdGUuY2FsbCh0aGlzLCBvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJveHkuY2xlYXJSZXZlcnNlUmVsYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgcHJveHkuc2V0LmNhbGwoc2VsZiwgb2JqKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzUmV2ZXJzZSkge1xuICAgICAgICAgICAgICAgIHdyYXBBcnJheS5jYWxsKHRoaXMsIHNlbGYucmVsYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm94eS5zZXRSZXZlcnNlLmNhbGwoc2VsZiwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJveHkuY2xlYXJSZXZlcnNlUmVsYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgICBwcm94eS5zZXQuY2FsbChzZWxmLCBvYmopO1xuICAgIH1cbn07XG5cbk9uZVRvTWFueVByb3h5LnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKG9iaikge1xuICAgIFJlbGF0aW9uc2hpcFByb3h5LnByb3RvdHlwZS5pbnN0YWxsLmNhbGwodGhpcywgb2JqKTtcbiAgICBpZiAodGhpcy5pc1JldmVyc2UpIHtcbiAgICAgICAgb2JqWyAoJ3NwbGljZScgKyB1dGlsLmNhcGl0YWxpc2VGaXJzdExldHRlcih0aGlzLnJldmVyc2VOYW1lKSldID0gXy5iaW5kKHByb3h5LnNwbGljZSwgdGhpcyk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLk9uZVRvTWFueVByb3h5ID0gT25lVG9NYW55UHJveHk7IiwiLyoqXG4gKiBAbW9kdWxlIHJlbGF0aW9uc2hpcHNcbiAqL1xuXG52YXIgcHJveHkgPSByZXF1aXJlKCcuL3Byb3h5JylcbiAgICAsIFJlbGF0aW9uc2hpcFByb3h5ID0gcHJveHkuUmVsYXRpb25zaGlwUHJveHlcbiAgICAsIFN0b3JlID0gcmVxdWlyZSgnLi9zdG9yZScpXG4gICAgLCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbiAgICAsIEludGVybmFsU2llc3RhRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvclxuICAgICwgcSA9IHJlcXVpcmUoJ3EnKVxuICAgICwgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuXG4vKipcbiAqIFtPbmVUb09uZVByb3h5IGRlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuZnVuY3Rpb24gT25lVG9PbmVQcm94eShvcHRzKSB7XG4gICAgUmVsYXRpb25zaGlwUHJveHkuY2FsbCh0aGlzLCBvcHRzKTtcbiAgICB0aGlzLl9yZXZlcnNlSXNBcnJheSA9IGZhbHNlO1xuICAgIHRoaXMuX2ZvcndhcmRJc0FycmF5ID0gZmFsc2U7XG59XG5cbk9uZVRvT25lUHJveHkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWxhdGlvbnNoaXBQcm94eS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBvYmplY3QgdGhhdCB3ZSdyZSBzZXR0aW5nXG4gKiBAcGFyYW0gb2JqXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IEFuIGVycm9yIG1lc3NhZ2Ugb3IgbnVsbFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZShvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXR1cm4gJ0Nhbm5vdCBhc3NpZ24gYXJyYXkgdG8gb25lIHRvIG9uZSByZWxhdGlvbnNoaXAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgoIW9iaiBpbnN0YW5jZW9mIFNpZXN0YU1vZGVsKSkge1xuXG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5PbmVUb09uZVByb3h5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcHJveHkuY2hlY2tJbnN0YWxsZWQuY2FsbCh0aGlzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKG9iaikge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlO1xuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlID0gdmFsaWRhdGUob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3h5LmNsZWFyUmV2ZXJzZVJlbGF0ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHByb3h5LnNldC5jYWxsKHNlbGYsIG9iaik7XG4gICAgICAgICAgICBwcm94eS5zZXRSZXZlcnNlLmNhbGwoc2VsZiwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJveHkuY2xlYXJSZXZlcnNlUmVsYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgICBwcm94eS5zZXQuY2FsbChzZWxmLCBvYmopO1xuICAgIH1cbn07XG5cbk9uZVRvT25lUHJveHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5faWQpIHtcbiAgICAgICAgU3RvcmUuZ2V0KHtfaWQ6IHRoaXMuX2lkfSwgZnVuY3Rpb24gKGVyciwgc3RvcmVkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWxhdGVkID0gc3RvcmVkO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sobnVsbCwgc3RvcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5leHBvcnRzLk9uZVRvT25lUHJveHkgPSBPbmVUb09uZVByb3h5OyIsIi8qKlxuICogQG1vZHVsZSByZWxhdGlvbnNoaXBzXG4gKi9cblxudmFyIEludGVybmFsU2llc3RhRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcixcbiAgICBTdG9yZSA9IHJlcXVpcmUoJy4vc3RvcmUnKSxcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vbWlzYycpLmRlZmluZVN1YlByb3BlcnR5LFxuICAgIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9vcGVyYXRpb24nKS5PcGVyYXRpb24sXG4gICAgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIF8gPSB1dGlsLl8sXG4gICAgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5JykuUXVlcnksXG4gICAgbG9nID0gcmVxdWlyZSgnLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL2xvZycpLFxuICAgIG5vdGlmaWNhdGlvbkNlbnRyZSA9IHJlcXVpcmUoJy4vbm90aWZpY2F0aW9uQ2VudHJlJyksXG4gICAgd3JhcEFycmF5Rm9yQXR0cmlidXRlcyA9IG5vdGlmaWNhdGlvbkNlbnRyZS53cmFwQXJyYXksXG4gICAgQXJyYXlPYnNlcnZlciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vYnNlcnZlLWpzL3NyYy9vYnNlcnZlJykuQXJyYXlPYnNlcnZlcixcbiAgICBjb3JlQ2hhbmdlcyA9IHJlcXVpcmUoJy4vY2hhbmdlcycpLFxuICAgIENoYW5nZVR5cGUgPSBjb3JlQ2hhbmdlcy5DaGFuZ2VUeXBlO1xuXG4vKipcbiAqIEBjbGFzcyAgW0ZhdWx0IGRlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtSZWxhdGlvbnNoaXBQcm94eX0gcHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGYXVsdChwcm94eSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnByb3h5ID0gcHJveHk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpc0ZhdWx0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJveHkuaXNGYXVsdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5cbkZhdWx0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnByb3h5LmdldC5hcHBseSh0aGlzLnByb3h5LCBhcmd1bWVudHMpO1xufTtcblxuRmF1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHJveHkuc2V0LmFwcGx5KHRoaXMucHJveHksIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIEBjbGFzcyAgW1JlbGF0aW9uc2hpcFByb3h5IGRlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZWxhdGlvbnNoaXBQcm94eShvcHRzKSB7XG4gICAgdGhpcy5fb3B0cyA9IG9wdHM7XG4gICAgaWYgKCF0aGlzKSByZXR1cm4gbmV3IFJlbGF0aW9uc2hpcFByb3h5KG9wdHMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZhdWx0ID0gbmV3IEZhdWx0KHRoaXMpO1xuICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9pZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJlbGF0ZWQgPSBudWxsO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNGYXVsdCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc2VsZi5yZWxhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLl9pZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5faWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5yZWxhdGVkID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLl9pZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdyZXZlcnNlTWFwcGluZycsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ2ZvcndhcmRNYXBwaW5nJywgdGhpcy5fb3B0cyk7XG4gICAgZGVmaW5lU3ViUHJvcGVydHkuY2FsbCh0aGlzLCAnZm9yd2FyZE5hbWUnLCB0aGlzLl9vcHRzKTtcbiAgICBkZWZpbmVTdWJQcm9wZXJ0eS5jYWxsKHRoaXMsICdyZXZlcnNlTmFtZScsIHRoaXMuX29wdHMpO1xuICAgIGRlZmluZVN1YlByb3BlcnR5LmNhbGwodGhpcywgJ2lzUmV2ZXJzZScsIHRoaXMuX29wdHMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNGb3J3YXJkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICFzZWxmLmlzUmV2ZXJzZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgc2VsZi5pc1JldmVyc2UgPSAhdjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX29wdHMuaXNSZXZlcnNlID09PSB1bmRlZmluZWQgJiYgdGhpcy5fb3B0cy5pc0ZvcndhcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlzUmV2ZXJzZSA9ICF0aGlzLl9vcHRzLmlzRm9yd2FyZDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fb3B0cy5pc1JldmVyc2UgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9vcHRzLmlzRm9yd2FyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEludGVybmFsU2llc3RhRXJyb3IoJ011c3Qgc3BlY2lmeSBlaXRoZXIgaXNSZXZlcnNlIG9yIGlzRm9yd2FyZCB3aGVuIGNvbmZpZ3VyaW5nIHJlbGF0aW9uc2hpcCBwcm94eS4nKTtcbiAgICB9XG4gfVxuXG5SZWxhdGlvbnNoaXBQcm94eS5wcm90b3R5cGUuX2R1bXAgPSBmdW5jdGlvbihhc0pzb24pIHtcbiAgICB2YXIgZHVtcGVkID0ge307XG59O1xuXG5SZWxhdGlvbnNoaXBQcm94eS5wcm90b3R5cGUuaW5zdGFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmopIHtcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmo7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGdldEZvcndhcmROYW1lLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNGYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZWxhdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXQodik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvYmpbKCdnZXQnICsgdXRpbC5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIobmFtZSkpXSA9IF8uYmluZCh0aGlzLmdldCwgdGhpcyk7XG4gICAgICAgICAgICBvYmpbKCdzZXQnICsgdXRpbC5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIobmFtZSkpXSA9IF8uYmluZCh0aGlzLnNldCwgdGhpcyk7XG4gICAgICAgICAgICBvYmpbbmFtZSArICdQcm94eSddID0gdGhpcztcbiAgICAgICAgICAgIGlmICghb2JqLl9wcm94aWVzKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9wcm94aWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvYmouX3Byb3hpZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdBbHJlYWR5IGluc3RhbGxlZC4nKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdObyBvYmplY3QgcGFzc2VkIHRvIHJlbGF0aW9uc2hpcCBpbnN0YWxsJyk7XG4gICAgfVxufTtcblxuUmVsYXRpb25zaGlwUHJveHkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdNdXN0IHN1YmNsYXNzIFJlbGF0aW9uc2hpcFByb3h5Jyk7XG59O1xuXG5SZWxhdGlvbnNoaXBQcm94eS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcignTXVzdCBzdWJjbGFzcyBSZWxhdGlvbnNoaXBQcm94eScpO1xufTtcblxuZnVuY3Rpb24gdmVyaWZ5TWFwcGluZyhvYmosIG1hcHBpbmcpIHtcbiAgICBpZiAob2JqLm1hcHBpbmcgIT0gbWFwcGluZykge1xuICAgICAgICB2YXIgZXJyID0gJ01hcHBpbmcgZG9lcyBub3QgbWF0Y2guIEV4cGVjdGVkICcgKyBtYXBwaW5nLnR5cGUgKyAnIGJ1dCBnb3QgJyArIG9iai5tYXBwaW5nLnR5cGU7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKGVycik7XG4gICAgfVxufVxuXG4vLyBUT0RPOiBTaGFyZSBjb2RlIGJldHdlZW4gZ2V0UmV2ZXJzZVByb3h5Rm9yT2JqZWN0IGFuZCBnZXRGb3J3YXJkUHJveHlGb3JPYmplY3RcblxuZnVuY3Rpb24gZ2V0UmV2ZXJzZVByb3h5Rm9yT2JqZWN0KG9iaikge1xuICAgIHZhciByZXZlcnNlTmFtZSA9IGdldFJldmVyc2VOYW1lLmNhbGwodGhpcyk7XG4gICAgdmFyIHByb3h5TmFtZSA9IChyZXZlcnNlTmFtZSArICdQcm94eScpO1xuICAgIHZhciByZXZlcnNlTWFwcGluZyA9IHRoaXMucmV2ZXJzZU1hcHBpbmc7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBTaG91bGQgZyAgIGV0IGNhdWdodCBpbiB0aGUgbWFwcGluZyBvcGVyYXRpb24/XG4gICAgaWYgKHV0aWwuaXNBcnJheShvYmopKSB7XG4gICAgICAgIC8vIF8uZWFjaChvYmosIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgLy8gICAgIHZlcmlmeU1hcHBpbmcobywgdGhpcy5mb3J3YXJkTWFwcGluZyk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICByZXR1cm4gXy5wbHVjayhvYmosIHByb3h5TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdmVyaWZ5TWFwcGluZyhvYmosIHRoaXMuZm9yd2FyZE1hcHBpbmcpO1xuICAgICAgICB2YXIgcHJveHkgPSBvYmpbcHJveHlOYW1lXTtcbiAgICAgICAgaWYgKCFwcm94eSkge1xuICAgICAgICAgICAgdmFyIGVyciA9ICdObyBwcm94eSB3aXRoIG5hbWUgXCInICsgcHJveHlOYW1lICsgJ1wiIG9uIG1hcHBpbmcgJyArIHJldmVyc2VNYXBwaW5nLnR5cGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEZvcndhcmRQcm94eUZvck9iamVjdChvYmopIHtcbiAgICB2YXIgZm9yd2FyZE5hbWUgPSBnZXRGb3J3YXJkTmFtZS5jYWxsKHRoaXMpO1xuICAgIHZhciBwcm94eU5hbWUgPSBmb3J3YXJkTmFtZSArICdQcm94eSc7XG4gICAgdmFyIGZvcndhcmRNYXBwaW5nID0gdGhpcy5mb3J3YXJkTWFwcGluZztcbiAgICBpZiAodXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgLy8gXy5lYWNoKG9iaiwgZnVuY3Rpb24obykge1xuICAgICAgICAvLyAgICAgdmVyaWZ5TWFwcGluZyhvLCB0aGlzLnJldmVyc2VNYXBwaW5nKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIHJldHVybiBfLnBsdWNrKG9iaiwgcHJveHlOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2ZXJpZnlNYXBwaW5nKG9iaiwgdGhpcy5yZXZlcnNlTWFwcGluZyk7XG4gICAgICAgIHZhciBwcm94eSA9IG9ialtwcm94eU5hbWVdO1xuICAgICAgICBpZiAoIXByb3h5KSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gJ05vIHByb3h5IHdpdGggbmFtZSBcIicgKyBwcm94eU5hbWUgKyAnXCIgb24gbWFwcGluZyAnICsgZm9yd2FyZE1hcHBpbmcudHlwZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3h5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmV2ZXJzZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGb3J3YXJkID8gdGhpcy5yZXZlcnNlTmFtZSA6IHRoaXMuZm9yd2FyZE5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldEZvcndhcmROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzRm9yd2FyZCA/IHRoaXMuZm9yd2FyZE5hbWUgOiB0aGlzLnJldmVyc2VOYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRSZXZlcnNlTWFwcGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ZvcndhcmQgPyB0aGlzLnJldmVyc2VNYXBwaW5nIDogdGhpcy5mb3J3YXJkTWFwcGluZztcbn1cblxuZnVuY3Rpb24gZ2V0Rm9yd2FyZE1hcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGb3J3YXJkID8gdGhpcy5mb3J3YXJkTWFwcGluZyA6IHRoaXMucmV2ZXJzZU1hcHBpbmc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5zdGFsbGVkKCkge1xuICAgIGlmICghdGhpcy5vYmplY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsU2llc3RhRXJyb3IoJ1Byb3h5IG11c3QgYmUgaW5zdGFsbGVkIG9uIGFuIG9iamVjdCBiZWZvcmUgY2FuIHVzZSBpdC4nKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29uZmlndXJlIF9pZCBhbmQgcmVsYXRlZCB3aXRoIHRoZSBuZXcgcmVsYXRlZCBvYmplY3QuXG4gKiBAcGFyYW0gb2JqXG4gKi9cbmZ1bmN0aW9uIHNldChvYmopIHtcbiAgICByZWdpc3RlclNldENoYW5nZS5jYWxsKHRoaXMsIG9iaik7XG4gICAgaWYgKG9iaikge1xuICAgICAgICBpZiAodXRpbC5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gXy5wbHVjayhvYmosICdfaWQnKTtcbiAgICAgICAgICAgIHRoaXMucmVsYXRlZCA9IG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lkID0gb2JqLl9pZDtcbiAgICAgICAgICAgIHRoaXMucmVsYXRlZCA9IG9iajtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWxhdGVkID0gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNwbGljZShpZHgsIG51bVJlbW92ZSkge1xuICAgIHJlZ2lzdGVyU3BsaWNlQ2hhbmdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGFkZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIHJldHVyblZhbHVlID0gXy5wYXJ0aWFsKHRoaXMuX2lkLnNwbGljZSwgaWR4LCBudW1SZW1vdmUpLmFwcGx5KHRoaXMuX2lkLCBfLnBsdWNrKGFkZCwgJ19pZCcpKTtcbiAgICBpZiAodGhpcy5yZWxhdGVkKSB7XG4gICAgICAgIF8ucGFydGlhbCh0aGlzLnJlbGF0ZWQuc3BsaWNlLCBpZHgsIG51bVJlbW92ZSkuYXBwbHkodGhpcy5yZWxhdGVkLCBhZGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmZ1bmN0aW9uIG9iakFzU3RyaW5nKG9iaikge1xuICAgIGZ1bmN0aW9uIF9vYmpBc1N0cmluZyhvYmopIHtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcgPSBvYmoubWFwcGluZztcbiAgICAgICAgICAgIHZhciBtYXBwaW5nTmFtZSA9IG1hcHBpbmcudHlwZTtcbiAgICAgICAgICAgIHZhciBpZGVudCA9IG9iai5faWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkZW50ID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWRlbnQgPSAnXCInICsgaWRlbnQgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmdOYW1lICsgJ1tfaWQ9JyArIGlkZW50ICsgJ10nO1xuICAgICAgICB9IGVsc2UgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaXNBcnJheShvYmopKSByZXR1cm4gXy5tYXAoX29iakFzU3RyaW5nLCBvYmopLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIF9vYmpBc1N0cmluZyhvYmopO1xufVxuXG5mdW5jdGlvbiBjbGVhclJldmVyc2VSZWxhdGVkKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYuaXNGYXVsdCkge1xuICAgICAgICBpZiAodGhpcy5yZWxhdGVkKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZVByb3h5ID0gZ2V0UmV2ZXJzZVByb3h5Rm9yT2JqZWN0LmNhbGwodGhpcywgdGhpcy5yZWxhdGVkKTtcbiAgICAgICAgICAgIHZhciByZXZlcnNlUHJveGllcyA9IHV0aWwuaXNBcnJheShyZXZlcnNlUHJveHkpID8gcmV2ZXJzZVByb3h5IDogW3JldmVyc2VQcm94eV07XG4gICAgICAgICAgICBfLmVhY2gocmV2ZXJzZVByb3hpZXMsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KHAuX2lkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gcC5faWQuaW5kZXhPZihzZWxmLm9iamVjdC5faWQpO1xuICAgICAgICAgICAgICAgICAgICBtYWtlQ2hhbmdlc1RvUmVsYXRlZFdpdGhvdXRPYnNlcnZhdGlvbnMuY2FsbChwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5jYWxsKHAsIGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5jYWxsKHAsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNlbGYuX2lkKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZU5hbWUgPSBnZXRSZXZlcnNlTmFtZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJldmVyc2VNYXBwaW5nID0gZ2V0UmV2ZXJzZU1hcHBpbmcuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IHV0aWwuaXNBcnJheShzZWxmLl9pZCkgPyBzZWxmLl9pZCA6IFtzZWxmLl9pZF07XG4gICAgICAgICAgICBpZiAodGhpcy5fcmV2ZXJzZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goaWRlbnRpZmllcnMsIGZ1bmN0aW9uKF9pZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiByZXZlcnNlTWFwcGluZy5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogcmV2ZXJzZU1hcHBpbmcudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHJldmVyc2VOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZElkOiBbc2VsZi5vYmplY3QuX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IFtzZWxmLm9iamVjdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLkRlbGV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iajogc2VsZi5vYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uZWFjaChpZGVudGlmaWVycywgZnVuY3Rpb24oX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IHJldmVyc2VNYXBwaW5nLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiByZXZlcnNlTWFwcGluZy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogcmV2ZXJzZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXc6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdJZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZElkOiBzZWxmLm9iamVjdC5faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHNlbGYub2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmo6IHNlbGYub2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZ2V0Rm9yd2FyZE5hbWUuY2FsbCh0aGlzKSArICcgaGFzIG5vIF9pZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ2hhbmdlc1RvUmVsYXRlZFdpdGhvdXRPYnNlcnZhdGlvbnMoZikge1xuICAgIGlmICh0aGlzLnJlbGF0ZWQpIHtcbiAgICAgICAgdGhpcy5yZWxhdGVkLm9uZVRvTWFueU9ic2VydmVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucmVsYXRlZC5vbmVUb01hbnlPYnNlcnZlciA9IG51bGw7XG4gICAgICAgIGYoKTtcbiAgICAgICAgd3JhcEFycmF5LmNhbGwodGhpcywgdGhpcy5yZWxhdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgZmF1bHQgd2UgY2FuIG1ha2UgY2hhbmdlcyBhbnl3YXkuXG4gICAgICAgIGYoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFJldmVyc2Uob2JqKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXZlcnNlUHJveHkgPSBnZXRSZXZlcnNlUHJveHlGb3JPYmplY3QuY2FsbCh0aGlzLCBvYmopO1xuICAgIHZhciByZXZlcnNlUHJveGllcyA9IHV0aWwuaXNBcnJheShyZXZlcnNlUHJveHkpID8gcmV2ZXJzZVByb3h5IDogW3JldmVyc2VQcm94eV07XG4gICAgXy5lYWNoKHJldmVyc2VQcm94aWVzLCBmdW5jdGlvbihwKSB7XG4gICAgICAgIGlmICh1dGlsLmlzQXJyYXkocC5faWQpKSB7XG4gICAgICAgICAgICBtYWtlQ2hhbmdlc1RvUmVsYXRlZFdpdGhvdXRPYnNlcnZhdGlvbnMuY2FsbChwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzcGxpY2UuY2FsbChwLCBwLl9pZC5sZW5ndGgsIDAsIHNlbGYub2JqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJSZXZlcnNlUmVsYXRlZC5jYWxsKHApO1xuICAgICAgICAgICAgc2V0LmNhbGwocCwgc2VsZi5vYmplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyU2V0Q2hhbmdlKG9iaikge1xuICAgIHZhciBwcm94eU9iamVjdCA9IHRoaXMub2JqZWN0O1xuICAgIGlmICghcHJveHlPYmplY3QpIHRocm93IG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdQcm94eSBtdXN0IGhhdmUgYW4gb2JqZWN0IGFzc29jaWF0ZWQnKTtcbiAgICB2YXIgbWFwcGluZyA9IHByb3h5T2JqZWN0Lm1hcHBpbmcudHlwZTtcbiAgICB2YXIgY29sbCA9IHByb3h5T2JqZWN0LmNvbGxlY3Rpb247XG4gICAgdmFyIG5ld0lkO1xuICAgIGlmICh1dGlsLmlzQXJyYXkob2JqKSkge1xuICAgICAgICBuZXdJZCA9IF8ucGx1Y2sob2JqLCAnX2lkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3SWQgPSBvYmogPyBvYmouX2lkIDogb2JqO1xuICAgIH1cbiAgICAvLyBXZSB0YWtlIFtdID09IG51bGwgPT0gdW5kZWZpbmVkIGluIHRoZSBjYXNlIG9mIHJlbGF0aW9uc2hpcHMuXG4gICAgdmFyIG9sZElkID0gdGhpcy5faWQ7XG4gICAgaWYgKHV0aWwuaXNBcnJheShvbGRJZCkgJiYgIW9sZElkLmxlbmd0aCkge1xuICAgICAgICBvbGRJZCA9IG51bGw7XG4gICAgfVxuICAgIHZhciBvbGQgPSB0aGlzLnJlbGF0ZWQ7XG4gICAgaWYgKHV0aWwuaXNBcnJheShvbGQpICYmICFvbGQubGVuZ3RoKSB7XG4gICAgICAgIG9sZCA9IG51bGw7XG4gICAgfVxuICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbiAgICAgICAgY29sbGVjdGlvbjogY29sbCxcbiAgICAgICAgbWFwcGluZzogbWFwcGluZyxcbiAgICAgICAgX2lkOiBwcm94eU9iamVjdC5faWQsXG4gICAgICAgIGZpZWxkOiBnZXRGb3J3YXJkTmFtZS5jYWxsKHRoaXMpLFxuICAgICAgICBuZXdJZDogbmV3SWQsXG4gICAgICAgIG9sZElkOiBvbGRJZCxcbiAgICAgICAgb2xkOiBvbGQsXG4gICAgICAgIG5ldzogb2JqLFxuICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNldCxcbiAgICAgICAgb2JqOiBwcm94eU9iamVjdFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclNwbGljZUNoYW5nZShpZHgsIG51bVJlbW92ZSkge1xuICAgIHZhciBhZGQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBtYXBwaW5nID0gdGhpcy5vYmplY3QubWFwcGluZy50eXBlO1xuICAgIHZhciBjb2xsID0gdGhpcy5vYmplY3QuY29sbGVjdGlvbjtcbiAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgIGNvbGxlY3Rpb246IGNvbGwsXG4gICAgICAgIG1hcHBpbmc6IG1hcHBpbmcsXG4gICAgICAgIF9pZDogdGhpcy5vYmplY3QuX2lkLFxuICAgICAgICBmaWVsZDogZ2V0Rm9yd2FyZE5hbWUuY2FsbCh0aGlzKSxcbiAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgcmVtb3ZlZElkOiB0aGlzLl9pZC5zbGljZShpZHgsIGlkeCArIG51bVJlbW92ZSksXG4gICAgICAgIHJlbW92ZWQ6IHRoaXMucmVsYXRlZCA/IHRoaXMucmVsYXRlZC5zbGljZShpZHgsIGlkeCArIG51bVJlbW92ZSkgOiBudWxsLFxuICAgICAgICBhZGRlZElkOiBhZGQubGVuZ3RoID8gXy5wbHVjayhhZGQsICdfaWQnKSA6IFtdLFxuICAgICAgICBhZGRlZDogYWRkLmxlbmd0aCA/IGFkZCA6IFtdLFxuICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNwbGljZSxcbiAgICAgICAgb2JqOiB0aGlzLm9iamVjdFxuICAgIH0pO1xufVxuXG5cbmZ1bmN0aW9uIHdyYXBBcnJheShhcnIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgd3JhcEFycmF5Rm9yQXR0cmlidXRlcyhhcnIsIHRoaXMucmV2ZXJzZU5hbWUsIHRoaXMub2JqZWN0KTtcbiAgICBpZiAoIWFyci5vbmVUb01hbnlPYnNlcnZlcikge1xuICAgICAgICBhcnIub25lVG9NYW55T2JzZXJ2ZXIgPSBuZXcgQXJyYXlPYnNlcnZlcihhcnIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uKHNwbGljZXMpIHtcbiAgICAgICAgICAgIHNwbGljZXMuZm9yRWFjaChmdW5jdGlvbihzcGxpY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWQgPSBzcGxpY2UuYWRkZWRDb3VudCA/IGFyci5zbGljZShzcGxpY2UuaW5kZXgsIHNwbGljZS5pbmRleCArIHNwbGljZS5hZGRlZENvdW50KSA6IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0gZ2V0Rm9yd2FyZE1hcHBpbmcuY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICBjb3JlQ2hhbmdlcy5yZWdpc3RlckNoYW5nZSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IG1hcHBpbmcuY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogbWFwcGluZy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBfaWQ6IHNlbGYub2JqZWN0Ll9pZCxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGdldEZvcndhcmROYW1lLmNhbGwoc2VsZiksXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IHNwbGljZS5yZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRJZDogXy5wbHVjayhzcGxpY2UucmVtb3ZlZCwgJ19pZCcpLFxuICAgICAgICAgICAgICAgICAgICBhZGRlZElkOiBfLnBsdWNrKHNwbGljZS5hZGRlZCwgJ19pZCcpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNwbGljZSxcbiAgICAgICAgICAgICAgICAgICAgb2JqOiBzZWxmLm9iamVjdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGFyci5vbmVUb01hbnlPYnNlcnZlci5vcGVuKG9ic2VydmVyRnVuY3Rpb24pO1xuICAgIH1cbn1cblxuZXhwb3J0cy5SZWxhdGlvbnNoaXBQcm94eSA9IFJlbGF0aW9uc2hpcFByb3h5O1xuZXhwb3J0cy5GYXVsdCA9IEZhdWx0O1xuZXhwb3J0cy5nZXRSZXZlcnNlUHJveHlGb3JPYmplY3QgPSBnZXRSZXZlcnNlUHJveHlGb3JPYmplY3Q7XG5leHBvcnRzLmdldEZvcndhcmRQcm94eUZvck9iamVjdCA9IGdldEZvcndhcmRQcm94eUZvck9iamVjdDtcbmV4cG9ydHMuZ2V0UmV2ZXJzZU5hbWUgPSBnZXRSZXZlcnNlTmFtZTtcbmV4cG9ydHMuZ2V0Rm9yd2FyZE5hbWUgPSBnZXRGb3J3YXJkTmFtZTtcbmV4cG9ydHMuZ2V0UmV2ZXJzZU1hcHBpbmcgPSBnZXRSZXZlcnNlTWFwcGluZztcbmV4cG9ydHMuZ2V0Rm9yd2FyZE1hcHBpbmcgPSBnZXRGb3J3YXJkTWFwcGluZztcbmV4cG9ydHMuY2hlY2tJbnN0YWxsZWQgPSBjaGVja0luc3RhbGxlZDtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5yZWdpc3RlclNldENoYW5nZSA9IHJlZ2lzdGVyU2V0Q2hhbmdlO1xuZXhwb3J0cy5zcGxpY2UgPSBzcGxpY2U7XG5leHBvcnRzLmNsZWFyUmV2ZXJzZVJlbGF0ZWQgPSBjbGVhclJldmVyc2VSZWxhdGVkO1xuZXhwb3J0cy5zZXRSZXZlcnNlID0gc2V0UmV2ZXJzZTtcbmV4cG9ydHMub2JqQXNTdHJpbmcgPSBvYmpBc1N0cmluZztcbmV4cG9ydHMud3JhcEFycmF5ID0gd3JhcEFycmF5O1xuZXhwb3J0cy5yZWdpc3RlclNwbGljZUNoYW5nZSA9IHJlZ2lzdGVyU3BsaWNlQ2hhbmdlO1xuZXhwb3J0cy5tYWtlQ2hhbmdlc1RvUmVsYXRlZFdpdGhvdXRPYnNlcnZhdGlvbnMgPSBtYWtlQ2hhbmdlc1RvUmVsYXRlZFdpdGhvdXRPYnNlcnZhdGlvbnM7IiwiLyoqXG4gKiBAbW9kdWxlIHF1ZXJ5XG4gKi9cblxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9sb2cnKTtcbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbnZhciBMb2dnZXIgPSBsb2cubG9nZ2VyV2l0aE5hbWUoJ1F1ZXJ5Jyk7XG52YXIgcSA9IHJlcXVpcmUoJ3EnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5Mb2dnZXIuc2V0TGV2ZWwobG9nLkxldmVsLndhcm4pO1xuXG4vKipcbiAqIEBjbGFzcyAgW1F1ZXJ5IGRlc2NyaXB0aW9uXVxuICogQHBhcmFtIHtNYXBwaW5nfSBtYXBwaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBRdWVyeShtYXBwaW5nLCBvcHRzKSB7XG4gICAgdGhpcy5tYXBwaW5nID0gbWFwcGluZztcbiAgICB0aGlzLnF1ZXJ5ID0gb3B0cztcbn1cblxuLyoqXG4gKiBJZiB0aGUgc3RvcmFnZSBleHRlbnNpb24gaXMgZW5hYmxlZCwgb2JqZWN0cyBtYXkgYmUgZmF1bHRlZCBhbmQgc28gd2UgbmVlZCB0byBxdWVyeSB2aWEgUG91Y2hEQi4gVGhlIHN0b3JhZ2VcbiAqIGV4dGVuc2lvbiBwcm92aWRlcyB0aGUgUmF3UXVlcnkgY2xhc3MgdG8gZW5hYmxlIHRoaXMuXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9leGVjdXRlVXNpbmdTdG9yYWdlRXh0ZW5zaW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgdmFyIHN0b3JhZ2VFeHRlbnNpb24gPSBzaWVzdGEuZXh0LnN0b3JhZ2U7XG4gICAgdmFyIFJhd1F1ZXJ5ID0gc3RvcmFnZUV4dGVuc2lvbi5SYXdRdWVyeTtcbiAgICB2YXIgUG91Y2ggPSBzdG9yYWdlRXh0ZW5zaW9uLlBvdWNoO1xuICAgIHZhciByYXdRdWVyeSA9IG5ldyBSYXdRdWVyeSh0aGlzLm1hcHBpbmcuY29sbGVjdGlvbiwgdGhpcy5tYXBwaW5nLnR5cGUsIHRoaXMucXVlcnkpO1xuICAgIHJhd1F1ZXJ5LmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICBMb2dnZXIuZGVidWcoJ2dvdCByZXN1bHRzJywgcmVzdWx0cyk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIFBvdWNoLnRvU2llc3RhKHJlc3VsdHMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICogQHBhcmFtIHtTaWVzdGFNb2RlbH0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gb2JqZWN0TWF0Y2hlc1F1ZXJ5KG9iaikge1xuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3JpZ0ZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB2YXIgc3BsdCA9IG9yaWdGaWVsZC5zcGxpdCgnX18nKTtcbiAgICAgICAgdmFyIG9wID0gJ2UnO1xuICAgICAgICB2YXIgZmllbGQ7XG4gICAgICAgIGlmIChzcGx0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICBmaWVsZCA9IHNwbHRbMF1cbiAgICAgICAgICAgIG9wID0gc3BsdFsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkID0gb3JpZ0ZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeU9iaiA9IHRoaXMucXVlcnlbb3JpZ0ZpZWxkXTtcbiAgICAgICAgdmFyIHZhbCA9IG9ialtmaWVsZF07XG4gICAgICAgIGlmIChvcCA9PSAnZScpIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT0gcXVlcnlPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3AgPT0gJ2x0Jykge1xuICAgICAgICAgICAgaWYgKHZhbCA+PSBxdWVyeU9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcCA9PSAnbHRlJykge1xuICAgICAgICAgICAgaWYgKHZhbCA+IHF1ZXJ5T2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wID09ICdndCcpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPD0gcXVlcnlPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3AgPT0gJ2d0ZScpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPCBxdWVyeU9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnUXVlcnkgb3BlcmF0b3IgXCInICsgb3AgKyAnXCInICsgJyBkb2VzIG5vdCBleGlzdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogSWYgdGhlIHN0b3JhZ2UgZXh0ZW5zaW9uIGlzIG5vdCBlbmFibGVkLCB3ZSBzaW1wbHkgY3ljbGUgdGhyb3VnaCBhbGwgb2JqZWN0cyBvZiB0aGUgdHlwZSByZXF1ZXN0ZWQgaW4gbWVtb3J5LlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZXhlY3V0ZUluTWVtb3J5KGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgdmFyIGNhY2hlQnlUeXBlID0gY2FjaGUuX2xvY2FsQ2FjaGVCeVR5cGU7XG4gICAgdmFyIG1hcHBpbmdOYW1lID0gdGhpcy5tYXBwaW5nLnR5cGU7XG4gICAgdmFyIGNvbGxlY3Rpb25OYW1lID0gdGhpcy5tYXBwaW5nLmNvbGxlY3Rpb247XG4gICAgdmFyIGNhY2hlQnlNYXBwaW5nID0gY2FjaGVCeVR5cGVbY29sbGVjdGlvbk5hbWVdO1xuICAgIHZhciBjYWNoZUJ5TG9jYWxJZDtcbiAgICBpZiAoY2FjaGVCeU1hcHBpbmcpIHtcbiAgICAgICAgY2FjaGVCeUxvY2FsSWQgPSBjYWNoZUJ5TWFwcGluZ1ttYXBwaW5nTmFtZV07XG4gICAgfVxuICAgIGlmIChjYWNoZUJ5TG9jYWxJZCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlQnlMb2NhbElkKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBlcnI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIG9iaiA9IGNhY2hlQnlMb2NhbElkW2tdO1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBvYmplY3RNYXRjaGVzUXVlcnkuY2FsbChzZWxmLCBvYmopO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihtYXRjaGVzKSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVyciA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSByZXMucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGVyciwgZXJyID8gbnVsbCA6IHJlcyk7XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5RdWVyeS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgLy8gaWYgKHNpZXN0YS5leHQuc3RvcmFnZUVuYWJsZWQpIHtcbiAgICAvLyAgICAgX2V4ZWN1dGVVc2luZ1N0b3JhZ2VFeHRlbnNpb24uY2FsbCh0aGlzLCBjYWxsYmFjayk7XG4gICAgLy8gfVxuICAgIC8vIGVsc2Uge1xuICAgIF9leGVjdXRlSW5NZW1vcnkuY2FsbCh0aGlzLCBjYWxsYmFjayk7XG4gICAgLy8gfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl9kdW1wID0gZnVuY3Rpb24oYXNKc29uKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBhc0pzb24gPyAne30nIDoge307XG59O1xuXG5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7IiwiLyoqXG4gKiBAbW9kdWxlIHJlbGF0aW9uc2hpcFxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzIHRoYXQgZGVzY3JpYmUgcmVsYXRpb25zaGlwcyBmb3IgbWFwcGluZ3MuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5SZWxhdGlvbnNoaXBUeXBlID0ge1xuICAgIE9uZVRvTWFueTogJ09uZVRvTWFueScsXG4gICAgT25lVG9PbmU6ICdPbmVUb09uZScsXG4gICAgTWFueVRvTWFueTogJ01hbnlUb01hbnknXG59O1xuXG5leHBvcnRzLlJlbGF0aW9uc2hpcFR5cGUgPSBSZWxhdGlvbnNoaXBUeXBlOyIsIi8qKlxuICogVGhlIFwic3RvcmVcIiBpcyByZXNwb25zaWJsZSBmb3IgbWVkaWF0aW5nIGJldHdlZW4gdGhlIGluLW1lbW9yeSBjYWNoZSBhbmQgYW55IHBlcnNpc3RlbnQgc3RvcmFnZS5cbiAqIE5vdGUgdGhhdCBwZXJzaXN0ZW50IHN0b3JhZ2UgaGFzIG5vdCBiZWVuIHByb3Blcmx5IGltcGxlbWVudGVkIHlldCBhbmQgc28gdGhpcyBpcyBwcmV0dHkgdXNlbGVzcy5cbiAqIEFsbCBxdWVyaWVzIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGNhY2hlIGluc3RlYWQuXG4gKiBAbW9kdWxlIHN0b3JlXG4gKi9cblxudmFyIHdyYXBwZWRDYWxsYmFjayA9IHJlcXVpcmUoJy4vbWlzYycpLndyYXBwZWRDYWxsYmFjaztcbnZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3I7XG52YXIgbG9nID0gcmVxdWlyZSgnLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL2xvZycpO1xudmFyIExvZ2dlciA9IGxvZy5sb2dnZXJXaXRoTmFtZSgnU3RvcmUnKTtcbkxvZ2dlci5zZXRMZXZlbChsb2cuTGV2ZWwud2Fybik7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgXyA9IHV0aWwuXztcbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbnZhciBxID0gcmVxdWlyZSgncScpO1xuXG5cbi8qKlxuICogW2dldCBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge09iamVjdH0gICBvcHRzXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciB4eXogPSAnYWZzZGYnO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIHZhciBhYmMgPSAnYXNkc2QnO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldChvcHRzLCBjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIGlmIChMb2dnZXIuZGVidWcuaXNFbmFibGVkKVxuICAgICAgICBMb2dnZXIuZGVidWcoJ2dldCcsIG9wdHMpO1xuICAgIHZhciBzaWVzdGFNb2RlbDtcbiAgICBpZiAob3B0cy5faWQpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNBcnJheShvcHRzLl9pZCkpIHtcbiAgICAgICAgICAgIC8vIFByb3h5IG9udG8gZ2V0TXVsdGlwbGUgaW5zdGVhZC5cbiAgICAgICAgICAgIGdldE11bHRpcGxlKF8ubWFwKG9wdHMuX2lkLCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIF9pZDogaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2llc3RhTW9kZWwgPSBjYWNoZS5nZXQob3B0cyk7XG4gICAgICAgICAgICBpZiAoc2llc3RhTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoTG9nZ2VyLmRlYnVnLmlzRW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmRlYnVnKCdIYWQgY2FjaGVkIG9iamVjdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHM6IG9wdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmo6IHNpZXN0YU1vZGVsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjayhjYWxsYmFjaykobnVsbCwgc2llc3RhTW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc0FycmF5KG9wdHMuX2lkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm94eSBvbnRvIGdldE11bHRpcGxlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIGdldE11bHRpcGxlKF8ubWFwKG9wdHMuX2lkLCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHNpZXN0YS5leHQuc3RvcmFnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc3RvcmUuZ2V0RnJvbVBvdWNoKG9wdHMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdTdG9yYWdlIG1vZHVsZSBub3QgaW5zdGFsbGVkJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRzLm1hcHBpbmcpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNBcnJheShvcHRzW29wdHMubWFwcGluZy5pZF0pKSB7XG4gICAgICAgICAgICAvLyBQcm94eSBvbnRvIGdldE11bHRpcGxlIGluc3RlYWQuXG4gICAgICAgICAgICBnZXRNdWx0aXBsZShfLm1hcChvcHRzW29wdHMubWFwcGluZy5pZF0sIGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgICAgICAgICBvW29wdHMubWFwcGluZy5pZF0gPSBpZDtcbiAgICAgICAgICAgICAgICBvLm1hcHBpbmcgPSBvcHRzLm1hcHBpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9cbiAgICAgICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWVzdGFNb2RlbCA9IGNhY2hlLmdldChvcHRzKTtcbiAgICAgICAgICAgIGlmIChzaWVzdGFNb2RlbCkge1xuICAgICAgICAgICAgICAgIGlmIChMb2dnZXIuZGVidWcuaXNFbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZGVidWcoJ0hhZCBjYWNoZWQgb2JqZWN0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0czogb3B0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iajogc2llc3RhTW9kZWxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd3JhcHBlZENhbGxiYWNrKGNhbGxiYWNrKShudWxsLCBzaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0gb3B0cy5tYXBwaW5nO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdldChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkRmllbGQgPSBtYXBwaW5nLmlkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBvcHRzW2lkRmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2V0KGlkLCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVkQ2FsbGJhY2soY2FsbGJhY2spKG5ldyBJbnRlcm5hbFNpZXN0YUVycm9yKCdJbnZhbGlkIG9wdGlvbnMgZ2l2ZW4gdG8gc3RvcmUuIE1pc3NpbmcgXCInICsgaWRGaWVsZC50b1N0cmluZygpICsgJy5cIicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzOiBvcHRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIHdheSBpbiB3aGljaCB0byBmaW5kIGFuIG9iamVjdCBsb2NhbGx5LlxuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG9wdHM6IG9wdHNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1zZyA9ICdJbnZhbGlkIG9wdGlvbnMgZ2l2ZW4gdG8gc3RvcmUnO1xuICAgICAgICBMb2dnZXIuZXJyb3IobXNnLCBjb250ZXh0KTtcbiAgICAgICAgd3JhcHBlZENhbGxiYWNrKGNhbGxiYWNrKShuZXcgSW50ZXJuYWxTaWVzdGFFcnJvcihtc2csIGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGdldE11bHRpcGxlKG9wdHNBcnJheSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGVmZXJyZWQgPSBxLmRlZmVyKCk7XG4gICAgY2FsbGJhY2sgPSB1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIoY2FsbGJhY2ssIGRlZmVycmVkKTtcbiAgICB2YXIgZG9jcyA9IFtdO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBfLmVhY2gob3B0c0FycmF5LCBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIGdldChvcHRzLCBmdW5jdGlvbihlcnIsIGRvYykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3MucHVzaChkb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvY3MubGVuZ3RoICsgZXJyb3JzLmxlbmd0aCA9PSBvcHRzQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZG9jcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuLyoqXG4gKiBVc2VzIHBvdWNoIGJ1bGsgZmV0Y2ggQVBJLiBNdWNoIGZhc3RlciB0aGFuIGdldE11bHRpcGxlLlxuICogQHBhcmFtIGxvY2FsSWRlbnRpZmllcnNcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXRNdWx0aXBsZUxvY2FsKGxvY2FsSWRlbnRpZmllcnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgIGNhbGxiYWNrID0gdXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGNhbGxiYWNrLCBkZWZlcnJlZCk7XG4gICAgdmFyIHJlc3VsdHMgPSBfLnJlZHVjZShsb2NhbElkZW50aWZpZXJzLCBmdW5jdGlvbihtZW1vLCBfaWQpIHtcbiAgICAgICAgdmFyIG9iaiA9IGNhY2hlLmdldCh7XG4gICAgICAgICAgICBfaWQ6IF9pZFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgbWVtby5jYWNoZWRbX2lkXSA9IG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lbW8ubm90Q2FjaGVkLnB1c2goX2lkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7XG4gICAgICAgIGNhY2hlZDoge30sXG4gICAgICAgIG5vdENhY2hlZDogW11cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZpbmlzaChlcnIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgXy5tYXAobG9jYWxJZGVudGlmaWVycywgZnVuY3Rpb24oX2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzLmNhY2hlZFtfaWRdO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2llc3RhLmV4dC5zdG9yYWdlRW5hYmxlZCAmJiByZXN1bHRzLm5vdENhY2hlZC5sZW5ndGgpIHtcbiAgICAgICAgc2llc3RhLmV4dC5zdG9yYWdlLnN0b3JlLmdldE11bHRpcGxlTG9jYWxGcm9tQ291Y2gocmVzdWx0cywgZmluaXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGdldE11bHRpcGxlUmVtb3RlKHJlbW90ZUlkZW50aWZpZXJzLCBtYXBwaW5nLCBjYWxsYmFjaykge1xuICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICBjYWxsYmFjayA9IHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihjYWxsYmFjaywgZGVmZXJyZWQpO1xuICAgIHZhciByZXN1bHRzID0gXy5yZWR1Y2UocmVtb3RlSWRlbnRpZmllcnMsIGZ1bmN0aW9uKG1lbW8sIGlkKSB7XG4gICAgICAgIHZhciBjYWNoZVF1ZXJ5ID0ge1xuICAgICAgICAgICAgbWFwcGluZzogbWFwcGluZ1xuICAgICAgICB9O1xuICAgICAgICBjYWNoZVF1ZXJ5W21hcHBpbmcuaWRdID0gaWQ7XG4gICAgICAgIHZhciBvYmogPSBjYWNoZS5nZXQoY2FjaGVRdWVyeSk7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIG1lbW8uY2FjaGVkW2lkXSA9IG9iajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lbW8ubm90Q2FjaGVkLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHtcbiAgICAgICAgY2FjaGVkOiB7fSxcbiAgICAgICAgbm90Q2FjaGVkOiBbXVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoKGVycikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBfLm1hcChyZW1vdGVJZGVudGlmaWVycywgZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMuY2FjaGVkW2lkXTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2llc3RhLmV4dC5zdG9yYWdlRW5hYmxlZCAmJiByZXN1bHRzLm5vdENhY2hlZC5sZW5ndGgpIHtcbiAgICAgICAgc2llc3RhLmV4dC5zdG9yYWdlLnN0b3JlLmdldE11bHRpcGxlUmVtb3RlRnJvbXBvdWNoKG1hcHBpbmcsIHJlbW90ZUlkZW50aWZpZXJzLCByZXN1bHRzLCBmaW5pc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmlzaCgpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLmdldE11bHRpcGxlID0gZ2V0TXVsdGlwbGU7XG5leHBvcnRzLmdldE11bHRpcGxlTG9jYWwgPSBnZXRNdWx0aXBsZUxvY2FsO1xuZXhwb3J0cy5nZXRNdWx0aXBsZVJlbW90ZSA9IGdldE11bHRpcGxlUmVtb3RlOyIsIi8qXG4gKiBUaGlzIGlzIGEgY29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdGFrZW4gZnJvbSBsaWJyYXJpZXMgc3VjaCBhcyBhc3luYy5qcywgdW5kZXJzY29yZS5qcyBldGMuXG4gKiBAbW9kdWxlIHV0aWxcbiAqL1xuXG5mdW5jdGlvbiBwcmludFN0YWNrVHJhY2UoKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3ByaW50U3RhY2tUcmFjZScpO1xuICAgIHZhciBzdGFjayA9IGUuc3RhY2s7XG4gICAgY29uc29sZS5sb2coc3RhY2spO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXNlRmlyc3RMZXR0ZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cblxuZXhwb3J0cy5wcmludFN0YWNrVHJhY2UgPSBwcmludFN0YWNrVHJhY2U7XG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IGNhcGl0YWxpc2VGaXJzdExldHRlcjtcblxudmFyIHJvb3QgPSB7fTtcbi8vIFNUQVJUIGFzeW5jLmpzIC8vXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIGRvUGFyYWxsZWwoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtlYWNoXS5jb25jYXQoYXJncykpO1xuICAgIH07XG59XG5cbnZhciBtYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG5cbmZ1bmN0aW9uIF9tYXAoYXJyLCBpdGVyYXRvcikge1xuICAgIGlmIChhcnIubWFwKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBlYWNoKGFyciwgZnVuY3Rpb24oeCwgaSwgYSkge1xuICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbih4LCBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHZhbHVlOiB4XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbih4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbih4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24oZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxudmFyIG1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XG5cbmZ1bmN0aW9uIGRvU2VyaWVzKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbZWFjaFNlcmllc10uY29uY2F0KGFyZ3MpKTtcbiAgICB9O1xufVxuXG5cblxuZnVuY3Rpb24gZWFjaFNlcmllcyhhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpdGVyYXRlKCk7XG59XG5cblxuXG5cbmZ1bmN0aW9uIF9lYWNoKGFyciwgaXRlcmF0b3IpIHtcbiAgICBpZiAoYXJyLmZvckVhY2gpIHtcbiAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZWFjaChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgIF9lYWNoKGFyciwgZnVuY3Rpb24oeCkge1xuICAgICAgICBpdGVyYXRvcih4LCBvbmx5X29uY2UoZG9uZSkpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24ga2V5cyhvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaik7XG4gICAgfVxuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuXG5cbnZhciBfcGFyYWxsZWwgPSBmdW5jdGlvbihlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICBpZiAoaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgZWFjaGZuLm1hcCh0YXNrcywgZnVuY3Rpb24oZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbihmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBlcnIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgZWFjaGZuLmVhY2goa2V5cyh0YXNrcyksIGZ1bmN0aW9uKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBzZXJpZXModGFza3MsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgbWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbihmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICBlYWNoU2VyaWVzKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24oaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcmFsbGVsKHRhc2tzLCBjYWxsYmFjaykge1xuICAgIF9wYXJhbGxlbCh7XG4gICAgICAgIG1hcDogbWFwLFxuICAgICAgICBlYWNoOiBlYWNoXG4gICAgfSwgdGFza3MsIGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0cy5zZXJpZXMgPSBzZXJpZXM7XG5leHBvcnRzLnBhcmFsbGVsID0gcGFyYWxsZWw7XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG4vLyBFTkQgYXN5bmMuanMgLy9cblxuLy8gU1RBUlQgdW5kZXJzY29yZS5qcyAvL1xuXG52YXIgXyA9IHt9O1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG52YXIgbmF0aXZlRm9yRWFjaCA9IEFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVNYXAgPSBBcnJheVByb3RvLm1hcDtcbnZhciBuYXRpdmVSZWR1Y2UgPSBBcnJheVByb3RvLnJlZHVjZTtcbnZhciBuYXRpdmVCaW5kID0gRnVuY1Byb3RvLmJpbmQ7XG52YXIgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlO1xudmFyIGJyZWFrZXIgPSB7fTtcblxuXy5rZXlzID0ga2V5cztcblxuXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRvciB0byBlYWNoIGVsZW1lbnQuXG4vLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG5fLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBvYmoubWFwID09PSBuYXRpdmVNYXApIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4vLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4vLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG5fLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJnc1tpXSA9PT0gXykgYXJnc1tpXSA9IGFyZ3VtZW50c1twb3NpdGlvbisrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbn07XG5cbi8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG5fLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xufTtcblxudmFyIHJlZHVjZUVycm9yID0gJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xuXG4vLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4vLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXG5fLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIG1lbW8sIGNvbnRleHQpIHtcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaWYgKG5hdGl2ZVJlZHVjZSAmJiBvYmoucmVkdWNlID09PSBuYXRpdmVSZWR1Y2UpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2UoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgICAgICBtZW1vID0gdmFsdWU7XG4gICAgICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWluaXRpYWwpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xuICAgIHJldHVybiBtZW1vO1xufTtcblxuXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG59O1xuXG4vLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuXG5pZiAodHlwZW9mKC8uLykgIT09ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gICAgfTtcbn1cblxuLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgbG9va3VwIGl0ZXJhdG9ycy5cbnZhciBsb29rdXBJdGVyYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xufTtcblxuLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdG9yLlxuXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcihpdGVyYXRvcik7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIGNyaXRlcmlhOiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xufTtcblxudmFyIGN0b3IgPSBmdW5jdGlvbigpIHt9O1xuXG4vLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbi8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbi8vIGF2YWlsYWJsZS5cbl8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJncywgYm91bmQ7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkpIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbn07XG5cblxuLy8gRU5EIHVuZGVyc2NvcmUuanMgLy9cblxuZXhwb3J0cy5fID0gXztcbnZhciBvYnNlcnZlID0gcmVxdWlyZSgnLi4vdmVuZG9yL29ic2VydmUtanMvc3JjL29ic2VydmUnKS5QbGF0Zm9ybTtcblxuZnVuY3Rpb24gbmV4dChjYWxsYmFjaykge1xuICAgIG9ic2VydmUucGVyZm9ybU1pY3JvdGFza0NoZWNrcG9pbnQoKTtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrKTtcbn1cblxuXG4vKipcbiAqIFBlcmZvcm1zIGRpcnR5IGNoZWNrL09iamVjdC5vYnNlcnZlIGNhbGxiYWNrcyBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gKlxuICogSWYgT2JqZWN0Lm9ic2VydmUgaXMgcHJlc2VudCxcbiAqIEBwYXJhbSBjYWxsYmFja1xuICovXG5leHBvcnRzLm5leHQgPSBuZXh0O1xuXG4vKipcbiAqIFJldHVybnMgYSBoYW5kbGVyIHRoYXQgYWN0cyB1cG9uIGEgY2FsbGJhY2sgb3IgYSBwcm9taXNlIGRlcGVuZGluZyBvbiB0aGUgcmVzdWx0IG9mIGEgZGlmZmVyZW50IGNhbGxiYWNrLlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAcGFyYW0gW3Byb21pc2VdXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlciA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBwcm9taXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgaWYgKGVycikgcHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIGVsc2UgcHJvbWlzZS5yZXNvbHZlLmFwcGx5KHByb21pc2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgICAgICB9XG4gICAgfTtcbn07IiwidmFyIGNoYWkgPSByZXF1aXJlKCdjaGFpJyk7XG52YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gY2hhaS5hc3NlcnQ7XG5cbnZhciBtYXBwaW5nT3BlcmF0aW9uID0gcmVxdWlyZSgnLi4vc3JjL21hcHBpbmdPcGVyYXRpb24nKTtcbnZhciBCdWxrTWFwcGluZ09wZXJhdGlvbiA9IG1hcHBpbmdPcGVyYXRpb24uQnVsa01hcHBpbmdPcGVyYXRpb247XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJyk7XG52YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG52YXIgY2FjaGUgPSByZXF1aXJlKCcuLi9zcmMvY2FjaGUnKTtcbnZhciBjb2xsZWN0aW9uO1xudmFyIFJlcG8sIFVzZXI7XG5cbmFzc2VydC5hcnJFcXVhbCA9IGZ1bmN0aW9uKGFycjEsIGFycjIpIHtcbiAgICBpZiAoIXV0aWwuaXNBcnJheShhcnIxKSkgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IoYXJyMS50b1N0cmluZygpICsgJyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBpZiAoIXV0aWwuaXNBcnJheShhcnIyKSkgdGhyb3cgbmV3IGNoYWkuQXNzZXJ0aW9uRXJyb3IoYXJyMi50b1N0cmluZygpICsgJyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBfLmNoYWluKGFycjEpLnppcChhcnIyKS5lYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNBcnJheSh4WzBdKSAmJiB1dGlsLmlzQXJyYXkoeFsxXSkpIHtcbiAgICAgICAgICAgIGFzc2VydC5hcnJFcXVhbCh4WzBdLCB4WzFdKTtcbiAgICAgICAgfSBlbHNlIGlmICh4WzBdICE9IHhbMV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjaGFpLkFzc2VydGlvbkVycm9yKGFycjEudG9TdHJpbmcoKSArICcgIT0gJyArIGFycjIudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmRlc2NyaWJlKCdhcnJheSBmbGF0dGVuaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgZGVzY3JpYmUoJ2ZsYXR0ZW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ21peHR1cmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmbGF0dGVuZWQgPSBtYXBwaW5nT3BlcmF0aW9uLmZsYXR0ZW5BcnJheShbJzEnLCBbJzInLCAnMyddLFxuICAgICAgICAgICAgICAgIFsnNCddLCAnNSdcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYXNzZXJ0LmFyckVxdWFsKFsnMScsICcyJywgJzMnLCAnNCcsICc1J10sIGZsYXR0ZW5lZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdhbGwgYXJyYXlzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZmxhdHRlbmVkID0gbWFwcGluZ09wZXJhdGlvbi5mbGF0dGVuQXJyYXkoW1xuICAgICAgICAgICAgICAgIFsnMSddLFxuICAgICAgICAgICAgICAgIFsnMicsICczJ10sXG4gICAgICAgICAgICAgICAgWyc0J10sXG4gICAgICAgICAgICAgICAgWyc1J11cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYXNzZXJ0LmFyckVxdWFsKFsnMScsICcyJywgJzMnLCAnNCcsICc1J10sIGZsYXR0ZW5lZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdubyBhcnJheXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmbGF0dGVuZWQgPSBtYXBwaW5nT3BlcmF0aW9uLmZsYXR0ZW5BcnJheShbJzEnLCAnMicsICczJywgJzQnLCAnNSddKTtcbiAgICAgICAgICAgIGFzc2VydC5hcnJFcXVhbChbJzEnLCAnMicsICczJywgJzQnLCAnNSddLCBmbGF0dGVuZWQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgndW5mbGF0dGVuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdtaXh0dXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdW5mbGF0dGVuZWQgPSBtYXBwaW5nT3BlcmF0aW9uLnVuZmxhdHRlbkFycmF5KFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sIFsnMScsIFsnMicsICczJ10sXG4gICAgICAgICAgICAgICAgWyc0J10sICc1J1xuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBhc3NlcnQuYXJyRXF1YWwoWydhJywgWydiJywgJ2MnXSxcbiAgICAgICAgICAgICAgICBbJ2QnXSwgJ2UnXG4gICAgICAgICAgICBdLCB1bmZsYXR0ZW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7XG5cbmRlc2NyaWJlKCdidWxrIG1hcHBpbmcgb3BlcmF0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgZGVzY3JpYmUoJ2dlbmVyYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBzLnJlc2V0KHRydWUpO1xuXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ015Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5iYXNlVVJMID0gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xuICAgICAgICAgICAgUmVwbyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUmVwbycsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnZnVsbF9uYW1lJywgJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAncmVwb3NpdG9yaWVzJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBVc2VyID0gY29sbGVjdGlvbi5tYXBwaW5nKCdVc2VyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbG9naW4nXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdlcnJvcnMnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3NpbXBsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcDtcblxuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ21pa2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcxMjMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3NpdG9yaWVzOiA1IC8vIEludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9naW46ICdtaWtlMicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMjMxNTYzNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3JpZXM6IFsgLy8gVmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSZXBvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9naW46ICdtaWtlNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMzEyNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3JpZXM6ICdhc2RhcycgLy8gSW52YWxpZFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ21pa2UzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzMjQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3NpdG9yaWVzOiBbIC8vIEludmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogJ25vc3VjaGxvY2FsaWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBuZXcgQnVsa01hcHBpbmdPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogVXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wLm9uQ29tcGxldGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9wLnN0YXJ0KCk7XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzY2FsYXIgaW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhvcC5lcnJvclswXSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhvcC5lcnJvclswXS5yZXBvc2l0b3JpZXMpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3ZhbGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhvcC5lcnJvclsxXSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnc2NhbGFyIHN0cmluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob3AuZXJyb3JbMl0pO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob3AuZXJyb3JbMl0ucmVwb3NpdG9yaWVzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdpbnZhbGlkIF9pZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob3AuZXJyb3JbM10pO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob3AuZXJyb3JbM10ucmVwb3NpdG9yaWVzKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdub24tZXhpc3RlbnQgX2lkJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbiAgICAgICAgICAgICAgICAgICAgX2lkOiAnbm9uZXhpc3RhbnQnXG4gICAgICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgQnVsa01hcHBpbmdPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBVc2VyLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3Aub25Db21wbGV0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3Auc3RhcnQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnYXJyYXkgdG8gc2NhbGFyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IFs1LCA2XVxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IEJ1bGtNYXBwaW5nT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogUmVwbyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wLm9uQ29tcGxldGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG9wLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wLnN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3NjYWxhciB0byBhcnJheScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2luOiAnbWlrZTQnLFxuICAgICAgICAgICAgICAgICAgICBpZDogJzEyMzEyNCcsXG4gICAgICAgICAgICAgICAgICAgIHJlcG9zaXRvcmllczogNVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIHZhciBvcCA9IG5ldyBCdWxrTWFwcGluZ09wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IFVzZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcC5vbkNvbXBsZXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhvcC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcC5zdGFydCgpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnbmV3JywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdmb3JlaWduIGtleScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ3N1YiBvcGVyYXRpb25zJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3duZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naW46ICdtaWtlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUmVwbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lOiAnQSBCaWcgUmVwbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdCbGFoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6ICdzZGZzZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUmVwbzInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxfbmFtZTogJ0Fub3RoZXIgQmlnIFJlcG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQmxzZGFoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3NkZnNkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogNVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSZXBvMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lOiAnWWV0IEFub3RoZXIgQmlnIFJlcG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQmxhaGFzZGFzZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IG5ldyBCdWxrTWFwcGluZ09wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogUmVwbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLl9jb25zdHJ1Y3RTdWJPcGVyYXRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3duZXJTdWJPcGVyYXRpb24gPSBvcC5zdWJPcHMub3duZXIub3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3duZXJJbmRleGVzID0gb3Auc3ViT3BzLm93bmVyLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3duZXJJbmRleGVzLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShvd25lckluZGV4ZXMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob3duZXJJbmRleGVzLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lclN1Yk9wZXJhdGlvbi5tYXBwaW5nLCBVc2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lclN1Yk9wZXJhdGlvbi5kYXRhWzBdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lclN1Yk9wZXJhdGlvbi5kYXRhWzFdLCBvd25lcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdub25lIGV4aXN0aW5nJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG93bmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2luOiAnbWlrZSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1JlcG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxfbmFtZTogJ0EgQmlnIFJlcG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQmxhaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1JlcG8yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsX25hbWU6ICdBbm90aGVyIEJpZyBSZXBvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0Jsc2RhaCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiA1XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1JlcG8zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdWxsX25hbWU6ICdZZXQgQW5vdGhlciBCaWcgUmVwbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdCbGFoYXNkYXNkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcCA9IG5ldyBCdWxrTWFwcGluZ09wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogUmVwbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLm9uQ29tcGxldGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gb3AuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RzID0gdGhpcy5vYmplY3RzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBvID0gb2JqZWN0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbzIgPSBvYmplY3RzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBvMyA9IG9iamVjdHNbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYXR0cmlidXRlcyBoYXZlIGJlZW4gbWFwcGVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5pZCwgJ3JlbW90ZUlkMScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvLmRlc2NyaXB0aW9uLCAnQmxhaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvLmZ1bGxfbmFtZSwgJ0EgQmlnIFJlcG8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5uYW1lLCAnUmVwbycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvMi5pZCwgJ3JlbW90ZUlkMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvMi5kZXNjcmlwdGlvbiwgJ0Jsc2RhaCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvMi5mdWxsX25hbWUsICdBbm90aGVyIEJpZyBSZXBvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcG8yLm5hbWUsICdSZXBvMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvMy5pZCwgJ3JlbW90ZUlkMycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvMy5kZXNjcmlwdGlvbiwgJ0JsYWhhc2Rhc2QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwbzMuZnVsbF9uYW1lLCAnWWV0IEFub3RoZXIgQmlnIFJlcG8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwbzMubmFtZSwgJ1JlcG8zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgcmVsYXRpb25zaGlwcyBoYXZlIGJlZW4gbWFwcGVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwbzIub3duZXIsIHJlcG8zLm93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgncmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdCgnbm9uZSBleGlzdGluZycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ21pa2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3JpZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUmVwbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bGxfbmFtZTogJ0EgQmlnIFJlcG8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gbmV3IEJ1bGtNYXBwaW5nT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBVc2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3Aub25Db21wbGV0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKEpTT04uc3RyaW5naWZ5KG9wLmVycm9yLCBudWxsLCA0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUob3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0cyA9IG9wLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqZWN0cy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmoubG9naW4sICdtaWtlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5pZCwgJzEyMycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmoucmVwb3NpdG9yaWVzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcG8gPSBvYmoucmVwb3NpdG9yaWVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvLmlkLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5uYW1lLCAnUmVwbycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvLmZ1bGxfbmFtZSwgJ0EgQmlnIFJlcG8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5vd25lciwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdleGlzdGluZycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBvID0gUmVwby5fbmV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdPbGQgTmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lOiAnT2xkIEZ1bGwgTmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ015Q29sbGVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JlcG8nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChyZXBvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ21pa2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3JpZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnNScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSZXBvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lOiAnQSBCaWcgUmVwbydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgQnVsa01hcHBpbmdPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IFVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5vbkNvbXBsZXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUob3AuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmplY3RzID0gb3AucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iamVjdHMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBvYmplY3RzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5sb2dpbiwgJ21pa2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouaWQsICcxMjMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmoucmVwb3NpdG9yaWVzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbyA9IG9iai5yZXBvc2l0b3JpZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5pZCwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5uYW1lLCAnUmVwbycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcG8uZnVsbF9uYW1lLCAnQSBCaWcgUmVwbycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcG8ub3duZXIsIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5zdGFydCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnbm8gcmVsYXRpb25zaGlwcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcDtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdub25lIGV4aXN0aW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naW46ICdtaWtlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ2JvYicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcxMjM0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcCA9IG5ldyBCdWxrTWFwcGluZ09wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogVXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ2xvb2t1cCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLl9sb29rdXAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHMubGVuZ3RoLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2sob3Aub2JqZWN0c1swXS5sb2dpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKG9wLm9iamVjdHNbMV0ubG9naW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgnY29tcGxldGlvbicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wLm9uQ29tcGxldGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0cyA9IG9wLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqZWN0cy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaWtlID0gb2JqZWN0c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9iID0gb2JqZWN0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobWlrZS5sb2dpbiwgJ21pa2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobWlrZS5pZCwgJzEyMycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChib2IubG9naW4sICdib2InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYm9iLmlkLCAnMTIzNCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3Auc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc2luZ2xldG9uLi4uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcDtcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHMucmVzZXQodHJ1ZSk7XG5cbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignTXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmJhc2VVUkwgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbSc7XG4gICAgICAgICAgICBSZXBvID0gY29sbGVjdGlvbi5tYXBwaW5nKCdSZXBvJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdmdWxsX25hbWUnLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnVXNlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdyZXBvc2l0b3JpZXMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFVzZXIgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1VzZXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydsb2dpbiddLFxuICAgICAgICAgICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCduZXcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbe1xuICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ21pa2UnLFxuICAgICAgICAgICAgICAgICAgICBpZDogJzEyMydcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2luOiAnYm9iJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICcxMjM0J1xuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIG9wID0gbmV3IEJ1bGtNYXBwaW5nT3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogVXNlcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdsb29rdXBTaW5nbGV0b24nLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgb3AuX2xvb2t1cFNpbmdsZXRvbihmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvcC5vYmplY3RzLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXSwgb3Aub2JqZWN0c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdtYXAnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgb3Aub25Db21wbGV0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gb3AuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0cy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHNbMF0sIG9wLm9iamVjdHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHNbMF0ubG9naW4sICdib2InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvcC5vYmplY3RzWzBdLmlkLCAnMTIzNCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcC5zdGFydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdleGlzdGluZywgY2FjaGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb2JqO1xuXG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIG9iaiA9IFVzZXIuX25ldyh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnNTY3J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbG9naW46ICdtaWtlJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICcxMjMnXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ2JvYicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzNCdcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICBvcCA9IG5ldyBCdWxrTWFwcGluZ09wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IFVzZXIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnbG9va3VwU2luZ2xldG9uJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIG9wLl9sb29rdXBTaW5nbGV0b24oZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0cy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHNbMF0sIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXSwgb3Aub2JqZWN0c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdtYXAnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgb3Aub25Db21wbGV0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gb3AuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0cy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHNbMF0sIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXSwgb3Aub2JqZWN0c1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXS5sb2dpbiwgJ2JvYicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHNbMF0uaWQsICcxMjM0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wLnN0YXJ0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxufSk7XG5cbmRlc2NyaWJlKCdidWcnLCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBjb2xsLCBDYXI7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgc2llc3RhLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBDYXIgPSBjb2xsLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddXG5cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGwuaW5zdGFsbChkb25lKTtcbiAgICB9KTtcblxuICAgIGl0KCdtdWx0aXBsZSBvYmplY3RzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICB2YXIgZGF0YSA9IFt7XG4gICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICBpZDogJzEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgaWQ6ICcyJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4gICAgICAgICAgICBuYW1lOiAnTGFtYm8nLFxuICAgICAgICAgICAgaWQ6ICczJ1xuICAgICAgICB9XTtcbiAgICAgICAgQ2FyLm1hcChkYXRhLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIENhci5tYXAoZGF0YSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTsiLCJ2YXIgc2llc3RhID0gcmVxdWlyZSgnLi4vaW5kZXgnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5kZXNjcmliZSgnY2FjaGUuLi4nLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFwcGluZztcblxuICAgIHZhciBTaWVzdGFNb2RlbCA9IHJlcXVpcmUoJy4uL3NyYy9vYmplY3QnKS5TaWVzdGFNb2RlbDtcbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbiAgICB2YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xuICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL3NyYy9jYWNoZScpO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHNpZXN0YS5yZXNldCh0cnVlKTsgXG4gICAgICAgIHZhciBjb2xsID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBtYXBwaW5nID0gY29sbC5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICB9KTtcbiAgICAgICAgY29sbC5pbnN0YWxsKGRvbmUpOyAgXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnaW5zZXJ0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdieSBwb3VjaCBpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgU2llc3RhTW9kZWwobWFwcGluZyk7XG4gICAgICAgICAgICByLl9pZCA9ICdkc2ZzZCc7XG4gICAgICAgICAgICBjYWNoZS5pbnNlcnQocik7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwociwgY2FjaGUuX2xvY2FsQ2FjaGUoKVtyLl9pZF0pO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHIsIGNhY2hlLl9sb2NhbENhY2hlQnlUeXBlW3IubWFwcGluZy5jb2xsZWN0aW9uXVtyLnR5cGVdW3IuX2lkXSwgcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdieSBkZWZhdWx0IGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IG5ldyBTaWVzdGFNb2RlbChtYXBwaW5nKTtcbiAgICAgICAgICAgIHIuaWQgPSAnZHNmc2QnO1xuICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KHIpO1xuXG4gICAgICAgICAgICB2YXIgcmVtb3RlQ2FjaGUgPSBjYWNoZS5fcmVtb3RlQ2FjaGUoKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChyLCByZW1vdGVDYWNoZVtyLmNvbGxlY3Rpb25dW3IudHlwZV1bci5pZF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnYnkgY3VzdG9tIGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG1hcHBpbmc7XG4gICAgICAgICAgICBtLmlkID0gJ2N1c3RvbUlkJztcbiAgICAgICAgICAgIHZhciByID0gbmV3IFNpZXN0YU1vZGVsKG0pO1xuICAgICAgICAgICAgci5jdXN0b21JZCA9ICdkc2ZzZCc7XG4gICAgICAgICAgICBjYWNoZS5pbnNlcnQocik7XG4gICAgICAgICAgICB2YXIgcmVtb3RlQ2FjaGUgPSBjYWNoZS5fcmVtb3RlQ2FjaGUoKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChyLCByZW1vdGVDYWNoZVtyLmNvbGxlY3Rpb25dW3IudHlwZV1bci5jdXN0b21JZF0pO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnYnkgcG91Y2ggaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByID0gbmV3IFNpZXN0YU1vZGVsKG1hcHBpbmcpO1xuICAgICAgICAgICAgci5pZCA9ICdkc2ZzZCc7XG4gICAgICAgICAgICBjYWNoZS5pbnNlcnQocik7XG4gICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBjYWNoZS5nZXQoe1xuICAgICAgICAgICAgICAgIG1hcHBpbmc6IG1hcHBpbmcsXG4gICAgICAgICAgICAgICAgaWQ6ICdkc2ZzZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJldHVybmVkLCByKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdieSByZXN0IGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgU2llc3RhTW9kZWwobWFwcGluZyk7XG4gICAgICAgICAgICBtb2RlbC5pZCA9ICdkc2ZzZCc7XG4gICAgICAgICAgICBtb2RlbC5faWQgPSAneHl6JztcbiAgICAgICAgICAgIGNhY2hlLmluc2VydChtb2RlbCk7XG4gICAgICAgICAgICB2YXIgcmV0dXJuZWQgPSBjYWNoZS5nZXQoe1xuICAgICAgICAgICAgICAgIG1hcHBpbmc6IG1hcHBpbmcsXG4gICAgICAgICAgICAgICAgaWQ6ICdkc2ZzZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJldHVybmVkLCBtb2RlbCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Z1bGwgdGVzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZywgcGVyc29uTWFwcGluZztcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmJhc2VVUkwgPSAnaHR0cDovL215d2Vic2l0ZS5jby51ay8nO1xuICAgICAgICAgICAgdmFyIGRlc2MgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZWdpc3RlclJlc3BvbnNlRGVzY3JpcHRvcihkZXNjKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ2Vycm9ycycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXQoJ2lnbm9yZSBkdXBsaWNhdGUgaW5zZXJ0cyBpZiBpcyB0aGUgc2FtZSBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAneHl6J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChwZXJzb24pO1xuICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChwZXJzb24pOyAvLyBTaG91bGQgYmUgZmluZSBhcyBpcyB0aGUgZXhhY3Qgc2FtZSBvYmplY3QuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2NhbnQgaW5zZXJ0IG9iamVjdCB3aXRoIHNhbWUgX2lkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQocGVyc29uKTtcbiAgICAgICAgICAgICAgICB2YXIgZHVwbGljYXRlT2JqZWN0ID0gbmV3IFNpZXN0YU1vZGVsKCk7XG4gICAgICAgICAgICAgICAgZHVwbGljYXRlT2JqZWN0Ll9pZCA9IHBlcnNvbi5faWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGR1cGxpY2F0ZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSwgc2llc3RhLkludGVybmFsU2llc3RhRXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdjYW50IGluc2VydCBvYmplY3Qgd2l0aCBzYW1lIGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eidcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQocGVyc29uKTtcblxuICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChwZXJzb25NYXBwaW5nLl9uZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCBzaWVzdGEuSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdkZWxldGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoJ3h5eicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICB9KTtcblxufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpXG4gICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5kZXNjcmliZSgnY2hhbmdlIGlkZW50aWZpZXJzJywgZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4gICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG4gICAgdmFyIGNvbGxlY3Rpb24sIGNhck1hcHBpbmc7XG5cbiAgICB2YXIgY2FyO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtpZDogJ3h5eicsIGNvbG91cjogJ3JlZCcsIG5hbWU6ICdmb3JkJ30sIGZ1bmN0aW9uIChlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCd4eXonLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICBhc3NlcnQuZXF1YWwoY2FjaGUuZ2V0KHtpZDogJ3h5eicsIG1hcHBpbmc6IGNhck1hcHBpbmd9KSwgY2FyKTtcbiAgICAgICAgY2FyLmlkID0gJ2FiYyc7XG4gICAgICAgIGFzc2VydC5ub3RPayhjYWNoZS5nZXQoe2lkOiAneHl6JywgbWFwcGluZzogY2FyTWFwcGluZ30pLCBjYXIpO1xuICAgICAgICBhc3NlcnQuZXF1YWwoY2FjaGUuZ2V0KHtpZDogJ2FiYycsIG1hcHBpbmc6IGNhck1hcHBpbmd9KSwgY2FyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgIH0pO1xuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuXG5kZXNjcmliZSgnaHR0cCEnLCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBSZWxhdGlvbnNoaXBUeXBlID0gcmVxdWlyZSgnLi4vc3JjL3JlbGF0aW9uc2hpcCcpLlJlbGF0aW9uc2hpcFR5cGU7XG4gICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuICAgIHZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi4vc3JjL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcjtcblxuICAgIHZhciBjb2xsZWN0aW9uLCBjYXJNYXBwaW5nLCBwZXJzb25NYXBwaW5nLCB2aXRhbFNpZ25zTWFwcGluZztcblxuICAgIHZhciBzZXJ2ZXI7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBzZXJ2ZXIgPSBzaW5vbi5mYWtlU2VydmVyLmNyZWF0ZSgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY29uZmlndXJlQ29sbGVjdGlvbihjYWxsYmFjaykge1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuICAgICAgICB9KTtcbiAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnY2FycydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aXRhbFNpZ25zTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnVml0YWxTaWducycsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydoZWFydFJhdGUnLCAnYmxvb2RQcmVzc3VyZSddLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvT25lLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAndml0YWxTaWducydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb2xsZWN0aW9uLmJhc2VVUkwgPSAnaHR0cDovL215d2Vic2l0ZS5jby51ay8nO1xuICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGFmdGVyRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBzZXJ2ZXIgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHNlcnZlci5yZXN0b3JlKCk7XG4gICAgfSk7XG5cblxuICAgIGRlc2NyaWJlKCdwYXRoIHJlZ2V4JywgZnVuY3Rpb24oKSB7XG5cblxuICAgICAgICBkZXNjcmliZSgnY2hlY2snLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJlQ29sbGVjdGlvbihkb25lKTtcbiAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVzcG9uc2VEZXNjcmlwdG9yKG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8oPzxjb2xvdXI+W2EtekEtWjAtOV0rKS8/J1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVzcG9uc2VEZXNjcmlwdG9yKG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGNvbG91cj5bYS16QS1aMC05XSspLz8nXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdzaW5ndWxhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIsIG9iaiwgcmVzcDtcblxuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6ICcwOTNob2RoZm5vJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnNSdcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFwiaHR0cDovL215d2Vic2l0ZS5jby51ay9jYXJzLzkvcHVycGxlL1wiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgSlNPTi5zdHJpbmdpZnkocmF3KV0pO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLkdFVCgnY2Fycy85L3B1cnBsZS8nLCBmdW5jdGlvbihfZXJyLCBfb2JqLCBfcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IF9vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gX3Jlc3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBtYXAgcmVnZXggbWF0Y2hlcyBvbnRvIHRoZSBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2Yob2JqLCBTaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouY29sb3VyLCAncHVycGxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmoubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmlkLCAnOScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdtdWx0aXBsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIsIG9ianMsIHJlc3A7XG5cbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJzA5M2hvZGhmbm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc1J1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAnMDkzaG9kaGZubycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJzInXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ29yYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAnMDkzaG9kaGZubycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEnXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJodHRwOi8vbXl3ZWJzaXRlLmNvLnVrL2NhcnMvcHVycGxlL1wiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgSlNPTi5zdHJpbmdpZnkocmF3KV0pO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLkdFVCgnY2Fycy9wdXJwbGUvJywgZnVuY3Rpb24oX2VyciwgX29ianMsIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqcyA9IF9vYmpzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9yZXNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgbWFwIHJlZ2V4IG1hdGNoZXMgb250byB0aGUgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob2Jqcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2gob2JqcywgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmNvbG91ciwgJ3B1cnBsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5uYW1lLCAnQXN0b24gTWFydGluJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3ZlcmJzJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgZGVzY3JpYmUoJ0dFVCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcblxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZUNvbGxlY3Rpb24oZG9uZSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnc3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnIsIG9iaiwgcmVzcDtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdzaW5nbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVzcG9uc2VEZXNjcmlwdG9yKG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAnMDkzaG9kaGZubycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc1J1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvY2Fycy81L1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgSlNPTi5zdHJpbmdpZnkocmF3KV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5HRVQoJ2NhcnMvNS8nLCBmdW5jdGlvbihfZXJyLCBfb2JqLCBfcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IF9lcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gX29iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gX3Jlc3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgnbm8gZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgncmV0dXJucyBkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzcC5kYXRhLmNvbG91ciwgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3AuZGF0YS5uYW1lLCAnQXN0b24gTWFydGluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzcC5kYXRhLm93bmVyLCAnMDkzaG9kaGZubycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3AuZGF0YS5pZCwgJzUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ3JldHVybnMgdGV4dCBzdGF0dXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXNwLnRleHRTdGF0dXMsICdzdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdyZXR1cm5zIGpxeGhyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2socmVzcC5qcVhIUik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdyZXR1cm5zIGEgY2FyIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2Yob2JqLCBTaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmNvbG91ciwgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5uYW1lLCAnQXN0b24gTWFydGluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmlkLCAnNScpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ211bHRpcGxlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZWdpc3RlclJlc3BvbnNlRGVzY3JpcHRvcihuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8/J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhdyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ293bmVySWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnNSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6ICdvd25lcklkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzYnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvY2Fycy9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIkdFVFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kV2l0aChtZXRob2QsIHBhdGgsIFtzdGF0dXMsIGhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHJhdyldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uR0VUKCdjYXJzLycsIGZ1bmN0aW9uKF9lcnIsIF9vYmosIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9lcnIpIGRvbmUoX2Vycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gX29iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gX3Jlc3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgncmV0dXJucyAyIGNhciBvYmplY3RzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbihjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihjYXIsIFNpZXN0YU1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdtYXBzIG93bmVyIG9udG8gc2FtZSBvYmonLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpbMF0ub3duZXIuX2lkLCBvYmpbMV0ub3duZXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpbMF0ub3duZXIucmVsYXRlZE9iamVjdCwgb2JqWzFdLm93bmVyLnJlbGF0ZWRPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnREVMRVRFJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmVDb2xsZWN0aW9uKGRvbmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdzdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2RlZmF1bHQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIsIG9iaiwgcmVzcCwgb2JqZWN0VG9EZWxldGU7XG5cbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKGRhdGEsIGZ1bmN0aW9uKGVyciwgX29iamVjdFRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFRvRGVsZXRlID0gX29iamVjdFRvRGVsZXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXNwb25zZURlc2NyaXB0b3IobmV3IHNpZXN0YS5leHQuaHR0cC5SZXNwb25zZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvY2Fycy81L1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIkRFTEVURVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgJ3tcInN0YXR1c1wiOiBcIm9rXCJ9J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uREVMRVRFKCdjYXJzLzUvJywgX29iamVjdFRvRGVsZXRlLCBmdW5jdGlvbihfZXJyLCBfb2JqLCBfcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBfb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwID0gX3Jlc3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdubyBlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdyZXR1cm5zIHRleHQgc3RhdHVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzcC50ZXh0U3RhdHVzLCAnc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgncmV0dXJucyBqcXhocicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHJlc3AuanFYSFIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgncmV0dXJucyBubyBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhvYmopO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgncmVtb3ZlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG9iamVjdFRvRGVsZXRlLnJlbW92ZWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdkZWxldGUgbm93JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgYmUgcmVtb3ZlZCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAneHl6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoZGF0YSwgZnVuY3Rpb24oZXJyLCBfb2JqZWN0VG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0VG9EZWxldGUgPSBfb2JqZWN0VG9EZWxldGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZWdpc3RlclJlc3BvbnNlRGVzY3JpcHRvcihuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IFwiaHR0cDovL215d2Vic2l0ZS5jby51ay9jYXJzLzUvXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwiREVMRVRFXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZFdpdGgobWV0aG9kLCBwYXRoLCBbc3RhdHVzLCBoZWFkZXJzLCAne1wic3RhdHVzXCI6IFwib2tcIn0nXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5ERUxFVEUoJ2NhcnMvNS8nLCBfb2JqZWN0VG9EZWxldGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRpb25Nb2RlOiAnbm93J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKF9lcnIsIF9vYmosIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhfb2JqZWN0VG9EZWxldGUucmVtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhfb2JqZWN0VG9EZWxldGUucmVtb3ZlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdvbiBzdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgb25seSBiZSByZW1vdmVkIG9uY2UgZmluaXNoZWQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKGRhdGEsIGZ1bmN0aW9uKGVyciwgX29iamVjdFRvRGVsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFRvRGVsZXRlID0gX29iamVjdFRvRGVsZXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXNwb25zZURlc2NyaXB0b3IobmV3IHNpZXN0YS5leHQuaHR0cC5SZXNwb25zZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvY2Fycy81L1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIkRFTEVURVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgJ3tcInN0YXR1c1wiOiBcIm9rXCJ9J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uREVMRVRFKCdjYXJzLzUvJywgX29iamVjdFRvRGVsZXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0aW9uTW9kZTogJ3N1Y2Nlc3MnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oX2VyciwgX29iaiwgX3Jlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKF9vYmplY3RUb0RlbGV0ZS5yZW1vdmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKF9vYmplY3RUb0RlbGV0ZS5yZW1vdmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3Jlc3RvcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBiZSByZXN0b3JlZCBvbiBmYWlsdXJlJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcChkYXRhLCBmdW5jdGlvbihlcnIsIF9vYmplY3RUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RUb0RlbGV0ZSA9IF9vYmplY3RUb0RlbGV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVzcG9uc2VEZXNjcmlwdG9yKG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJodHRwOi8vbXl3ZWJzaXRlLmNvLnVrL2NhcnMvNS9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJERUxFVEVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gNTAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kV2l0aChtZXRob2QsIHBhdGgsIFtzdGF0dXMsIGhlYWRlcnMsICd7XCJzdGF0dXNcIjogXCJva1wifSddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLkRFTEVURSgnY2Fycy81LycsIF9vYmplY3RUb0RlbGV0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGlvbk1vZGU6ICdyZXN0b3JlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKF9lcnIsIF9vYmosIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhfb2JqZWN0VG9EZWxldGUucmVtb3ZlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhfb2JqZWN0VG9EZWxldGUucmVtb3ZlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdQT1NUJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZXJyLCBvYmosIHJlc3A7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmVDb2xsZWN0aW9uKGRvbmUpO1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZURlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnY2Fycy8/J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXNwb25zZURlc2NyaXB0b3IocmVzcG9uc2VEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdjYXJzLz8nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZWdpc3RlclJlcXVlc3REZXNjcmlwdG9yKHJlcXVlc3REZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnc3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXI7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJodHRwOi8vbXl3ZWJzaXRlLmNvLnVrL2NhcnMvXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIlBPU1RcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgSlNPTi5zdHJpbmdpZnkocmF3KV0pO1xuICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5jb2xvdXIsICdyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5QT1NUKCdjYXJzLycsIGNhciwgZnVuY3Rpb24oX2VyciwgX29iaiwgX3Jlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IF9vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9yZXNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbm8gZXJyb3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbWFwcGVkIG9udG8gdGhlIHBvc3RlZCBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhciwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5pZCwgJ3JlbW90ZUlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3VyLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdQVVQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlcnIsIG9iaiwgcmVzcDtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZUNvbGxlY3Rpb24oZG9uZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXNwb25zZURlc2NyaXB0b3IocmVzcG9uc2VEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXF1ZXN0RGVzY3JpcHRvcihyZXF1ZXN0RGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3N1Y2Nlc3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FyO1xuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc1J1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJodHRwOi8vbXl3ZWJzaXRlLmNvLnVrL2NhcnMvNS9cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwiUFVUXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kV2l0aChtZXRob2QsIHBhdGgsIFtzdGF0dXMsIGhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHJhdyldKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc1J1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLmNvbG91ciwgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5uYW1lLCAnQXN0b24gTWFydGluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLmlkLCAnNScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5QVVQoJ2NhcnMvNS8nLCBjYXIsIGZ1bmN0aW9uKF9lcnIsIF9vYmosIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBfb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBfcmVzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vIGVycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ21hcHBlZCBvbnRvIHRoZSBwb3N0ZWQgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmosIGNhcik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuaWQsICc1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3VyLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdQQVRDSCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVyciwgb2JqLCByZXNwO1xuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJlQ29sbGVjdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVzcG9uc2VEZXNjcmlwdG9yKHJlc3BvbnNlRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXF1ZXN0RGVzY3JpcHRvcihyZXF1ZXN0RGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnc3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYXI7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJzUnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvY2Fycy81L1wiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJQQVRDSFwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZFdpdGgobWV0aG9kLCBwYXRoLCBbc3RhdHVzLCBoZWFkZXJzLCBKU09OLnN0cmluZ2lmeShyYXcpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnNSdcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5jb2xvdXIsICdyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5pZCwgJzUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uUEFUQ0goJ2NhcnMvNS8nLCBjYXIsIGZ1bmN0aW9uKF9lcnIsIF9vYmosIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBfb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBfcmVzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vIGVycm9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ21hcHBlZCBvbnRvIHRoZSBwb3N0ZWQgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmosIGNhcik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuaWQsICc1Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3VyLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJycpXG4gICAgICAgICAgICB9KTtcblxuXG5cblxuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnT1BUSU9OUycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVyciwgb2JqLCByZXNwO1xuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJlQ29sbGVjdGlvbihkb25lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnc3VjY2VzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uOiAnc29tZXRoaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gXCJodHRwOi8vbXl3ZWJzaXRlLmNvLnVrL3NvbWV0aGluZy9cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwiT1BUSU9OU1wiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gMjAwO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIucmVzcG9uZFdpdGgobWV0aG9kLCBwYXRoLCBbc3RhdHVzLCBoZWFkZXJzLCBKU09OLnN0cmluZ2lmeShyYXcpXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uT1BUSU9OUygnc29tZXRoaW5nLycsIGZ1bmN0aW9uKF9lcnIsIF9vYmosIF9yZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gX29iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBfcmVzcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXQoJ25vIGVycicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdCgnbm8gb2JqJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhvYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdyZXNwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhyZXNwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdIRUFEJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZXJyLCBvYmosIHJlc3A7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmVDb2xsZWN0aW9uKGRvbmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdzdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb246ICdzb21ldGhpbmcnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvc29tZXRoaW5nL1wiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJIRUFEXCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5yZXNwb25kV2l0aChtZXRob2QsIHBhdGgsIFtzdGF0dXMsIGhlYWRlcnMsIEpTT04uc3RyaW5naWZ5KHJhdyldKTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5IRUFEKCdzb21ldGhpbmcvJywgZnVuY3Rpb24oX2VyciwgX29iaiwgX3Jlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IF9lcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBfb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9yZXNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdCgnbm8gZXJyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdubyBvYmonLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKG9iaik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXQoJ3Jlc3AnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHJlc3ApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGh0dHA6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjOS5odG1sXG4gICAgICAgICAqL1xuICAgICAgICBkZXNjcmliZSgnVFJBQ0UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlcnIsIG9iaiwgcmVzcDtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZUNvbGxlY3Rpb24oZG9uZSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnVFJBQ0UnLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnY2Fycy8nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZWdpc3RlclJlc3BvbnNlRGVzY3JpcHRvcihyZXNwb25zZURlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdUUkFDRScsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICdjYXJzLydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVxdWVzdERlc2NyaXB0b3IocmVxdWVzdERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdzdWNjZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcjtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhdyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgICAgICAgICAgICAgfTsgLy8gVHJhY2UgaXMgc3VwcG9zZWQgdG8gYmUgYSByZWZsZWN0aW9uIG9mIHRoZSByZXNwb25zZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwibWVzc2FnZS9odHRwXCJcbiAgICAgICAgICAgICAgICAgICAgfTsgLy8gaHR0cDovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWM5Lmh0bWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhdGggPSBcImh0dHA6Ly9teXdlYnNpdGUuY28udWsvY2Fycy9cIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IFwiVFJBQ0VcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmRXaXRoKG1ldGhvZCwgcGF0aCwgW3N0YXR1cywgaGVhZGVycywgSlNPTi5zdHJpbmdpZnkocmF3KV0pO1xuICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uVFJBQ0UoJ2NhcnMvJywgX2NhciwgZnVuY3Rpb24oX2VyciwgX29iaiwgX3Jlc3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IF9vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IF9yZXNwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyLnJlc3BvbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXQoJ25vIGVycicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdCgnb2JqJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhvYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdyZXNwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXNwLmpxWEhSLnJlc3BvbnNlVGV4dCwgJ3tcImNvbG91clwiOlwicmVkXCJ9Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhyZXNwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYWpheCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9sbGFyO1xuICAgICAgICB2YXIgZmFrZURvbGxhciA9IHtcbiAgICAgICAgICAgIGFqYXg6IGZ1bmN0aW9uKCkge31cbiAgICAgICAgfVxuXG4gICAgICAgIGJlZm9yZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRvbGxhciA9ICQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkID0gZmFrZURvbGxhcjtcbiAgICAgICAgICAgIGpRdWVyeSA9IGZha2VEb2xsYXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFmdGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJCA9IGRvbGxhcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2RlZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChzLmV4dC5odHRwLmFqYXgsIGZha2VEb2xsYXIuYWpheCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdubyAkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHMuZXh0Lmh0dHAuYWpheCwgZmFrZURvbGxhci5hamF4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ25vIGFqYXggYXQgYWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgalF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHMuZXh0Lmh0dHAuYWpheDtcbiAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2V0IGFqYXgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBmYWtlQWpheCA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgICAgICBzLnNldEFqYXgoZmFrZUFqYXgpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHMuZXh0Lmh0dHAuYWpheCwgZmFrZUFqYXgpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHMuZ2V0QWpheCgpLCBmYWtlQWpheCk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc3BlY2lmaWMgZmllbGRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY29uZmlndXJlQ29sbGVjdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VEZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXNwb25zZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVzcG9uc2VEZXNjcmlwdG9yKHJlc3BvbnNlRGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3REZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXF1ZXN0RGVzY3JpcHRvcihyZXF1ZXN0RGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICc1J1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3VyLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLmlkLCAnNScpO1xuICAgICAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuX3NlcmlhbGlzZU9iamVjdC5jYWxsKHJlcXVlc3REZXNjcmlwdG9yLCB7ZmllbGRzOlsnY29sb3VyJ119LCBjYXIsIGZ1bmN0aW9uIChlcnIsIGRhdGEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChrZXlzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGtleXNbMF0sICdjb2xvdXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgneHl6JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkdW1wKCdoZWxsbycpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpLFxuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cblxuZGVzY3JpYmUoJ2NvbGxlY3Rpb24gc2V0dXAnLCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi4vc3JjL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcjtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnaW5zdGFsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbjtcbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignTXlDb2xsZWN0aW9uJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdub3QgaW5zdGFsbGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQubm90T2soY29sbGVjdGlvbi5pbnN0YWxsZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnY29uZmlndXJlIHdpdGhvdXQgbWFwcGluZ3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGl0KCdldmVudHVhbGx5IGZpbmlzaGVzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3JhaXNlcyBhbiBlcnJvciBpZiB0cnlpbmcgdG8gY29uZmlndXJlIHR3aWNlJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnaXMgYWNjZXNzaWJsZSBpbiB0aGUgc2llc3RhIG9iamVjdCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHMuTXlDb2xsZWN0aW9uLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdyYWlzZXMgYW4gZXJyb3IgaWYgdHJ5aW5nIHRvIGNvbmZpZ3VyZSB0d2ljZScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ2NvbmZpZ3VyZSB3aXRoIG1hcHBpbmdzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpdCgnbmFtZSBiZWZvcmUgb2JqZWN0JywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nMSA9IGNvbGxlY3Rpb24ubWFwcGluZygnbWFwcGluZzEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2F0dHIxJywgJ2F0dHIyJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGluZzIgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ21hcHBpbmcyJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydhdHRyMScsICdhdHRyMicsICdhdHRyMyddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uWydtYXBwaW5nMSddLCBtYXBwaW5nMSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uWydtYXBwaW5nMiddLCBtYXBwaW5nMik7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnbmFtZSB3aXRoaW4gb2JqZWN0JywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nMSA9IGNvbGxlY3Rpb24ubWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtYXBwaW5nMScsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2F0dHIxJywgJ2F0dHIyJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGluZzIgPSBjb2xsZWN0aW9uLm1hcHBpbmcoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWFwcGluZzInLFxuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydhdHRyMScsICdhdHRyMicsICdhdHRyMyddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uWydtYXBwaW5nMSddLCBtYXBwaW5nMSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uWydtYXBwaW5nMiddLCBtYXBwaW5nMik7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnbm8gbmFtZSBzcGVjaWZpZWQgd2l0aGluIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ubWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnYXR0cjEnLCAnYXR0cjInXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgndmFyYXJnJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXBwaW5ncyA9IGNvbGxlY3Rpb24ubWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtYXBwaW5nMScsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2F0dHIxJywgJ2F0dHIyJ11cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdtYXBwaW5nMicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2F0dHIxJywgJ2F0dHIyJywgJ2F0dHIzJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25bJ21hcHBpbmcxJ10sIG1hcHBpbmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25bJ21hcHBpbmcyJ10sIG1hcHBpbmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdhcnJheScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGluZ3MgPSBjb2xsZWN0aW9uLm1hcHBpbmcoW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21hcHBpbmcxJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnYXR0cjEnLCAnYXR0cjInXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ21hcHBpbmcyJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnYXR0cjEnLCAnYXR0cjInLCAnYXR0cjMnXVxuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25bJ21hcHBpbmcxJ10sIG1hcHBpbmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25bJ21hcHBpbmcyJ10sIG1hcHBpbmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdjb25maWd1cmUgd2l0aCBkZXNjcmlwdG9ycycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1hcHBpbmcxLCBtYXBwaW5nMjtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZzEgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ21hcHBpbmcxJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydhdHRyMScsICdhdHRyMiddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFwcGluZzIgPSBjb2xsZWN0aW9uLm1hcHBpbmcoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbWFwcGluZzInLFxuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydhdHRyMScsICdhdHRyMicsICdhdHRyMyddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlc2NyaWJlKCdyZXF1ZXN0IGRlc2NyaXB0b3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpdCgnc2luZ2xlJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvcnMgPSBjb2xsZWN0aW9uLmRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBtYXBwaW5nMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvcGF0aC8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZXNjcmlwdG9ycy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3IxID0gZGVzY3JpcHRvcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKHJlcXVlc3REZXNjcmlwdG9yMSwgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcnMgPSBjb2xsZWN0aW9uLmRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBtYXBwaW5nMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvcGF0aC8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvcjIgPSBkZXNjcmlwdG9yc1swXTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YocmVxdWVzdERlc2NyaXB0b3IyLCBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcXVlc3REZXNjcmlwdG9yMS5tYXBwaW5nLCBtYXBwaW5nMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVxdWVzdERlc2NyaXB0b3IyLm1hcHBpbmcsIG1hcHBpbmcyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlc2NyaWJlKCdyZXNwb25zZSBkZXNjcmlwdG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaXQoJ3NpbmdsZScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JzID0gY29sbGVjdGlvbi5kZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBtYXBwaW5nMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvcGF0aC8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZXNjcmlwdG9ycy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VEZXNjcmlwdG9yMSA9IGRlc2NyaXB0b3JzWzBdO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihyZXNwb25zZURlc2NyaXB0b3IxLCBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JzID0gY29sbGVjdGlvbi5kZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBtYXBwaW5nMixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvcGF0aC8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZXNjcmlwdG9ycy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VEZXNjcmlwdG9yMiA9IGRlc2NyaXB0b3JzWzBdO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihyZXNwb25zZURlc2NyaXB0b3IyLCBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXNwb25zZURlc2NyaXB0b3IxLm1hcHBpbmcsIG1hcHBpbmcxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXNwb25zZURlc2NyaXB0b3IyLm1hcHBpbmcsIG1hcHBpbmcyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdib3RoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3JzO1xuXG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzID0gY29sbGVjdGlvbi5kZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogWydHRVQnLCAnUE9TVCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogbWFwcGluZzEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL3BhdGgvKD88aWQ+WzAtOV0pLz8nXG4gICAgICAgICAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgndHdvIGRlc2NyaXB0b3JzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZXNjcmlwdG9ycy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3R5cGVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZURlc2NyaXB0b3IxID0gZGVzY3JpcHRvcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKHJlc3BvbnNlRGVzY3JpcHRvcjEsIHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvcjEgPSBkZXNjcmlwdG9yc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YocmVxdWVzdERlc2NyaXB0b3IxLCBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdyZWdpc3RyYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdpc3RyeSA9IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZWdpc3RyeScsIHJlZ2lzdHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3REZXNjcmlwdG9ycyA9IHJlZ2lzdHJ5LnJlcXVlc3REZXNjcmlwdG9ycy5NeUNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZURlc2NyaXB0b3JzID0gcmVnaXN0cnkucmVzcG9uc2VEZXNjcmlwdG9ycy5NeUNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXF1ZXN0RGVzY3JpcHRvcnMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3BvbnNlRGVzY3JpcHRvcnMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ3JlcXVlc3QgZGVzY3JpcHRvcicsIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4gICAgdmFyIEludGVybmFsU2llc3RhRXJyb3IgPSByZXF1aXJlKCcuLi9zcmMvZXJyb3InKS5JbnRlcm5hbFNpZXN0YUVycm9yO1xuICAgIHZhciBSZWxhdGlvbnNoaXBUeXBlID0gcmVxdWlyZSgnLi4vc3JjL3JlbGF0aW9uc2hpcCcpLlJlbGF0aW9uc2hpcFR5cGU7XG5cbiAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZywgcGVyc29uTWFwcGluZztcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJ11cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdtYXRjaGluZycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGRlc2NyaWJlKCdwYXRoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpdCgnbWF0Y2ggaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPycsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSByLl9tYXRjaFBhdGgoJy9jYXJzLzUvJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG1hdGNoLmlkLCAnNScpO1xuICAgICAgICAgICAgICAgIG1hdGNoID0gci5fbWF0Y2hQYXRoKCcvY2Fycy81Jyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG1hdGNoLmlkLCAnNScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdxdWVyeSBwYXJhbXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJyonLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gZGVzY3JpcHRvci5fbWF0Y2hQYXRoKCcvY2Fycy81P3g9NSZ5PXJhbmRvbScpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChtYXRjaC5pZCwgJzUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnaHR0cCBtZXRob2RzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpdCgnYWxsIGh0dHAgbWV0aG9kcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnKicsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfLmVhY2goci5odHRwTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHIubWV0aG9kLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFsnKiddLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHIuaHR0cE1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShyLm1ldGhvZCwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBbJyonLCAnR0VUJ10sXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfLmVhY2goci5odHRwTWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHIubWV0aG9kLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnbWF0Y2ggYWdhaW5zdCBhbGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJyonLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKHIuaHR0cE1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soci5fbWF0Y2hNZXRob2QobWV0aG9kKSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhyLl9tYXRjaE1ldGhvZChtZXRob2QudG9VcHBlckNhc2UoKSkpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soci5fbWF0Y2hNZXRob2QobWV0aG9kLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ21hdGNoIGFnYWluc3Qgc29tZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBbJ1BPU1QnLCAnUFVUJ10sXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQub2soci5fbWF0Y2hNZXRob2QoJ1BPU1QnKSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHIuX21hdGNoTWV0aG9kKCdQVVQnKSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHIuX21hdGNoTWV0aG9kKCdwb3N0JykpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhyLl9tYXRjaE1ldGhvZCgncHV0JykpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhyLl9tYXRjaE1ldGhvZCgnUG9TdCcpKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQub2soci5fbWF0Y2hNZXRob2QoJ3BVdCcpKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soci5fbWF0Y2hNZXRob2QoJ0hFQUQnKSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHIuX21hdGNoTWV0aG9kKCdoZWFkJykpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhyLl9tYXRjaE1ldGhvZCgnaEVhRCcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ21hdGNoIGFnYWluc3Qgc2luZ2xlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0TWF0Y2hNZXRob2Qocikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soci5fbWF0Y2hNZXRob2QoJ1BPU1QnKSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhyLl9tYXRjaE1ldGhvZCgncG9zdCcpKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHIuX21hdGNoTWV0aG9kKCdQb1N0JykpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soci5fbWF0Y2hNZXRob2QoJ0hFQUQnKSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhyLl9tYXRjaE1ldGhvZCgnaGVhZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHIuX21hdGNoTWV0aG9kKCdoRWFEJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFzc2VydE1hdGNoTWV0aG9kKG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogWydQT1NUJ10sXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TWF0Y2hNZXRob2QobmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBbJ3BPc1QnXSxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRNYXRjaE1ldGhvZChuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdwT3NUJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRNYXRjaE1ldGhvZChuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRNYXRjaE1ldGhvZChuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3NwZWNpZnkgbWFwcGluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnYXMgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoci5tYXBwaW5nLCBjYXJNYXBwaW5nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdhcyBzdHJpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiAnQ2FyJyxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoJ0NhcicsIHIubWFwcGluZy50eXBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdhcyBzdHJpbmcsIGJ1dCBjb2xsZWN0aW9uIGFzIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdDYXInLFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKCdDYXInLCByLm1hcHBpbmcudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnc2hvdWxkIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBwYXNzZWQgYXMgc3RyaW5nIHdpdGhvdXQgY29sbGVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhfLnBhcnRpYWwoc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3IsIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiAnQ2FyJ1xuICAgICAgICAgICAgfSksIEludGVybmFsU2llc3RhRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdpZiBudWxsLCBzaG91bGQgYmUgbnVsbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQubm90T2soci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdpZiBlbXB0eSBzdHJpbmcsIHNob3VsZCBiZSBudWxsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgZGF0YTogJycsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQubm90T2soci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdpZiBsZW5ndGggMSwgc2hvdWxkIGJlIGEgc3RyaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgZGF0YTogJ2FiYycsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoci5kYXRhLCAnYWJjJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnaWYgPiBsZW5ndGggMSwgc2hvdWxkIGJlIGFuIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgIGRhdGE6ICdwYXRoLnRvLmRhdGEnLFxuICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHIuZGF0YS5wYXRoLnRvLCAnZGF0YScpO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzY3JpYmUoJ2VtYmVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB4OiAxLFxuICAgICAgICAgICAgICAgIHk6IDIsXG4gICAgICAgICAgICAgICAgejogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGl0KCdpZiBudWxsLCBzaG91bGQgc2ltcGx5IHJldHVybiB0aGUgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEsIHIuX2VtYmVkRGF0YShkYXRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdpZiBlbXB0eSBzdHJpbmcsIHNob3VsZCBzaW1wbHkgcmV0dXJuIHRoZSBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ICcnLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEsIHIuX2VtYmVkRGF0YShkYXRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdpZiBsZW5ndGggMSwgc2hvdWxkIHJldHVybiAxIGxldmVsIGRlZXAgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAnYWJjJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLCByLl9lbWJlZERhdGEoZGF0YSkuYWJjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ2lmID4gbGVuZ3RoIDEsIHNob3VsZCByZXR1cm4gbiBsZXZlbCBkZWVwIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogJ3BhdGgudG8uZGF0YScsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdERhdGEgPSByLl9lbWJlZERhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEsIGV4dHJhY3REYXRhLnBhdGgudG8uZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlc2NyaWJlKCdleHRyYWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB4OiAxLFxuICAgICAgICAgICAgICAgIHk6IDIsXG4gICAgICAgICAgICAgICAgejogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGl0KCdpZiBudWxsLCBzaG91bGQgc2ltcGx5IHJldHVybiB0aGUgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhY3REYXRhID0gci5fZXh0cmFjdERhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGV4dHJhY3REYXRhLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ2lmIGVtcHR5IHN0cmluZywgc2hvdWxkIHNpbXBseSByZXR1cm4gdGhlIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogJycsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdERhdGEgPSByLl9leHRyYWN0RGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZXh0cmFjdERhdGEsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnaWYgbGVuZ3RoIDEsIHNob3VsZCByZXR1cm4gMSBsZXZlbCBkZWVwIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogJ2FiYycsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdERhdGEgPSByLl9leHRyYWN0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGFiYzogZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChleHRyYWN0RGF0YSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdpZiA+IGxlbmd0aCAxLCBzaG91bGQgcmV0dXJuIG4gbGV2ZWwgZGVlcCBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ICdwYXRoLnRvLmRhdGEnLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhY3REYXRhID0gci5fZXh0cmFjdERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChleHRyYWN0RGF0YSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgncmVnaXN0cnknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZWdpc3RlciByZXF1ZXN0IGRlc2NyaXB0b3InLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgZGF0YTogJ3BhdGgudG8uZGF0YScsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlZ2lzdGVyUmVxdWVzdERlc2NyaXB0b3Iocik7XG4gICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvclJlZ2lzdHJ5LnJlcXVlc3REZXNjcmlwdG9yc1tjYXJNYXBwaW5nLmNvbGxlY3Rpb25dLCByKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlc2NyaWJlKCdyZXF1ZXN0IGRlc2NyaXB0b3JzIGZvciBjb2xsZWN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAncGF0aC50by5kYXRhJyxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yUmVnaXN0cnkucmVnaXN0ZXJSZXF1ZXN0RGVzY3JpcHRvcihkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ3JlcXVlc3QgZGVzY3JpcHRvcnMgc2hvdWxkIGJlIGFjY2Vzc2libGUgYnkgY29sbGVjdGlvbiBuYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZXF1ZXN0RGVzY3JpcHRvcnNGb3JDb2xsZWN0aW9uKGNhck1hcHBpbmcuY29sbGVjdGlvbiksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgncmVxdWVzdCBkZXNjcmlwdG9ycyBzaG91bGQgYmUgYWNjZXNzaWJsZSBieSBjb2xsZWN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3JSZWdpc3RyeS5yZXF1ZXN0RGVzY3JpcHRvcnNGb3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24pLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ21hdGNoIGh0dHAgY29uZmlnJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlc2NyaWJlKCdubyBkYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdtYXRjaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhkZXNjcmlwdG9yLl9tYXRjaENvbmZpZyh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnL2NhcnMvNS8nXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnbm8gbWF0Y2ggYmVjYXVzZSBvZiBtZXRob2QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZGVzY3JpcHRvci5fbWF0Y2hDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiAnL2NhcnMvNS8nXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnbm8gbWF0Y2ggYmVjYXVzZSBvZiB1cmwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZGVzY3JpcHRvci5fbWF0Y2hDb25maWcoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIHVybDogJy9hc2Rhc2QvJ1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdtYXRjaCBhZ2FpbnN0IGRhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG5cbiAgICAgICAgZGVzY3JpYmUoJ2RhdGEgc3BlY2lmaWVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiAncGF0aC50by5kYXRhJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnbWF0Y2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQub2soZGVzY3JpcHRvci5fbWF0Y2hEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdubyBtYXRjaCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhkZXNjcmlwdG9yLl9tYXRjaERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiB7IC8vIE1pc3NpbmcgJ3RvJ1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdkYXRhIHVuc3BlY2lmaWVkJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgfSlcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NvbXBvdW5kIG1hdGNoJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yO1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nLFxuICAgICAgICAgICAgICAgIGRhdGE6ICdwYXRoLnRvLmRhdGEnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3N1Y2Nlc3MnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHVybDogJy9jYXJzLzUvJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3NlcnQub2soZGVzY3JpcHRvci5tYXRjaChjb25maWcsIGRhdGEpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZGVmYXVsdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3I7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5EZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdkZWZhdWx0IG1ldGhvZCBpcyBHRVQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZXNjcmlwdG9yLm1ldGhvZC5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRlc2NyaXB0b3IubWV0aG9kWzBdLCAnR0VUJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnZGVmYXVsdCBwYXRoIGlzIGJsYW5rJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGVzY3JpcHRvci5wYXRoLCAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnZGVmYXVsdCBkYXRhIGlzIG51bGwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChkZXNjcmlwdG9yLmRhdGEsIG51bGwpO1xuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Vycm9ycycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnbm8gbWFwcGluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBuZXcgc2llc3RhLmV4dC5odHRwLkRlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAnZGF0YSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3NpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkZXNjcmliZSgnc2VyaWFsaXNhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXQoJ2RlZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90RXF1YWwocmVxdWVzdERlc2NyaXB0b3Iuc2VyaWFsaXNlciwgc2llc3RhLmV4dC5odHRwLlNlcmlhbGlzZXIuaWRTZXJpYWxpc2VyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnYnVpbHQtaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGlzZXI6IHNpZXN0YS5leHQuaHR0cC5TZXJpYWxpc2VyLmlkU2VyaWFsaXNlclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdCgndXNlcyB0aGUgc2VyaWFsaXNlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcXVlc3REZXNjcmlwdG9yLnNlcmlhbGlzZXIsIHNpZXN0YS5leHQuaHR0cC5TZXJpYWxpc2VyLmlkU2VyaWFsaXNlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdCgnc2VyaWFsaXNlcycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAneHl6J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IuX3NlcmlhbGlzZShjYXIsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLCBjYXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdkZXB0aCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3I7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpc2VyOiBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5kZXB0aFNlcmlhbGl6ZXIoMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgndXNlcyB0aGUgc2VyaWFsaXNlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKHJlcXVlc3REZXNjcmlwdG9yLnNlcmlhbGlzZXIsIHNpZXN0YS5leHQuaHR0cC5TZXJpYWxpc2VyLmlkU2VyaWFsaXNlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdzZXJpYWxpc2VzIGF0IGRlcHRoJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvci5fc2VyaWFsaXNlKGNhciwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEub3duZXIsICcxMjMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgndHJhbnNmb3JtcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdERlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ2tleSBwYXRocycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG91cic6ICdwYXRoLnRvLmNvbG91cidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvci5fdHJhbnNmb3JtRGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhkYXRhLmNvbG91cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5wYXRoLnRvLmNvbG91ciwgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgna2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29sb3VyJzogJ2NvbG9yJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yLl90cmFuc2Zvcm1EYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGRhdGEuY29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLmNvbG9yLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdmdW5jdGlvbiB3aXRoIHJldHVybiB2YWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvdXInOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09ICdyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yLl90cmFuc2Zvcm1EYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEuY29sb3VyLCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgnZnVuY3Rpb24gd2l0aCByZXR1cm4gdmFsIGFuZCBrZXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvdXInOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09ICdyZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnY29sb3InLCBuZXdWYWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IuX3RyYW5zZm9ybURhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZGF0YS5jb2xvdXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEuY29sb3IsICdibHVlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdpbnZhbGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29sb3VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3RmOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXM6ICd0aGlzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvci5fdHJhbnNmb3JtRGF0YShkYXRhKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdkdXJpbmcgc2VyaWFsaXNhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLyg/PGlkPlswLTldKS8/JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXNlcjogc2llc3RhLmV4dC5odHRwLlNlcmlhbGlzZXIuZGVwdGhTZXJpYWxpemVyKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29sb3VyJzogJ3BhdGgudG8uY29sb3VyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3BlcmZvcm1zIHRyYW5zZm9ybScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvci5fc2VyaWFsaXNlKGNhciwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5vd25lciwgJzEyMycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGRhdGEuY29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLnBhdGgudG8uY29sb3VyLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdlbWJlZCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2lkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICdwYXRoLnRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpc2VyOiBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5pZFNlcmlhbGlzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgnc2VyaWFsaXNlcyBhdCBkZXB0aCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAneHl6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IuX3NlcmlhbGlzZShjYXIsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLnBhdGgudG8sICd4eXonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZGVwdGgnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3REZXNjcmlwdG9yO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlcXVlc3REZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICcvY2Fycy8oPzxpZD5bMC05XSkvPycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogJ3BhdGgudG8nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgICAgICAgICBpdCgnc2VyaWFsaXNlcyBhdCBkZXB0aCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAneHl6JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERlc2NyaXB0b3IuX3NlcmlhbGlzZShjYXIsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLnBhdGgudG8ub3duZXIsICcxMjMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnY3VzdG9tJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXF1ZXN0RGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnL2NhcnMvKD88aWQ+WzAtOV0pLz8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ICdwYXRoLnRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpc2VyOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdzZXJpYWxpc2VzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvci5fc2VyaWFsaXNlKGNhciwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEucGF0aC50bywgJ3h5eicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ2N1c3RvbScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FyU2VyaWFsaXNlcihmaWVsZHMsIGNhciwgZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggaW4gZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXJbZmllbGRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtmaWVsZF0gPSBjYXJbZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhci5vd25lclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm93bmVyID0gcGVyc29uLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0RGVzY3JpcHRvciwgc2VyaWFsaXNlcjtcblxuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGlzZXIgPSBfLnBhcnRpYWwoY2FyU2VyaWFsaXNlciwgWyduYW1lJ10pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVxdWVzdERlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJy9jYXJzLz8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXNlcjogc2VyaWFsaXNlclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCd1c2VzIHRoZSBjdXN0b20gc2VyaWFsaXNlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVxdWVzdERlc2NyaXB0b3Iuc2VyaWFsaXNlciwgc2VyaWFsaXNlcik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnc2VyaWFsaXNlcycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEyMycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REZXNjcmlwdG9yLl9zZXJpYWxpc2UoY2FyLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEub3duZXIsICdNaWNoYWVsIEZvcmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5uYW1lLCAnQXN0b24gTWFydGluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGRhdGEuY29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdSZXNwb25zZURlc2NyaXB0b3InLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBkZXNjcmliZSgndHJhbnNmb3JtcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGVzY3JpcHRvcjtcbiAgICAgICAgICAgIGl0KCdrZXkgcGF0aHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZURlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvdXInOiAncGF0aC50by5jb2xvdXInXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yLl90cmFuc2Zvcm1EYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhkYXRhLmNvbG91cik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEucGF0aC50by5jb2xvdXIsICdyZWQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgna2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXNwb25zZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sb3VyJzogJ2NvbG9yJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVzY3JpcHRvci5fdHJhbnNmb3JtRGF0YShkYXRhKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZGF0YS5jb2xvdXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLmNvbG9yLCAncmVkJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2Z1bmN0aW9uIHdpdGggcmV0dXJuIHZhbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3Jtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbG91cic6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PSAncmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWwgPSAnYmx1ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdWYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yLl90cmFuc2Zvcm1EYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLmNvbG91ciwgJ2JsdWUnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnZnVuY3Rpb24gd2l0aCByZXR1cm4gdmFsIGFuZCBrZXknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZURlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvdXInOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT0gJ3JlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsID0gJ2JsdWUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydjb2xvcicsIG5ld1ZhbF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yLl90cmFuc2Zvcm1EYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhkYXRhLmNvbG91cik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEuY29sb3IsICdibHVlJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2Z1bmN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVzY3JpcHRvciA9IG5ldyBzaWVzdGEuZXh0Lmh0dHAuUmVzcG9uc2VEZXNjcmlwdG9yKHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtczogZnVuY3Rpb24oX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLCBfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRhdGEgPSByZXNwb25zZURlc2NyaXB0b3IuX3RyYW5zZm9ybURhdGEoZGF0YSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGRhdGEuY29sb3VyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5rZXksICd2YWx1ZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdpbnZhbGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEZXNjcmlwdG9yID0gbmV3IHNpZXN0YS5leHQuaHR0cC5SZXNwb25zZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sb3VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHd0Zjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpczogJ3RoaXMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlRGVzY3JpcHRvci5fdHJhbnNmb3JtRGF0YShkYXRhKTtcblxuICAgICAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3IpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3RyYW5zZm9ybXMgZHVyaW5nIGRlc2VyaWFsaXNhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlRGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZURlc2NyaXB0b3IgPSBuZXcgc2llc3RhLmV4dC5odHRwLlJlc3BvbnNlRGVzY3JpcHRvcih7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvdXInOiAnY29sb3InXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgndHJhbnNmb3JtcyBkdXJpbmcgZXh0cmFjdERhdGEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdGVkID0gcmVzcG9uc2VEZXNjcmlwdG9yLl9leHRyYWN0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZXh0cmFjdGVkLmNvbG9yLCAncmVkJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGV4dHJhY3RlZC5jb2xvdXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgndHJhbnNmb3JtcyBkdXJpbmcgbWF0Y2hEYXRhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dHJhY3RlZCA9IHJlc3BvbnNlRGVzY3JpcHRvci5fbWF0Y2hEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChleHRyYWN0ZWQuY29sb3IsICdyZWQnKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZXh0cmFjdGVkLmNvbG91cik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG59KTsiLCIvKipcbiAqIEFuIGludGVncmF0aW9uIHRlc3QgdGhhdCBjcmVhdGVzIHR3byBjb21wbGV4IGNvbGxlY3Rpb25zIGFuZCB0aGVuIGVzdGFibGlzaGVzIGludGVyLWNvbGxlY3Rpb24gcmVsYXRpb25zaGlwc1xuICogYmV0d2VlbiB0aGUgbWFwcGluZ3MgaW4gZWFjaCBiZWZvcmUgY3JlYXRpbmcgb2JqZWN0cyBldGMuXG4gKlxuICogV2UgdGhlbiBwcm9jZWVkIHRvIHRlc3QgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBzeXN0ZW0uXG4gKi9cblxudmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpLFxuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xudmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL3NyYy9jYWNoZScpO1xuXG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xuXG5kZXNjcmliZSgnaW50ZXJjb2xsZWN0aW9uIHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbXlPZmZsaW5lQ29sbGVjdGlvbjtcbiAgICB2YXIgbXlPbmxpbmVDb2xsZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG5cbiAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdNeU9mZmxpbmVDb2xsZWN0aW9uJyk7XG4gICAgICAgIG15T25saW5lQ29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdNeU9ubGluZUNvbGxlY3Rpb24nKTtcblxuICAgICAgICBteU9mZmxpbmVDb2xsZWN0aW9uLm1hcHBpbmcoJ0ZvbGRlcicsIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZSddLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRCeToge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnVXNlcicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnZm9sZGVycydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG15T2ZmbGluZUNvbGxlY3Rpb24ubWFwcGluZygnRG93bmxvYWRlZFBob3RvJywge1xuICAgICAgICAgICAgYXR0cmlidXRlczogWydjcmVhdGlvbkRhdGUnXSxcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVkQnk6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1VzZXInLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2ZpbGVzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZm9sZGVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdGb2xkZXInLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2ZpbGVzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGhvdG86IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ015T25saW5lQ29sbGVjdGlvbi5QaG90bycsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9PbmUsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdmaWxlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbi5tYXBwaW5nKCdVc2VyJywge1xuICAgICAgICAgICAgYXR0cmlidXRlczogWyd1c2VybmFtZSddLFxuICAgICAgICAgICAgaW5kZXhlczogWyd1c2VybmFtZSddXG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24ubWFwcGluZygnUGhvdG8nLCB7XG4gICAgICAgICAgICBpZDogJ3Bob3RvSWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydoZWlnaHQnLCAnd2lkdGgnLCAndXJsJ10sXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgY3JlYXRlZEJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdVc2VyJyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdwaG90b3MnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24ubWFwcGluZygnVXNlcicsIHtcbiAgICAgICAgICAgIGlkOiAndXNlcklkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsndXNlcm5hbWUnLCAnbmFtZSddXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaW5pc2hlZENyZWF0aW5nTXlPbmxpbmVDb2xsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBmaW5pc2hlZENyZWF0aW5nTXlPZmZsaW5lQ29sbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIG15T2ZmbGluZUNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIGZpbmlzaGVkQ3JlYXRpbmdNeU9mZmxpbmVDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZENyZWF0aW5nTXlPbmxpbmVDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZENyZWF0aW5nTXlPZmZsaW5lQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtYXBSZW1vdGVVc2VycyhjYWxsYmFjaykge1xuICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uVXNlci5tYXAoW3tcbiAgICAgICAgICAgIHVzZXJuYW1lOiAnbXRmb3JkJyxcbiAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgdXNlcklkOiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdXNlcm5hbWU6ICdibGFoYmxhaCcsXG4gICAgICAgICAgICBuYW1lOiAnQmxhaCBCbGFoJyxcbiAgICAgICAgICAgIHVzZXJJZDogJzInXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiAnYm9ibScsXG4gICAgICAgICAgICBuYW1lOiAnQm9iIE1hcmxleScsXG4gICAgICAgICAgICB1c2VySWQ6ICczJ1xuICAgICAgICB9XSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcFJlbW90ZVBob3RvcyhjYWxsYmFjaykge1xuICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uUGhvdG8ubWFwKFt7XG4gICAgICAgICAgICBoZWlnaHQ6IDUwMCxcbiAgICAgICAgICAgIHdpZHRoOiA1MDAsXG4gICAgICAgICAgICB1cmw6ICdodHRwOi8vc29tZXdoZXJlL2ltYWdlLmpwZWcnLFxuICAgICAgICAgICAgcGhvdG9JZDogJzEwJyxcbiAgICAgICAgICAgIGNyZWF0ZWRCeTogJzEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGhlaWdodDogMTUwMCxcbiAgICAgICAgICAgIHdpZHRoOiAxNTAwLFxuICAgICAgICAgICAgdXJsOiAnaHR0cDovL3NvbWV3aGVyZS9pbWFnZTIuanBlZycsXG4gICAgICAgICAgICBwaG90b0lkOiAnMTEnLFxuICAgICAgICAgICAgY3JlYXRlZEJ5OiAnMSdcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgaGVpZ2h0OiA1MDAsXG4gICAgICAgICAgICB3aWR0aDogNzUwLFxuICAgICAgICAgICAgdXJsOiAnaHR0cDovL3NvbWV3aGVyZS9pbWFnZTMuanBlZycsXG4gICAgICAgICAgICBwaG90b0lkOiAnMTInLFxuICAgICAgICAgICAgY3JlYXRlZEJ5OiAnMidcbiAgICAgICAgfV0sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXBPZmZsaW5lVXNlcnMoY2FsbGJhY2spIHtcbiAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbi5Vc2VyLm1hcChbe1xuICAgICAgICAgICAgdXNlcm5hbWU6ICdtaWtlJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICB1c2VybmFtZTogJ2dheidcbiAgICAgICAgfV0sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsT2ZmbGluZUZpeHR1cmVzKGNhbGxiYWNrKSB7XG4gICAgICAgIG1hcE9mZmxpbmVVc2VycyhjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE9ubGluZUZpeHR1cmVzKGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLnNlcmllcyhbXG4gICAgICAgICAgICBtYXBSZW1vdGVVc2VycyxcbiAgICAgICAgICAgIG1hcFJlbW90ZVBob3Rvc1xuICAgICAgICBdLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGluc3RhbGxPZmZsaW5lRml4dHVyZXMoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICBpbnN0YWxsT25saW5lRml4dHVyZXMoZG9uZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2xvY2FsIHF1ZXJpZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVzY3JpYmUoJ29mZmxpbmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG1pa2Ugd2hlbiBxdWVyeWluZyBmb3IgaGltJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIG15T2ZmbGluZUNvbGxlY3Rpb24uVXNlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiAnZ2F6J1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgdXNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwodXNlcnMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHVzZXJzWzBdLnVzZXJuYW1lLCAnZ2F6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnb25saW5lJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDMgdXNlcnMgd2hlbiBydW4gYSBsb2NhbCBhbGwgcXVlcnkgYWdhaW5zdCB1c2VycycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uVXNlci5hbGwoZnVuY3Rpb24oZXJyLCB1c2Vycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbCh1c2Vycy5sZW5ndGgsIDMpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gMyBwaG90b3Mgd2hlbiBydW4gYSBsb2NhbCBhbGwgcXVlcnkgYWdhaW5zdCBwaG90b3MnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgbXlPbmxpbmVDb2xsZWN0aW9uLlBob3RvLmFsbChmdW5jdGlvbihlcnIsIHBob3Rvcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwaG90b3MubGVuZ3RoLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDIgcGhvdG9zIHdpdGggaGVpZ2h0IDUwMCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQoMTAwMDApO1xuICAgICAgICAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5QaG90by5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTAwXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBwaG90b3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGhvdG9zLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChwaG90b3MsIGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwLmhlaWdodCwgNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiAxIHBob3RvIHdpdGggaGVpZ2h0IDUwMCwgd2lkdGgsIDc1MCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQoMTAwMDApO1xuICAgICAgICAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5QaG90by5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogNTAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogNzUwXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBwaG90b3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGhvdG9zLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwaG90b3NbMF0uaGVpZ2h0LCA1MDApO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGhvdG9zWzBdLndpZHRoLCA3NTApO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBiZSBhYmxlIHRvIHF1ZXJ5IGJ5IHJlbW90ZSBpZGVudGlmaWVyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5Vc2VyLmdldCgnMScsIGZ1bmN0aW9uKGVyciwgdXNlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbCh1c2VyLnVzZXJJZCwgJzEnKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG5cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ3JlbGF0aW9uc2hpcCBtYXBwaW5ncycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkZXNjcmliZSgnb25saW5lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnROdW1QaG90b3ModXNlcklkLCBudW1QaG90b3MsIGRvbmUpIHtcbiAgICAgICAgICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uVXNlci5nZXQodXNlcklkLCBmdW5jdGlvbihlcnIsIHVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sodXNlcik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbCh1c2VyLnVzZXJJZCwgdXNlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gdXNlci5waG90b3NQcm94eTtcbiAgICAgICAgICAgICAgICAgICAgcHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGhvdG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGhvdG9zID8gcGhvdG9zLmxlbmd0aCA6IDAsIG51bVBob3Rvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0KCd1c2VyIHdpdGggaWQgMSBzaG91bGQgaGF2ZSAyIHBob3RvcycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1QaG90b3MoJzEnLCAyLCBkb25lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgndXNlciB3aXRoIGlkIDIgc2hvdWxkIGhhdmUgMSBwaG90by4uLicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1QaG90b3MoJzInLCAxLCBkb25lKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgndXNlciB3aXRoIGlkIDMgc2hvdWxkIGhhdmUgbm8gcGhvdG9zJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bVBob3RvcygnMycsIDAsIGRvbmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG5cblxuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uLy4uL2luZGV4JylcbiAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCdpbnRlcmNvbGwgcmVsYXRpb25zaGlwcycsIGZ1bmN0aW9uICgpIHtcblxuXG4gICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBSZWxhdGlvbnNoaXBUeXBlID0gcmVxdWlyZSgnLi4vLi4vc3JjL3JlbGF0aW9uc2hpcCcpLlJlbGF0aW9uc2hpcFR5cGU7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcy5yZXNldCh0cnVlKTtcbiAgICB9KTtcblxuICAgIHZhciBjb2xsZWN0aW9uLCBjYXJNYXBwaW5nLCBwZXJzb25NYXBwaW5nO1xuXG4gICAgZnVuY3Rpb24gY29uZmlndXJlQVBJKHR5cGUsIGRvbmUpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgIH0pO1xuICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoJ0ludGVyLWNvbGxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhbm90aGVyQ29sbGVjdGlvbjtcbiAgICAgICAgdmFyIG9iajtcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICBjb25maWd1cmVBUEkoUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksIGRvbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYW5vdGhlckNvbGxlY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdmb3JlaWduIGtleScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBhbm90aGVyQ29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdhbm90aGVyQ29sbGVjdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgYW5vdGhlckNvbGxlY3Rpb24ubWFwcGluZygnQW5vdGhlck1hcHBpbmcnLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZmllbGQnXSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ215Q29sbGVjdGlvbi5QZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdvdGhlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYW5vdGhlckNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYW5vdGhlckNvbGxlY3Rpb25bJ0Fub3RoZXJNYXBwaW5nJ10ubWFwKHtmaWVsZDogNSwgcGVyc29uOiB7bmFtZTogJ01pY2hhZWwnLCBhZ2U6IDIzLCBpZDogJ3h5eid9fSwgZnVuY3Rpb24gKGVyciwgX29iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gX29iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnaW5zdGFsbHMgZm9yd2FyZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gb2JqLnBlcnNvbjtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihwZXJzb24sIFNpZXN0YU1vZGVsKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLm5hbWUsICdNaWNoYWVsJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbi5hZ2UsIDIzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnaW5zdGFsbHMgYmFja3dhcmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwZXJzb24gPSBvYmoucGVyc29uO1xuICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5vdGhlciwgb2JqKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5cbn0pOyIsInZhciBzID0gcmVxdWlyZSgnLi4vLi4vaW5kZXgnKSxcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5kZXNjcmliZSgncGVyZm9ybSBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG5cblxuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBSZWxhdGlvbnNoaXBUeXBlID0gcmVxdWlyZSgnLi4vLi4vc3JjL3JlbGF0aW9uc2hpcCcpLlJlbGF0aW9uc2hpcFR5cGU7XG5cbiAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi8uLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG4gICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NhY2hlJyk7XG4gICAgdmFyIE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3ZlbmRvci9vcGVyYXRpb25zLmpzL3NyYy9vcGVyYXRpb24nKS5PcGVyYXRpb247XG5cbiAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZywgcGVyc29uTWFwcGluZztcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBudWxsO1xuICAgICAgICBjYXJNYXBwaW5nID0gbnVsbDtcbiAgICAgICAgcGVyc29uTWFwcGluZyA9IG51bGw7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBudW1JbmNvbXBsZXRlID0gMDtcbiAgICAgICAgXy5lYWNoKE9wZXJhdGlvbi5ydW5uaW5nLCBmdW5jdGlvbihvcCkge1xuICAgICAgICAgICAgaWYgKCFvcC5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBudW1JbmNvbXBsZXRlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQubm90T2sobnVtSW5jb21wbGV0ZSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZW1wdHknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdlbXB0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe30sIGZ1bmN0aW9uKGVyciwgX29iaikge1xuICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhfb2JqKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuXG5cbiAgICBkZXNjcmliZSgnbm8gaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCd4eXonLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgb2JqO1xuICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IF9vYmo7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdubyByZWxhdGlvbnNoaXBzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvYmo7XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnZGZhZGYnXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvYmogPSBfb2JqO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ25ldycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBpdCgncmV0dXJucyBhIG1vZGVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2Yob2JqLCBTaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2hhcyB0aGUgcmlnaHQgZmllbGRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXIsICdyZWQnKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLm5hbWUsICdBc3RvbiBNYXJ0aW4nKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmlkLCAnZGZhZGYnKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQub2sob2JqLl9pZCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdleGlzdGluZyBpbiBjYWNoZScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBkZXNjcmliZSgndmlhIGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld09iajtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2RmYWRmJ1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3T2JqID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgYmUgbWFwcGVkIG9udG8gdGhlIG9sZCBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5ld09iaiwgb2JqKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSB0aGUgbmV3IGNvbG91cicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobmV3T2JqLmNvbG91ciwgJ2JsdWUnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgndmlhIF9pZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdPYmo7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBvYmouX2lkXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmogPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBiZSBtYXBwZWQgb250byB0aGUgb2xkIG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobmV3T2JqLCBvYmopO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBoYXZlIHRoZSBuZXcgY29sb3VyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuZXdPYmouY29sb3VyLCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3dpdGggcmVsYXRpb25zaGlwJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlc2NyaWJlKCdmb3JlaWduIGtleScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdyZW1vdGUgaWQnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdvYmplY3QgdGhhdCBhbHJlYWR5IGV4aXN0cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiwgY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9wZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ3BlcnNvblJlbW90ZUlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ293bmVyIG9mIGNhciBzaG91bGQgYmUgbWljaGFlbCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lclByb3h5LmdldChmdW5jdGlvbihlcnIsIG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ21pY2hhZWwgc2hvdWxkIG93biB0aGUgY2FyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgY2Fycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgncmVtb3RlIGlkIG9mIGFuIG9iamVjdCB0aGF0IGRvZXNudCBleGlzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2NhclJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnY2FyIHNob3VsZCBoYXZlIGEgbmV3IG93bmVyIGFuZCBuZXcgb3duZXIgc2hvdWxkIGhhdmUgYSBjYXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbi5pZCwgJ3BlcnNvblJlbW90ZUlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgY2Fycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZWlkcyBvZiBvYmplY3RzIHRoYXQgYWxyZWFkeSBleGlzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiwgY2FycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbihlcnIsIG9ianMsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzID0gb2JqcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnM6IFsncmVtb3RlSWQxJywgJ3JlbW90ZUlkMicsICdyZW1vdGVJZDMnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdjYXJzIHNob3VsZCBoYXZlIHBlcnNvbiBhcyB0aGVpciBvd25lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChjYXJzLCBmdW5jdGlvbihjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdwZXJzb24gc2hvdWxkIGhhdmUgY2FyIG9iamVjdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5jYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZWlkcyBvZiBvYmplY3RzIHRoYXQgZG9udCBleGlzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzOiBbJ3JlbW90ZUlkMScsICdyZW1vdGVJZDInLCAncmVtb3RlSWQzJ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9wZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3BlcnNvbiBoYXMgMyBuZXcgY2FycywgYW5kIHRob3NlIGNhcnMgYXJlIG93bmVkIGJ5IHRoZSBwZXJzb24nLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnNQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdtaXh0dXJlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhdyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbihlcnIsIG9ianMsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBvYmpzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnM6IFsncmVtb3RlSWQxJywgJ3JlbW90ZUlkMicsICdyZW1vdGVJZDMnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9wZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IF9wZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdjYXJzIHNob3VsZCBoYXZlIHBlcnNvbiBhcyB0aGVpciBvd25lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChjYXJzLCBmdW5jdGlvbihjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdwZXJzb24gc2hvdWxkIGhhdmUgY2FyIG9iamVjdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5jYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3BlcnNvbiBoYXMgMyBuZXcgY2FycywgYW5kIHRob3NlIGNhcnMgYXJlIG93bmVkIGJ5IHRoZSBwZXJzb24nLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnNQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVzY3JpYmUoJ29iamVjdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiwgY2FyO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9wZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogcGVyc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2NhclJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ293bmVyIG9mIGNhciBzaG91bGQgYmUgbWljaGFlbCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lclByb3h5LmdldChmdW5jdGlvbihlcnIsIG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ21pY2hhZWwgc2hvdWxkIHRoZSBjYXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fyc1Byb3h5LmdldChmdW5jdGlvbihlcnIsIGNhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgncmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXJzO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcsIGZ1bmN0aW9uKGVyciwgb2JqcywgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBvYmpzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzOiBvYmpzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdjYXJzIHNob3VsZCBoYXZlIHBlcnNvbiBhcyB0aGVpciBvd25lcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIub3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgncGVyc29uIHNob3VsZCBoYXZlIGNhciBvYmplY3RzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ2xvY2FsIGlkIHdpdGhpbiBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXI7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IHBlcnNvbi5faWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdCgnb3duZXIgb2YgY2FyIHNob3VsZCBiZSBtaWNoYWVsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgb3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdCgnbWljaGFlbCBzaG91bGQgdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgY2Fycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgncmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXJzO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcsIGZ1bmN0aW9uKGVyciwgb2JqcywgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzID0gb2JqcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyczogXy5tYXAoY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogY2FyLl9pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ2NhcnMgc2hvdWxkIGhhdmUgcGVyc29uIGFzIHRoZWlyIG93bmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdwZXJzb24gc2hvdWxkIGhhdmUgY2FyIG9iamVjdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChjYXJzLCBmdW5jdGlvbihjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZSBpZCB3aXRoaW4gb2JqZWN0JywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgnb2JqZWN0IHRoYXQgYWxyZWFkeSBleGlzdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb24sIGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQxMjMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkMTIzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnb3duZXIgb2YgY2FyIHNob3VsZCBiZSBtaWNoYWVsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lclByb3h5LmdldChmdW5jdGlvbihlcnIsIG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ21pY2hhZWwgc2hvdWxkIHRoZSBjYXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnNQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdyZW1vdGUgaWQgb2YgYW4gb2JqZWN0IHRoYXQgZG9lc250IGV4aXN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnY2FyIHNob3VsZCBoYXZlIGEgbmV3IG93bmVyIGFuZCBuZXcgb3duZXIgc2hvdWxkIGhhdmUgYSBjYXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbi5pZCwgJ3BlcnNvblJlbW90ZUlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgY2Fycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZWlkcyBvZiBvYmplY3RzIHRoYXQgYWxyZWFkeSBleGlzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiwgY2FycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbihlcnIsIG9ianMsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBvYmpzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2NhcnMgc2hvdWxkIGhhdmUgcGVyc29uIGFzIHRoZWlyIG93bmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3BlcnNvbiBzaG91bGQgaGF2ZSBjYXIgb2JqZWN0cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChjYXJzLCBmdW5jdGlvbihjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgncmVtb3RlaWRzIG9mIG9iamVjdHMgdGhhdCBkb250IGV4aXN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IF9wZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgncGVyc29uIGhhcyAzIG5ldyBjYXJzLCBhbmQgdGhvc2UgY2FycyBhcmUgb3duZWQgYnkgdGhlIHBlcnNvbicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fyc1Byb3h5LmdldChmdW5jdGlvbihlcnIsIGNhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fycy5sZW5ndGgsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ21peHR1cmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb24sIGNhcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlbW90ZUlkM1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcsIGZ1bmN0aW9uKGVyciwgb2JqcywgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FycyA9IG9ianM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2NhcnMgc2hvdWxkIGhhdmUgcGVyc29uIGFzIHRoZWlyIG93bmVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3BlcnNvbiBzaG91bGQgaGF2ZSBjYXIgb2JqZWN0cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChjYXJzLCBmdW5jdGlvbihjYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgncGVyc29uIGhhcyAzIG5ldyBjYXJzLCBhbmQgdGhvc2UgY2FycyBhcmUgb3duZWQgYnkgdGhlIHBlcnNvbicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fyc1Byb3h5LmdldChmdW5jdGlvbihlcnIsIGNhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fycy5sZW5ndGgsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goY2FycywgZnVuY3Rpb24oY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdvbmUtdG8tb25lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGVyc29uTWFwcGluZztcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9PbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcblxuXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBkZXNjcmliZSgncmVtb3RlIGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ29iamVjdCB0aGF0IGFscmVhZHkgZXhpc3RzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IF9wZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdvd25lciBvZiBjYXIgc2hvdWxkIGJlIG1pY2hhZWwnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgb3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnbWljaGFlbCBzaG91bGQgb3duIHRoZSBjYXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbnNDYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLCBwZXJzb25zQ2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgncmVtb3RlIGlkIG9mIGFuIG9iamVjdCB0aGF0IGRvZXNudCBleGlzdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2NhclJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2NhciBzaG91bGQgaGF2ZSBhIG5ldyBvd25lciBhbmQgbmV3IG93bmVyIHNob3VsZCBoYXZlIGEgY2FyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uaWQsICdwZXJzb25SZW1vdGVJZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uc0Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbnNDYXIsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdyZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdvYmplY3QgdGhhdCBhbHJlYWR5IGV4aXN0cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiwgY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyOiAnY2FyUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ293bmVyIG9mIGNhciBzaG91bGQgYmUgbWljaGFlbCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdtaWNoYWVsIHNob3VsZCBvd24gdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uc0Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIHBlcnNvbnNDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZSBpZCBvZiBhbiBvYmplY3QgdGhhdCBkb2VzbnQgZXhpc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ3BlcnNvblJlbW90ZUlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdjYXIgc2hvdWxkIGhhdmUgYSBuZXcgb3duZXIgYW5kIG5ldyBvd25lciBzaG91bGQgaGF2ZSBhIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBwZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmlkLCAncGVyc29uUmVtb3RlSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbnNDYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25zQ2FyLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgncmVtb3RlIGlkIHdpdGhpbiBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgnb2JqZWN0IHRoYXQgYWxyZWFkeSBleGlzdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb24sIGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ293bmVyIG9mIGNhciBzaG91bGQgYmUgbWljaGFlbCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdtaWNoYWVsIHNob3VsZCBvd24gdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uc0Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIHBlcnNvbnNDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZSBpZCBvZiBhbiBvYmplY3QgdGhhdCBkb2VzbnQgZXhpc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdjYXIgc2hvdWxkIGhhdmUgYSBuZXcgb3duZXIgYW5kIG5ldyBvd25lciBzaG91bGQgaGF2ZSBhIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBwZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmlkLCAncGVyc29uUmVtb3RlSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbnNDYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25zQ2FyLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgncmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgnb2JqZWN0IHRoYXQgYWxyZWFkeSBleGlzdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb24sIGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfcGVyc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ293bmVyIG9mIGNhciBzaG91bGQgYmUgbWljaGFlbCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdtaWNoYWVsIHNob3VsZCBvd24gdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uc0Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIHBlcnNvbnNDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbW90ZSBpZCBvZiBhbiBvYmplY3QgdGhhdCBkb2VzbnQgZXhpc3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdjYXIgc2hvdWxkIGhhdmUgYSBuZXcgb3duZXIgYW5kIG5ldyBvd25lciBzaG91bGQgaGF2ZSBhIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBwZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmlkLCAncGVyc29uUmVtb3RlSWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbnNDYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25zQ2FyLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnX2lkIHdpdGhpbiBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXI7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBwZXJzb24uX2lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdvd25lciBvZiBjYXIgc2hvdWxkIGJlIG1pY2hhZWwnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdtaWNoYWVsIHNob3VsZCBvd24gdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBwZXJzb25zQ2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIHBlcnNvbnNDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgncmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXI7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGNhci5faWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9wZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdvd25lciBvZiBjYXIgc2hvdWxkIGJlIG1pY2hhZWwnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdtaWNoYWVsIHNob3VsZCBvd24gdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBwZXJzb25zQ2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIHBlcnNvbnNDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXI7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBfcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogcGVyc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdCgnb3duZXIgb2YgY2FyIHNob3VsZCBiZSBtaWNoYWVsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgb3duZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpdCgnbWljaGFlbCBzaG91bGQgb3duIHRoZSBjYXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVyc29uc0Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLCBwZXJzb25zQ2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiwgY2FyO1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcjogY2FyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX3BlcnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IF9wZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ293bmVyIG9mIGNhciBzaG91bGQgYmUgbWljaGFlbCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lclByb3h5LmdldChmdW5jdGlvbihlcnIsIG93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ21pY2hhZWwgc2hvdWxkIG93biB0aGUgY2FyJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhclByb3h5LmdldChmdW5jdGlvbihlcnIsIHBlcnNvbnNDYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhciwgcGVyc29uc0Nhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY2F2ZWF0cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hcHBpbmcgYW4gYXR0cmlidXRlIHRoYXQgZG9lc250IGV4aXN0JywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ2FzdG9uIG1hcnRpbicsXG4gICAgICAgICAgICAgICAgZXh0cmFuZW91czogJ2JsYWgnXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soY2FyLmV4dHJhbmVvdXMpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2Vycm9ycycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBkZXNjcmliZSgnb25lLXRvLW9uZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBlcnNvbk1hcHBpbmc7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvT25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2Fzc2lnbiBhcnJheSB0byBzY2FsYXIgcmVsYXRpb25zaGlwJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiBbJ3JlbW90ZUlkMScsICdyZW1vdGVJZDInXSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdjYXJSZW1vdGVJZCdcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3duZXJFcnJvciA9IGVyci5vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG93bmVyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2Fzc2lnbiBhcnJheSB0byBzY2FsYXIgcmVsYXRpb25zaGlwIHJldmVyc2UnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgY2FyOiBbJ3JlbW90ZUlkMScsICdyZW1vdGVJZDInXSxcbiAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soZXJyLmNhcik7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSk7XG4gICAgICAgIGRlc2NyaWJlKCdmb3JlaWduIGtleScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgcGVyc29uTWFwcGluZztcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdhc3NpZ24gYXJyYXkgdG8gc2NhbGFyIHJlbGF0aW9uc2hpcCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICBvd25lcjogWydyZW1vdGVJZDEnLCAncmVtb3RlSWQyJ10sXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnY2FyUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG93bmVyRXJyb3IgPSBlcnIub3duZXI7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhvd25lckVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdhc3NpZ24gc2NhbGFyIHRvIHZlY3RvciByZWxhdGlvbnNoaXAgcmV2ZXJzZScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICBjYXJzOiAncmVtb3RlSWQxJyxcbiAgICAgICAgICAgICAgICAgICAgYWdlOiAyMyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soZXJyLmNhcnMpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2J1bGsnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVzY3JpYmUoJ25ldycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVzY3JpYmUoJ25vIHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdhbGwgdmFsaWQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDFzZGZzZGZkc2Znc2RmJ1xuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDJkZmdkZmdkZmdcIlxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDNkZmdkZmdkZmdkZmdcIlxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcsIGZ1bmN0aW9uKGVyciwgb2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianMubGVuZ3RoLCByYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzWzBdLmNvbG91ciwgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianNbMV0uY29sb3VyLCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianNbMl0uY29sb3VyLCAnZ3JlZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcmVpZ24ga2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBlcnNvbk1hcHBpbmc7XG5cbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3NhbWUgb3duZXIgdXNpbmcgX21hcEJ1bGsnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvd25lcklkID0gJ293bmVySWQ0NjIzNDUzNDUnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBvd25lcklkXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlbW90ZUlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVySWRcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogb3duZXJJZFxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcsIGZ1bmN0aW9uKGVyciwgb2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianMubGVuZ3RoLCByYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzWzBdLm93bmVyLCBvYmpzWzFdLm93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzWzFdLm93bmVyLCBvYmpzWzJdLm93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzYW1lIG93bmVyIHVzaW5nIG1hcCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG93bmVySWQgPSAnb3duZXJJZCEhITMzNCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXJSYXcxID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IG93bmVySWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhclJhdzIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibycsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiBvd25lcklkXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKGNhclJhdzEsIGZ1bmN0aW9uKGVyciwgY2FyMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoY2FyUmF3MiwgZnVuY3Rpb24oZXJyLCBjYXIyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcjEub3duZXIsIGNhcjIub3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdmYXVsdGVkIHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYXJzO1xuXG4gICAgICAgICAgICB2YXIgcGVyc29uTWFwcGluZztcblxuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICBkZXNjcmliZSgndmlhIHJlbW90ZSBpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcsIGZ1bmN0aW9uKGVyciwgb2JqcywgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBvYmpzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBoYXZlIG1hcHBlZCBvbnRvIE1pY2hhZWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMF0ub3duZXIsIGNhcnNbMV0ub3duZXIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fyc1sxXS5vd25lciwgY2Fyc1syXS5vd25lcik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdidWxrIGJ1bGsnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcxID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0ZvcmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlbW90ZUlkM1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3MSwgZnVuY3Rpb24oZXJyLCBvYmpzLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKG9ianMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fycy5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXJzLmxlbmd0aCA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcyID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdQZWF1Z2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQ2hldnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlbW90ZUlkNVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLl9tYXBCdWxrKHJhdzIsIGZ1bmN0aW9uKGVyciwgb2JqcywgcmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChvYmpzLCBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMucHVzaChvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fycy5sZW5ndGggPT0gOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3MyA9IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRmVyYXJyaScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1ZvbHZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogXCJyZW1vdGVJZDhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRG9kZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlbW90ZUlkOVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3MywgZnVuY3Rpb24oZXJyLCBvYmpzLCByZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKG9ianMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fycy5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXJzLmxlbmd0aCA9PSA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBtYXBwZWQgb250byBNaWNoYWVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgOSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fyc1tpXS5vd25lciwgY2Fyc1tpICsgMV0ub3duZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgndmlhIG5lc3RlZCByZW1vdGUgaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDIzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTGFtYm8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlbW90ZUlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbihlcnIsIG9ianMsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzID0gb2JqcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBtYXBwZWQgb250byBNaWNoYWVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzWzBdLm93bmVyLCBjYXJzWzFdLm93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMV0ub3duZXIsIGNhcnNbMl0ub3duZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3ZpYSBuZXN0ZWQgcmVtb3RlIGlkIHdpdGggdW5tZXJnZWRDaGFuZ2VzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0KDUwMDApO1xuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3BlcnNvblJlbW90ZUlkJ1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncGVyc29uUmVtb3RlSWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVtb3RlSWQzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdwZXJzb25SZW1vdGVJZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbihlcnIsIG9ianMsIHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzID0gb2JqcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBtYXBwZWQgb250byBNaWNoYWVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzWzBdLm93bmVyLCBjYXJzWzFdLm93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMV0ub3duZXIsIGNhcnNbMl0ub3duZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBjaGFuZ2VkIHRoZSBuYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzWzBdLm93bmVyLm5hbWUsICdCb2InKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMV0ub3duZXIubmFtZSwgJ0JvYicpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fyc1syXS5vd25lci5uYW1lLCAnQm9iJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgfSk7XG5cblxuICAgIH0pO1xufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi8uLi9pbmRleCcpXG4gICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5kZXNjcmliZSgnbWFwcGluZyEnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE1hcHBpbmcgPSByZXF1aXJlKCcuLi8uLi9zcmMvbWFwcGluZycpLk1hcHBpbmc7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcy5yZXNldCh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdfZmllbGRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBNYXBwaW5nKHtcbiAgICAgICAgICAgIHR5cGU6ICd0eXBlJyxcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydmaWVsZDEnLCAnZmllbGQyJ11cbiAgICAgICAgfSk7XG4gICAgICAgIGFzc2VydC5pbmNsdWRlKG0uX2ZpZWxkcywgJ2lkJyk7XG4gICAgICAgIGFzc2VydC5pbmNsdWRlKG0uX2ZpZWxkcywgJ2ZpZWxkMScpO1xuICAgICAgICBhc3NlcnQuaW5jbHVkZShtLl9maWVsZHMsICdmaWVsZDInKTtcbiAgICAgICAgYXNzZXJ0Lm5vdEluY2x1ZGUobS5fZmllbGRzLCAndHlwZScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2F0dHJpYnV0ZXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gbmV3IE1hcHBpbmcoe1xuICAgICAgICAgICAgdHlwZTogJ3R5cGUnLFxuICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2ZpZWxkMScsICdmaWVsZDInXVxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0LmluY2x1ZGUobS5hdHRyaWJ1dGVzLCAnZmllbGQxJyk7XG4gICAgICAgIGFzc2VydC5pbmNsdWRlKG0uYXR0cmlidXRlcywgJ2ZpZWxkMicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3R5cGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gbmV3IE1hcHBpbmcoe1xuICAgICAgICAgICAgdHlwZTogJ3R5cGUnLFxuICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2ZpZWxkMScsICdmaWVsZDInXVxuICAgICAgICB9KTtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKG0udHlwZSwgJ3R5cGUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdpZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgTWFwcGluZyh7XG4gICAgICAgICAgICB0eXBlOiAndHlwZScsXG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZmllbGQxJywgJ2ZpZWxkMiddXG4gICAgICAgIH0pO1xuICAgICAgICBhc3NlcnQuZXF1YWwobS5pZCwgJ2lkJyk7XG4gICAgfSk7XG5cblxuXG5cbn0pOyIsIi8qXG4gVGhlc2UgdGVzdHMgZGVhbCB3aXRoIHRoZSBjcmVhdGlvbiBvZiBuZXcgU2llc3RhTW9kZWwgb2JqZWN0cy5cbiAqL1xuXG52YXIgcyA9IHJlcXVpcmUoJy4uLy4uL2luZGV4JylcbiAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCdtYXBwaW5nIG5ldyBvYmplY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG5cbiAgICB2YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xuICAgIHZhciBPbmVUb01hbnlQcm94eSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9vbmVUb01hbnlQcm94eScpLk9uZVRvTWFueVByb3h5O1xuICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jYWNoZScpO1xuICAgIFxuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZmllbGRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZztcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCd2YWxpZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbiAgICAgICAgICAgIF8uZWFjaChjYXJNYXBwaW5nLl9maWVsZHMsIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNhcltmXSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnaWQgZmllbGQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FyO1xuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Nob3VsZCBiZSBwcmVzZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5wcm9wZXJ0eShjYXIsICdpZCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdpbiBjYWNoZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGNhcik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIGNhY2hlLmdldCh7X2lkOiBjYXIuX2lkfSkpO1xuICAgICAgICAgICAgICAgICAgICBjYXIuaWQgPSAnbmV3UmVtb3RlSWQnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgdXBkYXRlIGNhY2hlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLCBjYWNoZS5nZXQoe2lkOiBjYXIuaWQsIG1hcHBpbmc6IGNhci5tYXBwaW5nfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgcmVtb3ZlIHByZXZpb3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLCBjYWNoZS5nZXQoe2lkOiBjYXIuaWQsIG1hcHBpbmc6IGNhci5tYXBwaW5nfSkpO1xuICAgICAgICAgICAgICAgICAgICBjYXIuaWQgPSAnYnJhbmROZXdSZW1vdGVJZCc7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIGNhY2hlLmdldCh7aWQ6IGNhci5pZCwgbWFwcGluZzogY2FyLm1hcHBpbmd9KSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYWNoZS5nZXQoe2lkOiAnbmV3UmVtb3RlSWQnLCBtYXBwaW5nOiBjYXIubWFwcGluZ30pKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgcmVtb3ZlIGFsbCBpZiBzZXQgcmVtb3RlaWQgdG8gbnVsbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhciwgY2FjaGUuZ2V0KHtpZDogY2FyLmlkLCBtYXBwaW5nOiBjYXIubWFwcGluZ30pKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyLmlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGNhY2hlLmdldCh7aWQ6ICduZXdSZW1vdGVJZCcsIG1hcHBpbmc6IGNhci5tYXBwaW5nfSkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgncmVsYXRpb25zaGlwcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24sIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbiAgICAgICAgZnVuY3Rpb24gY29uZmlndXJlQVBJKHR5cGUsIHJldmVyc2VOYW1lLCBkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiByZXZlcnNlTmFtZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydhZ2UnLCAnbmFtZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyZUFQSShSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSwgJ2NhcnMnLCBkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ2luc3RhbGxhdGlvbiBvZiBwcm94aWVzJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpdCgnaW5zdGFsbHMgZm9yd2FyZCByZWxhdGVkIG9iamVjdCBwcm94eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FyT2JqZWN0ID0gY2FyTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2FyT2JqZWN0Lm93bmVyUHJveHksIE9uZVRvTWFueVByb3h5KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnaW5zdGFsbHMgcmV2ZXJzZSByZWxhdGVkIG9iamVjdCBwcm94eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGVyc29uT2JqZWN0ID0gcGVyc29uTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YocGVyc29uT2JqZWN0LmNhcnNQcm94eSwgT25lVG9NYW55UHJveHkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuXG5cbn0pO1xuIiwidmFyIHMgPSByZXF1aXJlKCcuLi8uLi9pbmRleCcpLFxuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCdtYXBwaW5nIHF1ZXJpZXMnLCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBTaWVzdGFNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL3NyYy9vYmplY3QnKS5TaWVzdGFNb2RlbDtcbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbiAgICB2YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xuICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jYWNoZScpO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgcy5yZXNldCh0cnVlKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdxdWVyaWVzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uLCBtYXBwaW5nO1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBtYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvcicsICduYW1lJ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLm1hcChbe1xuICAgICAgICAgICAgICAgICAgICBpZDogNCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJ1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IDUsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdGb3JkJ1xuICAgICAgICAgICAgICAgIH1dLCBkb25lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnYWxsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbWFwcGluZy5hbGwoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihjYXIsIFNpZXN0YU1vZGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3F1ZXJ5JywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0KDEwMDAwKTtcbiAgICAgICAgICAgIG1hcHBpbmcucXVlcnkoe1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmVkJ1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihjYXIsIFNpZXN0YU1vZGVsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2dldCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2V0KDQsIGZ1bmN0aW9uKGVyciwgY2FyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhjYXIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGNhciwgU2llc3RhTW9kZWwpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3IsICdyZWQnKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3JldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbiAgICAgICAgdmFyIGNvbGxlY3Rpb247XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgaXQoJ2NhY2hlZCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuICAgICAgICAgICAgICAgICAgICBhZ2U6IDIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnMidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlkOiA1XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLmdldCgnMicsIGZ1bmN0aW9uKGVyciwgcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhwLCAnU2hvdWxkIGJlIGFibGUgdG8gZmV0Y2ggdGhlIHBlcnNvbicpO1xuICAgICAgICAgICAgICAgICAgICBwLmNhcnNQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fycy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMF0ub3duZXIsIHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uLy4uL2luZGV4JylcbiAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCdtYXBwaW5nIHZhbGlkYXRpb24nLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIE1hcHBpbmcgPSAgcmVxdWlyZSgnLi4vLi4vc3JjL21hcHBpbmcnKS5NYXBwaW5nO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgndmFsaWRhdGlvbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoJ25vIHR5cGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbSA9IG5ldyBNYXBwaW5nKHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2ZpZWxkMScsICdmaWVsZDInXSxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gbS5fdmFsaWRhdGUoKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCgxLCBlcnJvcnMubGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdubyBjb2xsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG0gPSBuZXcgTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydmaWVsZDEnLCAnZmllbGQyJ10sXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NhcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IG0uX3ZhbGlkYXRlKCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoMSwgZXJyb3JzLmxlbmd0aCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufSk7IiwiXG52YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4Jyk7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xudmFyIG5vdGlmaWNhdGlvbkNlbnRyZSA9IHJlcXVpcmUoJy4uL3NyYy9ub3RpZmljYXRpb25DZW50cmUnKS5ub3RpZmljYXRpb25DZW50cmU7XG5cbmRlc2NyaWJlKCdOb3RpZmljYXRpb24gQ2VudHJlJywgZnVuY3Rpb24gKCkge1xuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2VtaXNzaW9ucycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXQoJ3NpbXBsZSBlbWlzc2lvbnMgd29yaycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25DZW50cmUub24oJ2JsYWgnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub3RpZmljYXRpb25DZW50cmUuZW1pdCgnYmxhaCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnZW1pc3Npb25zIHdpdGggcGF5bG9hZHMgd29yaycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uQ2VudHJlLm9uKCdibGFoJywgZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGF5bG9hZCwgcCk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub3RpZmljYXRpb25DZW50cmUuZW1pdCgnYmxhaCcsIHApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuXG5cblxuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ25vdGlmaWNhdGlvbnMnLCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uLFxuICAgICAgICBDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi4vc3JjL2NoYW5nZXMnKS5DaGFuZ2VUeXBlLFxuICAgICAgICB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKVxuICAgIG5vdGlmaWNhdGlvbkNlbnRyZSA9IHJlcXVpcmUoJy4uL3NyYy9ub3RpZmljYXRpb25DZW50cmUnKS5ub3RpZmljYXRpb25DZW50cmU7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgIH0pO1xuXG4gICAgdmFyIGNhcjtcbiAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZztcbiAgICB2YXIgY2FyO1xuXG4gICAgdmFyIG5vdGlmLCBjb2xsZWN0aW9uTm90aWYsIGdlbmVyaWNOb3RpZiwgbG9jYWxJZE5vdGlmLCByZW1vdGVJZE5vdGlmO1xuXG4gICAgZGVzY3JpYmUoJ2F0dHJpYnV0ZXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbm90aWYgPSBudWxsO1xuICAgICAgICAgICAgY29sbGVjdGlvbk5vdGlmID0gbnVsbDtcbiAgICAgICAgICAgIGdlbmVyaWNOb3RpZiA9IG51bGw7XG4gICAgICAgICAgICBjYXIgPSBudWxsO1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBjYXJNYXBwaW5nID0gbnVsbDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3NldCB2YWx1ZScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eidcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRG9uZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGlmICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY05vdGlmICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5vdGlmICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbElkTm90aWYgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJZE5vdGlmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vbmNlKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub25jZSgnbXlDb2xsZWN0aW9uJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9uY2UoJ1NpZXN0YScsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY05vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9uY2UoX2Nhci5faWQsIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSWROb3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub25jZSgnbXlDb2xsZWN0aW9uOkNhcjp4eXonLCBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVJZE5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLmNvbG91ciA9ICdibHVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnYWxsIG5vdGlmcyBlcXVhbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYsIGdlbmVyaWNOb3RpZik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGdlbmVyaWNOb3RpZiwgY29sbGVjdGlvbk5vdGlmKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY29sbGVjdGlvbk5vdGlmLCBsb2NhbElkTm90aWYpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChsb2NhbElkTm90aWYsIHJlbW90ZUlkTm90aWYpO1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgaXQoJ25vdGlmIGNvbnRhaW5zIGNvbGxlY3Rpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLm1hcHBpbmcsICdDYXInKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnY2hhbmdlRGljdCBjb250YWlucyBhdHRyaWJ1dGUgbmFtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5maWVsZCwgJ2NvbG91cicpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdjaGFuZ2VEaWN0IGNvbnRhaW5zIGNoYW5nZSB0eXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnY2hhbmdlRGljdCBjb250YWlucyBvbGQgdmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYub2xkLCAncmVkJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2NoYW5nZURpY3QgY29udGFpbnMgbmV3IHZhbHVlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLm5ldywgJ2JsdWUnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnY2hhbmdlRGljdCBjb250YWlucyBuZXcgdmFsdWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdhcnJheSBub3RpZmljYXRpb25zJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3NlbmRzIG5vdGlmaWNhdGlvbnMgZm9yIGFsbCBsZXZlbHMnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdGlmcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyczogWydyZWQnLCAnYmx1ZSddLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZzLnB1c2gobik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90aWZzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzLm9uY2UoJ215Q29sbGVjdGlvbjpDYXInLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHMub25jZSgnbXlDb2xsZWN0aW9uJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBzLm9uY2UoJ1NpZXN0YScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcy5vbmNlKF9jYXIuX2lkLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHMub25jZSgnbXlDb2xsZWN0aW9uOkNhcjp4eXonLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGNhci5jb2xvdXJzLnB1c2goJ2dyZWVuJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3B1c2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyczogWydyZWQnLCAnYmx1ZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eidcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbmNlKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5jb2xvdXJzLnB1c2goJ2dyZWVuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbm90aWYgY29udGFpbnMgY29sbGVjdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vdGlmIGNvbnRhaW5zIG1hcHBpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLm1hcHBpbmcsICdDYXInKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLl9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnY2hhbmdlRGljdCBjb250YWlucyBjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLmZpZWxkLCAnY29sb3VycycpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuaW5kZXgsIDIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYucmVtb3ZlZC5sZW5ndGgsIDApO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuYWRkZWQubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdwb3AnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyczogWydyZWQnLCAnYmx1ZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eidcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbmNlKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5jb2xvdXJzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBjb2xsZWN0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbm90aWYgY29udGFpbnMgbWFwcGluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYubWFwcGluZywgJ0NhcicpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vdGlmIGNvbnRhaW5zIF9pZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLmZpZWxkLCAnY29sb3VycycpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYucmVtb3ZlZC5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShub3RpZi5yZW1vdmVkLCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuYWRkZWQubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnc2hpZnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyczogWydyZWQnLCAnYmx1ZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3h5eidcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbmNlKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5jb2xvdXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vdGlmIGNvbnRhaW5zIGNvbGxlY3Rpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5tYXBwaW5nLCAnQ2FyJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbm90aWYgY29udGFpbnMgaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLl9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbm90aWYgY29udGFpbnMgY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5maWVsZCwgJ2NvbG91cnMnKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLmluZGV4LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLnJlbW92ZWQubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUobm90aWYucmVtb3ZlZCwgJ3JlZCcpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuYWRkZWQubGVuZ3RoLCAwKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgndW5zaGlmdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXJzOiBbJ3JlZCcsICdibHVlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAneHl6J1xuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIF9jYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHMub25jZSgnbXlDb2xsZWN0aW9uOkNhcicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIuY29sb3Vycy51bnNoaWZ0KCdncmVlbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vdGlmIGNvbnRhaW5zIHR5cGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5tYXBwaW5nLCAnQ2FyJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpdCgnbm90aWYgY29udGFpbnMgb2JqZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ25vdGlmIGNvbnRhaW5zIGNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuZmllbGQsICdjb2xvdXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5pbmRleCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5yZW1vdmVkLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5hZGRlZC5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3NvcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm90aWZzID0gW107XG5cbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cnM6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2NhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZnMucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90aWZzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMucmVtb3ZlTGlzdGVuZXIoJ215Q29sbGVjdGlvbjpDYXInLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uOkNhcicsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5jb2xvdXJzLnNvcnQoKTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBjb2xsZWNpdG9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChub3RpZnMsIGZ1bmN0aW9uKG5vdGlmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZWFjaChub3RpZnMsIGZ1bmN0aW9uKG5vdGlmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYubWFwcGluZywgJ0NhcicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKG5vdGlmcywgZnVuY3Rpb24obm90aWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdub3RpZiBjb250YWlucyBjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92YWxOb3RpZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZE5vdGlmO1xuICAgICAgICAgICAgICAgICAgICBfLmVhY2gobm90aWZzLCBmdW5jdGlvbihub3RpZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLmZpZWxkLCAnY29sb3VycycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RpZi5yZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92YWxOb3RpZiA9IG5vdGlmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RpZi5hZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE5vdGlmID0gbm90aWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3JlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb247XG4gICAgICAgIHZhciBjYXIsIHBlcnNvbjtcbiAgICAgICAgdmFyIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbiAgICAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG5cblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdhcnJheScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgcGVyc29uTm90aWYsIHBlcnNvbkdlbmVyaWNOb3RpZiwgcGVyc29uQ29sbGVjdGlvbk5vdGlmO1xuICAgICAgICAgICAgdmFyIGNhck5vdGlmLCBjYXJHZW5lcmljTm90aWYsIGNhckNvbGxlY3Rpb25Ob3RpZjtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcmVpZ24ga2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cnMnLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgncHVzaCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyQ2FyO1xuXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyQ2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBwZXJzb25NYXBwaW5nLl9uZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdteUNvbGxlY3Rpb246UGVyc29uJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UgJiYgbi5tYXBwaW5nID09ICdQZXJzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuU3BsaWNlICYmIG4ubWFwcGluZyA9PSAnUGVyc29uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25Db2xsZWN0aW9uTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignU2llc3RhJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UgJiYgbi5tYXBwaW5nID09ICdQZXJzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbkdlbmVyaWNOb3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TZXQgJiYgbi5tYXBwaW5nID09ICdDYXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuU2V0ICYmIG4ubWFwcGluZyA9PSAnQ2FyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJDb2xsZWN0aW9uTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignU2llc3RhJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TZXQgJiYgbi5tYXBwaW5nID09ICdDYXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhckdlbmVyaWNOb3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fycy5wdXNoKGFub3RoZXJDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5uZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkNlbnRyZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgncGVyc29uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgndHlwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25Ob3RpZi50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkdlbmVyaWNOb3RpZi50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNvbGxlY3Rpb25Ob3RpZi50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2lkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uTm90aWYuYWRkZWRJZCwgYW5vdGhlckNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkdlbmVyaWNOb3RpZi5hZGRlZElkLCBhbm90aGVyQ2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ29sbGVjdGlvbk5vdGlmLmFkZGVkSWQsIGFub3RoZXJDYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnYWRkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Ob3RpZi5hZGRlZCwgYW5vdGhlckNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uR2VuZXJpY05vdGlmLmFkZGVkLCBhbm90aGVyQ2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Db2xsZWN0aW9uTm90aWYuYWRkZWQsIGFub3RoZXJDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdjYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCd0eXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhck5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyR2VuZXJpY05vdGlmLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyQ29sbGVjdGlvbk5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTm90aWYubmV3SWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJHZW5lcmljTm90aWYubmV3SWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJDb2xsZWN0aW9uTm90aWYubmV3SWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCduZXcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTm90aWYubmV3LCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJHZW5lcmljTm90aWYubmV3LCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJDb2xsZWN0aW9uTm90aWYubmV3LCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnc3BsaWNlJywgZnVuY3Rpb24oZG9uZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBwZXJzb25NYXBwaW5nLl9uZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdteUNvbGxlY3Rpb246UGVyc29uJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uQ29sbGVjdGlvbk5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ1NpZXN0YScsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuU3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbkdlbmVyaWNOb3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TZXQgJiYgbi5tYXBwaW5nID09ICdDYXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuU2V0ICYmIG4ubWFwcGluZyA9PSAnQ2FyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJDb2xsZWN0aW9uTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignU2llc3RhJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TZXQgJiYgbi5tYXBwaW5nID09ICdDYXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhckdlbmVyaWNOb3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fycy5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uQ2VudHJlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdwZXJzb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCd0eXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbk5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uR2VuZXJpY05vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ29sbGVjdGlvbk5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Ob3RpZi5yZW1vdmVkSWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkdlbmVyaWNOb3RpZi5yZW1vdmVkSWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNvbGxlY3Rpb25Ob3RpZi5yZW1vdmVkSWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdhZGRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbk5vdGlmLnJlbW92ZWQsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uR2VuZXJpY05vdGlmLnJlbW92ZWQsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ29sbGVjdGlvbk5vdGlmLnJlbW92ZWQsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2NhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3R5cGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJHZW5lcmljTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJDb2xsZWN0aW9uTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCduZXcgaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soY2FyTm90aWYubmV3SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGNhckdlbmVyaWNOb3RpZi5uZXdJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGNhckNvbGxlY3Rpb25Ob3RpZi5uZXdJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ25ldycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXJOb3RpZi5uZXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXJHZW5lcmljTm90aWYubmV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soY2FyQ29sbGVjdGlvbk5vdGlmLm5ldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ29sZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJOb3RpZi5vbGQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckdlbmVyaWNOb3RpZi5vbGQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNvbGxlY3Rpb25Ob3RpZi5vbGQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ29sZCBpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJOb3RpZi5vbGRJZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckdlbmVyaWNOb3RpZi5vbGRJZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNvbGxlY3Rpb25Ob3RpZi5vbGRJZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdtYW55IHRvIG1hbnknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk1hbnlUb01hbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ25vIGZhdWx0cycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyQ2FyO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdwdXNoJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5vdGhlckNhciA9IGNhck1hcHBpbmcuX25ldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uOlBlcnNvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ1BlcnNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ1BlcnNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbkNvbGxlY3Rpb25Ob3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdTaWVzdGEnLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UgJiYgbi5tYXBwaW5nID09ICdQZXJzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25HZW5lcmljTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uOkNhcicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ0NhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ0NhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhckNvbGxlY3Rpb25Ob3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdTaWVzdGEnLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UgJiYgbi5tYXBwaW5nID09ICdDYXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJHZW5lcmljTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMucHVzaChhbm90aGVyQ2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkNlbnRyZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdwZXJzb24nLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0KCd0eXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25Ob3RpZi50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25HZW5lcmljTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ29sbGVjdGlvbk5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Ob3RpZi5hZGRlZElkLCBhbm90aGVyQ2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkdlbmVyaWNOb3RpZi5hZGRlZElkLCBhbm90aGVyQ2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNvbGxlY3Rpb25Ob3RpZi5hZGRlZElkLCBhbm90aGVyQ2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnYWRkZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uTm90aWYuYWRkZWQsIGFub3RoZXJDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25HZW5lcmljTm90aWYuYWRkZWQsIGFub3RoZXJDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Db2xsZWN0aW9uTm90aWYuYWRkZWQsIGFub3RoZXJDYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdjYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCgndHlwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyR2VuZXJpY05vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNvbGxlY3Rpb25Ob3RpZi50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyTm90aWYuYWRkZWRJZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhckdlbmVyaWNOb3RpZi5hZGRlZElkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyQ29sbGVjdGlvbk5vdGlmLmFkZGVkSWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2FkZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhck5vdGlmLmFkZGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJHZW5lcmljTm90aWYuYWRkZWQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhckNvbGxlY3Rpb25Ob3RpZi5hZGRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cblxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdzcGxpY2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IGNhck1hcHBpbmcuX25ldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uOlBlcnNvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ1BlcnNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ1BlcnNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Ob3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdTaWVzdGEnLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UgJiYgbi5tYXBwaW5nID09ICdQZXJzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmljTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uOkNhcicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ0NhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhck5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLlNwbGljZSAmJiBuLm1hcHBpbmcgPT0gJ0NhcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhckNvbGxlY3Rpb25Ob3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdTaWVzdGEnLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5TcGxpY2UgJiYgbi5tYXBwaW5nID09ICdDYXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJHZW5lcmljTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwubmV4dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uQ2VudHJlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCd0eXBlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZ2VuZXJpY05vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY29sbGVjdGlvbk5vdGlmLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJHZW5lcmljTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJDb2xsZWN0aW9uTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnbmV3IG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbm90aWYgPSBudWxsO1xuICAgICAgICAgICAgZ2VuZXJpY05vdGlmID0gbnVsbDtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25Ob3RpZiA9IG51bGw7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbjpDYXInLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5OZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLk5ldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHMub24oJ1NpZXN0YScsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLk5ldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJpY05vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAneHl6J1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uQ2VudHJlLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2lzIG5vdGlmJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQub2sobm90aWYpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnaXMgZ2VuZXJpY05vdGlmJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQub2soZ2VuZXJpY05vdGlmKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2lzIGNvbGxlY3Rpb25Ob3RpZicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0Lm9rKGNvbGxlY3Rpb25Ob3RpZik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCd0eXBlIGlzIE5ldycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLnR5cGUsIENoYW5nZVR5cGUuTmV3KTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChnZW5lcmljTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5OZXcpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25Ob3RpZi50eXBlLCBDaGFuZ2VUeXBlLk5ldyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCduZXcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5uZXcsIGNhcik7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoZ2VuZXJpY05vdGlmLm5ldywgY2FyKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uTm90aWYubmV3LCBjYXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnX2lkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYubmV3SWQsIGNhci5faWQpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGdlbmVyaWNOb3RpZi5uZXdJZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY29sbGVjdGlvbk5vdGlmLm5ld0lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGdlbmVyaWNOb3RpZi5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25Ob3RpZi5faWQsIGNhci5faWQpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ29iamVjdCByZW1vdmFsJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBub3RpZiA9IG51bGw7XG4gICAgICAgICAgICBnZW5lcmljTm90aWYgPSBudWxsO1xuICAgICAgICAgICAgY29sbGVjdGlvbk5vdGlmID0gbnVsbDtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICd4eXonXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBfY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhciA9IF9jYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdteUNvbGxlY3Rpb246Q2FyJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uJywgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT0gQ2hhbmdlVHlwZS5SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbk5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ1NpZXN0YScsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyaWNOb3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25DZW50cmUucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnaXMgbm90aWYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5vayhub3RpZik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdpcyBnZW5lcmljTm90aWYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5vayhnZW5lcmljTm90aWYpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnaXMgY29sbGVjdGlvbk5vdGlmJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQub2soY29sbGVjdGlvbk5vdGlmKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3R5cGUgaXMgTmV3JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYudHlwZSwgQ2hhbmdlVHlwZS5SZW1vdmUpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGdlbmVyaWNOb3RpZi50eXBlLCBDaGFuZ2VUeXBlLlJlbW92ZSk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY29sbGVjdGlvbk5vdGlmLnR5cGUsIENoYW5nZVR5cGUuUmVtb3ZlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ25ldycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLm9sZCwgY2FyKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChnZW5lcmljTm90aWYub2xkLCBjYXIpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25Ob3RpZi5vbGQsIGNhcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdfaWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi5vbGRJZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoZ2VuZXJpY05vdGlmLm9sZElkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uTm90aWYub2xkSWQsIGNhci5faWQpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLl9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoZ2VuZXJpY05vdGlmLl9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY29sbGVjdGlvbk5vdGlmLl9pZCwgY2FyLl9pZCk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnb2JqZWN0IHJlc3RvcmF0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbm90aWYgPSBudWxsO1xuICAgICAgICAgICAgZ2VuZXJpY05vdGlmID0gbnVsbDtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25Ob3RpZiA9IG51bGw7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAneHl6J1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcy5vbignbXlDb2xsZWN0aW9uOkNhcicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmID0gbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMub24oJ215Q29sbGVjdGlvbicsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi50eXBlID09IENoYW5nZVR5cGUuTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Ob3RpZiA9IG47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLm9uKCdTaWVzdGEnLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PSBDaGFuZ2VUeXBlLk5ldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmljTm90aWYgPSBuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkNlbnRyZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdpcyBub3RpZicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0Lm9rKG5vdGlmKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2lzIGdlbmVyaWNOb3RpZicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0Lm9rKGdlbmVyaWNOb3RpZik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdpcyBjb2xsZWN0aW9uTm90aWYnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5vayhjb2xsZWN0aW9uTm90aWYpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgndHlwZSBpcyBOZXcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChub3RpZi50eXBlLCBDaGFuZ2VUeXBlLk5ldyk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoZ2VuZXJpY05vdGlmLnR5cGUsIENoYW5nZVR5cGUuTmV3KTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uTm90aWYudHlwZSwgQ2hhbmdlVHlwZS5OZXcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbmV3JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYubmV3LCBjYXIpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGdlbmVyaWNOb3RpZi5uZXcsIGNhcik7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoY29sbGVjdGlvbk5vdGlmLm5ldywgY2FyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ19pZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5vdGlmLm5ld0lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChnZW5lcmljTm90aWYubmV3SWQsIGNhci5faWQpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNvbGxlY3Rpb25Ob3RpZi5uZXdJZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwobm90aWYuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChnZW5lcmljTm90aWYuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xsZWN0aW9uTm90aWYuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbn0pOyIsInZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKSxcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5kZXNjcmliZSgnb2JqZWN0ISEnLCBmdW5jdGlvbigpIHtcblxuICAgIHZhciBTaWVzdGFNb2RlbCA9IHJlcXVpcmUoJy4uL3NyYy9vYmplY3QnKS5TaWVzdGFNb2RlbDtcbiAgICB2YXIgTWFwcGluZyA9IHJlcXVpcmUoJy4uL3NyYy9tYXBwaW5nJykuTWFwcGluZztcbiAgICB2YXIgY2FjaGUgPSByZXF1aXJlKCcuLi9zcmMvY2FjaGUnKTtcbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcblxuICAgIHZhciBtYXBwaW5nLCBjb2xsZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgIG1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoe1xuICAgICAgICAgICAgbmFtZTogJ0NhcicsXG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nXG4gICAgICAgIH0pXG4gICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdmaWVsZHMnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICBpdCgnaWRGaWVsZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgU2llc3RhTW9kZWwobWFwcGluZyk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoci5pZEZpZWxkLCAnaWQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3R5cGUgZmllbGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByID0gbmV3IFNpZXN0YU1vZGVsKG1hcHBpbmcpO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHIudHlwZSwgJ0NhcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnY29sbGVjdGlvbiBmaWVsZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHIgPSBuZXcgU2llc3RhTW9kZWwobWFwcGluZyk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoci5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCd0eXBlIGZpZWxkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgciA9IG5ldyBTaWVzdGFNb2RlbChtYXBwaW5nKTtcbiAgICAgICAgICAgIGFzc2VydC5ub3RPayhyLmlzU2F2ZWQpO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3JlbW92YWwnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgY2FyO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICAgIGNhciA9IG5ldyBTaWVzdGFNb2RlbChtYXBwaW5nKTtcbiAgICAgICAgICAgIGNhci5jb2xvdXIgPSAncmVkJztcbiAgICAgICAgICAgIGNhci5uYW1lID0gJ0FzdG9uIE1hcnRpbic7XG4gICAgICAgICAgICBjYXIuaWQgPSAnMic7XG4gICAgICAgICAgICBjYXIuX2lkID0gJ3h5eic7XG4gICAgICAgICAgICBjYWNoZS5pbnNlcnQoY2FyKTtcbiAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXIucmVtb3ZlZCk7XG4gICAgICAgICAgICBhc3NlcnQub2soY2FjaGUuY29udGFpbnMoY2FyKSk7XG4gICAgICAgICAgICBjYXIucmVtb3ZlKCk7XG4gICAgICAgICAgICBhc3NlcnQubm90T2soY2FjaGUuY29udGFpbnMoY2FyKSk7XG4gICAgICAgICAgICBhc3NlcnQub2soY2FyLnJlbW92ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXQoJ2RlbGV0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Jlc3RvcmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICAgICAgY2FyLnJlc3RvcmUoKTtcbiAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXIucmVtb3ZlZCk7XG4gICAgICAgICAgICBhc3NlcnQub2soY2FjaGUuY29udGFpbnMoY2FyKSk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbn0pOyIsInZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKVxuICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuLyoqXG4gKiBBc3NlcnRpb25zIGFnYWluc3QgdGhlIG9ic2VydmUtanMgbGlicmFyeSBmcm9tIHBvbHltZXIsIG1vZGlmaWVkIHRvIGZpdCBicm93c2VyaWZ5LlxuICovXG5cbmRlc2NyaWJlKCdvYnNlcnZlcicsIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBBcnJheU9ic2VydmVyID0gcmVxdWlyZSgnLi4vdmVuZG9yL29ic2VydmUtanMvc3JjL29ic2VydmUnKS5BcnJheU9ic2VydmVyO1xuXG4gICAgaXQoJ2luZGV4ZXMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICB2YXIgYXJyID0gWzEsIDIsIDNdO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQXJyYXlPYnNlcnZlcihhcnIpO1xuICAgICAgICBvYnNlcnZlci5vcGVuKGZ1bmN0aW9uIChzcGxpY2VzKSB7XG4gICAgICAgICAgICBzcGxpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNwbGljZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNwbGljZS5yZW1vdmVkLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc3BsaWNlLnJlbW92ZWQsIDIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3BsaWNlLmFkZGVkQ291bnQsIDIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3BsaWNlLmluZGV4LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyWzBdID0gNDtcbiAgICAgICAgYXJyWzFdID0gNTtcbiAgICB9KTtcblxuICAgIGl0KCdwdXNoJyxmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICB2YXIgYXJyID0gWzEsIDIsIDNdO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQXJyYXlPYnNlcnZlcihhcnIpO1xuICAgICAgICBvYnNlcnZlci5vcGVuKGZ1bmN0aW9uIChzcGxpY2VzKSB7XG4gICAgICAgICAgICBzcGxpY2VzLmZvckVhY2goZnVuY3Rpb24gKHNwbGljZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzcGxpY2UucmVtb3ZlZC5sZW5ndGgsIDApO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3BsaWNlLmluZGV4LCAzKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZS5hZGRlZENvdW50LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyLnB1c2goNik7XG4gICAgfSk7XG5cbiAgICBpdCgnc29ydCcsZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgdmFyIGFyciA9IFsyLCAxLCAzXTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEFycmF5T2JzZXJ2ZXIoYXJyKTtcbiAgICAgICAgb2JzZXJ2ZXIub3BlbihmdW5jdGlvbiAoc3BsaWNlcykge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyLnNvcnQoKTtcbiAgICB9KTtcblxufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpLFxuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCduZXcgb2JqZWN0IHByb3h5JywgZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgUmVsYXRpb25zaGlwUHJveHkgPSByZXF1aXJlKCcuLi9zcmMvcHJveHknKS5SZWxhdGlvbnNoaXBQcm94eTtcbiAgICB2YXIgT25lVG9PbmVQcm94eSA9IHJlcXVpcmUoJy4uL3NyYy9vbmVUb09uZVByb3h5JykuT25lVG9PbmVQcm94eTtcbiAgICB2YXIgT25lVG9NYW55UHJveHkgPSByZXF1aXJlKCcuLi9zcmMvb25lVG9NYW55UHJveHknKS5PbmVUb01hbnlQcm94eTtcbiAgICB2YXIgTWFueVRvTWFueVByb3h5ID0gcmVxdWlyZSgnLi4vc3JjL21hbnlUb01hbnlQcm94eScpLk1hbnlUb01hbnlQcm94eTtcbiAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG4gICAgdmFyIEZhdWx0ID0gcmVxdWlyZSgnLi4vc3JjL3Byb3h5JykuRmF1bHQ7XG4gICAgdmFyIEludGVybmFsU2llc3RhRXJyb3IgPSByZXF1aXJlKCcuLi9zcmMvZXJyb3InKS5JbnRlcm5hbFNpZXN0YUVycm9yO1xuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL3NyYy9jYWNoZScpO1xuICAgIHZhciBDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi4vc3JjL2NoYW5nZXMnKS5DaGFuZ2VUeXBlO1xuXG4gICAgdmFyIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbiAgICB2YXIgY29sbGVjdGlvbjtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICB9KTtcbiAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZW5lcmljJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlc2NyaWJlKCdpbnN0YWxsYXRpb24nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYXIsIHBlcnNvbiwgcmVsYXRpb25zaGlwLCBwcm94eTtcblxuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm94eSA9IG5ldyBSZWxhdGlvbnNoaXBQcm94eSh7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhciA9IG5ldyBTaWVzdGFNb2RlbChjYXJNYXBwaW5nKTtcbiAgICAgICAgICAgICAgICBwZXJzb24gPSBuZXcgU2llc3RhTW9kZWwocGVyc29uTWFwcGluZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3Rocm93cyBhbiBlcnJvciBpZiB0cnkgdG8gaW5zdGFsbCB0d2ljZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByb3h5Lmluc3RhbGwoY2FyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQudGhyb3dzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwcm94eS5pbnN0YWxsKGNhcik7XG4gICAgICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQgaW5zdGFsbGF0aW9uJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJveHkgPSBuZXcgUmVsYXRpb25zaGlwUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJveHkuaW5zdGFsbChjYXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ2luc3RhbGxzIHNldHRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soY2FyWydzZXRPd25lciddKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdCgnaW5zdGFsbHMgZ2V0dGVyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhjYXJbJ2dldE93bmVyJ10pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZhdWx0cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdCgnaXMgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHByb3h5LmlzRm9yd2FyZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdpcyBub3QgcmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHByb3h5LmlzUmV2ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdubyByZWxhdGlvbnNoaXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBhIGZhdWx0IG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGNhci5vd25lciwgRmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBmYXVsdGVkLCBhcyBubyByZWxhdGlvbnNoaXAgc2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGNhci5vd25lci5pc0ZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgncmVsYXRpb25zaGlwLCBmYXVsdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5Ll9pZCA9ICd4eXonO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBhIGZhdWx0IG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGNhci5vd25lciwgRmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBmYXVsdGVkLCBhcyBfaWQgZXhpc3RzLCBidXQgbm8gcmVsYXRlZCBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2soY2FyLm93bmVyLmlzRmF1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdyZWxhdGlvbnNoaXAsIGZhdWx0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHkuX2lkID0gJ3h5eic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHkucmVsYXRlZCA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eS5yZWxhdGVkLl9pZCA9ICd4eXonO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBhIGZhdWx0IG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIub3duZXIsIHByb3h5LnJlbGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBub3QgZmF1bHRlZCwgYXMgcmVsYXRpb25zaGlwIHNldCBhbmQgcmVsYXRlZCBhc3NpZ25lZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXIub3duZXIuaXNGYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdyZXZlcnNlIGluc3RhbGxhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gbmV3IFJlbGF0aW9uc2hpcFByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcm94eS5pbnN0YWxsKHBlcnNvbik7XG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmYXVsdHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ2lzIHJlZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHByb3h5LmlzUmV2ZXJzZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdpcyBub3QgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHByb3h5LmlzRm9yd2FyZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdubyByZWxhdGlvbnNoaXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBhIGZhdWx0IG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKHBlcnNvbi5jYXJzLCBGYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2lzIGZhdWx0ZWQsIGFzIG5vIHJlbGF0aW9uc2hpcCBzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2socGVyc29uLmNhcnMuaXNGYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbGF0aW9uc2hpcCwgZmF1bHRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eS5faWQgPSBbJ3h5eiddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBhIGZhdWx0IG9iamVjdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKHBlcnNvbi5jYXJzLCBGYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2lzIGZhdWx0ZWQsIGFzIHJlbGF0aW9uc2hpcCBzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2socGVyc29uLmNhcnMuaXNGYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3JlbGF0aW9uc2hpcCwgZmF1bHRlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eS5faWQgPSAneHl6JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eS5yZWxhdGVkID0gW25ldyBTaWVzdGFNb2RlbChjYXJNYXBwaW5nKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHkucmVsYXRlZFswXS5faWQgPSAneHl6JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnaXMgYSBmYXVsdCBvYmplY3QnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmNhcnNbMF0sIHByb3h5LnJlbGF0ZWRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdpcyBub3QgZmF1bHRlZCwgYXMgcmVsYXRpb25zaGlwIHNldCBhbmQgcmVsYXRlZCBhc3NpZ25lZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhwZXJzb24uY2Fycy5pc0ZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdzdWJjbGFzcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhciwgcGVyc29uLCBwcm94eTtcblxuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwcm94eSA9IG5ldyBSZWxhdGlvbnNoaXBQcm94eSh7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogdHJ1ZVxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FyID0gbmV3IFNpZXN0YU1vZGVsKGNhck1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIHBlcnNvbiA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbiAgICAgICAgICAgICAgICBwcm94eS5pbnN0YWxsKGNhcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ3NldCBzaG91bGQgZmFpbCBpZiBub3Qgc3ViY2xhc3NlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQudGhyb3dzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIuc2V0KHBlcnNvbik7XG4gICAgICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2dldCBzaG91bGQgZmFpbCBpZiBub3Qgc3ViY2xhc3NlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhci5vd25lci5nZXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG5cbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdvbmUtdG8tb25lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXJQcm94eSwgcGVyc29uUHJveHk7XG4gICAgICAgIHZhciBjYXIsIHBlcnNvbjtcblxuICAgICAgICBkZXNjcmliZSgnZ2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhclByb3h5ID0gbmV3IE9uZVRvT25lUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eSA9IG5ldyBPbmVUb09uZVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3J3YXJkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhciA9IG5ldyBTaWVzdGFNb2RlbChjYXJNYXBwaW5nKTtcbiAgICAgICAgICAgICAgICBjYXIuX2lkID0gJ2Nhcic7XG4gICAgICAgICAgICAgICAgY2FyUHJveHkuaW5zdGFsbChjYXIpO1xuICAgICAgICAgICAgICAgIHBlcnNvbiA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbiAgICAgICAgICAgICAgICBwZXJzb24uX2lkID0gJ3BlcnNvbic7XG4gICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaW5zdGFsbChwZXJzb24pO1xuICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChwZXJzb24pO1xuICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChjYXIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdmb3J3YXJkJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIGNhclByb3h5Ll9pZCA9IHBlcnNvbi5faWQ7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGNhclByb3h5LmlzRmF1bHQpO1xuICAgICAgICAgICAgICAgIGNhclByb3h5LmdldChmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24sIG9iaik7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgncmV2ZXJzZScsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5faWQgPSBjYXIuX2lkO1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhwZXJzb25Qcm94eS5pc0ZhdWx0KTtcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLCBvYmopO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdzZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjYXJQcm94eSwgcGVyc29uUHJveHk7XG4gICAgICAgICAgICB2YXIgY2FyLCBwZXJzb247XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhclByb3h5ID0gbmV3IE9uZVRvT25lUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eSA9IG5ldyBPbmVUb09uZVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3J3YXJkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhciA9IG5ldyBTaWVzdGFNb2RlbChjYXJNYXBwaW5nKTtcbiAgICAgICAgICAgICAgICBjYXIuX2lkID0gJ2Nhcic7XG4gICAgICAgICAgICAgICAgY2FyUHJveHkuaW5zdGFsbChjYXIpO1xuICAgICAgICAgICAgICAgIGNhclByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwZXJzb24gPSBuZXcgU2llc3RhTW9kZWwocGVyc29uTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgcGVyc29uLl9pZCA9ICdwZXJzb24nO1xuICAgICAgICAgICAgICAgIHBlcnNvblByb3h5Lmluc3RhbGwocGVyc29uKTtcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ25vbmUgcHJlLWV4aXN0aW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5faWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhclByb3h5LnJlbGF0ZWQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25Qcm94eS5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvblByb3h5LnJlbGF0ZWQsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2JhY2t3YXJkcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCBmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25Qcm94eS5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvblByb3h5LnJlbGF0ZWQsIGNhcik7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgcmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBjYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhclByb3h5Ll9pZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdwcmUtZXhpc3RpbmcnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uLCBhbm90aGVyUGVyc29uUHJveHk7XG5cbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uID0gbmV3IFNpZXN0YU1vZGVsKHBlcnNvbk1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uLl9pZCA9ICdhbm90aGVyUGVyc29uJztcbiAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvblByb3h5ID0gbmV3IE9uZVRvT25lUHJveHkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb25Qcm94eS5pbnN0YWxsKGFub3RoZXJQZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkuaXNGYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQoYW5vdGhlclBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQoY2FyKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ25vIGZhdWx0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBhbm90aGVyUGVyc29uO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkuX2lkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCByZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIGNsZWFyIHRoZSBvbGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGFub3RoZXJQZXJzb25Qcm94eS5pc0ZhdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soYW5vdGhlclBlcnNvblByb3h5Ll9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGFub3RoZXJQZXJzb25Qcm94eS5yZWxhdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2JhY2t3YXJkcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5faWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgY2xlYXIgdGhlIG9sZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhhbm90aGVyUGVyc29uUHJveHkuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soYW5vdGhlclBlcnNvblByb3h5LnJlbGF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhhbm90aGVyUGVyc29uUHJveHkuaXNGYXVsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmYXVsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gYW5vdGhlclBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhclByb3h5LnJlbGF0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkucmVsYXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCBmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIub3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhclByb3h5Ll9pZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhclByb3h5LnJlbGF0ZWQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgcmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvblByb3h5LnJlbGF0ZWQsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2JhY2t3YXJkcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gY2FyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IGNhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5faWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2ZvcmVpZ24ga2V5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjYXJQcm94eSwgcGVyc29uUHJveHk7XG4gICAgICAgIHZhciBjYXIsIHBlcnNvbjtcblxuICAgICAgICBkZXNjcmliZSgnZ2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNhclByb3h5ID0gbmV3IE9uZVRvTWFueVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVyJyxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3J3YXJkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGVyc29uUHJveHkgPSBuZXcgT25lVG9NYW55UHJveHkoe1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FyID0gbmV3IFNpZXN0YU1vZGVsKGNhck1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIGNhci5faWQgPSAnY2FyJztcbiAgICAgICAgICAgICAgICBjYXJQcm94eS5pbnN0YWxsKGNhcik7XG4gICAgICAgICAgICAgICAgcGVyc29uID0gbmV3IFNpZXN0YU1vZGVsKHBlcnNvbk1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIHBlcnNvbi5faWQgPSAncGVyc29uJztcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5pbnN0YWxsKHBlcnNvbik7XG4gICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KHBlcnNvbik7XG4gICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGNhcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ2dldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdubyBmYXVsdCcsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJQcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdmb3J3YXJkJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyUHJveHkuX2lkID0gcGVyc29uLl9pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhclByb3h5LnJlbGF0ZWQgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbiwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ3JldmVyc2UnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5faWQgPSBbY2FyLl9pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5yZWxhdGVkID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaXQoJ2ZvcndhcmQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJQcm94eS5faWQgPSBwZXJzb24uX2lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24sIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdyZXZlcnNlJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkuX2lkID0gW2Nhci5faWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgY2Fycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fycy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ3NldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhclByb3h5LCBwZXJzb25Qcm94eTtcbiAgICAgICAgICAgIHZhciBjYXIsIHBlcnNvbjtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FyUHJveHkgPSBuZXcgT25lVG9NYW55UHJveHkoe1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eSA9IG5ldyBPbmVUb01hbnlQcm94eSh7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXIgPSBuZXcgU2llc3RhTW9kZWwoY2FyTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgY2FyLl9pZCA9ICdjYXInO1xuICAgICAgICAgICAgICAgIGNhclByb3h5Lmluc3RhbGwoY2FyKTtcbiAgICAgICAgICAgICAgICBjYXJQcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcGVyc29uID0gbmV3IFNpZXN0YU1vZGVsKHBlcnNvbk1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIHBlcnNvbi5faWQgPSAncGVyc29uJztcbiAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5pbnN0YWxsKHBlcnNvbik7XG4gICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaXNGYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXNjcmliZSgnbm9uZSBwcmUtZXhpc3RpbmcnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIub3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkuX2lkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCByZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5yZWxhdGVkLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpdCgnbXVsdGlwbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyQ2FyID0gbmV3IFNpZXN0YU1vZGVsKGNhck1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5vdGhlckNhci5faWQgPSAnYW5vdGhlckNhcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5vdGhlckNhclByb3h5ID0gbmV3IE9uZVRvTWFueVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyQ2FyUHJveHkuaW5zdGFsbChhbm90aGVyQ2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFub3RoZXJDYXJQcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyQ2FyLm93bmVyID0gcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb24uY2FycywgYW5vdGhlckNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJDYXIub3duZXIsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnYmFja3dhcmRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5yZWxhdGVkLCBjYXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhclByb3h5Ll9pZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlc2NyaWJlKCdwcmUtZXhpc3RpbmcnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uLCBhbm90aGVyUGVyc29uUHJveHk7XG5cbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uID0gbmV3IFNpZXN0YU1vZGVsKHBlcnNvbk1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uLl9pZCA9ICdhbm90aGVyUGVyc29uJztcbiAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvblByb3h5ID0gbmV3IE9uZVRvTWFueVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkuaW5zdGFsbChhbm90aGVyUGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvblByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGFub3RoZXJQZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQocGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGNhcik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnbm8gZmF1bHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IGFub3RoZXJQZXJzb247XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5faWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5yZWxhdGVkLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgY2xlYXIgdGhlIG9sZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYW5vdGhlclBlcnNvblByb3h5Ll9pZC5sZW5ndGgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhbm90aGVyUGVyc29uUHJveHkucmVsYXRlZC5sZW5ndGgsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdiYWNrd2FyZHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IFtjYXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5jYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCByZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5faWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgY2xlYXIgdGhlIG9sZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25Qcm94eS5faWQubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYW5vdGhlclBlcnNvblByb3h5LnJlbGF0ZWQubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZhdWx0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBhbm90aGVyUGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyUHJveHkucmVsYXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb25Qcm94eS5yZWxhdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBwZXJzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkuX2lkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCByZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5jYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgnYmFja3dhcmRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCBmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5LnJlbGF0ZWQsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgcmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkuX2lkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuXG5cbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdtYW55IHRvIG1hbnknLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhclByb3h5LCBwZXJzb25Qcm94eTtcbiAgICAgICAgdmFyIGNhciwgcGVyc29uO1xuXG4gICAgICAgIGRlc2NyaWJlKCdnZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FyUHJveHkgPSBuZXcgTWFueVRvTWFueVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVycycsXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBlcnNvblByb3h5ID0gbmV3IE1hbnlUb01hbnlQcm94eSh7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcnMnLFxuICAgICAgICAgICAgICAgICAgICBpc1JldmVyc2U6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXIgPSBuZXcgU2llc3RhTW9kZWwoY2FyTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgY2FyLl9pZCA9ICdjYXInO1xuICAgICAgICAgICAgICAgIGNhclByb3h5Lmluc3RhbGwoY2FyKTtcbiAgICAgICAgICAgICAgICBwZXJzb24gPSBuZXcgU2llc3RhTW9kZWwocGVyc29uTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgcGVyc29uLl9pZCA9ICdwZXJzb24nO1xuICAgICAgICAgICAgICAgIHBlcnNvblByb3h5Lmluc3RhbGwocGVyc29uKTtcbiAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQocGVyc29uKTtcbiAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQoY2FyKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnbm8gZmF1bHQnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhclByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaXNGYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ2ZvcndhcmQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhclByb3h5Ll9pZCA9IFtwZXJzb24uX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY2FyUHJveHkucmVsYXRlZCA9IFtwZXJzb25dO1xuICAgICAgICAgICAgICAgICAgICBjYXJQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBwZW9wbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlb3BsZSwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhclByb3h5LnJlbGF0ZWQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3JldmVyc2UnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlcnNvblByb3h5Ll9pZCA9IFtjYXIuX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkucmVsYXRlZCA9IFtjYXJdO1xuICAgICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVzY3JpYmUoJ2ZhdWx0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaXQoJ2ZvcndhcmQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhclByb3h5Ll9pZCA9IFtwZXJzb24uX2lkXTtcbiAgICAgICAgICAgICAgICAgICAgY2FyUHJveHkuZ2V0KGZ1bmN0aW9uKGVyciwgcGVvcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZW9wbGUsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGl0KCdyZXZlcnNlJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5faWQgPSBbY2FyLl9pZF07XG4gICAgICAgICAgICAgICAgICAgIHBlcnNvblByb3h5LmdldChmdW5jdGlvbihlcnIsIGNhcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnc2V0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FyUHJveHksIHBlcnNvblByb3h5O1xuICAgICAgICAgICAgdmFyIGNhciwgcGVyc29uO1xuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjYXJQcm94eSA9IG5ldyBNYW55VG9NYW55UHJveHkoe1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4gICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXJzJywgXG4gICAgICAgICAgICAgICAgICAgIGlzRm9yd2FyZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBlcnNvblByb3h5ID0gbmV3IE1hbnlUb01hbnlQcm94eSh7XG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcnMnLFxuICAgICAgICAgICAgICAgICAgICBpc0ZvcndhcmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FyID0gbmV3IFNpZXN0YU1vZGVsKGNhck1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIGNhci5faWQgPSAnY2FyJztcbiAgICAgICAgICAgICAgICBjYXJQcm94eS5pbnN0YWxsKGNhcik7XG4gICAgICAgICAgICAgICAgY2FyUHJveHkuaXNGYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBlcnNvbiA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbiAgICAgICAgICAgICAgICBwZXJzb24uX2lkID0gJ3BlcnNvbic7XG4gICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaW5zdGFsbChwZXJzb24pO1xuICAgICAgICAgICAgICAgIHBlcnNvblByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnbm9uZSBwcmUtZXhpc3RpbmcnLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lcnMgPSBbcGVyc29uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhci5vd25lcnMsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJQcm94eS5faWQsIHBlcnNvbi5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgcmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVycyA9IFtwZXJzb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5faWQsIGNhci5faWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnYmFja3dhcmRzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb24uY2FycywgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5yZWxhdGVkLCBjYXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXIub3duZXJzLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyUHJveHkuX2lkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhclByb3h5LnJlbGF0ZWQsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgZGVzY3JpYmUoJ3ByZS1leGlzdGluZycsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFub3RoZXJQZXJzb24sIGFub3RoZXJQZXJzb25Qcm94eTtcblxuICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb24gPSBuZXcgU2llc3RhTW9kZWwocGVyc29uTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb24uX2lkID0gJ2Fub3RoZXJQZXJzb24nO1xuICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkgPSBuZXcgTWFueVRvTWFueVByb3h5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGb3J3YXJkOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvblByb3h5Lmluc3RhbGwoYW5vdGhlclBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb25Qcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChhbm90aGVyUGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChjYXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVzY3JpYmUoJ25vIGZhdWx0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJzID0gW2Fub3RoZXJQZXJzb25dO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBkZXNjcmliZSgnZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lcnMgPSBbcGVyc29uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXIub3duZXJzLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhclByb3h5Ll9pZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCByZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVycyA9IFtwZXJzb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5jYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIGNsZWFyIHRoZSBvbGQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJzID0gW3BlcnNvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25Qcm94eS5faWQubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYW5vdGhlclBlcnNvblByb3h5LnJlbGF0ZWQubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdiYWNrd2FyZHMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IGZvcndhcmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IFtjYXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbi5jYXJzLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvblByb3h5Ll9pZCwgY2FyLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkucmVsYXRlZCwgY2FyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCByZXZlcnNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXIub3duZXJzLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhclByb3h5Ll9pZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyUHJveHkucmVsYXRlZCwgcGVyc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmYXVsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVycyA9IFthbm90aGVyUGVyc29uXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhclByb3h5LnJlbGF0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkucmVsYXRlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIHNldCBmb3J3YXJkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVycyA9IFtwZXJzb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhci5vd25lcnMsIHBlcnNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyUHJveHkuX2lkLCBwZXJzb24uX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjYXJQcm94eS5yZWxhdGVkLCBwZXJzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJzID0gW3BlcnNvbl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5yZWxhdGVkLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2JhY2t3YXJkcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBzZXQgZm9yd2FyZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uLmNhcnMsIGNhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uUHJveHkuX2lkLCBjYXIuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25Qcm94eS5yZWxhdGVkLCBjYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgc2V0IHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IFtjYXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNhclByb3h5Ll9pZCwgcGVyc29uLl9pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSk7XG5cblxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcblxuXG4gICAgfSk7XG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ3F1ZXJ5JywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIFF1ZXJ5ID0gcmVxdWlyZSgnLi4vc3JjL3F1ZXJ5JykuUXVlcnk7XG4gICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4gICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgcy5yZXNldCh0cnVlKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdiYXNpYycsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiwgbWFwcGluZztcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBtYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdvYmplY3QgZXhpc3RzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsJyxcbiAgICAgICAgICAgICAgICBhZ2U6IDE1XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KG1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMTVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbihlcnIsIG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqc1swXSwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdvYmplY3QgZG9lcyBub3QgZXhpc3QnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwnLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkobWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAxNVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uKGVyciwgb2Jqcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianMubGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdtdWx0aXBsZSBtYXRjaGVzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgbWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KG1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbihlcnIsIG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShvYmpzLCBtYXBwZWRbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24sIHBlcnNvbk1hcHBpbmcsIGNhck1hcHBpbmc7XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPbmVUb01hbnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnY2FycydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnYXR0cmlidXRlcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXQoJ21hdGNoZXMnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwnLFxuICAgICAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQm9iJyxcbiAgICAgICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBRdWVyeShwZXJzb25NYXBwaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19lOiAyMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShvYmpzLCBtYXBwZWRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ25vIG1hdGNoZXMnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwnLFxuICAgICAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQm9iJyxcbiAgICAgICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBRdWVyeShwZXJzb25NYXBwaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19lOiAyM1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhvYmpzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgncmVsYXRpb25zaGlwcycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXQoJ21vZGVsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwnLFxuICAgICAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBwZXJzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lcjogcGVyc29uXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgY2FyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBRdWVyeShjYXJNYXBwaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyX19lOiBwZXJzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG9ianMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdsdCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiwgcGVyc29uTWFwcGluZywgY2FyTWFwcGluZztcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoZXMgYWxsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KHBlcnNvbk1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZV9fbHQ6IDIyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKG9ianMsIG1hcHBlZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2hlcyBzb21lJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjJcbiAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KHBlcnNvbk1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZV9fbHQ6IDIyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdubyBtYXRjaGVzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KHBlcnNvbk1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZV9fbHQ6IDIxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2sob2Jqcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnbHRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uLCBwZXJzb25NYXBwaW5nLCBjYXJNYXBwaW5nO1xuXG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2hlcyBhbGwnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcChbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsJyxcbiAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0JvYicsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkocGVyc29uTWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19sdGU6IDIxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKG9ianMsIG1hcHBlZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2hlcyBzb21lJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obicsXG4gICAgICAgICAgICAgICAgYWdlOiAyM1xuICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkocGVyc29uTWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19sdGU6IDIyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKG9ianMsIG1hcHBlZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbm8gbWF0Y2hlcycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwnLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnQm9iJyxcbiAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyLCBtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBRdWVyeShwZXJzb25NYXBwaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VfX2x0ZTogMjBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbihlcnIsIG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhvYmpzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdndCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29sbGVjdGlvbiwgcGVyc29uTWFwcGluZywgY2FyTWFwcGluZztcblxuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ21hdGNoZXMgYWxsJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KHBlcnNvbk1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZV9fZ3Q6IDIwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKG9ianMsIG1hcHBlZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2hlcyBzb21lJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obicsXG4gICAgICAgICAgICAgICAgYWdlOiAyM1xuICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkocGVyc29uTWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19ndDogMjFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbihlcnIsIG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShvYmpzLCBtYXBwZWRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdubyBtYXRjaGVzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIsIG1hcHBlZCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBlZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IFF1ZXJ5KHBlcnNvbk1hcHBpbmcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZV9fZ3Q6IDIxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2sob2Jqcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ3RlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xsZWN0aW9uLCBwZXJzb25NYXBwaW5nLCBjYXJNYXBwaW5nO1xuXG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2hlcyBhbGwnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcChbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsJyxcbiAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0JvYicsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkocGVyc29uTWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19ndGU6IDIxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKG9ianMsIG1hcHBlZFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbWF0Y2hlcyBzb21lJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoW3tcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCcsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdCb2InLFxuICAgICAgICAgICAgICAgIGFnZTogMjJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnSm9obicsXG4gICAgICAgICAgICAgICAgYWdlOiAyM1xuICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkocGVyc29uTWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19ndGU6IDIyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24oZXJyLCBvYmpzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUob2JqcywgbWFwcGVkWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKG9ianMsIG1hcHBlZFsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbm8gbWF0Y2hlcycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKFt7XG4gICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwnLFxuICAgICAgICAgICAgICAgIGFnZTogMjFcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnQm9iJyxcbiAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyLCBtYXBwZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBRdWVyeShwZXJzb25NYXBwaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZ2VfX2d0ZTogMjJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbihlcnIsIG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhvYmpzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuXG5cbiAgICBkZXNjcmliZSgnZXJyb3JzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnT25lVG9NYW55JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2ludmFsaWQgb3AnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcChbe1xuICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsJyxcbiAgICAgICAgICAgICAgICBhZ2U6IDIxXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0JvYicsXG4gICAgICAgICAgICAgICAgYWdlOiAyMVxuICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgbWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkocGVyc29uTWFwcGluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlX19kZnNvaWdzZDogMjFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbihlcnIsIG9ianMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKG9ianMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICB9KTtcblxuXG5cblxuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ3JlY3Vyc2l2ZSByZWxhdGlvbnNoaXBzJywgZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbiAgICB2YXIgY2FjaGUgPSByZXF1aXJlKCcuLi9zcmMvY2FjaGUnKTtcbiAgICB2YXIgY29sbGVjdGlvbjtcbiAgICB2YXIgUmVwbztcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ015Q29sbGVjdGlvbicpO1xuICAgICAgICBjb2xsZWN0aW9uLmJhc2VVUkwgPSAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbSc7XG4gICAgICAgIFJlcG8gPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1JlcG8nLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZSddLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgIGZvcmtlZEZyb206IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1JlcG8nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnT25lVG9NYW55JyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2ZvcmtzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICB9KTtcblxuICAgIGl0KCdtYXAnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgIFx0dmFyIG1hc3RlclJlcG9EYXRhID0ge2lkOiAnNScsIG5hbWU6ICdNYXN0ZXIgUmVwbyd9O1xuICAgIFx0UmVwby5tYXAobWFzdGVyUmVwb0RhdGEsIGZ1bmN0aW9uIChlcnIsIHJlcG8pIHtcbiAgICBcdFx0aWYgKGVycikge1xuICAgIFx0XHRcdGRvbmUoZXJyKTtcbiAgICBcdFx0fVxuICAgIFx0XHRlbHNlIHtcbiAgICBcdFx0XHR2YXIgY2hpbGRSZXBvRGF0YSA9IHtpZDogJzYnLCBuYW1lOiAnQ2hpbGQgUmVwbycsIGZvcmtlZEZyb206IHtfaWQ6IHJlcG8uX2lkfX07XG4gICAgXHRcdFx0UmVwby5tYXAoY2hpbGRSZXBvRGF0YSwgZnVuY3Rpb24gKGVyciwgY2hpbGRSZXBvKSB7XG4gICAgXHRcdFx0XHRpZiAoZXJyKSB7XG4gICAgXHRcdFx0XHRcdGRvbmUoZXJyKTtcbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdGVsc2Uge1xuICAgIFx0XHRcdFx0XHRhc3NlcnQuaW5jbHVkZShyZXBvLmZvcmtzLCBjaGlsZFJlcG8pO1xuICAgIFx0XHRcdFx0XHRhc3NlcnQuZXF1YWwoY2hpbGRSZXBvLmZvcmtlZEZyb20sIHJlcG8pO1xuICAgIFx0XHRcdFx0XHRkb25lKCk7XG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0fSk7XG4gICAgXHRcdH1cbiAgICBcdH0pO1xuICAgIH0pO1xuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ21hcHBpbmcgcmVsYXRpb25zaGlwcycsIGZ1bmN0aW9uKCkge1xuXG5cbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbiAgICB2YXIgSW50ZXJuYWxTaWVzdGFFcnJvciA9IHJlcXVpcmUoJy4uL3NyYy9lcnJvcicpLkludGVybmFsU2llc3RhRXJyb3I7XG4gICAgdmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcblxuXG4gICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgcy5yZXNldCh0cnVlKTtcbiAgICB9KTtcblxuICAgIHZhciBjb2xsZWN0aW9uLCBjYXJNYXBwaW5nLCBwZXJzb25NYXBwaW5nO1xuXG4gICAgZnVuY3Rpb24gY29uZmlndXJlQVBJKHR5cGUsIGRvbmUpIHtcbiAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgIH0pO1xuICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoJ3ZhbGlkJywgZnVuY3Rpb24oKSB7XG5cblxuICAgICAgICBkZXNjcmliZSgnRm9yZWlnbiBLZXknLCBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJlQVBJKFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2NvbmZpZ3VyZXMgcmV2ZXJzZSBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhck1hcHBpbmcucmVsYXRpb25zaGlwcy5vd25lci5yZXZlcnNlTWFwcGluZywgcGVyc29uTWFwcGluZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2NvbmZpZ3VyZXMgcmV2ZXJzZSBuYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhck1hcHBpbmcucmVsYXRpb25zaGlwcy5vd25lci5yZXZlcnNlTmFtZSwgJ2NhcnMnKTtcblxuICAgICAgICAgICAgICAgIGl0KCdjb25maWd1cmVzIGZvcndhcmQgbWFwcGluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTWFwcGluZy5yZWxhdGlvbnNoaXBzLm93bmVyLmZvcndhcmRNYXBwaW5nLCBjYXJNYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnY29uZmlndXJlcyBmb3J3YXJkIG5hbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTWFwcGluZy5yZWxhdGlvbnNoaXBzLm93bmVyLmZvcndhcmROYW1lLCAnb3duZXInKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnaW5zdGFsbHMgb24gcmV2ZXJzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGVyc29uTWFwcGluZy5yZWxhdGlvbnNoaXBzLmNhcnMpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPSAnaXNGb3J3YXJkJyAmJiBrZXkgIT0gJ2lzUmV2ZXJzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25NYXBwaW5nLnJlbGF0aW9uc2hpcHMuY2Fyc1trZXldLCBjYXJNYXBwaW5nLnJlbGF0aW9uc2hpcHMub3duZXJba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdPbmVUb09uZScsIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmVBUEkoUmVsYXRpb25zaGlwVHlwZS5PbmVUb09uZSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ2NvbmZpZ3VyZXMgcmV2ZXJzZSBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhck1hcHBpbmcucmVsYXRpb25zaGlwcy5vd25lci5yZXZlcnNlTWFwcGluZywgcGVyc29uTWFwcGluZyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2NvbmZpZ3VyZXMgcmV2ZXJzZSBuYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhck1hcHBpbmcucmVsYXRpb25zaGlwcy5vd25lci5yZXZlcnNlTmFtZSwgJ2NhcnMnKTtcblxuXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnY29uZmlndXJlcyBmb3J3YXJkIG1hcHBpbmcnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyTWFwcGluZy5yZWxhdGlvbnNoaXBzLm93bmVyLmZvcndhcmRNYXBwaW5nLCBjYXJNYXBwaW5nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ2NvbmZpZ3VyZXMgZm9yd2FyZCBuYW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhck1hcHBpbmcucmVsYXRpb25zaGlwcy5vd25lci5mb3J3YXJkTmFtZSwgJ293bmVyJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ2luc3RhbGxzIG9uIHJldmVyc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHBlcnNvbk1hcHBpbmcucmVsYXRpb25zaGlwcy5jYXJzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT0gJ2lzRm9yd2FyZCcgJiYga2V5ICE9ICdpc1JldmVyc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uTWFwcGluZy5yZWxhdGlvbnNoaXBzLmNhcnNba2V5XSwgY2FyTWFwcGluZy5yZWxhdGlvbnNoaXBzLm93bmVyW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cblxuXG5cblxuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG5cblxuICAgIGRlc2NyaWJlKCdpbnZhbGlkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdObyBzdWNoIG1hcHBpbmcnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnYXNkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQub2soZXJyKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ05vIHN1Y2ggcmVsYXRpb25zaGlwIHR5cGUnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcblxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ludmFsaWR0eXBlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGVycik7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cblxufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpXG4gICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5cbmRlc2NyaWJlKCdyZXN0JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBDb2xsZWN0aW9uUmVnaXN0cnkgPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvblJlZ2lzdHJ5JykuQ29sbGVjdGlvblJlZ2lzdHJ5O1xuICAgIHZhciBjb2xsZWN0aW9uO1xuXG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcy5yZXNldCh0cnVlKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdDcmVhdGUgQmFzaWMgUmVzdCBBUEknLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2dsb2JhbCBhY2Nlc3MnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwoQ29sbGVjdGlvblJlZ2lzdHJ5Lm15Q29sbGVjdGlvbiwgY29sbGVjdGlvbik7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnT2JqZWN0IG1hcHBpbmcgcmVnaXN0cmF0aW9uJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBjb2xsZWN0aW9uO1xuICAgICAgICBkZXNjcmliZSgnYmFzaWMnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdyYXcgbWFwcGluZyB0byBNYXBwaW5nIG9iamVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnRNYXBwaW5nKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhd01hcHBpbmcgPSBjb2xsZWN0aW9uLl9yYXdNYXBwaW5ncy5QZXJzb247XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhyYXdNYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBpbmdPYmogPSBjb2xsZWN0aW9uLlBlcnNvbjtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG1hcHBpbmdPYmoudHlwZSwgJ1BlcnNvbicpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobWFwcGluZ09iai5pZCwgJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChtYXBwaW5nT2JqLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUobWFwcGluZ09iai5fZmllbGRzLCAnbmFtZScpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShtYXBwaW5nT2JqLl9maWVsZHMsICdhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG1hcHBpbmdPYmopO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0KCdtYXBwaW5ncycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWFwcGluZyhjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuXG5cbiAgICB9KVxuXG59KTsiLCJ2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4JyksXG4gICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ3NlcmlhbGlzZXJzJywgZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbiAgICB2YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xuXG4gICAgdmFyIGNvbGxlY3Rpb24sIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmcsIHZpdGFsU2lnbnNNYXBwaW5nO1xuXG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2lkIHNlcmlhbGlzZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnY2FycydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gdGhlIGlkIGlmIGhhcyBvbmUnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICBpZDogNVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNpZXN0YS5leHQuaHR0cC5TZXJpYWxpc2VyLmlkU2VyaWFsaXNlcihjYXIpLCBjYXIuaWQpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBpZiBkb2VzbnQgaGF2ZSBhbiBpZCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nXG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2llc3RhLmV4dC5odHRwLlNlcmlhbGlzZXIuaWRTZXJpYWxpc2VyKGNhciksIG51bGwpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBpZiBubyBpZCBmaWVsZCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICBpZDogNVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNpZXN0YS5leHQuaHR0cC5TZXJpYWxpc2VyLmlkU2VyaWFsaXNlcihjYXIpLCBudWxsKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZGVwdGggc2VyaWFsaXNlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG5cbiAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ10sXG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgICAgICB2aXRhbFNpZ25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnVml0YWxTaWducycsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvT25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ3BlcnNvbidcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZpdGFsU2lnbnNNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdWaXRhbFNpZ25zJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnaGVhcnRSYXRlJywgJ2Jsb29kUHJlc3N1cmUnXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2RlcHRoIDAnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICBpZDogNSxcbiAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IDI4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLlNlcmlhbGlzZXIuZGVwdGhTZXJpYWxpemVyKDApKGNhciwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEuY29sb3VyLCBjYXIuY29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEubmFtZSwgY2FyLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5pZCwgY2FyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEub3duZXIsIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdkZXB0aCAxJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4gICAgICAgICAgICAgICAgaWQ6IDUsXG4gICAgICAgICAgICAgICAgb3duZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4gICAgICAgICAgICAgICAgICAgIGlkOiAyOCxcbiAgICAgICAgICAgICAgICAgICAgdml0YWxTaWduczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDM1LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhcnRSYXRlOiA2NVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgc2llc3RhLmV4dC5odHRwLlNlcmlhbGlzZXIuZGVwdGhTZXJpYWxpemVyKDEpKGNhciwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEuY29sb3VyLCBjYXIuY29sb3VyKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEubmFtZSwgY2FyLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5pZCwgY2FyLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEub3duZXIuaWQsIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRhdGEub3duZXIudml0YWxTaWducywgMzUpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2RlcHRoIDInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbiAgICAgICAgICAgICAgICBpZDogNSxcbiAgICAgICAgICAgICAgICBvd25lcjoge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IDI4LFxuICAgICAgICAgICAgICAgICAgICB2aXRhbFNpZ25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogMzUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFydFJhdGU6IDY1XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5kZXB0aFNlcmlhbGl6ZXIoMikoY2FyLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5jb2xvdXIsIGNhci5jb2xvdXIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5uYW1lLCBjYXIubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkYXRhLmlkLCBjYXIuaWQpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5vd25lci5pZCwgMjgpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZGF0YS5vd25lci52aXRhbFNpZ25zLmhlYXJ0UmF0ZSwgNjUpO1xuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdhdmFpbGliaWxpdHkgb24gc2llc3RhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdpZCwgYW5nbG9waG9uZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChzLnNlcmlhbGlzZXJzLmlkLCBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5pZFNlcmlhbGlzZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgncm9vdCwgYW5nbG9waG9uZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChzLnNlcmlhbGlzZXJzLmRlcHRoLCBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5kZXB0aFNlcmlhbGl6ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ2lkLCBhbWVyaWNhbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChzLnNlcmlhbGl6ZXJzLmlkLCBzaWVzdGEuZXh0Lmh0dHAuU2VyaWFsaXNlci5pZFNlcmlhbGlzZXIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgncm9vdCwgYW1lcmljYW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwocy5zZXJpYWxpemVycy5kZXB0aCwgc2llc3RhLmV4dC5odHRwLlNlcmlhbGlzZXIuZGVwdGhTZXJpYWxpemVyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cblxufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpLFxuICAgIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCdzaW5nbGV0b24gbWFwcGluZycsIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL3NyYy9jYWNoZScpO1xuICAgIHZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL3NyYy9zdG9yZScpO1xuXG4gICAgdmFyIGNvbGxlY3Rpb24sIGNhck1hcHBpbmc7XG5cbiAgICBmdW5jdGlvbiBDYXJPYmplY3QoKSB7XG4gICAgICAgIFNpZXN0YU1vZGVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgQ2FyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2llc3RhTW9kZWwucHJvdG90eXBlKTtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ0NhcicpO1xuICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtYXAgb250byB0aGUgc2FtZSBzaW5nbGV0b24gb2JqZWN0LCBldmVuIGlmIGEgZGlmZmVyZW50IGlkZW50aWZpZXInLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICBpZDogNVxuICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgIGlkOiAxMFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIGNhcjIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3VyLCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuaWQsIDEwKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG1hcCBvbnRvIHRoZSBzYW1lIHNpbmdsZXRvbiBvYmplY3QnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgIGNvbG91cjogJ3JlZCdcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJ1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIsIGNhcjIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIuY29sb3VyLCAnYmx1ZScpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuXG5cbiAgICBpdCgnY2FjaGUgc2hvdWxkIHJldHVybiBzaW5nbGV0b24nLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhck1hcHBpbmcubWFwKHtcbiAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICBpZDogNVxuICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGNhcikge1xuICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgdmFyIG9iaiA9IGNhY2hlLmdldCh7XG4gICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLCBjYXIpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdnZXQgc2hvdWxkIHNpbXBseSByZXR1cm4gdGhlIGNhcicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0KDUwMDApO1xuICAgICAgICBjYXJNYXBwaW5nLm1hcCh7XG4gICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgaWQ6IDVcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgIGNhck1hcHBpbmcuZ2V0KGZ1bmN0aW9uKGVyciwgX2Nhcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLCBfY2FyKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbn0pOyIsInZhciBzaWVzdGEgPSByZXF1aXJlKCcuLi9pbmRleCcpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbmRlc2NyaWJlKCdzdGF0aXN0aWNzJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIENhciwgUGVyc29uLCBjb2xsO1xuXG4gICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4gICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgc2llc3RhLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBDYXIgPSBjb2xsLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuICAgICAgICAgICAgICAgIG93bmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnT25lVG9NYW55JyxcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgUGVyc29uID0gY29sbC5tYXBwaW5nKCdQZXJzb24nLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnYWdlJywgJ25hbWUnXVxuICAgICAgICB9KTtcbiAgICAgICAgY29sbC5pbnN0YWxsKGRvbmUpO1xuICAgIH0pO1xuXG4gICAgYmVmb3JlKGZ1bmN0aW9uKCkge1xuICAgICAgICBzaWVzdGEuZXh0LnN0b3JhZ2VFbmFibGVkID0gZmFsc2U7XG4gICAgfSk7XG4gICAgYWZ0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpZXN0YS5leHQuc3RvcmFnZUVuYWJsZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdjb2xsZWN0aW9uIGxldmVsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgbWFwcGluZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaXQoJ25vIG9iamVjdHMnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgY29sbC5jb3VudChmdW5jdGlvbihlcnIsIG4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnb25lIG9iamVjdCcsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBDYXIubWFwKHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdtdWx0aXBsZSBvYmplY3RzJywgZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgICAgICAgIENhci5tYXAoW3tcbiAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleSdcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJ1xuICAgICAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsLmNvdW50KGZ1bmN0aW9uKGVyciwgbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG4sIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGVzY3JpYmUoJ211bHRpcGxlIG1hcHBpbmdzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpdCgnbXVsdGlwbGUgb2JqZWN0cycsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICBDYXIubWFwKFt7XG4gICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0JlbnRsZXknXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibydcbiAgICAgICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgUGVyc29uLm1hcChbe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSm9obiBEb2UnXG4gICAgICAgICAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cblxufSk7IiwiLy8gdmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpXG4vLyAgICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG4vLyBkZXNjcmliZSgnZ2VuZXJhdGlvbiBvZiBjaGFuZ2VzIGR1cmluZyBhcnJheSBvcGVyYXRpb25zJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgdmFyIGNvbGxlY3Rpb247XG4vLyAgICAgdmFyIGNhciwgcGVyc29uO1xuLy8gICAgIHZhciBjYXJNYXBwaW5nLCBwZXJzb25NYXBwaW5nO1xuXG4vLyAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4gICAgXG4vLyAgICAgdmFyIENoYW5nZVR5cGUgPSByZXF1aXJlKCcuLi9zcmMvY2hhbmdlcycpLkNoYW5nZVR5cGU7XG4vLyAgICAgdmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcbi8vICAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJyk7XG5cbi8vICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgIHMucmVzZXQodHJ1ZSk7XG4vLyAgICAgICAgIGRvbmUoKTtcbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdhZ2FpbnN0IGF0dHJpYnV0ZXMnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcblxuLy8gICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ11cbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4vLyAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgncHVzaCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgIGNhci5jb2xvdXJzID0gW107XG4vLyAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVzZXRDaGFuZ2VzKCk7XG4vLyAgICAgICAgICAgICBjYXIuY29sb3Vycy5wdXNoKCdyZWQnKTtcbi8vICAgICAgICAgICAgIHV0aWwubmV4dChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKDEsIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzLmxlbmd0aCk7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzWzBdO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGNoYW5nZS5hZGRlZCwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFuZ2UuaW5kZXgsIDApO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFuZ2UuZmllbGQsICdjb2xvdXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGl0KCdzcGxpY2UnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgY2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICBjYXIuY29sb3VycyA9IFsncmVkJ107XG4vLyAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVzZXRDaGFuZ2VzKCk7XG4vLyAgICAgICAgICAgICBjYXIuY29sb3Vycy5zcGxpY2UoMCwgMSk7XG4vLyAgICAgICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbCgxLCBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShjaGFuZ2UucmVtb3ZlZCwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFuZ2UuaW5kZXgsIDApO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFuZ2UuZmllbGQsICdjb2xvdXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGl0KCdzb3J0JywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgIGNhciA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgY2FyLmNvbG91cnMgPSBbJ3JlZCcsICdibHVlJywgJ2dyZWVuJ107XG4vLyAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVzZXRDaGFuZ2VzKCk7XG4vLyAgICAgICAgICAgICBjYXIuY29sb3Vycy5zb3J0KCk7XG4vLyAgICAgICAgICAgICAvLyBSZWQgaXMgcmVtb3ZlZCBhbmQgaW5zZXJ0ZWQgZWxzZXdoZXJlLlxuLy8gICAgICAgICAgICAgdXRpbC5uZXh0KGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoMiwgcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMubGVuZ3RoKTtcbi8vICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdhZ2FpbnN0IHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgZGVzY3JpYmUoJ2ZvcmVpZ24ga2V5JywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcblxuLy8gICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ10sXG4vLyAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdwdXNoJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgICAgICB2YXIgYW5vdGhlckNhciA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5jaGFuZ2VzLnJlc2V0Q2hhbmdlcygpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzLnB1c2goYW5vdGhlckNhcik7XG4vLyAgICAgICAgICAgICAgICAgdXRpbC5uZXh0KGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJDYXIub3duZXIsIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBhbGxDaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXM7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhbGxDaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBzcGxpY2VQcmVkaWNhdGUgPSBmdW5jdGlvbiAoeCkge3JldHVybiB4LnR5cGUgPT09IENoYW5nZVR5cGUuU3BsaWNlfTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGljZUNoYW5nZSA9IF8uZmluZChhbGxDaGFuZ2VzLCBzcGxpY2VQcmVkaWNhdGUpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3BsaWNlQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc3BsaWNlQ2hhbmdlLmFkZGVkLCBhbm90aGVyQ2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZUNoYW5nZS5pbmRleCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzcGxpY2VDaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgaXQoJ3NwbGljZScsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY2FyID0gY2FyTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyXTtcbi8vICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVzZXRDaGFuZ2VzKCk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMuc3BsaWNlKDAsIDEpO1xuLy8gICAgICAgICAgICAgICAgIHV0aWwubmV4dChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXIub3duZXJQcm94eS5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soY2FyLm93bmVyUHJveHkucmVsYXRlZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBhbGxDaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXM7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhbGxDaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBzcGxpY2VQcmVkaWNhdGUgPSBmdW5jdGlvbiAoeCkge3JldHVybiB4LnR5cGUgPT09IENoYW5nZVR5cGUuU3BsaWNlfTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGljZUNoYW5nZSA9IF8uZmluZChhbGxDaGFuZ2VzLCBzcGxpY2VQcmVkaWNhdGUpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzcGxpY2VDaGFuZ2UucmVtb3ZlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZUNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdtYW55IHRvIG1hbnknLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcblxuLy8gICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ10sXG4vLyAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyczoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuTWFueVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnY2Fycydcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ25vIGZhdWx0cycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBpdCgncHVzaCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhciA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgYW5vdGhlckNhciA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb24gPSBwZXJzb25NYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyXTtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5jaGFuZ2VzLnJlc2V0Q2hhbmdlcygpO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fycy5wdXNoKGFub3RoZXJDYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoY2FyLm93bmVycywgcGVyc29uLCAnb3JpZ2luYWwgY2FyIHNob3VsZCBoYXZlIG93bmVyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShhbm90aGVyQ2FyLm93bmVycywgcGVyc29uLCAnbmV3IGNhciBzaG91bGQgaGF2ZSBvd25lcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhbGxDaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaWNlUHJlZGljYXRlID0gZnVuY3Rpb24gKHgpIHtyZXR1cm4geC5faWQgPT09IHBlcnNvbi5faWR9O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGljZUNoYW5nZSA9IF8uZmluZChhbGxDaGFuZ2VzLCBzcGxpY2VQcmVkaWNhdGUpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZUNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzcGxpY2VDaGFuZ2UuYWRkZWQsIGFub3RoZXJDYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZUNoYW5nZS5pbmRleCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3BsaWNlQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzcGxpY2UnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5yZXNldENoYW5nZXMoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMuc3BsaWNlKDAsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhbGxDaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uUHJlZCA9IGZ1bmN0aW9uICh4KSB7cmV0dXJuIHguX2lkID09PSBwZXJzb24uX2lkfTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb25DaGFuZ2UgPSBfLmZpbmQoYWxsQ2hhbmdlcywgcGVyc29uUHJlZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyUHJlZCA9IGZ1bmN0aW9uICh4KSB7cmV0dXJuIHguX2lkID09PSBjYXIuX2lkfTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXJDaGFuZ2UgPSBfLmZpbmQoYWxsQ2hhbmdlcywgY2FyUHJlZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25DaGFuZ2UucmVtb3ZlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhjYXIub3duZXJzUHJveHkuX2lkLmxlbmd0aCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soY2FyLm93bmVyc1Byb3h5LnJlbGF0ZWQubGVuZ3RoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnZmF1bHQgaW4gdGhlIHJldmVyc2UnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgaXQoJ3B1c2gnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGFub3RoZXJDYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5yZXNldENoYW5nZXMoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyc1Byb3h5LnJlbGF0ZWQgPSBudWxsO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fycy5wdXNoKGFub3RoZXJDYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB1dGlsLm5leHQoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsbENoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhbGxDaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaWNlUHJlZGljYXRlID0gZnVuY3Rpb24gKHgpIHtyZXR1cm4geC5faWQgPT09IHBlcnNvbi5faWR9O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGljZUNoYW5nZSA9IF8uZmluZChhbGxDaGFuZ2VzLCBzcGxpY2VQcmVkaWNhdGUpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZUNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzcGxpY2VDaGFuZ2UuYWRkZWRJZCwgYW5vdGhlckNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNwbGljZUNoYW5nZS5pbmRleCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc3BsaWNlQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzcGxpY2UnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5yZXNldENoYW5nZXMoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyc1Byb3h5LnJlbGF0ZWQgPSBudWxsO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2Fycy5zcGxpY2UoMCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHV0aWwubmV4dChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFsbENoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb25QcmVkID0gZnVuY3Rpb24gKHgpIHtyZXR1cm4geC5faWQgPT09IHBlcnNvbi5faWR9O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkNoYW5nZSA9IF8uZmluZChhbGxDaGFuZ2VzLCBwZXJzb25QcmVkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXJQcmVkID0gZnVuY3Rpb24gKHgpIHtyZXR1cm4geC5faWQgPT09IGNhci5faWR9O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhckNoYW5nZSA9IF8uZmluZChhbGxDaGFuZ2VzLCBjYXJQcmVkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5yZW1vdmVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGNhci5vd25lcnNQcm94eS5faWQubGVuZ3RoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuXG5cblxuXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgfSk7XG4vLyB9KTsiLCIvLyB2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4Jylcbi8vICAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbi8vIGRlc2NyaWJlKCdhdHRyaWJ1dGUgcy5leHQuc3RvcmFnZS5jaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb25cbi8vICAgICAgICAgLCBDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi4vc3JjL2NoYW5nZXMnKS5DaGFuZ2VUeXBlO1xuXG4vLyAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIHMucmVzZXQodHJ1ZSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnYXR0cmlidXRlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgdmFyIGNvbGxlY3Rpb24sIGNhck1hcHBpbmc7XG4vLyAgICAgICAgIHZhciBjYXI7XG5cbi8vICAgICAgICAgdmFyIG5vdGlmLCBjb2xsZWN0aW9uTm90aWYsIGdlbmVyaWNOb3RpZjtcblxuLy8gICAgICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgbm90aWYgPSBudWxsO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbk5vdGlmID0gbnVsbDtcbi8vICAgICAgICAgICAgIGdlbmVyaWNOb3RpZiA9IG51bGw7XG4vLyAgICAgICAgICAgICBjYXIgPSBudWxsO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbiA9IG51bGw7XG4vLyAgICAgICAgICAgICBjYXJNYXBwaW5nID0gbnVsbDtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgZGVzY3JpYmUoJ3NldCcsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuXG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG5cbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgnbm8gcHJldmlvdXMgdmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gY2FyTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgbW9kZWwuY29sb3VyID0gJ3JlZCc7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGNzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKG1vZGVsLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGMgPSBjc1swXTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMubmV3LCAncmVkJyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMuX2lkLCBtb2RlbC5faWQpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMuZmllbGQsICdjb2xvdXInKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soYy5vbGQpO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdoYXMgcHJldmlvdXMgdmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gY2FyTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgbW9kZWwuX192YWx1ZXMuY29sb3VyID0gJ2JsdWUnO1xuLy8gICAgICAgICAgICAgICAgIG1vZGVsLmNvbG91ciA9ICdyZWQnO1xuLy8gICAgICAgICAgICAgICAgIHZhciBjcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihtb2RlbC5faWQpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgIHZhciBjID0gY3NbMF07XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLm5ldywgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLm9sZCwgJ2JsdWUnKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5faWQsIG1vZGVsLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5maWVsZCwgJ2NvbG91cicpO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdyZW1vdGUgaWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gY2FyTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgbW9kZWwuaWQgPSAneHl6Jztcbi8vICAgICAgICAgICAgICAgICB2YXIgY3MgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIobW9kZWwuX2lkKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY3MubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICB2YXIgYyA9IGNzWzBdO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5uZXcsICd4eXonKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soYy5vbGQpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLl9pZCwgbW9kZWwuX2lkKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLmZpZWxkLCAnaWQnKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdhcnJheScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ11cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ3NldCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBpdCgnbm8gcHJldmlvdXMgdmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgICAgICBtb2RlbC5jb2xvdXJzID0gWydncmVlbicsICdibHVlJ107XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihtb2RlbC5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY3MubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBjc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5uZXcsIG1vZGVsLmNvbG91cnMpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soYy5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5faWQsIG1vZGVsLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5maWVsZCwgJ2NvbG91cnMnKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdoYXMgcHJldmlvdXMgdmFsdWUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgb2xkQ29sb3VycyA9IFsncHVycGxlJywgJ3JlZCddO1xuLy8gICAgICAgICAgICAgICAgICAgICBtb2RlbC5fX3ZhbHVlcy5jb2xvdXJzID0gb2xkQ29sb3Vycztcbi8vICAgICAgICAgICAgICAgICAgICAgbW9kZWwuY29sb3VycyA9IFsnZ3JlZW4nLCAnYmx1ZSddO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY3MgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIobW9kZWwuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gY3NbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMubmV3LCBtb2RlbC5jb2xvdXJzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMub2xkLCBvbGRDb2xvdXJzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMuX2lkLCBtb2RlbC5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMuZmllbGQsICdjb2xvdXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ3B1c2gnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IGNhck1hcHBpbmcuX25ldygpO1xuLy8gICAgICAgICAgICAgICAgIG1vZGVsLmNvbG91cnMgPSBbXTtcbi8vICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVzZXRDaGFuZ2VzKCk7XG4vLyAgICAgICAgICAgICAgICAgbW9kZWwuY29sb3Vycy5wdXNoKCdyZWQnKTtcbi8vICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKG1vZGVsLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNzWzBdO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMucmVtb3ZlZC5sZW5ndGgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5hZGRlZFswXSwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5faWQsIG1vZGVsLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5maWVsZCwgJ2NvbG91cnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdpbmRleCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gY2FyTWFwcGluZy5fbmV3KCk7XG4vLyAgICAgICAgICAgICAgICAgbW9kZWwuY29sb3VycyA9IFsnYmx1ZScsICdncmVlbicsICdwdXJwbGUnXTtcbi8vICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVzZXRDaGFuZ2VzKCk7XG4vLyAgICAgICAgICAgICAgICAgbW9kZWwuY29sb3Vyc1sxXSA9ICdyZWQnO1xuLy8gICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY3MgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIobW9kZWwuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gY3NbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMuaW5kZXgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5yZW1vdmVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLnJlbW92ZWRbMF0sICdncmVlbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5hZGRlZFswXSwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5faWQsIG1vZGVsLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGMubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYy5maWVsZCwgJ2NvbG91cnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgfSk7XG5cbi8vICAgICB9KTtcblxuLy8gfSk7IiwiLy8gdmFyIGNoYWkgPSByZXF1aXJlKCdjaGFpJyk7XG4vLyB2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4Jylcbi8vICAgICAsIGFzc2VydCA9IGNoYWkuYXNzZXJ0O1xuXG4vLyB2YXIgbWFwcGluZ09wZXJhdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9tYXBwaW5nT3BlcmF0aW9uJyk7XG4vLyB2YXIgQnVsa01hcHBpbmdPcGVyYXRpb24gPSBtYXBwaW5nT3BlcmF0aW9uLkJ1bGtNYXBwaW5nT3BlcmF0aW9uO1xuLy8gdmFyIHV0aWwgPSByZXF1aXJlKCcuLi9zcmMvdXRpbCcpO1xuLy8gdmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcbi8vIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuLy8gdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG4vLyB2YXIgY29sbGVjdGlvbjtcbi8vIHZhciBSZXBvLCBVc2VyO1xuXG5cbi8vIGRlc2NyaWJlKCdidWxrIG1hcHBpbmcgb3BlcmF0aW9uJywgZnVuY3Rpb24gKCkge1xuLy8gICAgIGRlc2NyaWJlKCdnZW5lcmFsJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBzLnJlc2V0KHRydWUpO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdNeUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgIGNvbGxlY3Rpb24uYmFzZVVSTCA9ICdodHRwczovL2FwaS5naXRodWIuY29tJztcbi8vICAgICAgICAgICAgIFJlcG8gPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1JlcG8nLCB7XG4vLyAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2Z1bGxfbmFtZScsICdkZXNjcmlwdGlvbiddLFxuLy8gICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdVc2VyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ3JlcG9zaXRvcmllcydcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgVXNlciA9IGNvbGxlY3Rpb24ubWFwcGluZygnVXNlcicsIHtcbi8vICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2xvZ2luJ11cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgIGRlc2NyaWJlKCduZXcnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3JlaWduIGtleScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgncmV2ZXJzZScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaXQoJ2V4aXN0aW5nJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wb3N0KHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzUnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdPbGQgTmFtZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVsbF9uYW1lOiAnT2xkIEZ1bGwgTmFtZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ015Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JlcG8nXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpbjogJ21pa2UnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMTIzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0b3JpZXM6IFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lkOiAnNScsIG5hbWU6ICdSZXBvJywgZnVsbF9uYW1lOiAnQSBCaWcgUmVwbyd9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3AgPSBuZXcgQnVsa01hcHBpbmdPcGVyYXRpb24oe21hcHBpbmc6IFVzZXIsIGRhdGE6IGRhdGF9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3Aub25Db21wbGV0aW9uKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcC5lcnJvcikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUob3AuZXJyb3IpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdHMgPSBvcC5yZXN1bHQ7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iamVjdHMubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmoubG9naW4sICdtaWtlJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouaWQsICcxMjMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5yZXBvc2l0b3JpZXMubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcG8gPSBvYmoucmVwb3NpdG9yaWVzWzBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVwby5pZCwgNSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvLm5hbWUsICdSZXBvJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXBvLmZ1bGxfbmFtZSwgJ0EgQmlnIFJlcG8nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcG8uX2lkLCByZXNwLmlkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlcG8ub3duZXIsIG9iaik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcC5zdGFydCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdzaW5nbGV0b24uLi4nLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIHZhciBvcDtcblxuLy8gICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBzLnJlc2V0KHRydWUpO1xuXG4vLyAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ015Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5iYXNlVVJMID0gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xuLy8gICAgICAgICAgICAgUmVwbyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUmVwbycsIHtcbi8vICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnZnVsbF9uYW1lJywgJ2Rlc2NyaXB0aW9uJ10sXG4vLyAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuLy8gICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1VzZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAncmVwb3NpdG9yaWVzJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBVc2VyID0gY29sbGVjdGlvbi5tYXBwaW5nKCdVc2VyJywge1xuLy8gICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbG9naW4nXSxcbi8vICAgICAgICAgICAgICAgICBzaW5nbGV0b246IHRydWVcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgnZXhpc3RpbmcsIGZhdWx0ZWQnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgZG9jID0ge2lkOiAnNTY3JywgX2lkOiAnbG9jYWxJZCcsIHR5cGU6ICdVc2VyJywgY29sbGVjdGlvbjogJ015Q29sbGVjdGlvbid9O1xuLy8gICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wdXQoZG9jLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9jLl9yZXYgPSByZXNwLnJldjtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB7bG9naW46ICdtaWtlJywgaWQ6ICcxMjMnfSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHtsb2dpbjogJ2JvYicsIGlkOiAnMTIzNCd9XG4vLyAgICAgICAgICAgICAgICAgICAgIF07XG4vLyAgICAgICAgICAgICAgICAgICAgIG9wID0gbmV3IEJ1bGtNYXBwaW5nT3BlcmF0aW9uKHttYXBwaW5nOiBVc2VyLCBkYXRhOiBkYXRhfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgnbG9va3VwU2luZ2xldG9uJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBvcC5fbG9va3VwU2luZ2xldG9uKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvcC5vYmplY3RzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXS5faWQsICdsb2NhbElkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXSwgb3Aub2JqZWN0c1sxXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdtYXAnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgIG9wLm9uQ29tcGxldGlvbihmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBvcC5lcnJvcjtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvcC5vYmplY3RzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXS5faWQsICdsb2NhbElkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXSwgb3Aub2JqZWN0c1sxXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob3Aub2JqZWN0c1swXS5sb2dpbiwgJ2JvYicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9wLm9iamVjdHNbMF0uaWQsICcxMjM0Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIG9wLnN0YXJ0KCk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgfSk7XG4vLyB9KTsiLCIvLyB2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4Jylcbi8vICAgICAsIGFzc2VydCA9IHJlcXVpcmUoJy4vdXRpbCcpLmFzc2VydDtcblxuLy8gZGVzY3JpYmUoJ2NoYW5nZXMhJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgdmFyIENoYW5nZVR5cGUgPSByZXF1aXJlKCcuLi9zcmMvY2hhbmdlcycpLkNoYW5nZVR5cGU7XG4vLyAgICAgdmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcblxuLy8gICAgIHZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi4vc3JjL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcjtcblxuLy8gICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuXG4vLyAgICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG5cbi8vICAgICB2YXIgY29yZUNoYW5nZXMgPSByZXF1aXJlKCcuLi9zcmMvY2hhbmdlcycpO1xuXG4vLyAgICAgdmFyIENoYW5nZSA9IGNvcmVDaGFuZ2VzLkNoYW5nZTtcbi8vICAgICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3NyYy91dGlsJyk7XG5cbi8vICAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZztcblxuLy8gICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBzLnJlc2V0KHRydWUpO1xuLy8gICAgIH0pO1xuXG4vLyAgICAgZGVzY3JpYmUoJ3JlZ2lzdGVyaW5nIGNoYW5nZXMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddXG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgaXQoJ3JlZ2lzdGVycyBhIGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgX2lkOiAneHl6J1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB2YXIgb2JqQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzW2NvbGxlY3Rpb24ubmFtZV1bY2FyTWFwcGluZy50eXBlXVsneHl6J107XG4vLyAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqQ2hhbmdlcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgdmFyIGNoYW5nZSA9IG9iakNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2hhbmdlLmNvbGxlY3Rpb24sIGNvbGxlY3Rpb24pO1xuLy8gICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNoYW5nZS5tYXBwaW5nLCBjYXJNYXBwaW5nKTtcbi8vICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjaGFuZ2UuX2lkLCAneHl6Jyk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdlcnJvcnMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIG5vIG1hcHBpbmcnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhcbi8vICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29yZUNoYW5nZXMucmVnaXN0ZXJDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiAneHl6J1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvclxuLy8gICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBubyBjb2xsZWN0aW9uJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoXG4vLyAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogJ3h5eidcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3Jcbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgbm8gX2lkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoXG4vLyAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmVDaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb25cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3Jcbi8vICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgfSlcbi8vICAgICAgICAgfSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnYWxsIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnYWxsIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzID0ge1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IHtcbi8vICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzE6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHh5ejogWydhZHNkJywgJ2FzZGFzJ11cbi8vICAgICAgICAgICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHh5ejE6IFsnZHNhc2RhJywgJ2ZoNDMnXVxuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgICAgICBhbm90aGVyQ29sbGVjdGlvbjoge1xuLy8gICAgICAgICAgICAgICAgICAgICBhbm90aGVyTWFwcGluZzoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgb2JqMTogWydhc2QnXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG9iajI6IFsnMTIzJywgJzU2NyddXG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9O1xuXG4vLyAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMubGVuZ3RoLCA3KTtcbi8vICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzLCAnYWRzZCcpO1xuLy8gICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMsICdhc2RhcycpO1xuLy8gICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMsICdkc2FzZGEnKTtcbi8vICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzLCAnZmg0MycpO1xuLy8gICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMsICdhc2QnKTtcbi8vICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzLCAnMTIzJyk7XG4vLyAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcywgJzU2NycpO1xuLy8gICAgICAgICB9KTtcbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdhcHBseWluZyBjaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdzZXQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ3NldCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSgpO1xuLy8gICAgICAgICAgICAgICAgIGMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uX25hbWU7XG4vLyAgICAgICAgICAgICAgICAgYy5tYXBwaW5nID0gY2FyTWFwcGluZy50eXBlO1xuLy8gICAgICAgICAgICAgICAgIGMuZmllbGQgPSAnY29sb3VyJztcbi8vICAgICAgICAgICAgICAgICBjLnR5cGUgPSBDaGFuZ2VUeXBlLlNldDtcbi8vICAgICAgICAgICAgICAgICBjLm5ldyA9ICdibHVlJztcbi8vICAgICAgICAgICAgICAgICBjLm9sZCA9ICdyZWQnO1xuLy8gICAgICAgICAgICAgICAgIGMuX2lkID0gb2JqLl9pZDtcbi8vICAgICAgICAgICAgICAgICBjLmFwcGx5KG9iaik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXIsICdibHVlJyk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ2Vycm9ycycsIGZ1bmN0aW9uICgpIHtcblxuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ2luY29ycmVjdCBfaWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLl9uYW1lO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm1hcHBpbmcgPSBjYXJNYXBwaW5nLnR5cGU7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuZmllbGQgPSAnY29sb3VyJztcbi8vICAgICAgICAgICAgICAgICAgICAgYy50eXBlID0gQ2hhbmdlVHlwZS5TZXQ7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMubmV3ID0gJ2JsdWUnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm9sZCA9ICdyZWQnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLl9pZCA9ICdyYW5kb21pZCc7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYy5hcHBseShvYmopO1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBpdCgnb2xkIGRvZXMgbm90IG1hdGNoIGN1cnJlbnQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLl9uYW1lO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm1hcHBpbmcgPSBjYXJNYXBwaW5nLnR5cGU7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuZmllbGQgPSAnY29sb3VyJztcbi8vICAgICAgICAgICAgICAgICAgICAgYy50eXBlID0gQ2hhbmdlVHlwZS5TZXQ7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMubmV3ID0gJ2JsdWUnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm9sZCA9ICdwdXJwbGUnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLl9pZCA9IG9iai5faWQ7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYy5hcHBseShvYmopO1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBkZXNjcmliZSgnc3BsaWNlJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cnMnLCAnbmFtZSddXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCd3b3JrcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiBbJ3JlZCcsICdibHVlJ10sIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKCk7XG4vLyAgICAgICAgICAgICAgICAgYy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbi8vICAgICAgICAgICAgICAgICBjLm1hcHBpbmcgPSBjYXJNYXBwaW5nO1xuLy8gICAgICAgICAgICAgICAgIGMuZmllbGQgPSAnY29sb3Vycyc7XG4vLyAgICAgICAgICAgICAgICAgYy50eXBlID0gQ2hhbmdlVHlwZS5TcGxpY2U7XG4vLyAgICAgICAgICAgICAgICAgYy5pbmRleCA9IDE7XG4vLyAgICAgICAgICAgICAgICAgYy5hZGRlZCA9IFsnZ3JlZW4nXTtcbi8vICAgICAgICAgICAgICAgICBjLnJlbW92ZWQgPSBbJ2JsdWUnXTtcbi8vICAgICAgICAgICAgICAgICBjLl9pZCA9IG9iai5faWQ7XG4vLyAgICAgICAgICAgICAgICAgYy5hcHBseShvYmopO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouY29sb3Vycy5sZW5ndGgsIDIpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouY29sb3Vyc1swXSwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouY29sb3Vyc1sxXSwgJ2dyZWVuJyk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ2Vycm9ycycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBpdCgnbm8gcmVtb3ZlIG9yIGFkZGVkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiBbJ3JlZCcsICdibHVlJ10sIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm1hcHBpbmcgPSBjYXJNYXBwaW5nO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmZpZWxkID0gJ2NvbG91cnMnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLnR5cGUgPSBDaGFuZ2VUeXBlLlNwbGljZTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5pbmRleCA9IDI7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuX2lkID0gb2JqLl9pZDtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjLmFwcGx5KG9iaik7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3IpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGl0KCdubyBpbmRleCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogWydyZWQnLCAnYmx1ZSddLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDaGFuZ2UoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5tYXBwaW5nID0gY2FyTWFwcGluZztcbi8vICAgICAgICAgICAgICAgICAgICAgYy5maWVsZCA9ICdjb2xvdXJzJztcbi8vICAgICAgICAgICAgICAgICAgICAgYy50eXBlID0gQ2hhbmdlVHlwZS5TcGxpY2U7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuYWRkZWQgPSBbJ2dyZWVuJ107XG4vLyAgICAgICAgICAgICAgICAgICAgIGMucmVtb3ZlZENvdW50ID0gMTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5faWQgPSBvYmouX2lkO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQudGhyb3dzKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGMuYXBwbHkob2JqKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgaXQoJ3JlbW92ZWQgZG9lc250IG1hdGNoJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiBbJ3JlZCcsICdibHVlJ10sIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm1hcHBpbmcgPSBjYXJNYXBwaW5nO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmZpZWxkID0gJ2NvbG91cnMnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLnR5cGUgPSBDaGFuZ2VUeXBlLlNwbGljZTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5pbmRleCA9IDE7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuYWRkZWQgPSBbJ2dyZWVuJ107XG4vLyAgICAgICAgICAgICAgICAgICAgIGMucmVtb3ZlZCA9IFsncHVycGxlJ107XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuX2lkID0gb2JqLl9pZDtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjLmFwcGx5KG9iaik7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3IpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBkZXNjcmliZSgncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgaXQoJ3dvcmtzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6IFsncmVkJywgJ2JsdWUnXSwgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDaGFuZ2UoKTtcbi8vICAgICAgICAgICAgICAgICBjLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuLy8gICAgICAgICAgICAgICAgIGMubWFwcGluZyA9IGNhck1hcHBpbmc7XG4vLyAgICAgICAgICAgICAgICAgYy5maWVsZCA9ICdjb2xvdXJzJztcbi8vICAgICAgICAgICAgICAgICBjLnR5cGUgPSBDaGFuZ2VUeXBlLkRlbGV0ZTtcbi8vICAgICAgICAgICAgICAgICBjLnJlbW92ZWQgPSBbJ3JlZCddO1xuLy8gICAgICAgICAgICAgICAgIGMuX2lkID0gb2JqLl9pZDtcbi8vICAgICAgICAgICAgICAgICBjLmFwcGx5KG9iaik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXJzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXJzWzBdLCAnYmx1ZScpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnZXJyb3JzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGl0KCdubyByZW1vdmVkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiBbJ3JlZCcsICdibHVlJ10sIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLm1hcHBpbmcgPSBjYXJNYXBwaW5nO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmZpZWxkID0gJ2NvbG91cnMnO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLnR5cGUgPSBDaGFuZ2VUeXBlLkRlbGV0ZTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5faWQgPSBvYmouX2lkO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQudGhyb3dzKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGMuYXBwbHkob2JqKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KVxuXG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnbWVyZ2UgY2hhbmdlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgZnVuY3Rpb24gdGVzdE1lcmdlKGNoYW5nZXMsIGRvY3MsIGNhbGxiYWNrKSB7XG4vLyAgICAgICAgICAgICB2YXIgZGIgPSBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCk7XG4vLyAgICAgICAgICAgICBkYi5idWxrRG9jcyhkb2NzLCBmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMubWVyZ2VDaGFuZ2VzKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuYWxsRG9jcyh7a2V5czogXy5wbHVjayhkb2NzLCAnX2lkJyksIGluY2x1ZGVfZG9jczogdHJ1ZX0sIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF8ucGx1Y2socmVzcC5yb3dzLCAnZG9jJykpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBkZXNjcmliZSgnc2V0JywgZnVuY3Rpb24gKCkge1xuXG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdhdHRyaWJ1dGUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGl0KCdzZXQgYXR0cmlidXRlJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZXMgPSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBteUNvbGxlY3Rpb246IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxJZDogW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IENoYW5nZSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbi5fbmFtZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLnR5cGUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdjb2xvdXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU2V0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogJ2JsdWUnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZDogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiAnbG9jYWxJZCdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH07XG5cbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGRvY3MgPSBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiAnbG9jYWxJZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICBdO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIHRlc3RNZXJnZShjaGFuZ2VzLCBkb2NzLCBmdW5jdGlvbiAoZXJyLCBkb2NzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3NbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvYy5jb2xvdXIsICdibHVlJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5hbGxDaGFuZ2VzLmxlbmd0aCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdyZWxhdGlvbnNoaXAnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbk1hcHBpbmc7XG4vLyAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcmVpZ24ga2V5JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICBpdCgnZm9yd2FyZCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBteUNvbGxlY3Rpb246IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJJZDogW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLl9uYW1lLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLnR5cGUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnb3duZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNldCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SWQ6ICdwZXJzb25JZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZElkOiBudWxsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6ICdjYXJJZCdcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2NzID0gW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiAnY2FySWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDYXInXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgXTtcblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGVzdE1lcmdlKGNoYW5nZXMsIGRvY3MsIGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSBkb2NzWzBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jLm93bmVyLCAncGVyc29uSWQnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICBpdCgncmV2ZXJzZScsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlcyA9IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBteUNvbGxlY3Rpb246IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25JZDogW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLl9uYW1lLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLnR5cGUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnb3duZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNldCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SWQ6IFsnY2FySWQxJywgJ2NhcklkMicsICdjYXJJZDMnXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkSWQ6IG51bGwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogJ3BlcnNvbklkJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvY3MgPSBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6ICdwZXJzb25JZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDI0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BlcnNvbidcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0TWVyZ2UoY2hhbmdlcywgZG9jcywgZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IGRvY3NbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5hcnJFcXVhbChkb2Mub3duZXIsIFsnY2FySWQxJywgJ2NhcklkMicsICdjYXJJZDMnXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgfSk7XG5cbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdhcHBseSBjaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdhdHRyaWJ1dGUnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VycycsICduYW1lJ11cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ3NldCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2NvbG91cnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNldCxcbi8vICAgICAgICAgICAgICAgICAgICAgbmV3OiAnYmx1ZScsXG4vLyAgICAgICAgICAgICAgICAgICAgIG9sZDogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIF9pZDogb2JqLl9pZFxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGMuYXBwbHlTaWVzdGFNb2RlbChvYmopO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmouY29sb3VycywgJ2JsdWUnKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgnc2V0LCBvbGQgaXMgd3JvbmcnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbi8vICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogY2FyTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdjb2xvdXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4vLyAgICAgICAgICAgICAgICAgICAgIG5ldzogJ2JsdWUnLFxuLy8gICAgICAgICAgICAgICAgICAgICBvbGQ6ICdncmVlbicsXG4vLyAgICAgICAgICAgICAgICAgICAgIF9pZDogb2JqLl9pZFxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmFwcGx5U2llc3RhTW9kZWwob2JqKTtcbi8vICAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgnc3BsaWNlJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6IFsncmVkJywgJ2JsdWUnXSwgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2NvbG91cnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNwbGljZSxcbi8vICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDEsXG4vLyAgICAgICAgICAgICAgICAgICAgIGFkZGVkOiBbJ2dyZWVuJ10sXG4vLyAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IFsnYmx1ZSddLFxuLy8gICAgICAgICAgICAgICAgICAgICBfaWQ6IG9iai5faWRcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjLmFwcGx5KG9iaik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXJzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXJzWzBdLCAncmVkJyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5jb2xvdXJzWzFdLCAnZ3JlZW4nKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdyZWxhdGlvbnNoaXBzJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICB2YXIgcGVyc29uTWFwcGluZztcblxuLy8gICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXJzJywgJ25hbWUnXSxcbi8vICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbidcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnc2V0JywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ25vIG9sZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaXQoJ25ldyBvbmx5JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhciA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdvd25lcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3OiBwZXJzb24sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkOiBudWxsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogY2FyLl9pZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjLmFwcGx5U2llc3RhTW9kZWwoY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IGNhci5vd25lclByb3h5O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHByb3h5Ll9pZCwgcGVyc29uLl9pZCwgJ1Nob3VsZCBzZXQgX2lkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkucmVsYXRlZCwgcGVyc29uLCAnU2hvdWxkIHNldCBwZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXIub3duZXIsIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGl0KCduZXdJZCBvbmx5JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhciA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdvd25lcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SWQ6IHBlcnNvbi5faWQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkOiBudWxsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogY2FyLl9pZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjLmFwcGx5U2llc3RhTW9kZWwoY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IGNhci5vd25lclByb3h5O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHByb3h5Ll9pZCwgcGVyc29uLl9pZCwgJ1Nob3VsZCBzZXQgX2lkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJzb24gb2JqZWN0IHNob3VsZCBiZSBwdWxsZWQgZnJvbSBjYWNoZS5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5yZWxhdGVkLCBwZXJzb24sICdTaG91bGQgc2V0IHBlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgcGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgaXQoJ2JvdGggbmV3IGFuZCBuZXdJZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjN9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnb3duZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU2V0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0lkOiBwZXJzb24uX2lkLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogcGVyc29uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZDogbnVsbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGNhci5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBjYXIub3duZXJQcm94eTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5faWQsIHBlcnNvbi5faWQsICdTaG91bGQgc2V0IF9pZCcpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHByb3h5LnJlbGF0ZWQsIHBlcnNvbiwgJ1Nob3VsZCBzZXQgcGVyc29uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyLm93bmVyLCBwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdvbGQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGl0KCduZXcgYW5kIG9sZCBvbmx5JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhciA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld093bmVyID0gY2FyTWFwcGluZy5fbmV3KHtuYW1lOiAnQm9iJywgYWdlOiAyNH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdvd25lcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3OiBuZXdPd25lcixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHBlcnNvbixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGNhci5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBjYXIub3duZXJQcm94eTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5faWQsIG5ld093bmVyLl9pZCwgJ1Nob3VsZCBzZXQgX2lkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkucmVsYXRlZCwgbmV3T3duZXIsICdTaG91bGQgc2V0IHBlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgbmV3T3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICBpdCgnbmV3SWQgYW5kIG9sZElkIG9ubHksIG5vIGZhdWx0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhciA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld093bmVyID0gY2FyTWFwcGluZy5fbmV3KHtuYW1lOiAnQm9iJywgYWdlOiAyNH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdvd25lcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SWQ6IG5ld093bmVyLl9pZCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRJZDogcGVyc29uLl9pZCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGNhci5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBjYXIub3duZXJQcm94eTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5faWQsIG5ld093bmVyLl9pZCwgJ1Nob3VsZCBzZXQgX2lkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkucmVsYXRlZCwgbmV3T3duZXIsICdTaG91bGQgc2V0IHBlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5vd25lciwgbmV3T3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICBpdCgnbmV3SWQgYW5kIG9sZElkIG9ubHksIGZhdWx0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhciA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gcGVyc29uO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld093bmVyID0gY2FyTWFwcGluZy5fbmV3KHtuYW1lOiAnQm9iJywgYWdlOiAyNH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdvd25lcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TZXQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SWQ6IG5ld093bmVyLl9pZCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRJZDogcGVyc29uLl9pZCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGNhci5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucmVzZXQoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGMuYXBwbHlTaWVzdGFNb2RlbChjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gY2FyLm93bmVyUHJveHk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkuX2lkLCBuZXdPd25lci5faWQsICdTaG91bGQgc2V0IF9pZCcpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHByb3h5LnJlbGF0ZWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHByb3h5LmlzRmF1bHQpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG5cbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgnZXJyb3JzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBpdCgnaW52YWxpZCBvbGRJZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjN9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnb3duZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU2V0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogcGVyc29uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZElkOiAneHl6Jyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGNhci5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGl0KCdpbnZhbGlkIG9sZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjN9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnb3duZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU2V0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogcGVyc29uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZDoge19pZDogJ3h5eid9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogY2FyLl9pZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQudGhyb3dzKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmFwcGx5U2llc3RhTW9kZWwoY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3IpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIH0pXG5cbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnc3BsaWNlJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3JlbW92ZWQgb25seScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjN9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjEgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY2FyMiA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ2JsdWUnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IFtjYXIxLCBjYXIyXTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU3BsaWNlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkOiBbY2FyMV0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IHBlcnNvbi5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuYXBwbHlTaWVzdGFNb2RlbChwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBwZXJzb24uY2Fyc1Byb3h5O1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkuX2lkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHByb3h5Ll9pZCwgY2FyMi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkucmVsYXRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwcm94eS5yZWxhdGVkLCBjYXIyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbi5jYXJzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgncmVtb3ZlZElkIG9ubHksIG5vIGZhdWx0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY2FyMSA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIyID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiAnYmx1ZScsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2NhcjEsIGNhcjJdO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2NhcnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TcGxpY2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRJZDogW2NhcjEuX2lkXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogcGVyc29uLl9pZFxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHBlcnNvbi5jYXJzUHJveHk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5faWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocHJveHkuX2lkLCBjYXIyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5yZWxhdGVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHByb3h5LnJlbGF0ZWQsIGNhcjIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmNhcnMubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdyZW1vdmVkSWQgb25seSwgZmF1bHQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb24gPSBwZXJzb25NYXBwaW5nLl9uZXcoe25hbWU6ICdNaWNoYWVsIEZvcmQnLCBhZ2U6IDIzfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIxID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjIgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdibHVlJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyMSwgY2FyMl07XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNwbGljZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZElkOiBbY2FyMS5faWRdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBwZXJzb24uX2lkXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBwZXJzb24uY2Fyc1Byb3h5O1xuLy8gICAgICAgICAgICAgICAgICAgICBwcm94eS5yZWxhdGVkID0gbnVsbDtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5faWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocHJveHkuX2lkLCBjYXIyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhwcm94eS5pc0ZhdWx0KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdhZGRlZCBvbmx5JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uID0gcGVyc29uTWFwcGluZy5fbmV3KHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyM30pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY2FyMSA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIyID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiAnYmx1ZScsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIzID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiAncHVycGxlJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyMSwgY2FyMl07XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gbmV3IENoYW5nZSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNwbGljZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiAwLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQ6IFtjYXIzXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogcGVyc29uLl9pZFxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgYy5hcHBseVNpZXN0YU1vZGVsKHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHBlcnNvbi5jYXJzUHJveHk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5faWQubGVuZ3RoLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocHJveHkuX2lkLCBjYXIzLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwcm94eS5yZWxhdGVkLmxlbmd0aCwgMyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHByb3h5LnJlbGF0ZWQsIGNhcjMpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLmNhcnMubGVuZ3RoLCAzKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ2FkZGVkSWQgb25seSwgbm8gZmF1bHQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb24gPSBwZXJzb25NYXBwaW5nLl9uZXcoe25hbWU6ICdNaWNoYWVsIEZvcmQnLCBhZ2U6IDIzfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXIxID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXJzOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjIgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdibHVlJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjMgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdwdXJwbGUnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb24uY2FycyA9IFtjYXIxLCBjYXIyXTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBuZXcgQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENoYW5nZVR5cGUuU3BsaWNlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IDAsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZElkOiBbY2FyMy5faWRdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgX2lkOiBwZXJzb24uX2lkXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjLmFwcGx5U2llc3RhTW9kZWwocGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gcGVyc29uLmNhcnNQcm94eTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHByb3h5Ll9pZC5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwcm94eS5faWQsIGNhcjMuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHByb3h5LnJlbGF0ZWQubGVuZ3RoLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocHJveHkucmVsYXRlZCwgY2FyMyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb24uY2Fycy5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG5cbi8vICAgICAgICAgICAgICAgICBpdCgnYWRkZWRJZCBvbmx5LCBmYXVsdCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbiA9IHBlcnNvbk1hcHBpbmcuX25ldyh7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjN9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcjEgPSBjYXJNYXBwaW5nLl9uZXcoe2NvbG91cnM6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY2FyMiA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ2JsdWUnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgY2FyMyA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyczogJ3B1cnBsZScsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2NhcjEsIGNhcjJdO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbixcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2NhcnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2hhbmdlVHlwZS5TcGxpY2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkSWQ6IFtjYXIzLl9pZF0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IHBlcnNvbi5faWRcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGMuYXBwbHlTaWVzdGFNb2RlbChwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBwZXJzb24uY2Fyc1Byb3h5O1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocHJveHkuX2lkLmxlbmd0aCwgMyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHByb3h5Ll9pZCwgY2FyMy5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2socHJveHkucmVsYXRlZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhwcm94eS5pc0ZhdWx0KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnc2F2ZScsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZywgcGVyc29uTWFwcGluZztcbi8vICAgICAgICAgdmFyIGNhciwgcGVyc29uLCBjYXJDaGFuZ2VzLCBwZXJzb25DaGFuZ2VzO1xuXG4vLyAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuLy8gICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbidcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuLy8gICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnYWdlJywgJ25hbWUnXVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjN9LCBmdW5jdGlvbiAoZXJyLCBfcGVyc29uKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uID0gX3BlcnNvbjtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLCBvd25lcjogcGVyc29ufSwgZnVuY3Rpb24gKGVyciwgX2Nhcikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyID0gX2Nhcjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwubmV4dChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FyQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc2F2ZShkb25lKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgncmVnaXN0ZXJzIGNoYW5nZXMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICBpdCgnZm9yd2FyZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyQ2hhbmdlcy5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgIF8uY2hhaW4oY2FyQ2hhbmdlcykucGx1Y2soJ19pZCcpLmVhY2goZnVuY3Rpb24gKHgpIHthc3NlcnQuZXF1YWwoeCwgY2FyLl9pZCk7fSk7XG4vLyAgICAgICAgICAgICAgICAgXy5jaGFpbihjYXJDaGFuZ2VzKS5wbHVjaygnY29sbGVjdGlvbicpLmVhY2goZnVuY3Rpb24gKHgpIHthc3NlcnQuZXF1YWwoeCwgJ215Q29sbGVjdGlvbicpO30pO1xuLy8gICAgICAgICAgICAgICAgIF8uY2hhaW4oY2FyQ2hhbmdlcykucGx1Y2soJ21hcHBpbmcnKS5lYWNoKGZ1bmN0aW9uICh4KSB7YXNzZXJ0LmVxdWFsKHgsICdDYXInKTt9KTtcbi8vICAgICAgICAgICAgICAgICB2YXIgY29sb3VyQ2hhbmdlID0gXy5maW5kV2hlcmUoY2FyQ2hhbmdlcywge2ZpZWxkOiAnY29sb3VyJ30pO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5vayhjb2xvdXJDaGFuZ2UpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjb2xvdXJDaGFuZ2UubmV3LCAncmVkJyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGNvbG91ckNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgIHZhciBuYW1lQ2hhbmdlID0gXy5maW5kV2hlcmUoY2FyQ2hhbmdlcywge2ZpZWxkOiAnbmFtZSd9KTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQub2sobmFtZUNoYW5nZSk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5hbWVDaGFuZ2UubmV3LCAnQXN0b24gTWFydGluJyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKG5hbWVDaGFuZ2Uub2xkKTtcbi8vICAgICAgICAgICAgICAgICB2YXIgb3duZXJDaGFuZ2UgPSBfLmZpbmRXaGVyZShjYXJDaGFuZ2VzLCB7ZmllbGQ6ICdvd25lcid9KTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQub2sob3duZXJDaGFuZ2UpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvd25lckNoYW5nZS5uZXcsIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG93bmVyQ2hhbmdlLm5ld0lkLCBwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2sob3duZXJDaGFuZ2Uub2xkKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgncmV2ZXJzZScsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdzYXZlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIGl0KCdzYXZlcyBjaGFuZ2VzJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMubWVyZ2VDaGFuZ2VzKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2socy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMubGVuZ3RoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLmdldChjYXIuX2lkLCBmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jLmNvbG91ciwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkb2MubmFtZSwgJ0FzdG9uIE1hcnRpbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkb2MuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkb2MubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KVxuXG4vLyAgICAgfSk7XG5cbi8vIH0pOyIsIi8vIHZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKVxuLy8gICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuXG4vLyBkZXNjcmliZSgnaW5kZXhlcycsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBzLnJlc2V0KHRydWUpO1xuLy8gICAgIH0pO1xuXG4vLyAgICAgZGVzY3JpYmUoJ0luZGV4JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBpdCgnaW5kZXggbmFtZScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIHZhciBpID0gbmV3IHMuZXh0LnN0b3JhZ2UuSW5kZXgoJ215Q29sbGVjdGlvbicsICdDYXInLCBbJ2NvbG91cicsICduYW1lJ10pO1xuLy8gICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGkuX2dldE5hbWUoKSwgJ215Q29sbGVjdGlvbl9JbmRleF9DYXJfY29sb3VyX25hbWUnKTtcbi8vICAgICAgICAgICAgIGkgPSBuZXcgcy5leHQuc3RvcmFnZS5JbmRleCgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIFsnbmFtZScsICdjb2xvdXInXSk7XG4vLyAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoaS5fZ2V0TmFtZSgpLCAnbXlDb2xsZWN0aW9uX0luZGV4X0Nhcl9jb2xvdXJfbmFtZScpO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgnbWFwIGZ1bmMnLCBmdW5jdGlvbiAoKSB7XG5cblxuXG4vLyAgICAgICAgICAgICBpdCgnbWFwIGZ1bmMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGkgPSBuZXcgcy5leHQuc3RvcmFnZS5JbmRleCgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIFsnY29sb3VyJywgJ25hbWUnXSk7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGVtaXNzaW9ucyA9IFtdO1xuXG4vLyAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZW1pdChpZCwgZG9jKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGVtaXNzaW9ucy5wdXNoKHtpZDogaWQsIGRvYzogZG9jfSk7XG4vLyAgICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgICAgICAgdmFyIHJhd01hcCA9IGkuX2NvbnN0cnVjdE1hcEZ1bmN0aW9uKCk7XG4vLyAgICAgICAgICAgICAgICAgZXZhbCgndmFyIG1hcEZ1bmMgPSAnICsgcmF3TWFwKTtcbi8vICAgICAgICAgICAgICAgICBtYXBGdW5jKHt0eXBlOiAnQ2FyJywgY29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nfSk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKDEsIGVtaXNzaW9ucy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgIHZhciBlbWlzc2lvbiA9IGVtaXNzaW9uc1swXTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZW1pc3Npb24uaWQsICdyZWRfQXN0b24gTWFydGluJylcbi8vICAgICAgICAgICAgIH0pO1xuXG5cblxuLy8gICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgIC8vIENoZWNrIHRoYXQgcXVlcmllcyB1c2luZyB0aGUgcy5leHQuc3RvcmFnZS5pbmRleCB3b3JrIGFzIGV4cGVjdGVkIHdpdGggcy5leHQuc3RvcmFnZS5Qb3VjaERCLlxuLy8gICAgICAgICBpdCgncG91Y2hkYiBzLmV4dC5zdG9yYWdlLmluZGV4JywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgIHZhciBpID0gbmV3IHMuZXh0LnN0b3JhZ2UuSW5kZXgoJ215Q29sbGVjdGlvbicsICdDYXInLCBbJ2NvbG91cicsICduYW1lJ10pO1xuLy8gICAgICAgICAgICAgdmFyIHZpZXcgPSBpLl9jb25zdHJ1Y3RQb3VjaERiVmlldygpO1xuLy8gICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnB1dCh2aWV3LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wb3N0KHt0eXBlOiAnQ2FyJywgY29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nfSwgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5xdWVyeShpLl9nZXROYW1lKCksIHtrZXk6ICdyZWRfQXN0b24gTWFydGluJ30sIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXNwLnRvdGFsX3Jvd3MsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnaW5zdGFsbGF0aW9uJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgIHZhciBpID0gbmV3IHMuZXh0LnN0b3JhZ2UuSW5kZXgoJ215Q29sbGVjdGlvbicsICdDYXInLCBbJ2NvbG91cicsICduYW1lJ10pO1xuLy8gICAgICAgICAgICAgaS5pbnN0YWxsKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocy5leHQuc3RvcmFnZS5JbmRleC5pbmRleGVzLCBpKTtcbi8vICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkuZ2V0KCdfZGVzaWduLycgKyBpLl9nZXROYW1lKCksIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhkb2MpO1xuLy8gICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSlcbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdJbmRleGVzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBpdCgnZmllbGQgY29tYmluYXRpb25zJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgdmFyIGNvbWJpbmF0aW9ucyA9IHMuZXh0LnN0b3JhZ2UuaW5kZXguX2dldEZpZWxkQ29tYmluYXRpb25zKFsnZmllbGQxJywgJ2ZpZWxkMicsICdmaWVsZDMnXSk7XG4vLyAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoOCwgY29tYmluYXRpb25zLmxlbmd0aCk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGl0KCdpbmRleGVzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBzLmV4dC5zdG9yYWdlLmluZGV4Ll9jb25zdHJ1Y3RJbmRleGVzKCdteUNvbGxlY3Rpb24nLCAnQ2FyJywgWydmaWVsZDEnLCAnZmllbGQyJywgJ2ZpZWxkMyddKTtcbi8vICAgICAgICAgICAgIGFzc2VydC5lcXVhbCg4LCBpbmRleGVzLmxlbmd0aCk7XG4vLyAgICAgICAgICAgICBfLmVhY2goaW5kZXhlcywgZnVuY3Rpb24gKGkpIHthc3NlcnQub2soaS5pbnN0YWxsKX0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnYnVsayBpbnN0YWxsYXRpb24nLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5pbmRleC5pbnN0YWxsSW5kZXhlcygnbXlDb2xsZWN0aW9uJywgJ0NhcicsIFsnZmllbGQxJywgJ2ZpZWxkMicsICdmaWVsZDMnXSwgZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgYWJsZSB0byBoYW5kbGUgY29uZmxpY3RzLlxuLy8gICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuaW5kZXguaW5zdGFsbEluZGV4ZXMoJ215Q29sbGVjdGlvbicsICdDYXInLCBbJ2ZpZWxkMScsICdmaWVsZDInLCAnZmllbGQzJ10sIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH0pO1xuXG5cbi8vIH0pO1xuXG5cblxuICAgIC8vIGRlc2NyaWJlKCdpbmRleCBpbnN0YWxsYXRpb24nLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyAgICAgaXQoJ2luc3RhbGxhdGlvbicsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgLy8gICAgICAgICB2YXIgbSA9IG5ldyBNYXBwaW5nKHtcbiAgICAvLyAgICAgICAgICAgICB0eXBlOiAnVHlwZScsXG4gICAgLy8gICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgLy8gICAgICAgICAgICAgYXR0cmlidXRlczogWydmaWVsZDEnLCAnZmllbGQyJ10sXG4gICAgLy8gICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbidcbiAgICAvLyAgICAgICAgIH0pO1xuICAgIC8vICAgICAgICAgbS5pbnN0YWxsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAvLyAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgLy8gICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBzLmV4dC5zdG9yYWdlLkluZGV4LmluZGV4ZXM7XG4gICAgLy8gICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGluZGV4ZXMubGVuZ3RoLCAyKTtcbiAgICAvLyAgICAgICAgICAgICBkb25lKCk7XG4gICAgLy8gICAgICAgICB9KTtcbiAgICAvLyAgICAgfSk7XG5cbiAgICAvLyAgICAgaXQoJ25vIGluZGV4ZXMgc3BlY2lmaWVkJywgZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICAgICAgdmFyIG0gPSBuZXcgTWFwcGluZyh7XG4gICAgLy8gICAgICAgICAgICAgdHlwZTogJ1R5cGUnLFxuICAgIC8vICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgIC8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZmllbGQxJywgJ2ZpZWxkMiddLFxuICAgIC8vICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nXG4gICAgLy8gICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgIHZhciBpbmRleGVzID0gbS5nZXRJbmRleGVzVG9JbnN0YWxsKCk7XG4gICAgLy8gICAgICAgICBhc3NlcnQuZXF1YWwoaW5kZXhlcy5sZW5ndGgsIDEpO1xuICAgIC8vICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoaW5kZXhlcywgJ2lkJyk7XG4gICAgLy8gICAgIH0pO1xuXG4gICAgLy8gICAgIGl0KCdpbmRleGVzIHNwZWNpZmllZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgICAgICAgIHZhciBtID0gbmV3IE1hcHBpbmcoe1xuICAgIC8vICAgICAgICAgICAgIHR5cGU6ICdUeXBlJyxcbiAgICAvLyAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAvLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2ZpZWxkMScsICdmaWVsZDInXSxcbiAgICAvLyAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbiAgICAvLyAgICAgICAgICAgICBpbmRleGVzOiBbJ2ZpZWxkMSddXG4gICAgLy8gICAgICAgICB9KTtcbiAgICAvLyAgICAgICAgIHZhciBpbmRleGVzID0gbS5nZXRJbmRleGVzVG9JbnN0YWxsKCk7XG4gICAgLy8gICAgICAgICBhc3NlcnQuZXF1YWwoaW5kZXhlcy5sZW5ndGgsIDIpO1xuICAgIC8vICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoaW5kZXhlcywgJ2lkJyk7XG4gICAgLy8gICAgICAgICBhc3NlcnQuaW5jbHVkZShpbmRleGVzLCAnZmllbGQxJyk7XG4gICAgLy8gICAgIH0pO1xuXG4gICAgLy8gICAgIGl0KCdpbnZhbGlkIGluZGV4ZXMgc3BlY2lmaWVkJywgZnVuY3Rpb24gKCkge1xuICAgIC8vICAgICAgICAgdmFyIG0gPSBuZXcgTWFwcGluZyh7XG4gICAgLy8gICAgICAgICAgICAgdHlwZTogJ1R5cGUnLFxuICAgIC8vICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgIC8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnZmllbGQxJywgJ2ZpZWxkMiddLFxuICAgIC8vICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLFxuICAgIC8vICAgICAgICAgICAgIGluZGV4ZXM6IFsnZmdkb2ZnbmRmb2cnXVxuICAgIC8vICAgICAgICAgfSk7XG4gICAgLy8gICAgICAgICB2YXIgaW5kZXhlcyA9IG0uZ2V0SW5kZXhlc1RvSW5zdGFsbCgpO1xuICAgIC8vICAgICAgICAgYXNzZXJ0LmVxdWFsKGluZGV4ZXMubGVuZ3RoLCAxKTtcbiAgICAvLyAgICAgICAgIGFzc2VydC5pbmNsdWRlKGluZGV4ZXMsICdpZCcpO1xuICAgIC8vICAgICB9KTtcblxuICAgIC8vIH0pOyIsIi8vIC8qKlxuLy8gICogQW4gaW50ZWdyYXRpb24gdGVzdCB0aGF0IGNyZWF0ZXMgdHdvIGNvbXBsZXggY29sbGVjdGlvbnMgYW5kIHRoZW4gZXN0YWJsaXNoZXMgaW50ZXItY29sbGVjdGlvbiByZWxhdGlvbnNoaXBzXG4vLyAgKiBiZXR3ZWVuIHRoZSBtYXBwaW5ncyBpbiBlYWNoIGJlZm9yZSBjcmVhdGluZyBvYmplY3RzIGV0Yy5cbi8vICAqXG4vLyAgKiBXZSB0aGVuIHByb2NlZWQgdG8gdGVzdCB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHN5c3RlbS5cbi8vICAqL1xuXG4vLyB2YXIgcyA9IHJlcXVpcmUoJy4uLy4uL2luZGV4Jylcbi8vICAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbi8vIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuLy8gdmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi8uLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcbi8vIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jYWNoZScpO1xuXG4vLyB2YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xuXG4vLyBkZXNjcmliZSgnaW50ZXJjb2xsZWN0aW9uIHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgdmFyIG15T2ZmbGluZUNvbGxlY3Rpb247XG4vLyAgICAgdmFyIG15T25saW5lQ29sbGVjdGlvbjtcblxuLy8gICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICAgICAgdmFyIGZpbmlzaGVkQ3JlYXRpbmdNeU9mZmxpbmVDb2xsZWN0aW9uID0gZmFsc2U7XG5cbi8vICAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdNeU9mZmxpbmVDb2xsZWN0aW9uJyk7XG5cbi8vICAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbi5tYXBwaW5nKCdGb2xkZXInLCB7XG4vLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnXSxcbi8vICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICBjcmVhdGVkQnk6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1VzZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2ZvbGRlcnMnXG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBteU9mZmxpbmVDb2xsZWN0aW9uLm1hcHBpbmcoJ0Rvd25sb2FkZWRQaG90bycsIHtcbi8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY3JlYXRpb25EYXRlJ10sXG4vLyAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgY3JlYXRlZEJ5OiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdVc2VyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdmaWxlcydcbi8vICAgICAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgICAgIGZvbGRlcjoge1xuLy8gICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnRm9sZGVyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdmaWxlcydcbi8vICAgICAgICAgICAgICAgICB9LFxuLy8gICAgICAgICAgICAgICAgIHBob3RvOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdNeU9ubGluZUNvbGxlY3Rpb24uUGhvdG8nLFxuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvT25lLFxuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnZmlsZSdcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIG15T2ZmbGluZUNvbGxlY3Rpb24ubWFwcGluZygnVXNlcicsIHtcbi8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsndXNlcm5hbWUnXSxcbi8vICAgICAgICAgICAgIGluZGV4ZXM6IFsndXNlcm5hbWUnXVxuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBteU9mZmxpbmVDb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgZmluaXNoZWRDcmVhdGluZ015T2ZmbGluZUNvbGxlY3Rpb24gPSB0cnVlO1xuLy8gICAgICAgICAgICAgaWYgKGZpbmlzaGVkQ3JlYXRpbmdNeU9ubGluZUNvbGxlY3Rpb24pIHtcbi8vICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIHZhciBmaW5pc2hlZENyZWF0aW5nTXlPbmxpbmVDb2xsZWN0aW9uID0gZmFsc2U7XG5cbi8vICAgICAgICAgbXlPbmxpbmVDb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ015T25saW5lQ29sbGVjdGlvbicpO1xuXG4vLyAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5tYXBwaW5nKCdQaG90bycsIHtcbi8vICAgICAgICAgICAgIGlkOiAncGhvdG9JZCcsXG4vLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2hlaWdodCcsICd3aWR0aCcsICd1cmwnXSxcbi8vICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICBjcmVhdGVkQnk6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1VzZXInLFxuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ3Bob3Rvcydcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5tYXBwaW5nKCdVc2VyJywge1xuLy8gICAgICAgICAgICAgaWQ6ICd1c2VySWQnLFxuLy8gICAgICAgICAgICAgYXR0cmlidXRlczogWyd1c2VybmFtZScsICduYW1lJ11cbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgbXlPbmxpbmVDb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgaWYgKGZpbmlzaGVkQ3JlYXRpbmdNeU9mZmxpbmVDb2xsZWN0aW9uKSB7XG4vLyAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9KTtcbi8vICAgICB9KTtcblxuLy8gICAgIGZ1bmN0aW9uIG1hcFJlbW90ZVVzZXJzKGNhbGxiYWNrKSB7XG4vLyAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5Vc2VyLm1hcChbXG4vLyAgICAgICAgICAgICB7dXNlcm5hbWU6ICdtdGZvcmQnLCBuYW1lOiAnTWljaGFlbCBGb3JkJywgdXNlcklkOiAnMSd9LFxuLy8gICAgICAgICAgICAge3VzZXJuYW1lOiAnYmxhaGJsYWgnLCBuYW1lOiAnQmxhaCBCbGFoJywgdXNlcklkOiAnMid9LFxuLy8gICAgICAgICAgICAge3VzZXJuYW1lOiAnYm9ibScsIG5hbWU6ICdCb2IgTWFybGV5JywgdXNlcklkOiAnMyd9XG4vLyAgICAgICAgIF0sIGNhbGxiYWNrKTtcbi8vICAgICB9XG5cbi8vICAgICBmdW5jdGlvbiBtYXBSZW1vdGVQaG90b3MoY2FsbGJhY2spIHtcbi8vICAgICAgICAgbXlPbmxpbmVDb2xsZWN0aW9uLlBob3RvLm1hcChbXG4vLyAgICAgICAgICAgICB7aGVpZ2h0OiA1MDAsIHdpZHRoOiA1MDAsIHVybDogJ2h0dHA6Ly9zb21ld2hlcmUvaW1hZ2UuanBlZycsIHBob3RvSWQ6ICcxMCcsIGNyZWF0ZWRCeTogJzEnfSxcbi8vICAgICAgICAgICAgIHtoZWlnaHQ6IDE1MDAsIHdpZHRoOiAxNTAwLCB1cmw6ICdodHRwOi8vc29tZXdoZXJlL2ltYWdlMi5qcGVnJywgcGhvdG9JZDogJzExJywgY3JlYXRlZEJ5OiAnMSd9LFxuLy8gICAgICAgICAgICAge2hlaWdodDogNTAwLCB3aWR0aDogNzUwLCB1cmw6ICdodHRwOi8vc29tZXdoZXJlL2ltYWdlMy5qcGVnJywgcGhvdG9JZDogJzEyJywgY3JlYXRlZEJ5OiAnMid9XG4vLyAgICAgICAgIF0sIGNhbGxiYWNrKTtcbi8vICAgICB9XG5cbi8vICAgICBmdW5jdGlvbiBtYXBPZmZsaW5lVXNlcnMoY2FsbGJhY2spIHtcbi8vICAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbi5Vc2VyLm1hcChbXG4vLyAgICAgICAgICAgICB7dXNlcm5hbWU6ICdtaWtlJ30sXG4vLyAgICAgICAgICAgICB7dXNlcm5hbWU6ICdnYXonfVxuLy8gICAgICAgICBdLCBjYWxsYmFjayk7XG4vLyAgICAgfVxuXG4vLyAgICAgZnVuY3Rpb24gaW5zdGFsbE9mZmxpbmVGaXh0dXJlcyhjYWxsYmFjaykge1xuLy8gICAgICAgICBtYXBPZmZsaW5lVXNlcnMoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgaWYgKCFlcnIpIHtcbi8vICAgICAgICAgICAgICAgICBteU9mZmxpbmVDb2xsZWN0aW9uLnNhdmUoY2FsbGJhY2spO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgfVxuXG4vLyAgICAgZnVuY3Rpb24gaW5zdGFsbE9ubGluZUZpeHR1cmVzKGNhbGxiYWNrKSB7XG4vLyAgICAgICAgIGFzeW5jLnNlcmllcyhbXG4vLyAgICAgICAgICAgICBtYXBSZW1vdGVVc2Vycyxcbi8vICAgICAgICAgICAgIG1hcFJlbW90ZVBob3Rvc1xuLy8gICAgICAgICBdLCBmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICBpZiAoIWVycikge1xuLy8gICAgICAgICAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5zYXZlKGNhbGxiYWNrKTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH1cblxuLy8gICAgIGRlc2NyaWJlKCdjYW4gaW5zdGFsbCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgaXQoJ0NhbiBpbnN0YWxsIG9mZmxpbmUgZml4dHVyZXMnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgaW5zdGFsbE9mZmxpbmVGaXh0dXJlcyhmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnY2FuIGluc3RhbGwgb25saW5lIGZpeHR1cmVzJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgIGluc3RhbGxPbmxpbmVGaXh0dXJlcyhmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhzLmV4dC5zdG9yYWdlLmNoYW5nZXMuYWxsQ2hhbmdlcy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnY2FuIGluc3RhbGwgYm90aCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBpbnN0YWxsT2ZmbGluZUZpeHR1cmVzKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgaW5zdGFsbE9ubGluZUZpeHR1cmVzKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2socy5leHQuc3RvcmFnZS5jaGFuZ2VzLmFsbENoYW5nZXMubGVuZ3RoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pXG4vLyAgICAgfSk7XG5cblxuLy8gICAgIC8qKlxuLy8gICAgICAqIEV4ZWN1dGUgdGhlIGludGVncmF0aW9uIHRlc3QuIFNlcGVyYXRlZCBvdXQgaW50byBhIGZ1bmN0aW9uIHNvIGNhbiBiZSBleGVjdXRlZCBoYXZpbmcgbWFuaXB1bGF0ZWQgcy5leHQuc3RvcmFnZS5Qb3VjaFxuLy8gICAgICAqL1xuLy8gICAgIGZ1bmN0aW9uIHRlc3RzKCkge1xuLy8gICAgICAgICBkZXNjcmliZSgnbG9jYWwgcXVlcmllcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG1pa2Ugd2hlbiBxdWVyeWluZyBmb3IgaGltJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgbXlPZmZsaW5lQ29sbGVjdGlvbi5Vc2VyLnF1ZXJ5KHt1c2VybmFtZTogJ2dheid9LCBmdW5jdGlvbiAoZXJyLCB1c2Vycykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHVzZXJzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwodXNlcnNbMF0udXNlcm5hbWUsICdnYXonKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ29ubGluZScsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDMgdXNlcnMgd2hlbiBydW4gYSBsb2NhbCBhbGwgcXVlcnkgYWdhaW5zdCB1c2VycycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5Vc2VyLmFsbChmdW5jdGlvbiAoZXJyLCB1c2Vycykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHVzZXJzLmxlbmd0aCwgMyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gMyBwaG90b3Mgd2hlbiBydW4gYSBsb2NhbCBhbGwgcXVlcnkgYWdhaW5zdCBwaG90b3MnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uUGhvdG8uYWxsKGZ1bmN0aW9uIChlcnIsIHBob3Rvcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBob3Rvcy5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIDIgcGhvdG9zIHdpdGggaGVpZ2h0IDUwMCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dCgxMDAwMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIG15T25saW5lQ29sbGVjdGlvbi5QaG90by5xdWVyeSh7aGVpZ2h0OiA1MDB9LCBmdW5jdGlvbiAoZXJyLCBwaG90b3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwaG90b3MubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChwaG90b3MsIGZ1bmN0aW9uIChwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHAuaGVpZ2h0LCA1MDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gMSBwaG90byB3aXRoIGhlaWdodCA1MDAsIHdpZHRoLCA3NTAnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXQoMTAwMDApO1xuLy8gICAgICAgICAgICAgICAgICAgICBteU9ubGluZUNvbGxlY3Rpb24uUGhvdG8ucXVlcnkoe2hlaWdodDogNTAwLCB3aWR0aDogNzUwfSwgZnVuY3Rpb24gKGVyciwgcGhvdG9zKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGhvdG9zLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGhvdG9zWzBdLmhlaWdodCwgNTAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwaG90b3NbMF0ud2lkdGgsIDc1MCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBiZSBhYmxlIHRvIHF1ZXJ5IGJ5IHJlbW90ZSBpZGVudGlmaWVyJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgbXlPbmxpbmVDb2xsZWN0aW9uLlVzZXIuZ2V0KCcxJywgZnVuY3Rpb24gKGVyciwgdXNlcikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHVzZXIudXNlcklkLCAnMScpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgICAgIH0pXG5cblxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBkZXNjcmliZSgncmVsYXRpb25zaGlwIG1hcHBpbmdzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ29ubGluZScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBmdW5jdGlvbiBhc3NlcnROdW1QaG90b3ModXNlcklkLCBudW1QaG90b3MsIGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgbXlPbmxpbmVDb2xsZWN0aW9uLlVzZXIuZ2V0KHVzZXJJZCwgZnVuY3Rpb24gKGVyciwgdXNlcikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHVzZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHVzZXIudXNlcklkLCB1c2VySWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gdXNlci5waG90b3NQcm94eTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5LmdldChmdW5jdGlvbiAoZXJyLCBwaG90b3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBob3RvcyA/IHBob3Rvcy5sZW5ndGggOiAwLCBudW1QaG90b3MpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICAgICAgIGl0KCd1c2VyIHdpdGggaWQgMSBzaG91bGQgaGF2ZSAyIHBob3RvcycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydE51bVBob3RvcygnMScsIDIsIGRvbmUpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3VzZXIgd2l0aCBpZCAyIHNob3VsZCBoYXZlIDEgcGhvdG8uLi4nLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnROdW1QaG90b3MoJzInLCAxLCBkb25lKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCd1c2VyIHdpdGggaWQgMyBzaG91bGQgaGF2ZSBubyBwaG90b3MnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnROdW1QaG90b3MoJzMnLCAwLCBkb25lKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgfSk7XG4vLyAgICAgfVxuXG4vLyAgICAgZGVzY3JpYmUoJ25vIGNhY2hlJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBpbnN0YWxsT2ZmbGluZUZpeHR1cmVzKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgaW5zdGFsbE9ubGluZUZpeHR1cmVzKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHRlc3RzKCk7XG4vLyAgICAgfSk7XG5cbi8vIC8vICAgIGRlc2NyaWJlKCdjYWNoZWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAvLyAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gLy8gICAgICAgICAgICBpbnN0YWxsT2ZmbGluZUZpeHR1cmVzKGZ1bmN0aW9uIChlcnIpIHtcbi8vIC8vICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vIC8vICAgICAgICAgICAgICAgIGluc3RhbGxPbmxpbmVGaXh0dXJlcyhkb25lKTtcbi8vIC8vICAgICAgICAgICAgfSk7XG4vLyAvLyAgICAgICAgfSk7XG4vLyAvLyAgICAgICAgdGVzdHMoKTtcbi8vIC8vICAgIH0pO1xuXG5cbi8vIH0pOyIsIi8vIHZhciBzID0gcmVxdWlyZSgnLi4vLi4vaW5kZXgnKVxuLy8gICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuLy8gZGVzY3JpYmUoJ3BlcmZvcm0gbWFwcGluZycsIGZ1bmN0aW9uICgpIHtcblxuXG4vLyAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi8uLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4vLyAgICAgdmFyIFJlbGF0aW9uc2hpcFR5cGUgPSByZXF1aXJlKCcuLi8uLi9zcmMvcmVsYXRpb25zaGlwJykuUmVsYXRpb25zaGlwVHlwZTtcblxuLy8gICAgIHZhciBTaWVzdGFNb2RlbCA9IHJlcXVpcmUoJy4uLy4uL3NyYy9vYmplY3QnKS5TaWVzdGFNb2RlbDtcbi8vICAgICB2YXIgY2FjaGUgPSByZXF1aXJlKCcuLi8uLi9zcmMvY2FjaGUnKTtcbi8vICAgICB2YXIgT3BlcmF0aW9uID0gcmVxdWlyZSgnLi4vLi4vdmVuZG9yL29wZXJhdGlvbnMuanMvc3JjL29wZXJhdGlvbicpLk9wZXJhdGlvbjtcblxuLy8gICAgIHZhciBjb2xsZWN0aW9uLCBjYXJNYXBwaW5nLCBwZXJzb25NYXBwaW5nO1xuXG4vLyAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIGNvbGxlY3Rpb24gPSBudWxsO1xuLy8gICAgICAgICBjYXJNYXBwaW5nID0gbnVsbDtcbi8vICAgICAgICAgcGVyc29uTWFwcGluZyA9IG51bGw7XG4vLyAgICAgICAgIHMucmVzZXQodHJ1ZSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICBhZnRlckVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICB2YXIgbnVtSW5jb21wbGV0ZSA9IDA7XG4vLyAgICAgICAgIF8uZWFjaChPcGVyYXRpb24ucnVubmluZywgZnVuY3Rpb24gKG9wKSB7XG4vLyAgICAgICAgICAgICBpZiAoIW9wLmNvbXBsZXRlZCkge1xuLy8gICAgICAgICAgICAgICAgIG51bUluY29tcGxldGUrKztcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIGFzc2VydC5ub3RPayhudW1JbmNvbXBsZXRlKTtcbi8vICAgICB9KTtcblxuXG4vLyAgICAgZGVzY3JpYmUoJ25vIHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIHZhciBvYmo7XG5cbi8vICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLCBpZDogJ2RmYWRmJ30sIGZ1bmN0aW9uIChlcnIsIF9vYmopIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIG9iaiA9IF9vYmo7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgnZXhpc3RpbmcgaW4gcG91Y2gnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCd2aWEgaWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIG5ld09iajtcbi8vICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB7X2lkOiAnbG9jYWxJZCcsIHR5cGU6ICdDYXInLCBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgY29sb3VyOiAncmVkJywgaWQ6ICdyZW1vdGVJZCd9O1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucHV0KGRvYywgZnVuY3Rpb24gKGVyciwgZG9jKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcCh7Y29sb3VyOiAnYmx1ZScsIGlkOiAncmVtb3RlSWQnfSwgZnVuY3Rpb24gKGVyciwgb2JqKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iaiA9IG9iajtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgYmUgbWFwcGVkIG9udG8gdGhlIG9sZCBvYmplY3QnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuZXdPYmouX2lkLCAnbG9jYWxJZCcpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBoYXZlIHRoZSBuZXcgY29sb3VyJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobmV3T2JqLmNvbG91ciwgJ2JsdWUnKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCd2aWEgX2lkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIHZhciBuZXdPYmo7XG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0ge19pZDogJ2xvY2FsSWQnLCB0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ3JlZCcsIGlkOiAncmVtb3RlSWQnfTtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnB1dChkb2MsIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe2NvbG91cjogJ2JsdWUnLCBfaWQ6ICdsb2NhbElkJ30sIGZ1bmN0aW9uIChlcnIsIG9iaikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iaiA9IG9iajtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIGJlIG1hcHBlZCBvbnRvIHRoZSBvbGQgb2JqZWN0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobmV3T2JqLl9pZCwgJ2xvY2FsSWQnKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSB0aGUgbmV3IGNvbG91cicsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG5ld09iai5jb2xvdXIsICdibHVlJyk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgaXQoJ29iaiByZW1vdmVkIGZyb20gY2FjaGUgc2hvdWxkIG5vdCBoYXZlIHRoZSBuZXcgY29sb3VyJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90RXF1YWwob2JqLmNvbG91ciwgJ2JsdWUnKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuXG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnd2l0aCByZWxhdGlvbnNoaXAnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgZGVzY3JpYmUoJ2ZvcmVpZ24ga2V5JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuLy8gICAgICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdmYXVsdGVkIHJlbGF0aW9uc2hpcCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgcGVyc29uLCBjYXI7XG5cbi8vICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBkb2MgPSB7bmFtZTogJ01pY2hhZWwgRm9yZCcsIGFnZTogMjMsIGlkOiAncGVyc29uUmVtb3RlSWQnLCBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgdHlwZTogJ1BlcnNvbicsIF9pZDogJ3BlcnNvbkxvY2FsSWQnfTtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnB1dChkb2MsIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKHtuYW1lOiAnQmVudGxleScsIGNvbG91cjogJ2JsYWNrJywgb3duZXI6ICdwZXJzb25SZW1vdGVJZCcsIGlkOiAnY2FyUmVtb3RlSWQnfSwgZnVuY3Rpb24gKGVyciwgX2Nhcikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIgPSBfY2FyO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbiA9IGNhci5vd25lcjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBtYXBwZWQgb250byBNaWNoYWVsJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLm5hbWUsICdNaWNoYWVsIEZvcmQnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbi5hZ2UsIDIzKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgfSk7XG5cblxuLy8gICAgIH0pO1xuXG5cbiAgXG4vLyAgICAgZGVzY3JpYmUoJ2J1bGsnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIGRlc2NyaWJlKCduZXcnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnbm8gcmVsYXRpb25zaGlwcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnYWxsIHZhbGlkJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIHJhdyA9IFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJywgaWQ6ICdyZW1vdGVJZDFzZGZzZGZkc2Znc2RmJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAnYmx1ZScsIG5hbWU6ICdMYW1ibycsIGlkOiBcInJlbW90ZUlkMmRmZ2RmZ2RmZ1wifSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdncmVlbicsIG5hbWU6ICdGb3JkJywgaWQ6IFwicmVtb3RlSWQzZGZnZGZnZGZnZGZnXCJ9XG4vLyAgICAgICAgICAgICAgICAgICAgIF07XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbiAoZXJyLCBvYmpzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIHJhdy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianNbMF0uY29sb3VyLCAncmVkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqc1sxXS5jb2xvdXIsICdibHVlJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqc1syXS5jb2xvdXIsICdncmVlbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnZm9yZWlnbiBrZXknLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbk1hcHBpbmc7XG5cbi8vICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcjoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzYW1lIG93bmVyIHVzaW5nIF9tYXBCdWxrJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIG93bmVySWQgPSAnb3duZXJJZDQ2MjM0NTM0NSc7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciByYXcgPSBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbicsIGlkOiAncmVtb3RlSWQxJywgb3duZXI6IG93bmVySWR9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2JsdWUnLCBuYW1lOiAnTGFtYm8nLCBpZDogXCJyZW1vdGVJZDJcIiwgb3duZXI6IG93bmVySWR9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2dyZWVuJywgbmFtZTogJ0ZvcmQnLCBpZDogXCJyZW1vdGVJZDNcIiwgb3duZXI6IG93bmVySWR9XG4vLyAgICAgICAgICAgICAgICAgICAgIF07XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbiAoZXJyLCBvYmpzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2Jqcy5sZW5ndGgsIHJhdy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianNbMF0ub3duZXIsIG9ianNbMV0ub3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianNbMV0ub3duZXIsIG9ianNbMl0ub3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3NhbWUgb3duZXIgdXNpbmcgbWFwJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIG93bmVySWQgPSAnb3duZXJJZCEhITMzNCc7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXJSYXcxID0ge2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLCBpZDogJ3JlbW90ZUlkMScsIG93bmVyOiBvd25lcklkfTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhclJhdzIgPSB7Y29sb3VyOiAnYmx1ZScsIG5hbWU6ICdMYW1ibycsIGlkOiBcInJlbW90ZUlkMlwiLCBvd25lcjogb3duZXJJZH07XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcubWFwKGNhclJhdzEsIGZ1bmN0aW9uIChlcnIsIGNhcjEpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLm1hcChjYXJSYXcyLCBmdW5jdGlvbiAoZXJyLCBjYXIyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcjEub3duZXIsIGNhcjIub3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdmYXVsdGVkIHJlbGF0aW9uc2hpcHMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICB2YXIgY2FycztcblxuLy8gICAgICAgICAgICAgdmFyIHBlcnNvbk1hcHBpbmc7XG5cbi8vICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbi8vICAgICAgICAgICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnY2Fycydcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbi8vICAgICAgICAgICAgIH0pO1xuXG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCd2aWEgcmVtb3RlIGlkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe25hbWU6ICdNaWNoYWVsIEZvcmQnLCBhZ2U6IDIzLCBpZDogJ3BlcnNvblJlbW90ZUlkJ30sIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0gW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJywgaWQ6ICdyZW1vdGVJZDEnLCBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2JsdWUnLCBuYW1lOiAnTGFtYm8nLCBpZDogXCJyZW1vdGVJZDJcIiwgb3duZXI6ICdwZXJzb25SZW1vdGVJZCd9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdncmVlbicsIG5hbWU6ICdGb3JkJywgaWQ6IFwicmVtb3RlSWQzXCIsIG93bmVyOiAncGVyc29uUmVtb3RlSWQnfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbiAoZXJyLCBvYmpzLCByZXMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FycyA9IG9ianM7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIGhhdmUgbWFwcGVkIG9udG8gTWljaGFlbCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMF0ub3duZXIsIGNhcnNbMV0ub3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fyc1sxXS5vd25lciwgY2Fyc1syXS5vd25lcik7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIH0pO1xuXG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdidWxrIGJ1bGsnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjYXJzID0gW107XG4vLyAgICAgICAgICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcubWFwKHtuYW1lOiAnTWljaGFlbCBGb3JkJywgYWdlOiAyMywgaWQ6ICdwZXJzb25SZW1vdGVJZCd9LCBmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhdzEgPSBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLCBpZDogJ3JlbW90ZUlkMScsIG93bmVyOiAncGVyc29uUmVtb3RlSWQnfSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAnYmx1ZScsIG5hbWU6ICdMYW1ibycsIGlkOiBcInJlbW90ZUlkMlwiLCBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2dyZWVuJywgbmFtZTogJ0ZvcmQnLCBpZDogXCJyZW1vdGVJZDNcIiwgb3duZXI6ICdwZXJzb25SZW1vdGVJZCd9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcxLCBmdW5jdGlvbiAoZXJyLCBvYmpzLCByZXMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKG9ianMsIGZ1bmN0aW9uIChvKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMucHVzaChvKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fycy5sZW5ndGggPT0gOSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3MiA9IFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAncmVkJywgbmFtZTogJ1BlYXVnZXQnLCBpZDogJ3JlbW90ZUlkNCcsIG93bmVyOiAncGVyc29uUmVtb3RlSWQnfSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAnYmx1ZScsIG5hbWU6ICdDaGV2eScsIGlkOiBcInJlbW90ZUlkNVwiLCBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2dyZWVuJywgbmFtZTogJ0ZvcmQnLCBpZDogXCJyZW1vdGVJZDZcIiwgb3duZXI6ICdwZXJzb25SZW1vdGVJZCd9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5fbWFwQnVsayhyYXcyLCBmdW5jdGlvbiAoZXJyLCBvYmpzLCByZXMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKG9ianMsIGZ1bmN0aW9uIChvKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMucHVzaChvKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fycy5sZW5ndGggPT0gOSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3MyA9IFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAncmVkJywgbmFtZTogJ0ZlcmFycmknLCBpZDogJ3JlbW90ZUlkNycsIG93bmVyOiAncGVyc29uUmVtb3RlSWQnfSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAnYmx1ZScsIG5hbWU6ICdWb2x2bycsIGlkOiBcInJlbW90ZUlkOFwiLCBvd25lcjogJ3BlcnNvblJlbW90ZUlkJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2dyZWVuJywgbmFtZTogJ0RvZGdlJywgaWQ6IFwicmVtb3RlSWQ5XCIsIG93bmVyOiAncGVyc29uUmVtb3RlSWQnfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3MywgZnVuY3Rpb24gKGVyciwgb2JqcywgcmVzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChvYmpzLCBmdW5jdGlvbiAobykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXJzLnB1c2gobyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coY2Fycy5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXJzLmxlbmd0aCA9PSA5KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBtYXBwZWQgb250byBNaWNoYWVsJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fycy5sZW5ndGgsIDkpO1xuLy8gICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbaV0ub3duZXIsIGNhcnNbaSArIDFdLm93bmVyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ3ZpYSBuZXN0ZWQgcmVtb3RlIGlkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe25hbWU6ICdNaWNoYWVsIEZvcmQnLCBhZ2U6IDIzLCBpZDogJ3BlcnNvblJlbW90ZUlkJ30sIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0gW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJywgaWQ6ICdyZW1vdGVJZDEnLCBvd25lcjoge2lkOiAncGVyc29uUmVtb3RlSWQnfX0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2JsdWUnLCBuYW1lOiAnTGFtYm8nLCBpZDogXCJyZW1vdGVJZDJcIiwgb3duZXI6IHtpZDogJ3BlcnNvblJlbW90ZUlkJ319LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdncmVlbicsIG5hbWU6ICdGb3JkJywgaWQ6IFwicmVtb3RlSWQzXCIsIG93bmVyOiB7aWQ6ICdwZXJzb25SZW1vdGVJZCd9fVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhck1hcHBpbmcuX21hcEJ1bGsocmF3LCBmdW5jdGlvbiAoZXJyLCBvYmpzLCByZXMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FycyA9IG9ianM7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnc2hvdWxkIGhhdmUgbWFwcGVkIG9udG8gTWljaGFlbCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnMubGVuZ3RoLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMF0ub3duZXIsIGNhcnNbMV0ub3duZXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fyc1sxXS5vd25lciwgY2Fyc1syXS5vd25lcik7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBkZXNjcmliZSgndmlhIG5lc3RlZCByZW1vdGUgaWQgd2l0aCB1bm1lcmdlZENoYW5nZXMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0KDUwMDApO1xuLy8gICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5tYXAoe25hbWU6ICdNaWNoYWVsIEZvcmQnLCBhZ2U6IDIzLCBpZDogJ3BlcnNvblJlbW90ZUlkJ30sIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmF3ID0gW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJywgaWQ6ICdyZW1vdGVJZDEnLCBvd25lcjoge2lkOiAncGVyc29uUmVtb3RlSWQnfX0sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NvbG91cjogJ2JsdWUnLCBuYW1lOiAnTGFtYm8nLCBpZDogXCJyZW1vdGVJZDJcIiwgb3duZXI6IHtpZDogJ3BlcnNvblJlbW90ZUlkJywgbmFtZTogJ0JvYid9fSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y29sb3VyOiAnZ3JlZW4nLCBuYW1lOiAnRm9yZCcsIGlkOiBcInJlbW90ZUlkM1wiLCBvd25lcjoge2lkOiAncGVyc29uUmVtb3RlSWQnfX1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjYXJNYXBwaW5nLl9tYXBCdWxrKHJhdywgZnVuY3Rpb24gKGVyciwgb2JqcywgcmVzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBvYmpzO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3Nob3VsZCBoYXZlIG1hcHBlZCBvbnRvIE1pY2hhZWwnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzWzBdLm93bmVyLCBjYXJzWzFdLm93bmVyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMV0ub3duZXIsIGNhcnNbMl0ub3duZXIpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGl0KCdzaG91bGQgaGF2ZSBjaGFuZ2VkIHRoZSBuYW1lJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fyc1swXS5vd25lci5uYW1lLCAnQm9iJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzWzFdLm93bmVyLm5hbWUsICdCb2InKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhcnNbMl0ub3duZXIubmFtZSwgJ0JvYicpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICB9KVxuXG4vLyAgICAgICAgIH0pO1xuXG5cbi8vICAgICB9KTtcbi8vIH0pOyIsIi8vIHZhciBzID0gcmVxdWlyZSgnLi4vLi4vaW5kZXgnKSxcbi8vICAgICBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG4vLyBkZXNjcmliZSgncGVyZm9ybWFuY2UnLCBmdW5jdGlvbigpIHtcblxuLy8gICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuLy8gICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jYWNoZScpO1xuLy8gICAgIHZhciBjb2xsZWN0aW9uO1xuLy8gICAgIHZhciBSZXBvLCBVc2VyLCBGb3JrLCBGb2xsb3c7XG5cbi8vICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdNeUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgY29sbGVjdGlvbi5iYXNlVVJMID0gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20nO1xuLy8gICAgICAgICBSZXBvID0gY29sbGVjdGlvbi5tYXBwaW5nKCdSZXBvJywge1xuLy8gICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnZnVsbF9uYW1lJywgJ2Rlc2NyaXB0aW9uJywgJ2h0bWxfdXJsJywgJ3dhdGNoZXJzX2NvdW50JywgJ3N0YXJnYXplcnNfY291bnQnLCAnZm9ya3MnXSxcbi8vICAgICAgICAgICAgIHJlbGF0aW9uc2hpcHM6IHtcbi8vICAgICAgICAgICAgICAgICBvd25lcjoge1xuLy8gICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnVXNlcicsXG4vLyAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPbmVUb01hbnknLFxuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAncmVwb3NpdG9yaWVzJ1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIEZvcmsgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0ZvcmsnLCB7XG4vLyAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgc291cmNlOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdSZXBvJyxcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09uZVRvTWFueScsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdmb3JrZWRfdG8nXG4vLyAgICAgICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgICAgICBmb3JrOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdSZXBvJyxcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09uZVRvT25lJyxcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2ZvcmtlZF9mcm9tJ1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIEZvbGxvdyA9IGNvbGxlY3Rpb24ubWFwcGluZygnRm9sbG93Jywge1xuLy8gICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuLy8gICAgICAgICAgICAgICAgIGZvbGxvd2VkOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdVc2VyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ09uZVRvTWFueScsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdmb2xsb3dlcnMnXG4vLyAgICAgICAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAgICAgICBmb2xsb3dlcjoge1xuLy8gICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnVXNlcicsXG4vLyAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdPbmVUb01hbnknLFxuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlOiAnZm9sbG93aW5nJ1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIFVzZXIgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1VzZXInLCB7XG4vLyAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbG9naW4nLCAnYXZhdGFyX3VybCddXG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnZnJlc2ggZGF0YWJhc2UnLCBmdW5jdGlvbigpIHtcblxuLy8gICAgICAgICAvKipcbi8vICAgICAgICAgICogT24gTWlrZSdzIE1hYywgMy40Z2h6IEludGVsIENvcmUgaTUsIDE2Z2IgMTYwME1oeiBERFIzLCBPU1ggMTAuOS4zLCBsb2dnaW5nIGRpc2FibGVkOlxuLy8gICAgICAgICAgKiAgICAtIDExLzkvMjAxNCAxMzoxNjogMi40MTUgc2Vjc1xuLy8gICAgICAgICAgKiAgICAtIDEyLzkvMjAxNCAwODozNjogMS4wODQgc2Vjc1xuLy8gICAgICAgICAgKiAgICAtIDEzLzkvMjAxNCAwODo0NjogMC41MyBzZWNzXG4vLyAgICAgICAgICAqXG4vLyAgICAgICAgICAqIE9uIE1pa2UncyBNYWNCb29rIEFpciwgMS43IEdIeiBJbnRlbCBDb3JlIGk1LCA0IEdCIDEzMzMgTUh6IEREUjMsIE9TWCAxMC4xMCBCZXRhLCBsb2dnaW5nIGRpc2FibGVkOlxuLy8gICAgICAgICAgKiAgICAtIDI2LzkvMjAxNCAxMTo0MjogMC45ODcgc2Vjc1xuLy8gICAgICAgICAgKi9cbi8vICAgICAgICAgaXQoJ3h5eicsIGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgICAgIHRoaXMudGltZW91dCgxMDAwMCk7XG4vLyAgICAgICAgICAgICB2YXIganNvbiA9IHJlcXVpcmUoJy4vcmVwb3MnKS5yZXBvcztcbi8vICAgICAgICAgICAgIFJlcG8ubWFwKGpzb24sIGRvbmUpO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnc3RvcmUnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICB0aGlzLnRpbWVvdXQoMTAwMDApO1xuLy8gICAgICAgICAgICAgdmFyIGpzb24gPSByZXF1aXJlKCcuL3JlcG9zJykucmVwb3M7XG4vLyAgICAgICAgICAgICBSZXBvLm1hcChqc29uLCBmdW5jdGlvbihlcnIsIG9ianMpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgc2llc3RhLnNhdmUoZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FjaGUucmVzZXQoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGlkZW50cyA9IF8ucGx1Y2sob2JqcywgJ2lkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0ge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB7fSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5vdENhY2hlZDogaWRlbnRzXG4vLyAgICAgICAgICAgICAgICAgICAgIH07XG4vLyAgICAgICAgICAgICAgICAgICAgIHNpZXN0YS5leHQuc3RvcmFnZS5zdG9yZS5nZXRNdWx0aXBsZVJlbW90ZUZyb21wb3VjaChSZXBvLCBpZGVudHMsIHJlc3VsdHMsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKDMwLCBPYmplY3Qua2V5cyhyZXN1bHRzLmNhY2hlZCkubGVuZ3RoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhyZXN1bHRzLm5vdENhY2hlZC5sZW5ndGgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBpdCgnZm9yaycsIGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgICAgIHRoaXMudGltZW91dCg4MDAwKTtcbi8vICAgICAgICAgICAgIHZhciByZXBvcyA9IHJlcXVpcmUoJy4vcmVwb3MnKS5yZXBvcztcbi8vICAgICAgICAgICAgIFJlcG8ubWFwKHJlcG9zLCBmdW5jdGlvbihlcnIsIG9ianMpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGZvcmtzID0gcmVxdWlyZSgnLi9yZXBvcycpLmZvcmtzO1xuLy8gICAgICAgICAgICAgICAgIHZhciByYXdGb3JrID0gXy5tYXAoZm9ya3MsIGZ1bmN0aW9uKGYpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvcms6IGYsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IG9ianNbMF0uX2lkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH07XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgRm9yay5tYXAocmF3Rm9yaywgZnVuY3Rpb24oZXJyLCBmb3Jrcykge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmb3Jrcy5sZW5ndGgsIDYpO1xuLy8gICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmtzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9yayA9IGZvcmtzW2ldO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZvcmsuc291cmNlLCBvYmpzWzBdKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgaXQoJ2ZvbGxvdycsIGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgICAgIHRoaXMudGltZW91dCg4MDAwKTtcbi8vICAgICAgICAgICAgIHZhciByZXBvcyA9IHJlcXVpcmUoJy4vcmVwb3MnKS5yZXBvcztcbi8vICAgICAgICAgICAgIFJlcG8ubWFwKHJlcG9zLCBmdW5jdGlvbihlcnIsIG9ianMpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHVzZXIgPSBvYmpzWzBdLm93bmVyO1xuXG4vLyAgICAgICAgICAgICAgICAgRm9sbG93Lm1hcChyZXF1aXJlKCcuL3JlcG9zJykuZm9sbG93cywgZnVuY3Rpb24oZXJyLCBmb2xsb3dlcnMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdwcm94aWVzJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnVXNlcicsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIGl0KCdmb2xsb3dlcnNQcm94eScsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBVc2VyLm1hcCh7aWQ6ICc1J30sIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob2JqWydmb2xsb3dlcnNQcm94eSddKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnZm9sbG93aW5nUHJveHknLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICBVc2VyLm1hcCh7aWQ6ICc1J30sIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob2JqWydmb2xsb3dpbmdQcm94eSddKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuXG4gICAgXG5cbi8vICAgICAgICAgfSk7XG5cblxuLy8gICAgIH0pO1xuXG5cbi8vIH0pOyIsIi8vIHZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKVxuLy8gICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuXG4vLyBkZXNjcmliZSgncG91Y2ggZG9jIGFkYXB0ZXInLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcblxuLy8gICAgIHZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi4vc3JjL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcjtcbi8vICAgICB2YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xuXG4vLyAgICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuLy8gICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL3NyYy9jYWNoZScpO1xuLy8gICAgIHZhciBjb3JlQ2hhbmdlcyA9IHJlcXVpcmUoJy4uL3NyYy9jaGFuZ2VzJyk7XG4vLyAgICAgdmFyIENoYW5nZVR5cGUgPSBjb3JlQ2hhbmdlcy5DaGFuZ2VUeXBlO1xuXG4vLyAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIHMucmVzZXQodHJ1ZSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnZnJvbSBwb3VjaCB0byBzaWVzdGEnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIGRlc2NyaWJlKCduZXcnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdzaW1wbGUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb247XG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlczogWyduYW1lJywgJ2FnZSddXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnYWJzb3JicyBwcm9wZXJ0aWVzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0ge25hbWU6ICdNaWNoYWVsJywgdHlwZTogJ1BlcnNvbicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLCBhZ2U6IDIzLCBfaWQ6ICdyYW5kb21JZCcsIF9yZXY6ICdyYW5kb21SZXYnfTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHMuZXh0LnN0b3JhZ2UuUG91Y2gudG9OZXcoZG9jKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9iai5uYW1lLCAnTWljaGFlbCcpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLmFnZSwgMjMpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQub2sob2JqLmlzU2F2ZWQpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgndG9TaWVzdGEnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uLCBwZXJzb25NYXBwaW5nO1xuXG4vLyAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdNeU9ubGluZUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2FnZScsICduYW1lJ11cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ2V4aXN0aW5nJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgZG9jID0ge25hbWU6ICdNaWNoYWVsJywgYWdlOiAxMiwgX2lkOiAnbG9jYWxJZCcsIGNvbGxlY3Rpb246ICdNeU9ubGluZUNvbGxlY3Rpb24nLCB0eXBlOiAnUGVyc29uJ307XG4vLyAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnB1dChkb2MsIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLlBlcnNvbi5tYXAoe19pZDogJ2xvY2FsSWQnLCBhZ2U6IDIzfSwgZnVuY3Rpb24gKGVyciwgcGVyc29uKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uLl9pZCwgZG9jLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnNhdmUoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkuZ2V0KHBlcnNvbi5faWQsIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpzID0gcy5leHQuc3RvcmFnZS5Qb3VjaC50b1NpZXN0YShbZG9jXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzWzBdLCBwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ25ldycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5QZXJzb24ubWFwKHtuYW1lOiAnTWljaGFlbCcsIGFnZTogMjN9LCBmdW5jdGlvbiAoZXJyLCBwZXJzb24pIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLnNhdmUoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLmdldChwZXJzb24uX2lkLCBmdW5jdGlvbiAoZXJyLCBkb2MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jLl9pZCA9ICdyYW5kb21pZCc7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jLl9yZXYgPSAncmFuZG9tcmV2Jztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2MuaWQgPSAncmFuZG9tcmVtb3RlaWQnO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqcyA9IHMuZXh0LnN0b3JhZ2UuUG91Y2gudG9TaWVzdGEoW2RvY10pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdEVxdWFsKG9ianNbMF0sIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2Yob2Jqc1swXSwgU2llc3RhTW9kZWwpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgnY2FjaGVkJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLlBlcnNvbi5tYXAoe25hbWU6ICdNaWNoYWVsJywgYWdlOiAyMywgaWQ6ICcyJ30sIGZ1bmN0aW9uIChlcnIsIHBlcnNvbikge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkuZ2V0KHBlcnNvbi5faWQsIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqcyA9IHMuZXh0LnN0b3JhZ2UuUG91Y2gudG9TaWVzdGEoW2RvY10pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChvYmpzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG9ianNbMF0sIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2Yob2Jqc1swXSwgU2llc3RhTW9kZWwpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pXG5cblxuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgndmFsaWRhdGlvbicsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIGl0KCdObyBBUEkgZmllbGQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LnRocm93KF8uYmluZChzLmV4dC5zdG9yYWdlLlBvdWNoLl92YWxpZGF0ZSwgcy5leHQuc3RvcmFnZS5Qb3VjaCwge3R5cGU6ICdDYXInfSksIEludGVybmFsU2llc3RhRXJyb3IpO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdObyB0eXBlIGZpZWxkJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC50aHJvdyhfLmJpbmQocy5leHQuc3RvcmFnZS5Qb3VjaC5fdmFsaWRhdGUsIHMuZXh0LnN0b3JhZ2UuUG91Y2gsIHtjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJ30pLCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGl0KCdub24gZXhpc3RlbnQgQVBJJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC50aHJvdyhfLmJpbmQocy5leHQuc3RvcmFnZS5Qb3VjaC5fdmFsaWRhdGUsIHMuZXh0LnN0b3JhZ2UuUG91Y2gsIHtjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgdHlwZTogJ0Nhcid9KSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ25vbiBleGlzdGVudCB0eXBlJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC50aHJvdyhfLmJpbmQocy5leHQuc3RvcmFnZS5Qb3VjaC5fdmFsaWRhdGUsIHMuZXh0LnN0b3JhZ2UuUG91Y2gsIHtjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgdHlwZTogJ0Nhcid9KSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBpdCgndmFsaWQnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddLFxuLy8gICAgICAgICAgICAgICAgICAgICBpbmRleGVzOiBbJ25hbWUnLCAnYWdlJ11cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwaW5nID0gcy5leHQuc3RvcmFnZS5Qb3VjaC5fdmFsaWRhdGUoe25hbWU6ICdNaWNoYWVsJywgdHlwZTogJ1BlcnNvbicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLCBhZ2U6IDIzfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5vayhtYXBwaW5nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgZGVzY3JpYmUoJ2NoYW5nZXMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZztcbi8vICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuXG4vLyAgICAgICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2NvbG91ciddXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuXG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgaXQoJ3BvdWNoIGFkYXB0ZXIgc2hvdWxkIGFwcGx5IHVubWVyZ2VkIHMuZXh0LnN0b3JhZ2UuY2hhbmdlcycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGRvYyA9IHtcbi8vICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDYXInLFxuLy8gICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICBfaWQ6ICdsb2NhbElkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbi8vICAgICAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wdXQoZG9jLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgZG9jLl9yZXYgPSByZXNwLnJldjtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5jaGFuZ2VzLnJlZ2lzdGVyQ2hhbmdlKHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24uX25hbWUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjYXJNYXBwaW5nLnR5cGUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ2NvbG91cicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNldCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogJ2JsdWUnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgb2xkOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogJ2xvY2FsSWQnXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLmNoYW5nZXMucmVnaXN0ZXJDaGFuZ2Uoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogY29sbGVjdGlvbi5fbmFtZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6IGNhck1hcHBpbmcudHlwZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiAnbmFtZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBDaGFuZ2VUeXBlLlNldCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogJ0JlbnRsZXknLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgb2xkOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF9pZDogJ2xvY2FsSWQnXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxzID0gcy5leHQuc3RvcmFnZS5Qb3VjaC50b1NpZXN0YShbZG9jXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChtb2RlbHNbMF0uY29sb3VyLCAnYmx1ZScpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobW9kZWxzWzBdLm5hbWUsICdCZW50bGV5Jyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG5cbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdmcm9tIHNpZXN0YSB0byBwb3VjaCcsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICB2YXIgY29sbGVjdGlvbiwgcGVyc29uTWFwcGluZywgY2FyTWFwcGluZztcblxuLy8gICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgcGVyc29uTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuLy8gICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXSxcbi8vICAgICAgICAgICAgICAgICBpbmRleGVzOiBbJ25hbWUnLCAnYWdlJ11cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdjb2xvdXInXSxcbi8vICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nOiAnUGVyc29uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlbGF0aW9uc2hpcFR5cGUuT25lVG9NYW55LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgaXQoJ3Nob3VsZCBjb252ZXJ0IG9iamVjdHMgd2l0aCBubyByZWxhdGlvbnNoaXBzIHN1Y2Nlc3NmdWxseScsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7bmFtZTogJ01pY2hhZWwnLCBhZ2U6IDIzLCBpZDogJ3h5eid9LCBmdW5jdGlvbiAoZXJyLCBwZXJzb24pIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgdmFyIGFkYXB0ZWQgPSBzLmV4dC5zdG9yYWdlLlBvdWNoLmZyb20ocGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYWRhcHRlZC5uYW1lLCAnTWljaGFlbCcpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhZGFwdGVkLmFnZSwgMjMpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhZGFwdGVkLmlkLCAneHl6Jyk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkYXB0ZWQuX2lkLCBwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYWRhcHRlZC50eXBlLCBwZXJzb24ubWFwcGluZy50eXBlKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYWRhcHRlZC5jb2xsZWN0aW9uLCBwZXJzb24uY29sbGVjdGlvbik7XG4vLyAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGl0KCdzaG91bGQgY29udmVydCBvYmplY3RzIHdpdGggcmVsYXRpb25zaGlwIHN1Y2Nlc3NmdWxseScsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLm1hcCh7bmFtZTogJ01pY2hhZWwnLCBhZ2U6IDIzLCBpZDogJ3h5eid9LCBmdW5jdGlvbiAoZXJyLCBwZXJzb24pIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe25hbWU6ICdBc3RvbiBNYXJ0aW4nLCBpZDogJ3h5ejEyMycsIG93bmVyOiB7X2lkOiBwZXJzb24uX2lkfX0sIGZ1bmN0aW9uIChlcnIsIGNhcikge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBhZGFwdGVkID0gcy5leHQuc3RvcmFnZS5Qb3VjaC5mcm9tKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhZGFwdGVkLm5hbWUsICdBc3RvbiBNYXJ0aW4nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkYXB0ZWQuaWQsICd4eXoxMjMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkYXB0ZWQuX2lkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkYXB0ZWQudHlwZSwgY2FyLm1hcHBpbmcudHlwZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChhZGFwdGVkLmNvbGxlY3Rpb24sIGNhci5jb2xsZWN0aW9uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFkYXB0ZWQub3duZXIsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICB9KTtcblxuXG4vLyAgICAgfSk7XG5cbi8vIH0pOyIsIi8vIHZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKVxuLy8gICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuLy8gZGVzY3JpYmUoJ25ldyBvYmplY3QgcHJveHknLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICB2YXIgUmVsYXRpb25zaGlwUHJveHkgPSByZXF1aXJlKCcuLi9zcmMvcHJveHknKS5SZWxhdGlvbnNoaXBQcm94eTtcbi8vICAgICB2YXIgT25lVG9PbmVQcm94eSA9IHJlcXVpcmUoJy4uL3NyYy9vbmVUb09uZVByb3h5JykuT25lVG9PbmVQcm94eTtcbi8vICAgICB2YXIgT25lVG9NYW55UHJveHkgPSByZXF1aXJlKCcuLi9zcmMvb25lVG9NYW55UHJveHknKS5PbmVUb01hbnlQcm94eTtcbi8vICAgICB2YXIgTWFueVRvTWFueVByb3h5ID0gcmVxdWlyZSgnLi4vc3JjL21hbnlUb01hbnlQcm94eScpLk1hbnlUb01hbnlQcm94eTtcbi8vICAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG4vLyAgICAgdmFyIEZhdWx0ID0gcmVxdWlyZSgnLi4vc3JjL3Byb3h5JykuRmF1bHQ7XG4vLyAgICAgdmFyIEludGVybmFsU2llc3RhRXJyb3IgPSByZXF1aXJlKCcuLi9zcmMvZXJyb3InKS5JbnRlcm5hbFNpZXN0YUVycm9yO1xuLy8gICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuLy8gICAgIHZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL3NyYy9jYWNoZScpO1xuLy8gICAgIHZhciBDaGFuZ2VUeXBlID0gcmVxdWlyZSgnLi4vc3JjL2NoYW5nZXMnKS5DaGFuZ2VUeXBlO1xuXG4vLyAgICAgdmFyIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbi8vICAgICB2YXIgY29sbGVjdGlvbjtcblxuLy8gICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgYXR0cmlidXRlczogWyduYW1lJywgJ2FnZSddXG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZG9uZSk7XG4vLyAgICAgfSk7XG5cbi8vICAgICBkZXNjcmliZSgnZm9yZWlnbiBrZXknLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIHZhciBjYXJQcm94eSwgcGVyc29uUHJveHk7XG4vLyAgICAgICAgIHZhciBjYXIsIHBlcnNvbjtcblxuLy8gICAgICAgICBkZXNjcmliZSgnZ2V0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgY2FyUHJveHkgPSBuZXcgT25lVG9NYW55UHJveHkoe1xuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkgPSBuZXcgT25lVG9NYW55UHJveHkoe1xuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgY2FyID0gbmV3IFNpZXN0YU1vZGVsKGNhck1hcHBpbmcpO1xuLy8gICAgICAgICAgICAgICAgIGNhci5faWQgPSAnY2FyJztcbi8vICAgICAgICAgICAgICAgICBjYXJQcm94eS5pbnN0YWxsKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uID0gbmV3IFNpZXN0YU1vZGVsKHBlcnNvbk1hcHBpbmcpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbi5faWQgPSAncGVyc29uJztcbi8vICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5pbnN0YWxsKHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGNhcik7XG4vLyAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdzZXQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICB2YXIgY2FyUHJveHksIHBlcnNvblByb3h5O1xuLy8gICAgICAgICAgICAgdmFyIGNhciwgcGVyc29uO1xuLy8gICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgY2FyUHJveHkgPSBuZXcgT25lVG9NYW55UHJveHkoe1xuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkgPSBuZXcgT25lVG9NYW55UHJveHkoe1xuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgY2FyID0gbmV3IFNpZXN0YU1vZGVsKGNhck1hcHBpbmcpO1xuLy8gICAgICAgICAgICAgICAgIGNhci5faWQgPSAnY2FyJztcbi8vICAgICAgICAgICAgICAgICBjYXJQcm94eS5pbnN0YWxsKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgY2FyUHJveHkuaXNGYXVsdCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbiA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbi8vICAgICAgICAgICAgICAgICBwZXJzb24uX2lkID0gJ3BlcnNvbic7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaW5zdGFsbChwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvblByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgIH0pO1xuICAgICAgIFxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ3ByZS1leGlzdGluZycsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uLCBhbm90aGVyUGVyc29uUHJveHk7XG5cbi8vICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvbiA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvbi5faWQgPSAnYW5vdGhlclBlcnNvbic7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb25Qcm94eSA9IG5ldyBPbmVUb01hbnlQcm94eSh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXInXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkuaW5zdGFsbChhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvblByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGFub3RoZXJQZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQocGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGNhcik7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgnbm8gZmF1bHQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gYW5vdGhlclBlcnNvbjtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnZ2VuZXJhdGVzIGNvcnJlY3Qgcy5leHQuc3RvcmFnZS5jaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lciA9IHBlcnNvbjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyQ2hhbmdlcy5sZW5ndGgsIDIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2VzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFub3RoZXJQZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYW5vdGhlclBlcnNvbkNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlID0gcGVyc29uQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDYXJDaGFuZ2UgPSBjYXJDaGFuZ2VzWzBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRDYXJDaGFuZ2UgPSBjYXJDaGFuZ2VzWzFdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UgPSBhbm90aGVyUGVyc29uQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZSA9IGFub3RoZXJQZXJzb25DaGFuZ2VzWzFdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuX2lkLCBwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuaW5kZXgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuYWRkZWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25DaGFuZ2UuYWRkZWQsIGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5hZGRlZElkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLmFkZGVkSWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuX2lkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQubGVuZ3RoLCAxLCAnRmlyc3QgY2hhbmdlIGFkZGVkSWQgcG9wdWxhdGVkJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQsIGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5faWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5pbmRleCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQubGVuZ3RoLCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWRJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5faWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UuZmllbGQsICdvd25lcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UubmV3LCBwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UubmV3SWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2Uub2xkLCBhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm9sZElkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5faWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5maWVsZCwgJ293bmVyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLm5ld0lkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLm5ldywgYW5vdGhlclBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGZpcnN0Q2FyQ2hhbmdlLm9sZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGZpcnN0Q2FyQ2hhbmdlLm9sZElkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdiYWNrd2FyZHMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnZ2VuZXJhdGVzIGNvcnJlY3Qgcy5leHQuc3RvcmFnZS5jaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhckNoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIoY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25DaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkNoYW5nZSA9IHBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlID0gYW5vdGhlclBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UgPSBhbm90aGVyUGVyc29uQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLl9pZCwgcGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2socGVyc29uQ2hhbmdlLm9sZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHBlcnNvbkNoYW5nZS5vbGRJZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5uZXcubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm5ld0lkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLm5ld0lkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25DaGFuZ2UubmV3LCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuX2lkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZElkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkSWQubGVuZ3RoLCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQsIGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5tYXBwaW5nLCAnUGVyc29uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuX2lkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuaW5kZXgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWRJZC5sZW5ndGgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWRJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5maWVsZCwgJ293bmVyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5uZXdJZCwgcGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5uZXcsIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5vbGQsIGFub3RoZXJQZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2Uub2xkSWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLmZpZWxkLCAnb3duZXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3LCBhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3SWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZmlyc3RDYXJDaGFuZ2Uub2xkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZmlyc3RDYXJDaGFuZ2Uub2xkSWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgnZmF1bHQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVyID0gYW5vdGhlclBlcnNvbjtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhclByb3h5LnJlbGF0ZWQgPSB1bmRlZmluZWQ7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkucmVsYXRlZCA9IHVuZGVmaW5lZDtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2dlbmVyYXRlcyBjb3JyZWN0IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXIgPSBwZXJzb247XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhckNoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIoY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25DaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkNoYW5nZSA9IHBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlID0gYW5vdGhlclBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UgPSBhbm90aGVyUGVyc29uQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLl9pZCwgcGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmFkZGVkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25DaGFuZ2UuYWRkZWRJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5hZGRlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLl9pZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5pbmRleCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWRJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5faWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLkRlbGV0ZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5faWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UuZmllbGQsICdvd25lcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UubmV3LCBwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIER1ZSB0byB0aGUgZmF1bHQuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHNlY29uZENhckNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UubmV3SWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2Uub2xkSWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLmZpZWxkLCAnb3duZXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3SWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3LCBhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZmlyc3RDYXJDaGFuZ2Uub2xkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdiYWNrd2FyZHMnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGl0KCdnZW5lcmF0ZXMgY29ycmVjdCBzLmV4dC5zdG9yYWdlLmNoYW5nZXMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc29uLmNhcnMgPSBbY2FyXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyQ2hhbmdlcy5sZW5ndGgsIDIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2VzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFub3RoZXJQZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYW5vdGhlclBlcnNvbkNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlID0gcGVyc29uQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDYXJDaGFuZ2UgPSBjYXJDaGFuZ2VzWzBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRDYXJDaGFuZ2UgPSBjYXJDaGFuZ2VzWzFdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UgPSBhbm90aGVyUGVyc29uQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZSA9IGFub3RoZXJQZXJzb25DaGFuZ2VzWzFdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuX2lkLCBwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhwZXJzb25DaGFuZ2Uub2xkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm5ld0lkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLm5ld0lkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm5ldy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5uZXcsIGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5uZXdJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5uZXdJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5tYXBwaW5nLCAnUGVyc29uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5faWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuaW5kZXgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZC5sZW5ndGgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZElkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNwbGljZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5faWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLkRlbGV0ZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5faWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UuZmllbGQsICdvd25lcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UubmV3SWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2Uub2xkSWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm5ldywgcGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEdWUgdG8gZmF1bHQuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHNlY29uZENhckNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuX2lkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuZmllbGQsICdvd25lcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5uZXdJZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5uZXcsIGFub3RoZXJQZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhmaXJzdENhckNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhmaXJzdENhckNoYW5nZS5vbGRJZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG5cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuXG5cbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdtYW55IHRvIG1hbnknLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgIHZhciBjYXJQcm94eSwgcGVyc29uUHJveHk7XG4vLyAgICAgICAgIHZhciBjYXIsIHBlcnNvbjtcblxuLy8gICAgICAgICBkZXNjcmliZSgnZ2V0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgY2FyUHJveHkgPSBuZXcgTWFueVRvTWFueVByb3h5KHtcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVycydcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eSA9IG5ldyBNYW55VG9NYW55UHJveHkoe1xuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwcGluZzogcGVyc29uTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VOYW1lOiAnY2FycycsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmROYW1lOiAnb3duZXJzJ1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIGNhciA9IG5ldyBTaWVzdGFNb2RlbChjYXJNYXBwaW5nKTtcbi8vICAgICAgICAgICAgICAgICBjYXIuX2lkID0gJ2Nhcic7XG4vLyAgICAgICAgICAgICAgICAgY2FyUHJveHkuaW5zdGFsbChjYXIpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbiA9IG5ldyBTaWVzdGFNb2RlbChwZXJzb25NYXBwaW5nKTtcbi8vICAgICAgICAgICAgICAgICBwZXJzb24uX2lkID0gJ3BlcnNvbic7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaW5zdGFsbChwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChjYXIpO1xuLy8gICAgICAgICAgICAgfSk7XG5cblxuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgnc2V0JywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgdmFyIGNhclByb3h5LCBwZXJzb25Qcm94eTtcbi8vICAgICAgICAgICAgIHZhciBjYXIsIHBlcnNvbjtcbi8vICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgIGNhclByb3h5ID0gbmV3IE1hbnlUb01hbnlQcm94eSh7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTWFwcGluZzogY2FyTWFwcGluZyxcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU5hbWU6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcnMnXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkgPSBuZXcgTWFueVRvTWFueVByb3h5KHtcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcHBpbmc6IHBlcnNvbk1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRNYXBwaW5nOiBjYXJNYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICBmb3J3YXJkTmFtZTogJ293bmVycydcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBjYXIgPSBuZXcgU2llc3RhTW9kZWwoY2FyTWFwcGluZyk7XG4vLyAgICAgICAgICAgICAgICAgY2FyLl9pZCA9ICdjYXInO1xuLy8gICAgICAgICAgICAgICAgIGNhclByb3h5Lmluc3RhbGwoY2FyKTtcbi8vICAgICAgICAgICAgICAgICBjYXJQcm94eS5pc0ZhdWx0ID0gZmFsc2U7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uID0gbmV3IFNpZXN0YU1vZGVsKHBlcnNvbk1hcHBpbmcpO1xuLy8gICAgICAgICAgICAgICAgIHBlcnNvbi5faWQgPSAncGVyc29uJztcbi8vICAgICAgICAgICAgICAgICBwZXJzb25Qcm94eS5pbnN0YWxsKHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uUHJveHkuaXNGYXVsdCA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdwcmUtZXhpc3RpbmcnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgICAgICB2YXIgYW5vdGhlclBlcnNvbiwgYW5vdGhlclBlcnNvblByb3h5O1xuXG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb24gPSBuZXcgU2llc3RhTW9kZWwocGVyc29uTWFwcGluZyk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGFub3RoZXJQZXJzb24uX2lkID0gJ2Fub3RoZXJQZXJzb24nO1xuLy8gICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkgPSBuZXcgTWFueVRvTWFueVByb3h5KHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBwaW5nOiBwZXJzb25NYXBwaW5nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE1hcHBpbmc6IGNhck1hcHBpbmcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZTogJ2NhcnMnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9yd2FyZE5hbWU6ICdvd25lcnMnXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkuaW5zdGFsbChhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgYW5vdGhlclBlcnNvblByb3h5LmlzRmF1bHQgPSBmYWxzZTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGFub3RoZXJQZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQocGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KGNhcik7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgnbm8gZmF1bHQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVycyA9IFthbm90aGVyUGVyc29uXTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ2ZvcndhcmQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnZ2VuZXJhdGVzIGNvcnJlY3Qgcy5leHQuc3RvcmFnZS5jaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhci5vd25lcnMgPSBbcGVyc29uXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FyQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FyQ2hhbmdlcy5sZW5ndGgsIDIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2VzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFub3RoZXJQZXJzb25DaGFuZ2VzID0gcy5leHQuc3RvcmFnZS5jaGFuZ2VzLmNoYW5nZXNGb3JJZGVudGlmaWVyKGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoYW5vdGhlclBlcnNvbkNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlID0gcGVyc29uQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDYXJDaGFuZ2UgPSBjYXJDaGFuZ2VzWzBdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWNvbmRDYXJDaGFuZ2UgPSBjYXJDaGFuZ2VzWzFdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UgPSBhbm90aGVyUGVyc29uQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZSA9IGFub3RoZXJQZXJzb25DaGFuZ2VzWzFdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuX2lkLCBwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuaW5kZXgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuYWRkZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5hZGRlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmFkZGVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLmFkZGVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuX2lkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWRJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWQubGVuZ3RoLCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UubWFwcGluZywgJ1BlcnNvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLl9pZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLmZpZWxkLCAnY2FycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5maWVsZCwgJ293bmVycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2Uub2xkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5uZXcubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRDYXJDaGFuZ2UubmV3LCBwZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UubmV3SWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRDYXJDaGFuZ2UubmV3SWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TZXQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuX2lkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuZmllbGQsICdvd25lcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3Lmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RDYXJDaGFuZ2UubmV3LCBhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3SWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdENhckNoYW5nZS5uZXdJZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhmaXJzdENhckNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhmaXJzdENhckNoYW5nZS5vbGRJZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdiYWNrd2FyZHMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnZ2VuZXJhdGVzIGNvcnJlY3Qgcy5leHQuc3RvcmFnZS5jaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhckNoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIoY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25DaGFuZ2VzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkNoYW5nZSA9IHBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlID0gYW5vdGhlclBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5tYXBwaW5nLCAnUGVyc29uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5faWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHBlcnNvbkNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UubmV3Lmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLm5ldywgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm5ld0lkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLm5ld0lkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLl9pZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5pbmRleCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZElkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQsIGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkSWQubGVuZ3RoLCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5maWVsZCwgJ293bmVycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UuaW5kZXgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UudHlwZSwgQ2hhbmdlVHlwZS5TcGxpY2UpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZENhckNoYW5nZS5hZGRlZCwgcGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRDYXJDaGFuZ2UuYWRkZWRJZCwgcGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5faWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5maWVsZCwgJ293bmVycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0Q2FyQ2hhbmdlLm5ldywgYW5vdGhlclBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RDYXJDaGFuZ2UubmV3SWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZmlyc3RDYXJDaGFuZ2Uub2xkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZmlyc3RDYXJDaGFuZ2Uub2xkSWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgnZmF1bHQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyLm93bmVycyA9IFthbm90aGVyUGVyc29uXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhclByb3h5LnJlbGF0ZWQgPSB1bmRlZmluZWQ7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhbm90aGVyUGVyc29uUHJveHkucmVsYXRlZCA9IHVuZGVmaW5lZDtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdmb3J3YXJkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaXQoJ2dlbmVyYXRlcyBjb3JyZWN0IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXIub3duZXJzID0gW3BlcnNvbl07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhckNoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIoY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25DaGFuZ2VzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkNoYW5nZSA9IHBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlID0gYW5vdGhlclBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UgPSBhbm90aGVyUGVyc29uQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLl9pZCwgcGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmluZGV4LCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlLmFkZGVkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShwZXJzb25DaGFuZ2UuYWRkZWRJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5hZGRlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLl9pZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5pbmRleCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZC5sZW5ndGgsIDApO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZElkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmFkZGVkSWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZCwgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLkRlbGV0ZSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5faWQsIGFub3RoZXJQZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5maWVsZCwgJ2NhcnMnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2Vjb25kQW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLCBjYXIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRBbm90aGVyUGVyc29uQ2hhbmdlLnJlbW92ZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZEFub3RoZXJQZXJzb25DaGFuZ2UucmVtb3ZlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5maWVsZCwgJ293bmVycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2Uub2xkSWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm5ld0lkLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoc2Vjb25kQ2FyQ2hhbmdlLm5ldywgcGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRDYXJDaGFuZ2UubmV3SWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubWFwcGluZywgJ0NhcicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5faWQsIGNhci5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5maWVsZCwgJ293bmVycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5uZXcubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UubmV3SWQubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdENhckNoYW5nZS5uZXcsIGFub3RoZXJQZXJzb24pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0Q2FyQ2hhbmdlLm5ld0lkLCBhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGZpcnN0Q2FyQ2hhbmdlLm9sZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGZpcnN0Q2FyQ2hhbmdlLm9sZElkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdiYWNrd2FyZHMnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpdCgnZ2VuZXJhdGVzIGNvcnJlY3Qgcy5leHQuc3RvcmFnZS5jaGFuZ2VzJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNvbi5jYXJzID0gW2Nhcl07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhckNoYW5nZXMgPSBzLmV4dC5zdG9yYWdlLmNoYW5nZXMuY2hhbmdlc0ZvcklkZW50aWZpZXIoY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhckNoYW5nZXMubGVuZ3RoLCAyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocGVyc29uQ2hhbmdlcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbm90aGVyUGVyc29uQ2hhbmdlcyA9IHMuZXh0LnN0b3JhZ2UuY2hhbmdlcy5jaGFuZ2VzRm9ySWRlbnRpZmllcihhbm90aGVyUGVyc29uLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGFub3RoZXJQZXJzb25DaGFuZ2VzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkNoYW5nZSA9IHBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1swXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kQ2FyQ2hhbmdlID0gY2FyQ2hhbmdlc1sxXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlID0gYW5vdGhlclBlcnNvbkNoYW5nZXNbMF07XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS50eXBlLCBDaGFuZ2VUeXBlLlNldCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5jb2xsZWN0aW9uLCAnbXlDb2xsZWN0aW9uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5tYXBwaW5nLCAnUGVyc29uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5faWQsIHBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHBlcnNvbkNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChwZXJzb25DaGFuZ2UubmV3Lmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHBlcnNvbkNoYW5nZS5uZXdJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHBlcnNvbkNoYW5nZS5uZXdJZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUocGVyc29uQ2hhbmdlLm5ldywgY2FyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLm1hcHBpbmcsICdQZXJzb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RBbm90aGVyUGVyc29uQ2hhbmdlLl9pZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuZmllbGQsICdjYXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5pbmRleCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWRJZC5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5hZGRlZElkLCBjYXIuX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdEFub3RoZXJQZXJzb25DaGFuZ2UuYWRkZWQsIGNhcik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkLmxlbmd0aCwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0QW5vdGhlclBlcnNvbkNoYW5nZS5yZW1vdmVkSWQubGVuZ3RoLCAwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU3BsaWNlKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLmNvbGxlY3Rpb24sICdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLm1hcHBpbmcsICdDYXInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoc2Vjb25kQ2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNlY29uZENhckNoYW5nZS5maWVsZCwgJ293bmVycycpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChzZWNvbmRDYXJDaGFuZ2UuaW5kZXgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5pbmNsdWRlKHNlY29uZENhckNoYW5nZS5hZGRlZElkLCBwZXJzb24uX2lkKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShzZWNvbmRDYXJDaGFuZ2UuYWRkZWQsIHBlcnNvbik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLnR5cGUsIENoYW5nZVR5cGUuU2V0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZmlyc3RDYXJDaGFuZ2UuY29sbGVjdGlvbiwgJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChmaXJzdENhckNoYW5nZS5tYXBwaW5nLCAnQ2FyJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGZpcnN0Q2FyQ2hhbmdlLmZpZWxkLCAnb3duZXJzJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmlyc3RDYXJDaGFuZ2UubmV3LCBhbm90aGVyUGVyc29uKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5jbHVkZShmaXJzdENhckNoYW5nZS5uZXdJZCwgYW5vdGhlclBlcnNvbi5faWQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhmaXJzdENhckNoYW5nZS5vbGQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5ub3RPayhmaXJzdENhckNoYW5nZS5vbGRJZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cblxuXG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSlcblxuXG4vLyAgICAgfSk7XG4vLyB9KTtcblxuIiwiLy8gdmFyIHMgPSByZXF1aXJlKCcuLi8uLi9pbmRleCcpXG4vLyAgICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG4vLyBkZXNjcmliZSgncHJveHkgaW50ZWdyYXRpb24nLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbi8vICAgICB2YXIgY2FjaGUgPSByZXF1aXJlKCcuLi8uLi9zcmMvY2FjaGUnKTtcbi8vICAgICB2YXIgUmVsYXRpb25zaGlwVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3NyYy9yZWxhdGlvbnNoaXAnKS5SZWxhdGlvbnNoaXBUeXBlO1xuXG4vLyAgICAgdmFyIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbi8vICAgICB2YXIgY29sbGVjdGlvbjtcblxuLy8gICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4vLyAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVsYXRpb25zaGlwVHlwZS5PbmVUb01hbnksXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgbWFwcGluZzogJ1BlcnNvbidcbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9XG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgICBwZXJzb25NYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdQZXJzb24nLCB7XG4vLyAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgIH0pO1xuXG4vLyAgICAgaXQoJ3h5eicsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgIGNhck1hcHBpbmcubWFwKHtcbi8vICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJywgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJyxcbi8vICAgICAgICAgICAgICAgICBhZ2U6IDIsXG4vLyAgICAgICAgICAgICAgICAgaWQ6IDJcbi8vICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgICBpZDogNVxuLy8gICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCBjYXIpIHtcbi8vICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgIGNvbGxlY3Rpb24uc2F2ZShmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgcGVyc29uTWFwcGluZy5nZXQoMiwgZnVuY3Rpb24gKGVyciwgcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSBwLmNhcnNQcm94eTtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHAuY2Fycy5pc0ZhdWx0KTtcbi8vICAgICAgICAgICAgICAgICAgICAgcC5jYXJzUHJveHkuZ2V0KGZ1bmN0aW9uIChlcnIsIGNhcnMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH0pO1xuXG4vLyB9KTsiLCIvLyB2YXIgcyA9IHJlcXVpcmUoJy4uLy4uL2luZGV4JyksXG4vLyAgICAgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuLy8gZGVzY3JpYmUoJ21hcHBpbmcgcXVlcmllcycsIGZ1bmN0aW9uKCkge1xuXG4vLyAgICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuLy8gICAgIHZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NvbGxlY3Rpb24nKS5Db2xsZWN0aW9uO1xuLy8gICAgIHZhciBSZWxhdGlvbnNoaXBUeXBlID0gcmVxdWlyZSgnLi4vLi4vc3JjL3JlbGF0aW9uc2hpcCcpLlJlbGF0aW9uc2hpcFR5cGU7XG4vLyAgICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vLi4vc3JjL2NhY2hlJyk7XG5cbi8vICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBzLnJlc2V0KHRydWUpO1xuLy8gICAgIH0pO1xuXG4vLyAgICAgZGVzY3JpYmUoJ3F1ZXJpZXMnLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgdmFyIGNvbGxlY3Rpb24sIG1hcHBpbmc7XG4vLyAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgICAgIG1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG9yJywgJ25hbWUnXVxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5idWxrRG9jcyhbe1xuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6IDQsXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nXG4vLyAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6IDUsXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsXG4vLyAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdGb3JkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbidcbi8vICAgICAgICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgIGl0KCdhbGwnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgbWFwcGluZy5hbGwoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMik7XG4vLyAgICAgICAgICAgICAgICAgXy5lYWNoKGNhcnMsIGZ1bmN0aW9uKGNhcikge1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihjYXIsIFNpZXN0YU1vZGVsKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgaXQoJ3F1ZXJ5JywgZnVuY3Rpb24oZG9uZSkge1xuLy8gICAgICAgICAgICAgdGhpcy50aW1lb3V0KDEwMDAwKTtcbi8vICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICBtYXBwaW5nLnF1ZXJ5KHtcbi8vICAgICAgICAgICAgICAgICBjb2xvcjogJ3JlZCdcbi8vICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgY2Fycykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2Fycy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgIF8uZWFjaChjYXJzLCBmdW5jdGlvbihjYXIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2FyLCBTaWVzdGFNb2RlbCk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGl0KCdnZXQnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgbWFwcGluZy5nZXQoNCwgZnVuY3Rpb24oZXJyLCBjYXIpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGNhcik7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2FyLCBTaWVzdGFNb2RlbCk7XG4vLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGNhci5jb2xvciwgJ3JlZCcpO1xuLy8gICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgIH0pO1xuXG4vLyAgICAgZGVzY3JpYmUoJ3JldmVyc2UnLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgdmFyIGNhck1hcHBpbmcsIHBlcnNvbk1hcHBpbmc7XG5cbi8vICAgICAgICAgdmFyIGNvbGxlY3Rpb247XG5cbi8vICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbi8vICAgICAgICAgICAgICAgICByZWxhdGlvbnNoaXBzOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG93bmVyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBSZWxhdGlvbnNoaXBUeXBlLk9uZVRvTWFueSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2U6ICdjYXJzJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nXG4vLyAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIHBlcnNvbk1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ1BlcnNvbicsIHtcbi8vICAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ25hbWUnLCAnYWdlJ11cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgIGl0KCdub3QgY2FjaGVkJywgZnVuY3Rpb24oZG9uZSkge1xuLy8gICAgICAgICAgICAgdGhpcy50aW1lb3V0KDUwMDApO1xuLy8gICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoe1xuLy8gICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgb3duZXI6IHtcbi8vICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgIGFnZTogMixcbi8vICAgICAgICAgICAgICAgICAgICAgaWQ6ICcyJ1xuLy8gICAgICAgICAgICAgICAgIH0sXG4vLyAgICAgICAgICAgICAgICAgaWQ6IDVcbi8vICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgY2FyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc2F2ZShmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICBwZXJzb25NYXBwaW5nLmdldCgnMicsIGZ1bmN0aW9uKGVyciwgcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKHAsICdTaG91bGQgYmUgYWJsZSB0byBmZXRjaCB0aGUgcGVyc29uJyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBwLmNhcnNQcm94eS5nZXQoZnVuY3Rpb24oZXJyLCBjYXJzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fyc1swXS5vd25lci5nZXQoZnVuY3Rpb24oZXJyLCBvd25lcikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChjYXJzWzBdLm93bmVyLCBwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcbi8vICAgICB9KTtcblxuXG4vLyB9KTsiLCIvLyB2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4Jylcbi8vICAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbi8vIGRlc2NyaWJlKCdxdWVyeScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICB2YXIgUXVlcnkgPSByZXF1aXJlKCcuLi9zcmMvcXVlcnknKS5RdWVyeTtcbi8vICAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbi8vICAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG5cbi8vICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICB9KTtcblxuLy8gICAgIC8vIFRPRE86IFN0b3JhZ2VcblxuLy8gICAgIC8vIGRlc2NyaWJlKCdyYXcgcXVlcnknLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgLy8gICAgIGl0KCdkZXNpZ24gZG9jIG5hbWUnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgLy8gICAgICAgICB2YXIgbmFtZSA9IG5ldyBzLmV4dC5zdG9yYWdlLlJhd1F1ZXJ5KCdteUNvbGxlY3Rpb24nLCAnQ2FyJywge2NvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nfSkuX2dldERlc2lnbkRvY05hbWUoKTtcbi8vICAgICAvLyAgICAgICAgIGFzc2VydC5lcXVhbChuYW1lLCAnX2Rlc2lnbi9teUNvbGxlY3Rpb25fSW5kZXhfQ2FyX2NvbG91cl9uYW1lJyk7XG4vLyAgICAgLy8gICAgIH0pO1xuXG5cbi8vICAgICAvLyAgICAgaXQoJ2ZpZWxkcycsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAvLyAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7Y29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAvLyAgICAgICAgIHZhciBmaWVsZHMgPSBxLl9nZXRGaWVsZHMoKTtcbi8vICAgICAvLyAgICAgICAgIGFzc2VydC5pbmNsdWRlKGZpZWxkcywgJ2NvbG91cicpO1xuLy8gICAgIC8vICAgICAgICAgYXNzZXJ0LmluY2x1ZGUoZmllbGRzLCAnbmFtZScpO1xuLy8gICAgIC8vICAgICB9KTtcblxuLy8gICAgIC8vICAgICBpdCgnY29uc3RydWN0IGtleScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAvLyAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7Y29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbi8vICAgICAvLyAgICAgICAgIHZhciBrZXkgPSBxLl9jb25zdHJ1Y3RLZXkoKTtcbi8vICAgICAvLyAgICAgICAgIGFzc2VydC5lcXVhbChrZXksICdyZWRfQXN0b24gTWFydGluJyk7XG4vLyAgICAgLy8gICAgIH0pO1xuXG4vLyAgICAgLy8gICAgIGl0KCdleGVjdXRlIHdpdGggbm8gcm93cyBhbmQgbm8gaW5kZXgnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgIC8vICAgICAgICAgdGhpcy50aW1lb3V0KDEwMDAwKTsgLy8gQ2FuIHRha2UgcXVpdGUgYSBsb25nIHRpbWUgc29tZXRpbWVzLlxuLy8gICAgIC8vICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgIC8vICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbi8vICAgICAvLyAgICAgICAgICAgICBpZiAoZG9uZSkgZG9uZShlcnIpO1xuLy8gICAgIC8vICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXN1bHRzLmxlbmd0aCwgMCk7XG4vLyAgICAgLy8gICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgIC8vICAgICAgICAgfSk7XG4vLyAgICAgLy8gICAgIH0pO1xuXG4vLyAgICAgLy8gICAgIGl0KCdleGVjdXRlIHdpdGggaW5kZXgnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgIC8vICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgIC8vICAgICAgICAgdmFyIGkgPSBuZXcgcy5leHQuc3RvcmFnZS5JbmRleCgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIFsnY29sb3VyJywgJ25hbWUnXSk7XG4vLyAgICAgLy8gICAgICAgICBpLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgIC8vICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAvLyAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgZG9uZShlcnIpO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzdWx0cy5sZW5ndGgsIDApO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgLy8gICAgICAgICB9KTtcbi8vICAgICAvLyAgICAgfSk7XG5cbi8vICAgICAvLyAgICAgaXQoJ2V4ZWN1dGUgd2l0aCBpbmRleCB3aXRoIHJvd3MnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgIC8vICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgIC8vICAgICAgICAgdmFyIGkgPSBuZXcgcy5leHQuc3RvcmFnZS5JbmRleCgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIFsnY29sb3VyJywgJ25hbWUnXSk7XG4vLyAgICAgLy8gICAgICAgICBpLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgIC8vICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAvLyAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucG9zdCh7J3R5cGUnOiAnQ2FyJywgY29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nfSwgZnVuY3Rpb24gKGVycikge1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgZG9uZShlcnIpO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdHMubGVuZ3RoLCAxKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgLy8gICAgICAgICB9KTtcbi8vICAgICAvLyAgICAgfSk7XG5cbi8vICAgICAvLyAgICAgaXQoJ2V4ZWN1dGUgd2l0aG91dCBpbmRleCB3aXRoIHJvd3MnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgIC8vICAgICAgICAgdGhpcy50aW1lb3V0KDEwMDAwKTsgLy8gQ2FuIHRha2UgcXVpdGUgYSBsb25nIHRpbWUgc29tZXRpbWVzLlxuLy8gICAgIC8vICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuLy8gICAgIC8vICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnBvc3Qoeyd0eXBlJzogJ0NhcicsIGNvbG91cjogJ3JlZCcsIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLCBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJ30sIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAvLyAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgLy8gICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIGRvbmUoZXJyKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlc3VsdHMubGVuZ3RoLCAxKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgIC8vICAgICAgICAgICAgIH0pO1xuLy8gICAgIC8vICAgICAgICAgfSk7XG4vLyAgICAgLy8gICAgIH0pO1xuXG5cbi8vICAgICAvLyB9KTtcblxuLy8gICAgIC8vIGRlc2NyaWJlKCdxdWVyeScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAvLyAgICAgdmFyIGNvbGxlY3Rpb24sIG1hcHBpbmc7XG5cbi8vICAgICAvLyAgICAgaXQoJ2FzZGFzZCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgLy8gICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgIC8vICAgICAgICAgbWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnUGVyc29uJywge1xuLy8gICAgIC8vICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgIC8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnbmFtZScsICdhZ2UnXVxuLy8gICAgIC8vICAgICAgICAgfSk7XG4vLyAgICAgLy8gICAgICAgICBjb2xsZWN0aW9uLmluc3RhbGwoZnVuY3Rpb24gKGVycikge1xuLy8gICAgIC8vICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAvLyAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucG9zdCh7dHlwZTogJ1BlcnNvbicsIGFnZTogMjMsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLCBuYW1lOiAnTWljaGFlbCd9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgUXVlcnkobWFwcGluZywge2FnZTogMjN9KTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIG9ianMpIHtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKG9ianMubGVuZ3RoKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2gob2JqcywgZnVuY3Rpb24gKG9iaikge1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihvYmosIFNpZXN0YU1vZGVsKTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4vLyAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuXG4vLyAgICAgLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgIC8vICAgICAgICAgICAgIH0pO1xuLy8gICAgIC8vICAgICAgICAgfSk7XG5cblxuLy8gICAgIC8vICAgICB9KVxuLy8gICAgIC8vIH0pO1xuXG5cbi8vIH0pOyIsIi8vIHZhciBzID0gcmVxdWlyZSgnLi4vLi4vaW5kZXgnKVxuLy8gICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuLy8gZGVzY3JpYmUoJ3JhdyBxdWVyeSBiZWhhdmlvdXInLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdkYXRhIHR5cGVzJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdpbmRleGVkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ3Npbmd1bGFyJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBuZXcgcy5leHQuc3RvcmFnZS5JbmRleCgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIFsnaWQnXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGluZGV4Lmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnc3RyaW5nJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnBvc3Qoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NhcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnYmxhaCdcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7aWQ6ICdibGFoJ30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbiAoZXJyLCBkb2NzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvY3MubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdudW1lcmljJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnBvc3Qoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NhcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiA1XG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBzLmV4dC5zdG9yYWdlLlJhd1F1ZXJ5KCdteUNvbGxlY3Rpb24nLCAnQ2FyJywge2lkOiA1fSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ251bWVyaWMgd2l0aCBzdHJpbmcgcXVlcnknLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucG9zdCh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDVcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7aWQ6ICc1J30pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbiAoZXJyLCBkb2NzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvY3MubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzdHJpbmcgd2l0aCBudW1lcmljIHF1ZXJ5JywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnBvc3Qoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NhcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnNSdcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7aWQ6IDV9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkb2NzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdtdWx0aXBsZScsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbmV3IHMuZXh0LnN0b3JhZ2UuSW5kZXgoJ215Q29sbGVjdGlvbicsICdDYXInLCBbJ2lkJywgJ2NvbG91cicsICdhZ2UnXSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGluZGV4Lmluc3RhbGwoZG9uZSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnbnVtZXJpYycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wb3N0KHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDYXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMlxuLy8gICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtpZDogNSwgY29sb3VyOiAncmVkJywgYWdlOiAyfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3N0cmluZycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wb3N0KHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDYXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzUnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IG5ldyBzLmV4dC5zdG9yYWdlLlJhd1F1ZXJ5KCdteUNvbGxlY3Rpb24nLCAnQ2FyJywge2lkOiAnNScsIGNvbG91cjogJ3JlZCcsIGFnZTogMn0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbiAoZXJyLCBkb2NzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvY3MubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuXG5cblxuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGRlc2NyaWJlKCdub3QgaW5kZXhlZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdzaW5ndWxhcicsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgIGl0KCdzdHJpbmcnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucG9zdCh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdibGFoJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtpZDogJ2JsYWgnfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ251bWVyaWMnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucG9zdCh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IDVcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7aWQ6IDV9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmV4ZWN1dGUoZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkb2NzLmxlbmd0aCwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICBpdCgnbnVtZXJpYyB3aXRoIHN0cmluZyBxdWVyeScsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wb3N0KHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDYXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNVxuLy8gICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtpZDogJzUnfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ3N0cmluZyB3aXRoIG51bWVyaWMgcXVlcnknLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkucG9zdCh7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2FyJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc1J1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtpZDogNX0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZXhlY3V0ZShmdW5jdGlvbiAoZXJyLCBkb2NzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvY3MubGVuZ3RoLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ211bHRpcGxlJywgZnVuY3Rpb24gKCkge1xuXG5cbi8vICAgICAgICAgICAgICAgICBpdCgnbnVtZXJpYycsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wb3N0KHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDYXInLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogNSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMlxuLy8gICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBuZXcgcy5leHQuc3RvcmFnZS5SYXdRdWVyeSgnbXlDb2xsZWN0aW9uJywgJ0NhcicsIHtpZDogNSwgY29sb3VyOiAncmVkJywgYWdlOiAyfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pOyAgXG5cbi8vICAgICAgICAgICAgICAgICBpdCgnc3RyaW5nJywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnBvc3Qoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NhcicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnNScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDJcbi8vICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gbmV3IHMuZXh0LnN0b3JhZ2UuUmF3UXVlcnkoJ215Q29sbGVjdGlvbicsICdDYXInLCB7aWQ6ICc1JywgY29sb3VyOiAncmVkJywgYWdlOiAyfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5leGVjdXRlKGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDEpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICB9KTtcblxuLy8gfSk7IiwiLy8gdmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpXG4vLyAgICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG4vLyBkZXNjcmliZSgnc2luZ2xldG9uIG1hcHBpbmcnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG4vLyAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4vLyAgICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG4vLyAgICAgdmFyIHN0b3JlID0gcmVxdWlyZSgnLi4vc3JjL3N0b3JlJyk7XG5cbi8vICAgICB2YXIgY29sbGVjdGlvbiwgY2FyTWFwcGluZztcblxuLy8gICAgIGZ1bmN0aW9uIENhck9iamVjdCgpIHtcbi8vICAgICAgICAgU2llc3RhTW9kZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbi8vICAgICB9XG5cbi8vICAgICBDYXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTaWVzdGFNb2RlbC5wcm90b3R5cGUpO1xuXG4vLyAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICBzLnJlc2V0KHRydWUpO1xuLy8gICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ0NhcicpO1xuLy8gICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4vLyAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbi8vICAgICAgICAgICAgIHNpbmdsZXRvbjogdHJ1ZVxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuLy8gICAgIH0pO1xuXG5cbi8vICAgICBpdCgnc3RvcmUgc2hvdWxkIHJldHVybiBzaW5nbGV0b24nLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICB0aGlzLnRpbWVvdXQoNTAwMCk7XG4vLyAgICAgICAgIGNhck1hcHBpbmcubWFwKHtjb2xvdXI6ICdyZWQnLCBpZDogNX0sIGZ1bmN0aW9uIChlcnIsIGNhcikge1xuLy8gICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgY29sbGVjdGlvbi5zYXZlKGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgY2FjaGUucmVzZXQoKTtcbi8vICAgICAgICAgICAgICAgICBzdG9yZS5nZXQoe21hcHBpbmc6IGNhck1hcHBpbmd9LCBmdW5jdGlvbiAoZXJyLCBvYmopIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwob2JqLl9pZCwgY2FyLl9pZCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcbi8vICAgICB9KTtcblxuXG5cbi8vIH0pOyIsIi8vIHZhciBzaWVzdGEgPSByZXF1aXJlKCcuLi9pbmRleCcpO1xuLy8gdmFyIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbi8vIGRlc2NyaWJlKCdzdGF0aXN0aWNzJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgdmFyIENhciwgUGVyc29uLCBjb2xsO1xuXG4vLyAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4vLyAgICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG5cbi8vICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgc2llc3RhLnJlc2V0KHRydWUpO1xuLy8gICAgICAgICBjb2xsID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuLy8gICAgICAgICBDYXIgPSBjb2xsLm1hcHBpbmcoJ0NhcicsIHtcbi8vICAgICAgICAgICAgIGlkOiAnaWQnLFxuLy8gICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuLy8gICAgICAgICAgICAgcmVsYXRpb25zaGlwczoge1xuLy8gICAgICAgICAgICAgICAgIG93bmVyOiB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmc6ICdQZXJzb24nLFxuLy8gICAgICAgICAgICAgICAgICAgICB0eXBlOiAnT25lVG9NYW55Jyxcbi8vICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZTogJ2NhcnMnXG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgUGVyc29uID0gY29sbC5tYXBwaW5nKCdQZXJzb24nLCB7XG4vLyAgICAgICAgICAgICBpZDogJ2lkJyxcbi8vICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnYWdlJywgJ25hbWUnXVxuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgY29sbC5pbnN0YWxsKGRvbmUpO1xuLy8gICAgIH0pO1xuXG4vLyAgICAgZGVzY3JpYmUoJ25vIGZhdWx0cycsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBkZXNjcmliZSgnY29sbGVjdGlvbiBsZXZlbCcsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgaXQoJ25vIG9iamVjdHMnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobiwgMCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ29uZSBvYmplY3QnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIENhci5tYXAoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvdW50KGZ1bmN0aW9uKGVyciwgbikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobiwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ211bHRpcGxlIG9iamVjdHMnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIENhci5tYXAoW3tcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5J1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTGFtYm8nXG4vLyAgICAgICAgICAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdtdWx0aXBsZSBtYXBwaW5ncycsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIGl0KCdtdWx0aXBsZSBvYmplY3RzJywgZnVuY3Rpb24oZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBDYXIubWFwKFt7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleSdcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBQZXJzb24ubWFwKFt7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyNCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTWljaGFlbCBGb3JkJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0pvaG4gRG9lJ1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvdW50KGZ1bmN0aW9uKGVyciwgbikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCA1KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgIH0pO1xuLy8gICAgIGRlc2NyaWJlKCdhbGwgZmF1bHRlZCcsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICBkZXNjcmliZSgnY29sbGVjdGlvbiBsZXZlbCcsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBtYXBwaW5nJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgaXQoJ29uZSBvYmplY3QnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIENhci5tYXAoe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgb2JqKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzaWVzdGEuc2F2ZShmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucmVzZXQoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvdW50KGZ1bmN0aW9uKGVyciwgbikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCAxKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ211bHRpcGxlIG9iamVjdHMnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIENhci5tYXAoW3tcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5J1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTGFtYm8nXG4vLyAgICAgICAgICAgICAgICAgICAgIH1dLCBmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNpZXN0YS5zYXZlKGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5yZXNldCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG4sIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdtdWx0aXBsZSBtYXBwaW5ncycsIGZ1bmN0aW9uKCkge1xuLy8gICAgICAgICAgICAgICAgIGl0KCdtdWx0aXBsZSBvYmplY3RzJywgZnVuY3Rpb24oZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICBDYXIubWFwKFt7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbidcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleSdcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFBlcnNvbi5tYXAoW3tcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZ2U6IDI0LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdNaWNoYWVsIEZvcmQnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdlOiAyNSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSm9obiBEb2UnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZXN0YS5zYXZlKGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobiwgNSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfSk7XG5cbi8vICAgICB9KTtcbi8vICAgICBkZXNjcmliZSgnc29tZSBmYXVsdGVkJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIGRlc2NyaWJlKCdjb2xsZWN0aW9uIGxldmVsJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnc2luZ2xlIG1hcHBpbmcnLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICBpdCgnbXVsdGlwbGUgb2JqZWN0cycsIGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgQ2FyLm1hcChbe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcxJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5Jyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMidcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMydcbi8vICAgICAgICAgICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgb2Jqcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc2llc3RhLnNhdmUoZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZS5fbG9jYWxDYWNoZSgpW29ianNbMV0uX2lkXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvdW50KGZ1bmN0aW9uKGVyciwgbikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnbXVsdGlwbGUgbWFwcGluZ3MnLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICBpdCgnbXVsdGlwbGUgb2JqZWN0cycsIGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgQ2FyLm1hcChbe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAncmVkJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBc3RvbiBNYXJ0aW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICcxJ1xuLy8gICAgICAgICAgICAgICAgICAgICB9LCB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdibHVlJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdCZW50bGV5Jyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMidcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnZ3JlZW4nLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0xhbWJvJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMydcbi8vICAgICAgICAgICAgICAgICAgICAgfV0sIGZ1bmN0aW9uKGVyciwgY2Fycykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgUGVyc29uLm1hcChbe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc0J1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0pvaG4gRG9lJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzUnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XSwgZnVuY3Rpb24oZXJyLCBwZW9wbGUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2llc3RhLnNhdmUoZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlLl9sb2NhbENhY2hlKClbY2Fyc1sxXS5faWRdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGUuX2xvY2FsQ2FjaGUoKVtwZW9wbGVbMV0uX2lkXTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb3VudChmdW5jdGlvbihlcnIsIG4pIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCA1KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgIH0pO1xuXG5cbi8vICAgICBkZXNjcmliZSgnYWxsIGZhdWx0ZWQsIHRoZW4gbWFwcGVkIGFnYWluJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIGRlc2NyaWJlKCdjb2xsZWN0aW9uIGxldmVsJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnc2luZ2xlIG1hcHBpbmcnLCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICBpdCgnb25lIG9iamVjdCcsIGZ1bmN0aW9uKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FzdG9uIE1hcnRpbicsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzEnXG4vLyAgICAgICAgICAgICAgICAgICAgIH07XG4vLyAgICAgICAgICAgICAgICAgICAgIENhci5tYXAoZGF0YSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzaWVzdGEuc2F2ZShmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUucmVzZXQoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDYXIubWFwKGRhdGEsIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwobiwgMSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgaXQoJ211bHRpcGxlIG9iamVjdHMnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gW3tcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMSdcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzInXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibycsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzMnXG4vLyAgICAgICAgICAgICAgICAgICAgIH1dO1xuLy8gICAgICAgICAgICAgICAgICAgICBDYXIubWFwKGRhdGEsIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc2llc3RhLnNhdmUoZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2FyLm1hcChkYXRhLCBmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvdW50KGZ1bmN0aW9uKGVyciwgbikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKG4sIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgZGVzY3JpYmUoJ211bHRpcGxlIG1hcHBpbmdzJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgaXQoJ211bHRpcGxlIG9iamVjdHMnLCBmdW5jdGlvbihkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXJEYXRhID0gW3tcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ3JlZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXN0b24gTWFydGluJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnMSdcbi8vICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQmVudGxleScsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzInXG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdMYW1ibycsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzMnXG4vLyAgICAgICAgICAgICAgICAgICAgIH1dO1xuLy8gICAgICAgICAgICAgICAgICAgICBDYXIubWFwKGNhckRhdGEsIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnNvbkRhdGEgPSBbe1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjQsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ01pY2hhZWwgRm9yZCcsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICc0J1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZTogMjUsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0pvaG4gRG9lJyxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJzUnXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFBlcnNvbi5tYXAocGVyc29uRGF0YSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZXN0YS5zYXZlKGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlc2V0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENhci5tYXAoY2FyRGF0YSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQZXJzb24ubWFwKHBlcnNvbkRhdGEsIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWVzdGEuc2F2ZShmdW5jdGlvbihlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG91Y2ggPSBzaWVzdGEuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG91Y2gucXVlcnkoZnVuY3Rpb24oZG9jKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jLnR5cGUgPT0gJ0NhcicpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0KGRvYy5faWQsIGRvYyk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgcmVzcCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtcCgnZXJyJywgZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bXAoJ3Jlc3AnLCByZXNwKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGwuY291bnQoZnVuY3Rpb24oZXJyLCBuKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChuLCA1KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgfSk7XG5cblxuXG4vLyB9KTsiLCIvLyB2YXIgcyA9IHJlcXVpcmUoJy4uL2luZGV4Jylcbi8vICAgICAsIGFzc2VydCA9IHJlcXVpcmUoJ2NoYWknKS5hc3NlcnQ7XG5cbi8vIGRlc2NyaWJlKCdzdG9yZScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICB2YXIgU3RvcmUgPSByZXF1aXJlKCcuLi9zcmMvc3RvcmUnKTtcbi8vICAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG4vLyAgICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4vLyAgICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG5cbi8vICAgICB2YXIgY2FyTWFwcGluZywgY29sbGVjdGlvbjtcblxuLy8gICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgcy5yZXNldCh0cnVlKTtcbi8vICAgICAgICAgY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKCdteUNvbGxlY3Rpb24nKTtcbi8vICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuLy8gICAgICAgICAgICAgaWQ6ICdpZCcsXG4vLyAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ11cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIGNvbGxlY3Rpb24uaW5zdGFsbChkb25lKTtcbi8vICAgICB9KTtcblxuLy8gICAgIGRlc2NyaWJlKCdnZXQnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgaXQoJ2luIHBvdWNoLCBoYXZlIF9pZCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICB2YXIgcG91Y2hpZCA9ICdwb3VjaElkJztcbi8vICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5wdXQoe3R5cGU6ICdDYXInLCBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgY29sb3VyOiAncmVkJywgX2lkOiBwb3VjaGlkfSwgZnVuY3Rpb24gKGVyciwgZG9jKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgIFN0b3JlLmdldCh7X2lkOiBwb3VjaGlkfSwgZnVuY3Rpb24gKGVyciwgb2JqKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlZE9iamVjdCA9IGNhY2hlLmdldCh7X2lkOiBvYmouX2lkfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoY2FjaGVkT2JqZWN0LCBvYmopO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgIGl0KCdpbiBwb3VjaCwgZG9udCBoYXZlIF9pZCcsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICB2YXIgcG91Y2hpZCA9ICdwb3VjaElkJztcbi8vICAgICAgICAgICAgIHZhciByZW1vdGVJZCA9ICd4eXonO1xuLy8gICAgICAgICAgICAgcy5leHQuc3RvcmFnZS5Qb3VjaC5nZXRQb3VjaCgpLnB1dCh7dHlwZTogJ0NhcicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLCBjb2xvdXI6ICdyZWQnLCBfaWQ6IHBvdWNoaWQsIGlkOiByZW1vdGVJZH0sIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICBTdG9yZS5nZXQoe2lkOiByZW1vdGVJZCwgbWFwcGluZzogY2FyTWFwcGluZ30sIGZ1bmN0aW9uIChlcnIsIGRvYykge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9KTtcblxuLy8gICAgICAgICBkZXNjcmliZSgnbXVsdGlwbGUnLCBmdW5jdGlvbiAoKSB7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdnZXRNdWx0aXBsZScsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdub3QgY2FjaGVkJywgZnVuY3Rpb24gKCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkuYnVsa0RvY3MoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogJ0NhcicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLCBjb2xvdXI6ICdyZWQnLCBfaWQ6ICdsb2NhbElkMScsIGlkOiAncmVtb3RlSWQxJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ2JsdWUnLCBfaWQ6ICdsb2NhbElkMicsIGlkOiAncmVtb3RlSWQyJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ2dyZWVuJywgX2lkOiAnbG9jYWxJZDMnLCBpZDogJ3JlbW90ZUlkMyd9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgaXQoJ2dldE11bHRpcGxlIHNob3VsZCByZXR1cm4gbXVsdGlwbGUnLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmUuZ2V0TXVsdGlwbGUoW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtfaWQ6ICdsb2NhbElkMSd9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtfaWQ6ICdsb2NhbElkMid9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtfaWQ6ICdsb2NhbElkMyd9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBdLCBmdW5jdGlvbiAoZXJyLCBkb2NzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChkb2NzLCBmdW5jdGlvbiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihkLCBTaWVzdGFNb2RlbCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGl0KCdnZXQgc2hvdWxkIHByb3h5IHRvIGdldE11bHRpcGxlIGlmIF9pZCBpcyBhbiBhcnJheScsIGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBTdG9yZS5nZXQoe19pZDogWydsb2NhbElkMScsICdsb2NhbElkMicsICdsb2NhbElkMyddfSwgZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goZG9jcywgZnVuY3Rpb24gKGQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoZCwgU2llc3RhTW9kZWwpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuXG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICBkZXNjcmliZSgnZ2V0TXVsdGlwbGVMb2NhbCcsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgIGRlc2NyaWJlKCdub3QgY2FjaGVkJywgZnVuY3Rpb24gKCkge1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5idWxrRG9jcyhcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ3JlZCcsIF9pZDogJ2xvY2FsSWQxJywgaWQ6ICdyZW1vdGVJZDEnfSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6ICdDYXInLCBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgY29sb3VyOiAnYmx1ZScsIF9pZDogJ2xvY2FsSWQyJywgaWQ6ICdyZW1vdGVJZDInfSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3R5cGU6ICdDYXInLCBjb2xsZWN0aW9uOiAnbXlDb2xsZWN0aW9uJywgY29sb3VyOiAnZ3JlZW4nLCBfaWQ6ICdsb2NhbElkMycsIGlkOiAncmVtb3RlSWQzJ31cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGl0KCd4eXonLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmUuZ2V0TXVsdGlwbGVMb2NhbChbJ2xvY2FsSWQxJywgJ2xvY2FsSWQyJywgJ2xvY2FsSWQzJ10sIGZ1bmN0aW9uIChlcnIsIGRvY3MpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvY3MubGVuZ3RoLCAzKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goZG9jcywgZnVuY3Rpb24gKGQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoZCwgU2llc3RhTW9kZWwpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pXG4vLyAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgZGVzY3JpYmUoJ3BhcnRpYWxseSBjYWNoZWQnLCBmdW5jdGlvbiAoKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHZhciBjYXJzO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXI6ICdyZWQnLCBpZDogJ3JlbW90ZUlkMSd9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvMiA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyOiAnZ3JlZW4nLCBpZDogJ3JlbW90ZUlkMyd9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBbbywgbzJdO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KG8pO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KG8yKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHMuZXh0LnN0b3JhZ2UuUG91Y2guZ2V0UG91Y2goKS5idWxrRG9jcyhcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ2JsdWUnLCBfaWQ6ICdsb2NhbElkMicsIGlkOiAncmVtb3RlSWQyJ31cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgIGl0KCd4eXonLCBmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsSWRlbnRpZmllcnMgPSBfLnBsdWNrKGNhcnMsICdfaWQnKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsSWRlbnRpZmllcnMucHVzaCgnbG9jYWxJZDInKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlLmdldE11bHRpcGxlTG9jYWwobG9jYWxJZGVudGlmaWVycywgZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChkb2NzLCBmdW5jdGlvbiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihkLCBTaWVzdGFNb2RlbCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIGRlc2NyaWJlKCdnZXRNdWx0aXBsZVJlbW90ZScsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgnbm90IGNhY2hlZCcsIGZ1bmN0aW9uICgpIHtcblxuLy8gICAgICAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkuYnVsa0RvY3MoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dHlwZTogJ0NhcicsIGNvbGxlY3Rpb246ICdteUNvbGxlY3Rpb24nLCBjb2xvdXI6ICdyZWQnLCBfaWQ6ICdsb2NhbElkMScsIGlkOiAncmVtb3RlSWQxJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ2JsdWUnLCBfaWQ6ICdsb2NhbElkMicsIGlkOiAncmVtb3RlSWQyJ30sXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ2dyZWVuJywgX2lkOiAnbG9jYWxJZDMnLCBpZDogJ3JlbW90ZUlkMyd9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICApO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICBpdCgneHl6JywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlLmdldE11bHRpcGxlUmVtb3RlKFsncmVtb3RlSWQxJywgJ3JlbW90ZUlkMicsICdyZW1vdGVJZDMnXSwgY2FyTWFwcGluZywgZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChkb2NzLCBmdW5jdGlvbiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihkLCBTaWVzdGFNb2RlbCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICBkZXNjcmliZSgncGFydGlhbGx5IGNhY2hlZCcsIGZ1bmN0aW9uICgpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgdmFyIGNhcnM7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbiAoZG9uZSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY2FyTWFwcGluZy5tYXAoW1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdyZWQnLCBpZDogJ3JlbW90ZUlkMSd9LFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjb2xvdXI6ICdncmVlbicsIGlkOiAncmVtb3RlSWQzJ31cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIF0sIGZ1bmN0aW9uIChlcnIsIF9jYXJzKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcnMgPSBfY2Fycztcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmV4dC5zdG9yYWdlLlBvdWNoLmdldFBvdWNoKCkuYnVsa0RvY3MoXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0eXBlOiAnQ2FyJywgY29sbGVjdGlvbjogJ215Q29sbGVjdGlvbicsIGNvbG91cjogJ2JsdWUnLCBfaWQ6ICdsb2NhbElkMicsIGlkOiAncmVtb3RlSWQyJ31cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZShlcnIpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcblxuLy8gICAgICAgICAgICAgICAgICAgICBpdCgneHl6JywgZnVuY3Rpb24gKGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIFN0b3JlLmdldE11bHRpcGxlUmVtb3RlKFsncmVtb3RlSWQxJywgJ3JlbW90ZUlkMicsICdyZW1vdGVJZDMnXSwgY2FyTWFwcGluZywgZnVuY3Rpb24gKGVyciwgZG9jcykge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIGRvbmUoZXJyKTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDMpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uZWFjaChkb2NzLCBmdW5jdGlvbiAoZCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihkLCBTaWVzdGFNb2RlbCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfSlcbi8vICAgICAgICAgICAgICAgICAgICAgfSlcblxuXG4vLyAgICAgICAgICAgICAgICAgfSk7XG5cbi8vICAgICAgICAgICAgIH0pXG5cblxuLy8gICAgICAgICB9KTtcblxuLy8gICAgIH0pO1xuXG5cbi8vIH0pOyIsInZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKSxcbiAgICBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5kZXNjcmliZSgnc3RvcmUuLi4uLi4nLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgU3RvcmUgPSByZXF1aXJlKCcuLi9zcmMvc3RvcmUnKTtcbiAgICB2YXIgU2llc3RhTW9kZWwgPSByZXF1aXJlKCcuLi9zcmMvb2JqZWN0JykuU2llc3RhTW9kZWw7XG4gICAgdmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9zcmMvY29sbGVjdGlvbicpLkNvbGxlY3Rpb247XG4gICAgdmFyIGNhY2hlID0gcmVxdWlyZSgnLi4vc3JjL2NhY2hlJyk7XG5cbiAgICB2YXIgY2FyTWFwcGluZywgY29sbGVjdGlvbjtcblxuICAgIGJlZm9yZUVhY2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBzLnJlc2V0KHRydWUpO1xuICAgICAgICBjb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24oJ215Q29sbGVjdGlvbicpO1xuICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXVxuICAgICAgICB9KTtcbiAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dldCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnYWxyZWFkeSBjYWNoZWQnLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBuZXcgU2llc3RhTW9kZWwoY2FyTWFwcGluZyk7XG4gICAgICAgICAgICB2YXIgcG91Y2hJZCA9ICdwb3VjaElkJztcbiAgICAgICAgICAgIG1vZGVsLl9pZCA9IHBvdWNoSWQ7XG4gICAgICAgICAgICBjYWNoZS5pbnNlcnQobW9kZWwpO1xuICAgICAgICAgICAgU3RvcmUuZ2V0KHtcbiAgICAgICAgICAgICAgICBfaWQ6IHBvdWNoSWRcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVyciwgZG9jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgZG9uZShlcnIpO1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChkb2MsIG1vZGVsKTtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ211bHRpcGxlJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdnZXRNdWx0aXBsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vVE9ET1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlc2NyaWJlKCdnZXRNdWx0aXBsZUxvY2FsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhcnM7XG5cbiAgICAgICAgICAgICAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbyA9IGNhck1hcHBpbmcuX25ldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdyZW1vdGVJZDEnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbzEgPSBjYXJNYXBwaW5nLl9uZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMidcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvMiA9IGNhck1hcHBpbmcuX25ldyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdncmVlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMydcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcnMgPSBbbywgbzEsIG8yXTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KG8pO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQobzEpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnNlcnQobzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaXQoJ3h5eicsIGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgU3RvcmUuZ2V0TXVsdGlwbGVMb2NhbChfLnBsdWNrKGNhcnMsICdfaWQnKSwgZnVuY3Rpb24oZXJyLCBkb2NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoZG9jcy5sZW5ndGgsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGRvY3MsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihkLCBTaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuXG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZXNjcmliZSgnZ2V0TXVsdGlwbGVSZW1vdGUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmliZSgnY2FjaGVkJywgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhcnM7XG5cbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlRWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvID0gY2FyTWFwcGluZy5fbmV3KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQxJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbzEgPSBjYXJNYXBwaW5nLl9uZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2JsdWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAncmVtb3RlSWQyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbzIgPSBjYXJNYXBwaW5nLl9uZXcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogJ2dyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogJ3JlbW90ZUlkMydcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FycyA9IFtvLCBvMSwgbzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5zZXJ0KG8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmluc2VydChvMik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGl0KCd4eXonLCBmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBTdG9yZS5nZXRNdWx0aXBsZVJlbW90ZShfLnBsdWNrKGNhcnMsICdpZCcpLCBjYXJNYXBwaW5nLCBmdW5jdGlvbihlcnIsIGRvY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSBkb25lKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGRvY3MubGVuZ3RoLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goZG9jcywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnQuaW5zdGFuY2VPZihkLCBTaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pXG5cblxuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG5cbn0pOyIsInZhciBzID0gcmVxdWlyZSgnLi4vaW5kZXgnKVxuICAgICwgYXNzZXJ0ID0gcmVxdWlyZSgnY2hhaScpLmFzc2VydDtcblxuZGVzY3JpYmUoJ3N1YmNsYXNzaW5nJywgZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIFNpZXN0YU1vZGVsID0gcmVxdWlyZSgnLi4vc3JjL29iamVjdCcpLlNpZXN0YU1vZGVsO1xuICAgIHZhciBJbnRlcm5hbFNpZXN0YUVycm9yID0gcmVxdWlyZSgnLi4vc3JjL2Vycm9yJykuSW50ZXJuYWxTaWVzdGFFcnJvcjtcbiAgICB2YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3NyYy9jb2xsZWN0aW9uJykuQ29sbGVjdGlvbjtcbiAgICB2YXIgY2FjaGUgPSByZXF1aXJlKCcuLi9zcmMvY2FjaGUnKTtcblxuICAgIHZhciBjb2xsZWN0aW9uLCBjYXJNYXBwaW5nO1xuXG4gICAgZnVuY3Rpb24gQ2FyT2JqZWN0KCkge1xuICAgICAgICBTaWVzdGFNb2RlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIENhck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpZXN0YU1vZGVsLnByb3RvdHlwZSk7XG5cbiAgICBiZWZvcmVFYWNoKGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIHMucmVzZXQodHJ1ZSk7XG4gICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbignQ2FyJyk7XG5cbiAgICAgICAgY29sbGVjdGlvbi5pbnN0YWxsKGRvbmUpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1hcHBpbmcobWFwcGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgbWFwcGluZy5pbnN0YWxsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLmluc3RhbGxSZWxhdGlvbnNoaXBzKCk7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5pbnN0YWxsUmV2ZXJzZVJlbGF0aW9uc2hpcHMoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpdCgnc2hvdWxkIGluc3RhbnRpYXRlIHdpdGggc3ViY2xhc3MgaWYgcHJlc2VudCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgc3ViY2xhc3M6IENhck9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgaW5zdGFsbE1hcHBpbmcoY2FyTWFwcGluZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNhciA9IGNhck1hcHBpbmcuX25ldyh7Y29sb3VyOiAncmVkJywgbmFtZTogJ0FzdG9uIE1hcnRpbid9KTtcbiAgICAgICAgICAgIGFzc2VydC5pbnN0YW5jZU9mKGNhciwgQ2FyT2JqZWN0KTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaW5zdGFudGlhdGUgd2l0aCBTaWVzdGFNb2RlbCBpZiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddXG4gICAgICAgIH0pO1xuICAgICAgICBpbnN0YWxsTWFwcGluZyhjYXJNYXBwaW5nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FyID0gY2FyTWFwcGluZy5fbmV3KHtjb2xvdXI6ICdyZWQnLCBuYW1lOiAnQXN0b24gTWFydGluJ30pO1xuICAgICAgICAgICAgYXNzZXJ0Lmluc3RhbmNlT2YoY2FyLCBTaWVzdGFNb2RlbCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGFuIGVycm9yIGlmIHNldHVwIHByb3RvdHlwZSwgYnV0IGRvIG5vdCBjYWxsIHN1cGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYXJPYmplY3QoKSB7fVxuXG4gICAgICAgIENhck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNpZXN0YU1vZGVsLnByb3RvdHlwZSk7XG4gICAgICAgIGFzc2VydC50aHJvd3MoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FyTWFwcGluZyA9IGNvbGxlY3Rpb24ubWFwcGluZygnQ2FyJywge1xuICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnY29sb3VyJywgJ25hbWUnXSxcbiAgICAgICAgICAgICAgICBzdWJjbGFzczogQ2FyT2JqZWN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgSW50ZXJuYWxTaWVzdGFFcnJvcik7XG4gICAgfSk7XG5cblxuICAgIGl0KCdzaG91bGQgdGhyb3cgYW4gZXJyb3IgaWYgZG8gbm90IGNhbGwgc3VwZXIgb3Igc2V0dXAgcHJvdG90eXBlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYXJPYmplY3QoKSB7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQudGhyb3dzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhck1hcHBpbmcgPSBjb2xsZWN0aW9uLm1hcHBpbmcoJ0NhcicsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2lkJyxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ2NvbG91cicsICduYW1lJ10sXG4gICAgICAgICAgICAgICAgc3ViY2xhc3M6IENhck9iamVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIEludGVybmFsU2llc3RhRXJyb3IpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiBkbyBub3QgdXNlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwcm90b3R5cGUsIGFzIHRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDYXJPYmplY3QoKSB7XG4gICAgICAgICAgICBTaWVzdGFNb2RlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQ2FyT2JqZWN0LnByb3RvdHlwZSA9IFNpZXN0YU1vZGVsLnByb3RvdHlwZTtcbiAgICAgICAgYXNzZXJ0LnRocm93cyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYXJNYXBwaW5nID0gY29sbGVjdGlvbi5tYXBwaW5nKCdDYXInLCB7XG4gICAgICAgICAgICAgICAgaWQ6ICdpZCcsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogWydjb2xvdXInLCAnbmFtZSddLFxuICAgICAgICAgICAgICAgIHN1YmNsYXNzOiBDYXJPYmplY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBJbnRlcm5hbFNpZXN0YUVycm9yKTtcbiAgICB9KTtcblxufSk7IiwidmFyIHMgPSByZXF1aXJlKCcuLi9pbmRleCcpXG4gICAgLCBhc3NlcnQgPSByZXF1aXJlKCdjaGFpJykuYXNzZXJ0O1xuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vc3JjL3V0aWwnKTtcbnZhciBxID0gcmVxdWlyZSgncScpO1xuXG5kZXNjcmliZSgnY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcicsIGZ1bmN0aW9uICgpIHtcbiAgICBkZXNjcmliZSgnbm8gZXJyb3Igb3IgcmVzdWx0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBkb1NvbWV0aGluZ1dpdGhOb0Vycm9yT3JSZXN1bHQgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0KCdwcm9taXNlIHJldHVybnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgICAgICAgICAgZG9Tb21ldGhpbmdXaXRoTm9FcnJvck9yUmVzdWx0ICh1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIobnVsbCwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdjYWxsYmFjayByZXR1cm5zJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIGRvU29tZXRoaW5nV2l0aE5vRXJyb3JPclJlc3VsdCAodXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGRvbmUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Byb21pc2UgJiBjYWxsYmFjayByZXR1cm5zJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja1JldHVybmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZVJldHVybmVkID0gZmFsc2U7XG4gICAgICAgICAgICBkb1NvbWV0aGluZ1dpdGhOb0Vycm9yT3JSZXN1bHQodXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja1JldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tSZXR1cm5lZCAmJiBwcm9taXNlUmV0dXJuZWQpIGRvbmUoKTtcbiAgICAgICAgICAgIH0sIGRlZmVycmVkKSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VSZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmV0dXJuZWQgJiYgcHJvbWlzZVJldHVybmVkKSBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnYW4gZXJyb3IsIG5vIHJlc3VsdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZG9Tb21ldGhpbmdXaXRoQW5FcnJvciAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCdzb21lIGVycm9yJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0KCdwcm9taXNlIHJldHVybnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgICAgICAgICAgZG9Tb21ldGhpbmdXaXRoQW5FcnJvciAodXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKG51bGwsIGRlZmVycmVkKSk7XG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlLmZhaWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnY2FsbGJhY2sgcmV0dXJucycsIGZ1bmN0aW9uIChkb25lKSB7XG4gICAgICAgICAgICBkb1NvbWV0aGluZ1dpdGhBbkVycm9yICh1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGFzc2VydC5vayhlcnIpO1xuICAgICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Byb21pc2UgJiBjYWxsYmFjayByZXR1cm5zJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja1JldHVybmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZVJldHVybmVkID0gZmFsc2U7XG4gICAgICAgICAgICBkb1NvbWV0aGluZ1dpdGhBbkVycm9yKHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm9rKGVycik7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tSZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmV0dXJuZWQgJiYgcHJvbWlzZVJldHVybmVkKSBkb25lKCk7XG4gICAgICAgICAgICB9LCBkZWZlcnJlZCkpO1xuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS5mYWlsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlUmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1JldHVybmVkICYmIHByb21pc2VSZXR1cm5lZCkgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ25vIGVycm9yIGFuZCBhIHNpbmdsZSByZXN1bHQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGRvU29tZXRoaW5nV2l0aE5vRXJyb3JBbmRBU2luZ2xlUmVzdWx0IChjYWxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3Jlc3VsdCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpdCgncHJvbWlzZSByZXR1cm5zJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9IHEuZGVmZXIoKTtcbiAgICAgICAgICAgIGRvU29tZXRoaW5nV2l0aE5vRXJyb3JBbmRBU2luZ2xlUmVzdWx0KHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihudWxsLCBkZWZlcnJlZCkpO1xuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2NhbGxiYWNrIHJldHVybnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgZG9Tb21ldGhpbmdXaXRoTm9FcnJvckFuZEFTaW5nbGVSZXN1bHQgKHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQubm90T2soZXJyKTtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzLCAncmVzdWx0Jyk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgncHJvbWlzZSAmIGNhbGxiYWNrIHJldHVybnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrUmV0dXJuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlUmV0dXJuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvU29tZXRoaW5nV2l0aE5vRXJyb3JBbmRBU2luZ2xlUmVzdWx0KHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tSZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmV0dXJuZWQgJiYgcHJvbWlzZVJldHVybmVkKSBkb25lKCk7XG4gICAgICAgICAgICB9LCBkZWZlcnJlZCkpO1xuICAgICAgICAgICAgZGVmZXJyZWQucHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzLCAncmVzdWx0Jyk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tSZXR1cm5lZCAmJiBwcm9taXNlUmV0dXJuZWQpIGRvbmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ25vIGVycm9yIGFuZCBtdWx0aXBsZSByZXN1bHRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBkb1NvbWV0aGluZ1dpdGhOb0Vycm9yQW5kTXVsdGlwbGVSZXN1bHRzIChjYWxsYmFjaykge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3Jlc3VsdDEnLCAncmVzdWx0MicsICdyZXN1bHQzJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0KCdwcm9taXNlIHJldHVybnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgICAgICAgICAgZG9Tb21ldGhpbmdXaXRoTm9FcnJvckFuZE11bHRpcGxlUmVzdWx0cyh1dGlsLmNvbnN0cnVjdENhbGxiYWNrQW5kUHJvbWlzZUhhbmRsZXIobnVsbCwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdjYWxsYmFjayByZXR1cm5zJywgZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgICAgIGRvU29tZXRoaW5nV2l0aE5vRXJyb3JBbmRNdWx0aXBsZVJlc3VsdHMgKHV0aWwuY29uc3RydWN0Q2FsbGJhY2tBbmRQcm9taXNlSGFuZGxlcihmdW5jdGlvbiAoZXJyLCByZXMxLCByZXMyLCByZXMzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKGVycik7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlczEsICdyZXN1bHQxJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlczIsICdyZXN1bHQyJyk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlczMsICdyZXN1bHQzJyk7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgncHJvbWlzZSAmIGNhbGxiYWNrIHJldHVybnMnLCBmdW5jdGlvbiAoZG9uZSkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrUmV0dXJuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlUmV0dXJuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvU29tZXRoaW5nV2l0aE5vRXJyb3JBbmRNdWx0aXBsZVJlc3VsdHModXRpbC5jb25zdHJ1Y3RDYWxsYmFja0FuZFByb21pc2VIYW5kbGVyKGZ1bmN0aW9uIChlcnIsIHJlczEsIHJlczIsIHJlczMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwocmVzMSwgJ3Jlc3VsdDEnKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHJlczIsICdyZXN1bHQyJyk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXMzLCAncmVzdWx0MycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBkb25lKGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrUmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1JldHVybmVkICYmIHByb21pc2VSZXR1cm5lZCkgZG9uZSgpO1xuICAgICAgICAgICAgfSwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgIGRlZmVycmVkLnByb21pc2UudGhlbihmdW5jdGlvbiAocmVzMSwgcmVzMiwgcmVzMykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChyZXMxLCAncmVzdWx0MScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9taXNlIHJlc29sdXRpb24gb25seSBhY2NlcHRzIG9uZSByZXN1bHQuLi5cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Lm5vdE9rKHJlczIpO1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnQubm90T2socmVzMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb21pc2VSZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrUmV0dXJuZWQgJiYgcHJvbWlzZVJldHVybmVkKSBkb25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cblxuXG5cblxufSk7IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdGVzdGluZ0V4cG9zZUN5Y2xlQ291bnQgPSBnbG9iYWwudGVzdGluZ0V4cG9zZUN5Y2xlQ291bnQ7XG5cbiAgLy8gRGV0ZWN0IGFuZCBkbyBiYXNpYyBzYW5pdHkgY2hlY2tpbmcgb24gT2JqZWN0L0FycmF5Lm9ic2VydmUuXG4gIGZ1bmN0aW9uIGRldGVjdE9iamVjdE9ic2VydmUoKSB7XG4gICAgaWYgKHR5cGVvZiBPYmplY3Qub2JzZXJ2ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgQXJyYXkub2JzZXJ2ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByZWNvcmRzID0gW107XG5cbiAgICBmdW5jdGlvbiBjYWxsYmFjayhyZWNzKSB7XG4gICAgICByZWNvcmRzID0gcmVjcztcbiAgICB9XG5cbiAgICB2YXIgdGVzdCA9IHt9O1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICBPYmplY3Qub2JzZXJ2ZSh0ZXN0LCBjYWxsYmFjayk7XG4gICAgQXJyYXkub2JzZXJ2ZShhcnIsIGNhbGxiYWNrKTtcbiAgICB0ZXN0LmlkID0gMTtcbiAgICB0ZXN0LmlkID0gMjtcbiAgICBkZWxldGUgdGVzdC5pZDtcbiAgICBhcnIucHVzaCgxLCAyKTtcbiAgICBhcnIubGVuZ3RoID0gMDtcblxuICAgIE9iamVjdC5kZWxpdmVyQ2hhbmdlUmVjb3JkcyhjYWxsYmFjayk7XG4gICAgaWYgKHJlY29yZHMubGVuZ3RoICE9PSA1KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKHJlY29yZHNbMF0udHlwZSAhPSAnYWRkJyB8fFxuICAgICAgICByZWNvcmRzWzFdLnR5cGUgIT0gJ3VwZGF0ZScgfHxcbiAgICAgICAgcmVjb3Jkc1syXS50eXBlICE9ICdkZWxldGUnIHx8XG4gICAgICAgIHJlY29yZHNbM10udHlwZSAhPSAnc3BsaWNlJyB8fFxuICAgICAgICByZWNvcmRzWzRdLnR5cGUgIT0gJ3NwbGljZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBPYmplY3QudW5vYnNlcnZlKHRlc3QsIGNhbGxiYWNrKTtcbiAgICBBcnJheS51bm9ic2VydmUoYXJyLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoYXNPYnNlcnZlID0gZGV0ZWN0T2JqZWN0T2JzZXJ2ZSgpO1xuXG4gIGZ1bmN0aW9uIGRldGVjdEV2YWwoKSB7XG4gICAgLy8gRG9uJ3QgdGVzdCBmb3IgZXZhbCBpZiB3ZSdyZSBydW5uaW5nIGluIGEgQ2hyb21lIEFwcCBlbnZpcm9ubWVudC5cbiAgICAvLyBXZSBjaGVjayBmb3IgQVBJcyBzZXQgdGhhdCBvbmx5IGV4aXN0IGluIGEgQ2hyb21lIEFwcCBjb250ZXh0LlxuICAgIGlmICh0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJyAmJiBjaHJvbWUuYXBwICYmIGNocm9tZS5hcHAucnVudGltZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEZpcmVmb3ggT1MgQXBwcyBkbyBub3QgYWxsb3cgZXZhbC4gVGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpcyB2ZXJ5IGhhY2t5XG4gICAgLy8gYnV0IGV2ZW4gaWYgc29tZSBvdGhlciBwbGF0Zm9ybSBhZGRzIHN1cHBvcnQgZm9yIHRoaXMgZnVuY3Rpb24gdGhpcyBjb2RlXG4gICAgLy8gd2lsbCBjb250aW51ZSB0byB3b3JrLlxuICAgIGlmIChuYXZpZ2F0b3IuZ2V0RGV2aWNlU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgZiA9IG5ldyBGdW5jdGlvbignJywgJ3JldHVybiB0cnVlOycpO1xuICAgICAgcmV0dXJuIGYoKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYXNFdmFsID0gZGV0ZWN0RXZhbCgpO1xuXG4gIGZ1bmN0aW9uIGlzSW5kZXgocykge1xuICAgIHJldHVybiArcyA9PT0gcyA+Pj4gMCAmJiBzICE9PSAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvTnVtYmVyKHMpIHtcbiAgICByZXR1cm4gK3M7XG4gIH1cblxuICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbiAgfVxuXG4gIHZhciBudW1iZXJJc05hTiA9IGdsb2JhbC5OdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBnbG9iYWwuaXNOYU4odmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlU2FtZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQgPT09IHJpZ2h0KVxuICAgICAgcmV0dXJuIGxlZnQgIT09IDAgfHwgMSAvIGxlZnQgPT09IDEgLyByaWdodDtcbiAgICBpZiAobnVtYmVySXNOYU4obGVmdCkgJiYgbnVtYmVySXNOYU4ocmlnaHQpKVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gbGVmdCAhPT0gbGVmdCAmJiByaWdodCAhPT0gcmlnaHQ7XG4gIH1cblxuICB2YXIgY3JlYXRlT2JqZWN0ID0gKCdfX3Byb3RvX18nIGluIHt9KSA/XG4gICAgZnVuY3Rpb24ob2JqKSB7IHJldHVybiBvYmo7IH0gOlxuICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHByb3RvID0gb2JqLl9fcHJvdG9fXztcbiAgICAgIGlmICghcHJvdG8pXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB2YXIgbmV3T2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqZWN0LCBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgbmFtZSkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgIH07XG5cbiAgdmFyIGlkZW50U3RhcnQgPSAnW1xcJF9hLXpBLVpdJztcbiAgdmFyIGlkZW50UGFydCA9ICdbXFwkX2EtekEtWjAtOV0nO1xuICB2YXIgaWRlbnRSZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIGlkZW50U3RhcnQgKyAnKycgKyBpZGVudFBhcnQgKyAnKicgKyAnJCcpO1xuXG4gIGZ1bmN0aW9uIGdldFBhdGhDaGFyVHlwZShjaGFyKSB7XG4gICAgaWYgKGNoYXIgPT09IHVuZGVmaW5lZClcbiAgICAgIHJldHVybiAnZW9mJztcblxuICAgIHZhciBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xuXG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgIGNhc2UgMHg1QjogLy8gW1xuICAgICAgY2FzZSAweDVEOiAvLyBdXG4gICAgICBjYXNlIDB4MkU6IC8vIC5cbiAgICAgIGNhc2UgMHgyMjogLy8gXCJcbiAgICAgIGNhc2UgMHgyNzogLy8gJ1xuICAgICAgY2FzZSAweDMwOiAvLyAwXG4gICAgICAgIHJldHVybiBjaGFyO1xuXG4gICAgICBjYXNlIDB4NUY6IC8vIF9cbiAgICAgIGNhc2UgMHgyNDogLy8gJFxuICAgICAgICByZXR1cm4gJ2lkZW50JztcblxuICAgICAgY2FzZSAweDIwOiAvLyBTcGFjZVxuICAgICAgY2FzZSAweDA5OiAvLyBUYWJcbiAgICAgIGNhc2UgMHgwQTogLy8gTmV3bGluZVxuICAgICAgY2FzZSAweDBEOiAvLyBSZXR1cm5cbiAgICAgIGNhc2UgMHhBMDogIC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgICBjYXNlIDB4RkVGRjogIC8vIEJ5dGUgT3JkZXIgTWFya1xuICAgICAgY2FzZSAweDIwMjg6ICAvLyBMaW5lIFNlcGFyYXRvclxuICAgICAgY2FzZSAweDIwMjk6ICAvLyBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gICAgICAgIHJldHVybiAnd3MnO1xuICAgIH1cblxuICAgIC8vIGEteiwgQS1aXG4gICAgaWYgKCgweDYxIDw9IGNvZGUgJiYgY29kZSA8PSAweDdBKSB8fCAoMHg0MSA8PSBjb2RlICYmIGNvZGUgPD0gMHg1QSkpXG4gICAgICByZXR1cm4gJ2lkZW50JztcblxuICAgIC8vIDEtOVxuICAgIGlmICgweDMxIDw9IGNvZGUgJiYgY29kZSA8PSAweDM5KVxuICAgICAgcmV0dXJuICdudW1iZXInO1xuXG4gICAgcmV0dXJuICdlbHNlJztcbiAgfVxuXG4gIHZhciBwYXRoU3RhdGVNYWNoaW5lID0ge1xuICAgICdiZWZvcmVQYXRoJzoge1xuICAgICAgJ3dzJzogWydiZWZvcmVQYXRoJ10sXG4gICAgICAnaWRlbnQnOiBbJ2luSWRlbnQnLCAnYXBwZW5kJ10sXG4gICAgICAnWyc6IFsnYmVmb3JlRWxlbWVudCddLFxuICAgICAgJ2VvZic6IFsnYWZ0ZXJQYXRoJ11cbiAgICB9LFxuXG4gICAgJ2luUGF0aCc6IHtcbiAgICAgICd3cyc6IFsnaW5QYXRoJ10sXG4gICAgICAnLic6IFsnYmVmb3JlSWRlbnQnXSxcbiAgICAgICdbJzogWydiZWZvcmVFbGVtZW50J10sXG4gICAgICAnZW9mJzogWydhZnRlclBhdGgnXVxuICAgIH0sXG5cbiAgICAnYmVmb3JlSWRlbnQnOiB7XG4gICAgICAnd3MnOiBbJ2JlZm9yZUlkZW50J10sXG4gICAgICAnaWRlbnQnOiBbJ2luSWRlbnQnLCAnYXBwZW5kJ11cbiAgICB9LFxuXG4gICAgJ2luSWRlbnQnOiB7XG4gICAgICAnaWRlbnQnOiBbJ2luSWRlbnQnLCAnYXBwZW5kJ10sXG4gICAgICAnMCc6IFsnaW5JZGVudCcsICdhcHBlbmQnXSxcbiAgICAgICdudW1iZXInOiBbJ2luSWRlbnQnLCAnYXBwZW5kJ10sXG4gICAgICAnd3MnOiBbJ2luUGF0aCcsICdwdXNoJ10sXG4gICAgICAnLic6IFsnYmVmb3JlSWRlbnQnLCAncHVzaCddLFxuICAgICAgJ1snOiBbJ2JlZm9yZUVsZW1lbnQnLCAncHVzaCddLFxuICAgICAgJ2VvZic6IFsnYWZ0ZXJQYXRoJywgJ3B1c2gnXVxuICAgIH0sXG5cbiAgICAnYmVmb3JlRWxlbWVudCc6IHtcbiAgICAgICd3cyc6IFsnYmVmb3JlRWxlbWVudCddLFxuICAgICAgJzAnOiBbJ2FmdGVyWmVybycsICdhcHBlbmQnXSxcbiAgICAgICdudW1iZXInOiBbJ2luSW5kZXgnLCAnYXBwZW5kJ10sXG4gICAgICBcIidcIjogWydpblNpbmdsZVF1b3RlJywgJ2FwcGVuZCcsICcnXSxcbiAgICAgICdcIic6IFsnaW5Eb3VibGVRdW90ZScsICdhcHBlbmQnLCAnJ11cbiAgICB9LFxuXG4gICAgJ2FmdGVyWmVybyc6IHtcbiAgICAgICd3cyc6IFsnYWZ0ZXJFbGVtZW50JywgJ3B1c2gnXSxcbiAgICAgICddJzogWydpblBhdGgnLCAncHVzaCddXG4gICAgfSxcblxuICAgICdpbkluZGV4Jzoge1xuICAgICAgJzAnOiBbJ2luSW5kZXgnLCAnYXBwZW5kJ10sXG4gICAgICAnbnVtYmVyJzogWydpbkluZGV4JywgJ2FwcGVuZCddLFxuICAgICAgJ3dzJzogWydhZnRlckVsZW1lbnQnXSxcbiAgICAgICddJzogWydpblBhdGgnLCAncHVzaCddXG4gICAgfSxcblxuICAgICdpblNpbmdsZVF1b3RlJzoge1xuICAgICAgXCInXCI6IFsnYWZ0ZXJFbGVtZW50J10sXG4gICAgICAnZW9mJzogWydlcnJvciddLFxuICAgICAgJ2Vsc2UnOiBbJ2luU2luZ2xlUXVvdGUnLCAnYXBwZW5kJ11cbiAgICB9LFxuXG4gICAgJ2luRG91YmxlUXVvdGUnOiB7XG4gICAgICAnXCInOiBbJ2FmdGVyRWxlbWVudCddLFxuICAgICAgJ2VvZic6IFsnZXJyb3InXSxcbiAgICAgICdlbHNlJzogWydpbkRvdWJsZVF1b3RlJywgJ2FwcGVuZCddXG4gICAgfSxcblxuICAgICdhZnRlckVsZW1lbnQnOiB7XG4gICAgICAnd3MnOiBbJ2FmdGVyRWxlbWVudCddLFxuICAgICAgJ10nOiBbJ2luUGF0aCcsICdwdXNoJ11cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIGMsIG5ld0NoYXIsIGtleSwgdHlwZSwgdHJhbnNpdGlvbiwgYWN0aW9uLCB0eXBlTWFwLCBtb2RlID0gJ2JlZm9yZVBhdGgnO1xuXG4gICAgdmFyIGFjdGlvbnMgPSB7XG4gICAgICBwdXNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcblxuICAgICAgYXBwZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGtleSA9IG5ld0NoYXJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGtleSArPSBuZXdDaGFyO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYXliZVVuZXNjYXBlUXVvdGUoKSB7XG4gICAgICBpZiAoaW5kZXggPj0gcGF0aC5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgdmFyIG5leHRDaGFyID0gcGF0aFtpbmRleCArIDFdO1xuICAgICAgaWYgKChtb2RlID09ICdpblNpbmdsZVF1b3RlJyAmJiBuZXh0Q2hhciA9PSBcIidcIikgfHxcbiAgICAgICAgICAobW9kZSA9PSAnaW5Eb3VibGVRdW90ZScgJiYgbmV4dENoYXIgPT0gJ1wiJykpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgbmV3Q2hhciA9IG5leHRDaGFyO1xuICAgICAgICBhY3Rpb25zLmFwcGVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAobW9kZSkge1xuICAgICAgaW5kZXgrKztcbiAgICAgIGMgPSBwYXRoW2luZGV4XTtcblxuICAgICAgaWYgKGMgPT0gJ1xcXFwnICYmIG1heWJlVW5lc2NhcGVRdW90ZShtb2RlKSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIHR5cGUgPSBnZXRQYXRoQ2hhclR5cGUoYyk7XG4gICAgICB0eXBlTWFwID0gcGF0aFN0YXRlTWFjaGluZVttb2RlXTtcbiAgICAgIHRyYW5zaXRpb24gPSB0eXBlTWFwW3R5cGVdIHx8IHR5cGVNYXBbJ2Vsc2UnXSB8fCAnZXJyb3InO1xuXG4gICAgICBpZiAodHJhbnNpdGlvbiA9PSAnZXJyb3InKVxuICAgICAgICByZXR1cm47IC8vIHBhcnNlIGVycm9yO1xuXG4gICAgICBtb2RlID0gdHJhbnNpdGlvblswXTtcbiAgICAgIGFjdGlvbiA9IGFjdGlvbnNbdHJhbnNpdGlvblsxXV0gfHwgbm9vcDtcbiAgICAgIG5ld0NoYXIgPSB0cmFuc2l0aW9uWzJdID09PSB1bmRlZmluZWQgPyBjIDogdHJhbnNpdGlvblsyXTtcbiAgICAgIGFjdGlvbigpO1xuXG4gICAgICBpZiAobW9kZSA9PT0gJ2FmdGVyUGF0aCcpIHtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuOyAvLyBwYXJzZSBlcnJvclxuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudChzKSB7XG4gICAgcmV0dXJuIGlkZW50UmVnRXhwLnRlc3Qocyk7XG4gIH1cblxuICB2YXIgY29uc3RydWN0b3JJc1ByaXZhdGUgPSB7fTtcblxuICBmdW5jdGlvbiBQYXRoKHBhcnRzLCBwcml2YXRlVG9rZW4pIHtcbiAgICBpZiAocHJpdmF0ZVRva2VuICE9PSBjb25zdHJ1Y3RvcklzUHJpdmF0ZSlcbiAgICAgIHRocm93IEVycm9yKCdVc2UgUGF0aC5nZXQgdG8gcmV0cmlldmUgcGF0aCBvYmplY3RzJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnB1c2goU3RyaW5nKHBhcnRzW2ldKSk7XG4gICAgfVxuXG4gICAgaWYgKGhhc0V2YWwgJiYgdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZ2V0VmFsdWVGcm9tID0gdGhpcy5jb21waWxlZEdldFZhbHVlRnJvbUZuKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETyhyYWZhZWx3KTogTWFrZSBzaW1wbGUgTFJVIGNhY2hlXG4gIHZhciBwYXRoQ2FjaGUgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRQYXRoKHBhdGhTdHJpbmcpIHtcbiAgICBpZiAocGF0aFN0cmluZyBpbnN0YW5jZW9mIFBhdGgpXG4gICAgICByZXR1cm4gcGF0aFN0cmluZztcblxuICAgIGlmIChwYXRoU3RyaW5nID09IG51bGwgfHwgcGF0aFN0cmluZy5sZW5ndGggPT0gMClcbiAgICAgIHBhdGhTdHJpbmcgPSAnJztcblxuICAgIGlmICh0eXBlb2YgcGF0aFN0cmluZyAhPSAnc3RyaW5nJykge1xuICAgICAgaWYgKGlzSW5kZXgocGF0aFN0cmluZy5sZW5ndGgpKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdGVkIHdpdGggYXJyYXktbGlrZSAocHJlLXBhcnNlZCkga2V5c1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgocGF0aFN0cmluZywgY29uc3RydWN0b3JJc1ByaXZhdGUpO1xuICAgICAgfVxuXG4gICAgICBwYXRoU3RyaW5nID0gU3RyaW5nKHBhdGhTdHJpbmcpO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gcGF0aENhY2hlW3BhdGhTdHJpbmddO1xuICAgIGlmIChwYXRoKVxuICAgICAgcmV0dXJuIHBhdGg7XG5cbiAgICB2YXIgcGFydHMgPSBwYXJzZVBhdGgocGF0aFN0cmluZyk7XG4gICAgaWYgKCFwYXJ0cylcbiAgICAgIHJldHVybiBpbnZhbGlkUGF0aDtcblxuICAgIHZhciBwYXRoID0gbmV3IFBhdGgocGFydHMsIGNvbnN0cnVjdG9ySXNQcml2YXRlKTtcbiAgICBwYXRoQ2FjaGVbcGF0aFN0cmluZ10gPSBwYXRoO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgUGF0aC5nZXQgPSBnZXRQYXRoO1xuXG4gIGZ1bmN0aW9uIGZvcm1hdEFjY2Vzc29yKGtleSkge1xuICAgIGlmIChpc0luZGV4KGtleSkpIHtcbiAgICAgIHJldHVybiAnWycgKyBrZXkgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnW1wiJyArIGtleS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCJdJztcbiAgICB9XG4gIH1cblxuICBQYXRoLnByb3RvdHlwZSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgX19wcm90b19fOiBbXSxcbiAgICB2YWxpZDogdHJ1ZSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRoU3RyaW5nID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXNbaV07XG4gICAgICAgIGlmIChpc0lkZW50KGtleSkpIHtcbiAgICAgICAgICBwYXRoU3RyaW5nICs9IGkgPyAnLicgKyBrZXkgOiBrZXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aFN0cmluZyArPSBmb3JtYXRBY2Nlc3NvcihrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoU3RyaW5nO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZUZyb206IGZ1bmN0aW9uKG9iaiwgZGlyZWN0T2JzZXJ2ZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAob2JqID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvYmogPSBvYmpbdGhpc1tpXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICBpdGVyYXRlT2JqZWN0czogZnVuY3Rpb24ob2JqLCBvYnNlcnZlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgb2JqID0gb2JqW3RoaXNbaSAtIDFdXTtcbiAgICAgICAgaWYgKCFpc09iamVjdChvYmopKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb2JzZXJ2ZShvYmosIHRoaXNbMF0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21waWxlZEdldFZhbHVlRnJvbUZuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIHZhciBwYXRoU3RyaW5nID0gJ29iaic7XG4gICAgICBzdHIgKz0gJ2lmIChvYmogIT0gbnVsbCc7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yICg7IGkgPCAodGhpcy5sZW5ndGggLSAxKTsgaSsrKSB7XG4gICAgICAgIGtleSA9IHRoaXNbaV07XG4gICAgICAgIHBhdGhTdHJpbmcgKz0gaXNJZGVudChrZXkpID8gJy4nICsga2V5IDogZm9ybWF0QWNjZXNzb3Ioa2V5KTtcbiAgICAgICAgc3RyICs9ICcgJiZcXG4gICAgICcgKyBwYXRoU3RyaW5nICsgJyAhPSBudWxsJztcbiAgICAgIH1cbiAgICAgIHN0ciArPSAnKVxcbic7XG5cbiAgICAgIHZhciBrZXkgPSB0aGlzW2ldO1xuICAgICAgcGF0aFN0cmluZyArPSBpc0lkZW50KGtleSkgPyAnLicgKyBrZXkgOiBmb3JtYXRBY2Nlc3NvcihrZXkpO1xuXG4gICAgICBzdHIgKz0gJyAgcmV0dXJuICcgKyBwYXRoU3RyaW5nICsgJztcXG5lbHNlXFxuICByZXR1cm4gdW5kZWZpbmVkOyc7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCdvYmonLCBzdHIpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZUZyb206IGZ1bmN0aW9uKG9iaiwgdmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBvYmogPSBvYmpbdGhpc1tpXV07XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNPYmplY3Qob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBvYmpbdGhpc1tpXV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGludmFsaWRQYXRoID0gbmV3IFBhdGgoJycsIGNvbnN0cnVjdG9ySXNQcml2YXRlKTtcbiAgaW52YWxpZFBhdGgudmFsaWQgPSBmYWxzZTtcbiAgaW52YWxpZFBhdGguZ2V0VmFsdWVGcm9tID0gaW52YWxpZFBhdGguc2V0VmFsdWVGcm9tID0gZnVuY3Rpb24oKSB7fTtcblxuICB2YXIgTUFYX0RJUlRZX0NIRUNLX0NZQ0xFUyA9IDEwMDA7XG5cbiAgZnVuY3Rpb24gZGlydHlDaGVjayhvYnNlcnZlcikge1xuICAgIHZhciBjeWNsZXMgPSAwO1xuICAgIHdoaWxlIChjeWNsZXMgPCBNQVhfRElSVFlfQ0hFQ0tfQ1lDTEVTICYmIG9ic2VydmVyLmNoZWNrXygpKSB7XG4gICAgICBjeWNsZXMrKztcbiAgICB9XG4gICAgaWYgKHRlc3RpbmdFeHBvc2VDeWNsZUNvdW50KVxuICAgICAgZ2xvYmFsLmRpcnR5Q2hlY2tDeWNsZUNvdW50ID0gY3ljbGVzO1xuXG4gICAgcmV0dXJuIGN5Y2xlcyA+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBvYmplY3RJc0VtcHR5KG9iamVjdCkge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlmZklzRW1wdHkoZGlmZikge1xuICAgIHJldHVybiBvYmplY3RJc0VtcHR5KGRpZmYuYWRkZWQpICYmXG4gICAgICAgICAgIG9iamVjdElzRW1wdHkoZGlmZi5yZW1vdmVkKSAmJlxuICAgICAgICAgICBvYmplY3RJc0VtcHR5KGRpZmYuY2hhbmdlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaWZmT2JqZWN0RnJvbU9sZE9iamVjdChvYmplY3QsIG9sZE9iamVjdCkge1xuICAgIHZhciBhZGRlZCA9IHt9O1xuICAgIHZhciByZW1vdmVkID0ge307XG4gICAgdmFyIGNoYW5nZWQgPSB7fTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gb2xkT2JqZWN0KSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSBvYmplY3RbcHJvcF07XG5cbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIG5ld1ZhbHVlID09PSBvbGRPYmplY3RbcHJvcF0pXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoIShwcm9wIGluIG9iamVjdCkpIHtcbiAgICAgICAgcmVtb3ZlZFtwcm9wXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkT2JqZWN0W3Byb3BdKVxuICAgICAgICBjaGFuZ2VkW3Byb3BdID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChwcm9wIGluIG9sZE9iamVjdClcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGFkZGVkW3Byb3BdID0gb2JqZWN0W3Byb3BdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgJiYgb2JqZWN0Lmxlbmd0aCAhPT0gb2xkT2JqZWN0Lmxlbmd0aClcbiAgICAgIGNoYW5nZWQubGVuZ3RoID0gb2JqZWN0Lmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBhZGRlZDogYWRkZWQsXG4gICAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgICAgY2hhbmdlZDogY2hhbmdlZFxuICAgIH07XG4gIH1cblxuICB2YXIgZW9tVGFza3MgPSBbXTtcbiAgZnVuY3Rpb24gcnVuRU9NVGFza3MoKSB7XG4gICAgaWYgKCFlb21UYXNrcy5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVvbVRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlb21UYXNrc1tpXSgpO1xuICAgIH1cbiAgICBlb21UYXNrcy5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIHJ1bkVPTSA9IGhhc09ic2VydmUgPyAoZnVuY3Rpb24oKXtcbiAgICB2YXIgZW9tT2JqID0geyBwaW5nUG9uZzogdHJ1ZSB9O1xuICAgIHZhciBlb21SdW5TY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIE9iamVjdC5vYnNlcnZlKGVvbU9iaiwgZnVuY3Rpb24oKSB7XG4gICAgICBydW5FT01UYXNrcygpO1xuICAgICAgZW9tUnVuU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgIGVvbVRhc2tzLnB1c2goZm4pO1xuICAgICAgaWYgKCFlb21SdW5TY2hlZHVsZWQpIHtcbiAgICAgICAgZW9tUnVuU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgZW9tT2JqLnBpbmdQb25nID0gIWVvbU9iai5waW5nUG9uZztcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgZW9tVGFza3MucHVzaChmbik7XG4gICAgfTtcbiAgfSkoKTtcblxuICB2YXIgb2JzZXJ2ZWRPYmplY3RDYWNoZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIG5ld09ic2VydmVkT2JqZWN0KCkge1xuICAgIHZhciBvYnNlcnZlcjtcbiAgICB2YXIgb2JqZWN0O1xuICAgIHZhciBkaXNjYXJkUmVjb3JkcyA9IGZhbHNlO1xuICAgIHZhciBmaXJzdCA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBjYWxsYmFjayhyZWNvcmRzKSB7XG4gICAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIuc3RhdGVfID09PSBPUEVORUQgJiYgIWRpc2NhcmRSZWNvcmRzKVxuICAgICAgICBvYnNlcnZlci5jaGVja18ocmVjb3Jkcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW46IGZ1bmN0aW9uKG9icykge1xuICAgICAgICBpZiAob2JzZXJ2ZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ09ic2VydmVkT2JqZWN0IGluIHVzZScpO1xuXG4gICAgICAgIGlmICghZmlyc3QpXG4gICAgICAgICAgT2JqZWN0LmRlbGl2ZXJDaGFuZ2VSZWNvcmRzKGNhbGxiYWNrKTtcblxuICAgICAgICBvYnNlcnZlciA9IG9icztcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlOiBmdW5jdGlvbihvYmosIGFycmF5T2JzZXJ2ZSkge1xuICAgICAgICBvYmplY3QgPSBvYmo7XG4gICAgICAgIGlmIChhcnJheU9ic2VydmUpXG4gICAgICAgICAgQXJyYXkub2JzZXJ2ZShvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE9iamVjdC5vYnNlcnZlKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfSxcbiAgICAgIGRlbGl2ZXI6IGZ1bmN0aW9uKGRpc2NhcmQpIHtcbiAgICAgICAgZGlzY2FyZFJlY29yZHMgPSBkaXNjYXJkO1xuICAgICAgICBPYmplY3QuZGVsaXZlckNoYW5nZVJlY29yZHMoY2FsbGJhY2spO1xuICAgICAgICBkaXNjYXJkUmVjb3JkcyA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIE9iamVjdC51bm9ic2VydmUob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICAgIG9ic2VydmVkT2JqZWN0Q2FjaGUucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLypcbiAgICogVGhlIG9ic2VydmVkU2V0IGFic3RyYWN0aW9uIGlzIGEgcGVyZiBvcHRpbWl6YXRpb24gd2hpY2ggcmVkdWNlcyB0aGUgdG90YWxcbiAgICogbnVtYmVyIG9mIE9iamVjdC5vYnNlcnZlIG9ic2VydmF0aW9ucyBvZiBhIHNldCBvZiBvYmplY3RzLiBUaGUgaWRlYSBpcyB0aGF0XG4gICAqIGdyb3VwcyBvZiBPYnNlcnZlcnMgd2lsbCBoYXZlIHNvbWUgb2JqZWN0IGRlcGVuZGVuY2llcyBpbiBjb21tb24gYW5kIHRoaXNcbiAgICogb2JzZXJ2ZWQgc2V0IGVuc3VyZXMgdGhhdCBlYWNoIG9iamVjdCBpbiB0aGUgdHJhbnNpdGl2ZSBjbG9zdXJlIG9mXG4gICAqIGRlcGVuZGVuY2llcyBpcyBvbmx5IG9ic2VydmVkIG9uY2UuIFRoZSBvYnNlcnZlZFNldCBhY3RzIGFzIGEgd3JpdGUgYmFycmllclxuICAgKiBzdWNoIHRoYXQgd2hlbmV2ZXIgYW55IGNoYW5nZSBjb21lcyB0aHJvdWdoLCBhbGwgT2JzZXJ2ZXJzIGFyZSBjaGVja2VkIGZvclxuICAgKiBjaGFuZ2VkIHZhbHVlcy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgb3B0aW1pemF0aW9uIGlzIGV4cGxpY2l0bHkgbW92aW5nIHdvcmsgZnJvbSBzZXR1cC10aW1lIHRvXG4gICAqIGNoYW5nZS10aW1lLlxuICAgKlxuICAgKiBUT0RPKHJhZmFlbHcpOiBJbXBsZW1lbnQgXCJnYXJiYWdlIGNvbGxlY3Rpb25cIi4gSW4gb3JkZXIgdG8gbW92ZSB3b3JrIG9mZlxuICAgKiB0aGUgY3JpdGljYWwgcGF0aCwgd2hlbiBPYnNlcnZlcnMgYXJlIGNsb3NlZCwgdGhlaXIgb2JzZXJ2ZWQgb2JqZWN0cyBhcmVcbiAgICogbm90IE9iamVjdC51bm9ic2VydmUoZCkuIEFzIGEgcmVzdWx0LCBpdCdzaWVzdGEgcG9zc2libGUgdGhhdCBpZiB0aGUgb2JzZXJ2ZWRTZXRcbiAgICogaXMga2VwdCBvcGVuLCBidXQgc29tZSBPYnNlcnZlcnMgaGF2ZSBiZWVuIGNsb3NlZCwgaXQgY291bGQgY2F1c2UgXCJsZWFrc1wiXG4gICAqIChwcmV2ZW50IG90aGVyd2lzZSBjb2xsZWN0YWJsZSBvYmplY3RzIGZyb20gYmVpbmcgY29sbGVjdGVkKS4gQXQgc29tZVxuICAgKiBwb2ludCwgd2Ugc2hvdWxkIGltcGxlbWVudCBpbmNyZW1lbnRhbCBcImdjXCIgd2hpY2gga2VlcHMgYSBsaXN0IG9mXG4gICAqIG9ic2VydmVkU2V0cyB3aGljaCBtYXkgbmVlZCBjbGVhbi11cCBhbmQgZG9lcyBzbWFsbCBhbW91bnRzIG9mIGNsZWFudXAgb24gYVxuICAgKiB0aW1lb3V0IHVudGlsIGFsbCBpcyBjbGVhbi5cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZWRPYmplY3Qob2JzZXJ2ZXIsIG9iamVjdCwgYXJyYXlPYnNlcnZlKSB7XG4gICAgdmFyIGRpciA9IG9ic2VydmVkT2JqZWN0Q2FjaGUucG9wKCkgfHwgbmV3T2JzZXJ2ZWRPYmplY3QoKTtcbiAgICBkaXIub3BlbihvYnNlcnZlcik7XG4gICAgZGlyLm9ic2VydmUob2JqZWN0LCBhcnJheU9ic2VydmUpO1xuICAgIHJldHVybiBkaXI7XG4gIH1cblxuICB2YXIgb2JzZXJ2ZWRTZXRDYWNoZSA9IFtdO1xuXG4gIGZ1bmN0aW9uIG5ld09ic2VydmVkU2V0KCkge1xuICAgIHZhciBvYnNlcnZlckNvdW50ID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gW107XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICB2YXIgcm9vdE9iajtcbiAgICB2YXIgcm9vdE9ialByb3BzO1xuXG4gICAgZnVuY3Rpb24gb2JzZXJ2ZShvYmosIHByb3ApIHtcbiAgICAgIGlmICghb2JqKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIGlmIChvYmogPT09IHJvb3RPYmopXG4gICAgICAgIHJvb3RPYmpQcm9wc1twcm9wXSA9IHRydWU7XG5cbiAgICAgIGlmIChvYmplY3RzLmluZGV4T2Yob2JqKSA8IDApIHtcbiAgICAgICAgb2JqZWN0cy5wdXNoKG9iaik7XG4gICAgICAgIE9iamVjdC5vYnNlcnZlKG9iaiwgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBvYnNlcnZlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopLCBwcm9wKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxSb290T2JqTm9uT2JzZXJ2ZWRQcm9wcyhyZWNzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHJlY3NbaV07XG4gICAgICAgIGlmIChyZWMub2JqZWN0ICE9PSByb290T2JqIHx8XG4gICAgICAgICAgICByb290T2JqUHJvcHNbcmVjLm5hbWVdIHx8XG4gICAgICAgICAgICByZWMudHlwZSA9PT0gJ3NldFByb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKHJlY3MpIHtcbiAgICAgIGlmIChhbGxSb290T2JqTm9uT2JzZXJ2ZWRQcm9wcyhyZWNzKSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBvYnNlcnZlciA9IG9ic2VydmVyc1tpXTtcbiAgICAgICAgaWYgKG9ic2VydmVyLnN0YXRlXyA9PSBPUEVORUQpIHtcbiAgICAgICAgICBvYnNlcnZlci5pdGVyYXRlT2JqZWN0c18ob2JzZXJ2ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlcnNbaV07XG4gICAgICAgIGlmIChvYnNlcnZlci5zdGF0ZV8gPT0gT1BFTkVEKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuY2hlY2tfKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0ge1xuICAgICAgb2JqZWN0OiB1bmRlZmluZWQsXG4gICAgICBvYmplY3RzOiBvYmplY3RzLFxuICAgICAgb3BlbjogZnVuY3Rpb24ob2JzLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFyb290T2JqKSB7XG4gICAgICAgICAgcm9vdE9iaiA9IG9iamVjdDtcbiAgICAgICAgICByb290T2JqUHJvcHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVycy5wdXNoKG9icyk7XG4gICAgICAgIG9ic2VydmVyQ291bnQrKztcbiAgICAgICAgb2JzLml0ZXJhdGVPYmplY3RzXyhvYnNlcnZlKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZTogZnVuY3Rpb24ob2JzKSB7XG4gICAgICAgIG9ic2VydmVyQ291bnQtLTtcbiAgICAgICAgaWYgKG9ic2VydmVyQ291bnQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgT2JqZWN0LnVub2JzZXJ2ZShvYmplY3RzW2ldLCBjYWxsYmFjayk7XG4gICAgICAgICAgT2JzZXJ2ZXIudW5vYnNlcnZlZENvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgb2JqZWN0cy5sZW5ndGggPSAwO1xuICAgICAgICByb290T2JqID0gdW5kZWZpbmVkO1xuICAgICAgICByb290T2JqUHJvcHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIG9ic2VydmVkU2V0Q2FjaGUucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlY29yZDtcbiAgfVxuXG4gIHZhciBsYXN0T2JzZXJ2ZWRTZXQ7XG5cbiAgZnVuY3Rpb24gZ2V0T2JzZXJ2ZWRTZXQob2JzZXJ2ZXIsIG9iaikge1xuICAgIGlmICghbGFzdE9ic2VydmVkU2V0IHx8IGxhc3RPYnNlcnZlZFNldC5vYmplY3QgIT09IG9iaikge1xuICAgICAgbGFzdE9ic2VydmVkU2V0ID0gb2JzZXJ2ZWRTZXRDYWNoZS5wb3AoKSB8fCBuZXdPYnNlcnZlZFNldCgpO1xuICAgICAgbGFzdE9ic2VydmVkU2V0Lm9iamVjdCA9IG9iajtcbiAgICB9XG4gICAgbGFzdE9ic2VydmVkU2V0Lm9wZW4ob2JzZXJ2ZXIsIG9iaik7XG4gICAgcmV0dXJuIGxhc3RPYnNlcnZlZFNldDtcbiAgfVxuXG4gIHZhciBVTk9QRU5FRCA9IDA7XG4gIHZhciBPUEVORUQgPSAxO1xuICB2YXIgQ0xPU0VEID0gMjtcbiAgdmFyIFJFU0VUVElORyA9IDM7XG5cbiAgdmFyIG5leHRPYnNlcnZlcklkID0gMTtcblxuICBmdW5jdGlvbiBPYnNlcnZlcigpIHtcbiAgICB0aGlzLnN0YXRlXyA9IFVOT1BFTkVEO1xuICAgIHRoaXMuY2FsbGJhY2tfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGFyZ2V0XyA9IHVuZGVmaW5lZDsgLy8gVE9ETyhyYWZhZWx3KTogU2hvdWxkIGJlIFdlYWtSZWZcbiAgICB0aGlzLmRpcmVjdE9ic2VydmVyXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbHVlXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlkXyA9IG5leHRPYnNlcnZlcklkKys7XG4gIH1cblxuICBPYnNlcnZlci5wcm90b3R5cGUgPSB7XG4gICAgb3BlbjogZnVuY3Rpb24oY2FsbGJhY2ssIHRhcmdldCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGVfICE9IFVOT1BFTkVEKVxuICAgICAgICB0aHJvdyBFcnJvcignT2JzZXJ2ZXIgaGFzIGFscmVhZHkgYmVlbiBvcGVuZWQuJyk7XG5cbiAgICAgIGFkZFRvQWxsKHRoaXMpO1xuICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICAgIHRoaXMudGFyZ2V0XyA9IHRhcmdldDtcbiAgICAgIHRoaXMuY29ubmVjdF8oKTtcbiAgICAgIHRoaXMuc3RhdGVfID0gT1BFTkVEO1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIH0sXG5cbiAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZV8gIT0gT1BFTkVEKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIHJlbW92ZUZyb21BbGwodGhpcyk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XG4gICAgICB0aGlzLnZhbHVlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY2FsbGJhY2tfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy50YXJnZXRfID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zdGF0ZV8gPSBDTE9TRUQ7XG4gICAgfSxcblxuICAgIGRlbGl2ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGVfICE9IE9QRU5FRClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkaXJ0eUNoZWNrKHRoaXMpO1xuICAgIH0sXG5cbiAgICByZXBvcnRfOiBmdW5jdGlvbihjaGFuZ2VzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrXy5hcHBseSh0aGlzLnRhcmdldF8sIGNoYW5nZXMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgT2JzZXJ2ZXIuX2Vycm9yVGhyb3duRHVyaW5nQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFeGNlcHRpb24gY2F1Z2h0IGR1cmluZyBvYnNlcnZlciBjYWxsYmFjazogJyArXG4gICAgICAgICAgICAgICAgICAgICAgIChleC5zdGFjayB8fCBleCkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNjYXJkQ2hhbmdlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoZWNrXyh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb2xsZWN0T2JzZXJ2ZXJzID0gIWhhc09ic2VydmU7XG4gIHZhciBhbGxPYnNlcnZlcnM7XG4gIE9ic2VydmVyLl9hbGxPYnNlcnZlcnNDb3VudCA9IDA7XG5cbiAgaWYgKGNvbGxlY3RPYnNlcnZlcnMpIHtcbiAgICBhbGxPYnNlcnZlcnMgPSBbXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFRvQWxsKG9ic2VydmVyKSB7XG4gICAgT2JzZXJ2ZXIuX2FsbE9ic2VydmVyc0NvdW50Kys7XG4gICAgaWYgKCFjb2xsZWN0T2JzZXJ2ZXJzKVxuICAgICAgcmV0dXJuO1xuXG4gICAgYWxsT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUFsbChvYnNlcnZlcikge1xuICAgIE9ic2VydmVyLl9hbGxPYnNlcnZlcnNDb3VudC0tO1xuICB9XG5cbiAgdmFyIHJ1bm5pbmdNaWNyb3Rhc2tDaGVja3BvaW50ID0gZmFsc2U7XG5cbiAgdmFyIGhhc0RlYnVnRm9yY2VGdWxsRGVsaXZlcnkgPSBoYXNPYnNlcnZlICYmIGhhc0V2YWwgJiYgKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBldmFsKCclUnVuTWljcm90YXNrcygpJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkoKTtcblxuICBnbG9iYWwuUGxhdGZvcm0gPSBnbG9iYWwuUGxhdGZvcm0gfHwge307XG5cbiAgZ2xvYmFsLlBsYXRmb3JtLnBlcmZvcm1NaWNyb3Rhc2tDaGVja3BvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJ1bm5pbmdNaWNyb3Rhc2tDaGVja3BvaW50KVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKGhhc0RlYnVnRm9yY2VGdWxsRGVsaXZlcnkpIHtcbiAgICAgIGV2YWwoJyVSdW5NaWNyb3Rhc2tzKCknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNvbGxlY3RPYnNlcnZlcnMpXG4gICAgICByZXR1cm47XG5cbiAgICBydW5uaW5nTWljcm90YXNrQ2hlY2twb2ludCA9IHRydWU7XG5cbiAgICB2YXIgY3ljbGVzID0gMDtcbiAgICB2YXIgYW55Q2hhbmdlZCwgdG9DaGVjaztcblxuICAgIGRvIHtcbiAgICAgIGN5Y2xlcysrO1xuICAgICAgdG9DaGVjayA9IGFsbE9ic2VydmVycztcbiAgICAgIGFsbE9ic2VydmVycyA9IFtdO1xuICAgICAgYW55Q2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQ2hlY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gdG9DaGVja1tpXTtcbiAgICAgICAgaWYgKG9ic2VydmVyLnN0YXRlXyAhPSBPUEVORUQpXG4gICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKG9ic2VydmVyLmNoZWNrXygpKVxuICAgICAgICAgIGFueUNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIGFsbE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChydW5FT01UYXNrcygpKVxuICAgICAgICBhbnlDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9IHdoaWxlIChjeWNsZXMgPCBNQVhfRElSVFlfQ0hFQ0tfQ1lDTEVTICYmIGFueUNoYW5nZWQpO1xuXG4gICAgaWYgKHRlc3RpbmdFeHBvc2VDeWNsZUNvdW50KVxuICAgICAgZ2xvYmFsLmRpcnR5Q2hlY2tDeWNsZUNvdW50ID0gY3ljbGVzO1xuXG4gICAgcnVubmluZ01pY3JvdGFza0NoZWNrcG9pbnQgPSBmYWxzZTtcbiAgfTtcblxuICBpZiAoY29sbGVjdE9ic2VydmVycykge1xuICAgIGdsb2JhbC5QbGF0Zm9ybS5jbGVhck9ic2VydmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgYWxsT2JzZXJ2ZXJzID0gW107XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE9iamVjdE9ic2VydmVyKG9iamVjdCkge1xuICAgIE9ic2VydmVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy52YWx1ZV8gPSBvYmplY3Q7XG4gICAgdGhpcy5vbGRPYmplY3RfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgT2JqZWN0T2JzZXJ2ZXIucHJvdG90eXBlID0gY3JlYXRlT2JqZWN0KHtcbiAgICBfX3Byb3RvX186IE9ic2VydmVyLnByb3RvdHlwZSxcblxuICAgIGFycmF5T2JzZXJ2ZTogZmFsc2UsXG5cbiAgICBjb25uZWN0XzogZnVuY3Rpb24oY2FsbGJhY2ssIHRhcmdldCkge1xuICAgICAgaWYgKGhhc09ic2VydmUpIHtcbiAgICAgICAgdGhpcy5kaXJlY3RPYnNlcnZlcl8gPSBnZXRPYnNlcnZlZE9iamVjdCh0aGlzLCB0aGlzLnZhbHVlXyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFycmF5T2JzZXJ2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9sZE9iamVjdF8gPSB0aGlzLmNvcHlPYmplY3QodGhpcy52YWx1ZV8pO1xuICAgICAgfVxuXG4gICAgfSxcblxuICAgIGNvcHlPYmplY3Q6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGNvcHkgPSBBcnJheS5pc0FycmF5KG9iamVjdCkgPyBbXSA6IHt9O1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmplY3QpIHtcbiAgICAgICAgY29weVtwcm9wXSA9IG9iamVjdFtwcm9wXTtcbiAgICAgIH07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKVxuICAgICAgICBjb3B5Lmxlbmd0aCA9IG9iamVjdC5sZW5ndGg7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9LFxuXG4gICAgY2hlY2tfOiBmdW5jdGlvbihjaGFuZ2VSZWNvcmRzLCBza2lwQ2hhbmdlcykge1xuICAgICAgdmFyIGRpZmY7XG4gICAgICB2YXIgb2xkVmFsdWVzO1xuICAgICAgaWYgKGhhc09ic2VydmUpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VSZWNvcmRzKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBvbGRWYWx1ZXMgPSB7fTtcbiAgICAgICAgZGlmZiA9IGRpZmZPYmplY3RGcm9tQ2hhbmdlUmVjb3Jkcyh0aGlzLnZhbHVlXywgY2hhbmdlUmVjb3JkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2xkVmFsdWVzID0gdGhpcy5vbGRPYmplY3RfO1xuICAgICAgICBkaWZmID0gZGlmZk9iamVjdEZyb21PbGRPYmplY3QodGhpcy52YWx1ZV8sIHRoaXMub2xkT2JqZWN0Xyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmSXNFbXB0eShkaWZmKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoIWhhc09ic2VydmUpXG4gICAgICAgIHRoaXMub2xkT2JqZWN0XyA9IHRoaXMuY29weU9iamVjdCh0aGlzLnZhbHVlXyk7XG5cbiAgICAgIHRoaXMucmVwb3J0XyhbXG4gICAgICAgIGRpZmYuYWRkZWQgfHwge30sXG4gICAgICAgIGRpZmYucmVtb3ZlZCB8fCB7fSxcbiAgICAgICAgZGlmZi5jaGFuZ2VkIHx8IHt9LFxuICAgICAgICBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAgIHJldHVybiBvbGRWYWx1ZXNbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICBdKTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGRpc2Nvbm5lY3RfOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChoYXNPYnNlcnZlKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbGRPYmplY3RfID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZWxpdmVyOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlXyAhPSBPUEVORUQpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgaWYgKGhhc09ic2VydmUpXG4gICAgICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfLmRlbGl2ZXIoZmFsc2UpO1xuICAgICAgZWxzZVxuICAgICAgICBkaXJ0eUNoZWNrKHRoaXMpO1xuICAgIH0sXG5cbiAgICBkaXNjYXJkQ2hhbmdlczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kaXJlY3RPYnNlcnZlcl8pXG4gICAgICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfLmRlbGl2ZXIodHJ1ZSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMub2xkT2JqZWN0XyA9IHRoaXMuY29weU9iamVjdCh0aGlzLnZhbHVlXyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIEFycmF5T2JzZXJ2ZXIoYXJyYXkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKVxuICAgICAgdGhyb3cgRXJyb3IoJ1Byb3ZpZGVkIG9iamVjdCBpcyBub3QgYW4gQXJyYXknKTtcbiAgICBPYmplY3RPYnNlcnZlci5jYWxsKHRoaXMsIGFycmF5KTtcbiAgfVxuXG4gIEFycmF5T2JzZXJ2ZXIucHJvdG90eXBlID0gY3JlYXRlT2JqZWN0KHtcblxuICAgIF9fcHJvdG9fXzogT2JqZWN0T2JzZXJ2ZXIucHJvdG90eXBlLFxuXG4gICAgYXJyYXlPYnNlcnZlOiB0cnVlLFxuXG4gICAgY29weU9iamVjdDogZnVuY3Rpb24oYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLnNsaWNlKCk7XG4gICAgfSxcblxuICAgIGNoZWNrXzogZnVuY3Rpb24oY2hhbmdlUmVjb3Jkcykge1xuICAgICAgdmFyIHNwbGljZXM7XG4gICAgICBpZiAoaGFzT2JzZXJ2ZSkge1xuICAgICAgICBpZiAoIWNoYW5nZVJlY29yZHMpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzcGxpY2VzID0gcHJvamVjdEFycmF5U3BsaWNlcyh0aGlzLnZhbHVlXywgY2hhbmdlUmVjb3Jkcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpY2VzID0gY2FsY1NwbGljZXModGhpcy52YWx1ZV8sIDAsIHRoaXMudmFsdWVfLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2xkT2JqZWN0XywgMCwgdGhpcy5vbGRPYmplY3RfLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3BsaWNlcyB8fCAhc3BsaWNlcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKCFoYXNPYnNlcnZlKVxuICAgICAgICB0aGlzLm9sZE9iamVjdF8gPSB0aGlzLmNvcHlPYmplY3QodGhpcy52YWx1ZV8pO1xuXG4gICAgICB0aGlzLnJlcG9ydF8oW3NwbGljZXNdKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgQXJyYXlPYnNlcnZlci5hcHBseVNwbGljZXMgPSBmdW5jdGlvbihwcmV2aW91cywgY3VycmVudCwgc3BsaWNlcykge1xuICAgIHNwbGljZXMuZm9yRWFjaChmdW5jdGlvbihzcGxpY2UpIHtcbiAgICAgIHZhciBzcGxpY2VBcmdzID0gW3NwbGljZS5pbmRleCwgc3BsaWNlLnJlbW92ZWQubGVuZ3RoXTtcbiAgICAgIHZhciBhZGRJbmRleCA9IHNwbGljZS5pbmRleDtcbiAgICAgIHdoaWxlIChhZGRJbmRleCA8IHNwbGljZS5pbmRleCArIHNwbGljZS5hZGRlZENvdW50KSB7XG4gICAgICAgIHNwbGljZUFyZ3MucHVzaChjdXJyZW50W2FkZEluZGV4XSk7XG4gICAgICAgIGFkZEluZGV4Kys7XG4gICAgICB9XG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkocHJldmlvdXMsIHNwbGljZUFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFBhdGhPYnNlcnZlcihvYmplY3QsIHBhdGgpIHtcbiAgICBPYnNlcnZlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5vYmplY3RfID0gb2JqZWN0O1xuICAgIHRoaXMucGF0aF8gPSBnZXRQYXRoKHBhdGgpO1xuICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgUGF0aE9ic2VydmVyLnByb3RvdHlwZSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgX19wcm90b19fOiBPYnNlcnZlci5wcm90b3R5cGUsXG5cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhfO1xuICAgIH0sXG5cbiAgICBjb25uZWN0XzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoaGFzT2JzZXJ2ZSlcbiAgICAgICAgdGhpcy5kaXJlY3RPYnNlcnZlcl8gPSBnZXRPYnNlcnZlZFNldCh0aGlzLCB0aGlzLm9iamVjdF8pO1xuXG4gICAgICB0aGlzLmNoZWNrXyh1bmRlZmluZWQsIHRydWUpO1xuICAgIH0sXG5cbiAgICBkaXNjb25uZWN0XzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnZhbHVlXyA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHRoaXMuZGlyZWN0T2JzZXJ2ZXJfKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfLmNsb3NlKHRoaXMpO1xuICAgICAgICB0aGlzLmRpcmVjdE9ic2VydmVyXyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXRlcmF0ZU9iamVjdHNfOiBmdW5jdGlvbihvYnNlcnZlKSB7XG4gICAgICB0aGlzLnBhdGhfLml0ZXJhdGVPYmplY3RzKHRoaXMub2JqZWN0Xywgb2JzZXJ2ZSk7XG4gICAgfSxcblxuICAgIGNoZWNrXzogZnVuY3Rpb24oY2hhbmdlUmVjb3Jkcywgc2tpcENoYW5nZXMpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWVfO1xuICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLnBhdGhfLmdldFZhbHVlRnJvbSh0aGlzLm9iamVjdF8pO1xuICAgICAgaWYgKHNraXBDaGFuZ2VzIHx8IGFyZVNhbWVWYWx1ZSh0aGlzLnZhbHVlXywgb2xkVmFsdWUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHRoaXMucmVwb3J0XyhbdGhpcy52YWx1ZV8sIG9sZFZhbHVlLCB0aGlzXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5wYXRoXylcbiAgICAgICAgdGhpcy5wYXRoXy5zZXRWYWx1ZUZyb20odGhpcy5vYmplY3RfLCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBDb21wb3VuZE9ic2VydmVyKHJlcG9ydENoYW5nZXNPbk9wZW4pIHtcbiAgICBPYnNlcnZlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5yZXBvcnRDaGFuZ2VzT25PcGVuXyA9IHJlcG9ydENoYW5nZXNPbk9wZW47XG4gICAgdGhpcy52YWx1ZV8gPSBbXTtcbiAgICB0aGlzLmRpcmVjdE9ic2VydmVyXyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9ic2VydmVkXyA9IFtdO1xuICB9XG5cbiAgdmFyIG9ic2VydmVyU2VudGluZWwgPSB7fTtcblxuICBDb21wb3VuZE9ic2VydmVyLnByb3RvdHlwZSA9IGNyZWF0ZU9iamVjdCh7XG4gICAgX19wcm90b19fOiBPYnNlcnZlci5wcm90b3R5cGUsXG5cbiAgICBjb25uZWN0XzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoaGFzT2JzZXJ2ZSkge1xuICAgICAgICB2YXIgb2JqZWN0O1xuICAgICAgICB2YXIgbmVlZHNEaXJlY3RPYnNlcnZlciA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZWRfLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgb2JqZWN0ID0gdGhpcy5vYnNlcnZlZF9baV1cbiAgICAgICAgICBpZiAob2JqZWN0ICE9PSBvYnNlcnZlclNlbnRpbmVsKSB7XG4gICAgICAgICAgICBuZWVkc0RpcmVjdE9ic2VydmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc0RpcmVjdE9ic2VydmVyKVxuICAgICAgICAgIHRoaXMuZGlyZWN0T2JzZXJ2ZXJfID0gZ2V0T2JzZXJ2ZWRTZXQodGhpcywgb2JqZWN0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja18odW5kZWZpbmVkLCAhdGhpcy5yZXBvcnRDaGFuZ2VzT25PcGVuXyk7XG4gICAgfSxcblxuICAgIGRpc2Nvbm5lY3RfOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlZF8ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZWRfW2ldID09PSBvYnNlcnZlclNlbnRpbmVsKVxuICAgICAgICAgIHRoaXMub2JzZXJ2ZWRfW2kgKyAxXS5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlZF8ubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMudmFsdWVfLmxlbmd0aCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmRpcmVjdE9ic2VydmVyXykge1xuICAgICAgICB0aGlzLmRpcmVjdE9ic2VydmVyXy5jbG9zZSh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXJlY3RPYnNlcnZlcl8gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFkZFBhdGg6IGZ1bmN0aW9uKG9iamVjdCwgcGF0aCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGVfICE9IFVOT1BFTkVEICYmIHRoaXMuc3RhdGVfICE9IFJFU0VUVElORylcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBhZGQgcGF0aHMgb25jZSBzdGFydGVkLicpO1xuXG4gICAgICB2YXIgcGF0aCA9IGdldFBhdGgocGF0aCk7XG4gICAgICB0aGlzLm9ic2VydmVkXy5wdXNoKG9iamVjdCwgcGF0aCk7XG4gICAgICBpZiAoIXRoaXMucmVwb3J0Q2hhbmdlc09uT3Blbl8pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMub2JzZXJ2ZWRfLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdGhpcy52YWx1ZV9baW5kZXhdID0gcGF0aC5nZXRWYWx1ZUZyb20ob2JqZWN0KTtcbiAgICB9LFxuXG4gICAgYWRkT2JzZXJ2ZXI6IGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZV8gIT0gVU5PUEVORUQgJiYgdGhpcy5zdGF0ZV8gIT0gUkVTRVRUSU5HKVxuICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGFkZCBvYnNlcnZlcnMgb25jZSBzdGFydGVkLicpO1xuXG4gICAgICB0aGlzLm9ic2VydmVkXy5wdXNoKG9ic2VydmVyU2VudGluZWwsIG9ic2VydmVyKTtcbiAgICAgIGlmICghdGhpcy5yZXBvcnRDaGFuZ2VzT25PcGVuXylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5vYnNlcnZlZF8ubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB0aGlzLnZhbHVlX1tpbmRleF0gPSBvYnNlcnZlci5vcGVuKHRoaXMuZGVsaXZlciwgdGhpcyk7XG4gICAgfSxcblxuICAgIHN0YXJ0UmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGVfICE9IE9QRU5FRClcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBvbmx5IHJlc2V0IHdoaWxlIG9wZW4nKTtcblxuICAgICAgdGhpcy5zdGF0ZV8gPSBSRVNFVFRJTkc7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RfKCk7XG4gICAgfSxcblxuICAgIGZpbmlzaFJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlXyAhPSBSRVNFVFRJTkcpXG4gICAgICAgIHRocm93IEVycm9yKCdDYW4gb25seSBmaW5pc2hSZXNldCBhZnRlciBzdGFydFJlc2V0Jyk7XG4gICAgICB0aGlzLnN0YXRlXyA9IE9QRU5FRDtcbiAgICAgIHRoaXMuY29ubmVjdF8oKTtcblxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIH0sXG5cbiAgICBpdGVyYXRlT2JqZWN0c186IGZ1bmN0aW9uKG9ic2VydmUpIHtcbiAgICAgIHZhciBvYmplY3Q7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZWRfLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIG9iamVjdCA9IHRoaXMub2JzZXJ2ZWRfW2ldXG4gICAgICAgIGlmIChvYmplY3QgIT09IG9ic2VydmVyU2VudGluZWwpXG4gICAgICAgICAgdGhpcy5vYnNlcnZlZF9baSArIDFdLml0ZXJhdGVPYmplY3RzKG9iamVjdCwgb2JzZXJ2ZSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hlY2tfOiBmdW5jdGlvbihjaGFuZ2VSZWNvcmRzLCBza2lwQ2hhbmdlcykge1xuICAgICAgdmFyIG9sZFZhbHVlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlZF8ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMub2JzZXJ2ZWRfW2ldO1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMub2JzZXJ2ZWRfW2krMV07XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gb2JzZXJ2ZXJTZW50aW5lbCkge1xuICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gcGF0aDtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuc3RhdGVfID09PSBVTk9QRU5FRCA/XG4gICAgICAgICAgICAgIG9ic2VydmFibGUub3Blbih0aGlzLmRlbGl2ZXIsIHRoaXMpIDpcbiAgICAgICAgICAgICAgb2JzZXJ2YWJsZS5kaXNjYXJkQ2hhbmdlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gcGF0aC5nZXRWYWx1ZUZyb20ob2JqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChza2lwQ2hhbmdlcykge1xuICAgICAgICAgIHRoaXMudmFsdWVfW2kgLyAyXSA9IHZhbHVlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZVNhbWVWYWx1ZSh2YWx1ZSwgdGhpcy52YWx1ZV9baSAvIDJdKSlcbiAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBvbGRWYWx1ZXMgPSBvbGRWYWx1ZXMgfHwgW107XG4gICAgICAgIG9sZFZhbHVlc1tpIC8gMl0gPSB0aGlzLnZhbHVlX1tpIC8gMl07XG4gICAgICAgIHRoaXMudmFsdWVfW2kgLyAyXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9sZFZhbHVlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBUT0RPKHJhZmFlbHcpOiBIYXZpbmcgb2JzZXJ2ZWRfIGFzIHRoZSB0aGlyZCBjYWxsYmFjayBhcmcgaGVyZSBpc1xuICAgICAgLy8gcHJldHR5IGxhbWUgQVBJLiBGaXguXG4gICAgICB0aGlzLnJlcG9ydF8oW3RoaXMudmFsdWVfLCBvbGRWYWx1ZXMsIHRoaXMub2JzZXJ2ZWRfXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGlkZW50Rm4odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9XG5cbiAgZnVuY3Rpb24gT2JzZXJ2ZXJUcmFuc2Zvcm0ob2JzZXJ2YWJsZSwgZ2V0VmFsdWVGbiwgc2V0VmFsdWVGbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9udFBhc3NUaHJvdWdoU2V0KSB7XG4gICAgdGhpcy5jYWxsYmFja18gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50YXJnZXRfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsdWVfID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2JzZXJ2YWJsZV8gPSBvYnNlcnZhYmxlO1xuICAgIHRoaXMuZ2V0VmFsdWVGbl8gPSBnZXRWYWx1ZUZuIHx8IGlkZW50Rm47XG4gICAgdGhpcy5zZXRWYWx1ZUZuXyA9IHNldFZhbHVlRm4gfHwgaWRlbnRGbjtcbiAgICAvLyBUT0RPKHJhZmFlbHcpOiBUaGlzIGlzIGEgdGVtcG9yYXJ5IGhhY2suIFBvbHltZXJFeHByZXNzaW9ucyBuZWVkcyB0aGlzXG4gICAgLy8gYXQgdGhlIG1vbWVudCBiZWNhdXNlIG9mIGEgYnVnIGluIGl0J3NpZXN0YSBkZXBlbmRlbmN5IHRyYWNraW5nLlxuICAgIHRoaXMuZG9udFBhc3NUaHJvdWdoU2V0XyA9IGRvbnRQYXNzVGhyb3VnaFNldDtcbiAgfVxuXG4gIE9ic2VydmVyVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBvcGVuOiBmdW5jdGlvbihjYWxsYmFjaywgdGFyZ2V0KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy50YXJnZXRfID0gdGFyZ2V0O1xuICAgICAgdGhpcy52YWx1ZV8gPVxuICAgICAgICAgIHRoaXMuZ2V0VmFsdWVGbl8odGhpcy5vYnNlcnZhYmxlXy5vcGVuKHRoaXMub2JzZXJ2ZWRDYWxsYmFja18sIHRoaXMpKTtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICB9LFxuXG4gICAgb2JzZXJ2ZWRDYWxsYmFja186IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWVGbl8odmFsdWUpO1xuICAgICAgaWYgKGFyZVNhbWVWYWx1ZSh2YWx1ZSwgdGhpcy52YWx1ZV8pKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICAgIHRoaXMudmFsdWVfID0gdmFsdWU7XG4gICAgICB0aGlzLmNhbGxiYWNrXy5jYWxsKHRoaXMudGFyZ2V0XywgdGhpcy52YWx1ZV8sIG9sZFZhbHVlKTtcbiAgICB9LFxuXG4gICAgZGlzY2FyZENoYW5nZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy52YWx1ZV8gPSB0aGlzLmdldFZhbHVlRm5fKHRoaXMub2JzZXJ2YWJsZV8uZGlzY2FyZENoYW5nZXMoKSk7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgfSxcblxuICAgIGRlbGl2ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2YWJsZV8uZGVsaXZlcigpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5zZXRWYWx1ZUZuXyh2YWx1ZSk7XG4gICAgICBpZiAoIXRoaXMuZG9udFBhc3NUaHJvdWdoU2V0XyAmJiB0aGlzLm9ic2VydmFibGVfLnNldFZhbHVlKVxuICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZhYmxlXy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcblxuICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm9ic2VydmFibGVfKVxuICAgICAgICB0aGlzLm9ic2VydmFibGVfLmNsb3NlKCk7XG4gICAgICB0aGlzLmNhbGxiYWNrXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudGFyZ2V0XyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub2JzZXJ2YWJsZV8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnZhbHVlXyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZ2V0VmFsdWVGbl8gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnNldFZhbHVlRm5fID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHZhciBleHBlY3RlZFJlY29yZFR5cGVzID0ge1xuICAgIGFkZDogdHJ1ZSxcbiAgICB1cGRhdGU6IHRydWUsXG4gICAgZGVsZXRlOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZGlmZk9iamVjdEZyb21DaGFuZ2VSZWNvcmRzKG9iamVjdCwgY2hhbmdlUmVjb3Jkcywgb2xkVmFsdWVzKSB7XG4gICAgdmFyIGFkZGVkID0ge307XG4gICAgdmFyIHJlbW92ZWQgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY29yZCA9IGNoYW5nZVJlY29yZHNbaV07XG4gICAgICBpZiAoIWV4cGVjdGVkUmVjb3JkVHlwZXNbcmVjb3JkLnR5cGVdKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gY2hhbmdlUmVjb3JkIHR5cGU6ICcgKyByZWNvcmQudHlwZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IocmVjb3JkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghKHJlY29yZC5uYW1lIGluIG9sZFZhbHVlcykpXG4gICAgICAgIG9sZFZhbHVlc1tyZWNvcmQubmFtZV0gPSByZWNvcmQub2xkVmFsdWU7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PSAndXBkYXRlJylcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PSAnYWRkJykge1xuICAgICAgICBpZiAocmVjb3JkLm5hbWUgaW4gcmVtb3ZlZClcbiAgICAgICAgICBkZWxldGUgcmVtb3ZlZFtyZWNvcmQubmFtZV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhZGRlZFtyZWNvcmQubmFtZV0gPSB0cnVlO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyB0eXBlID0gJ2RlbGV0ZSdcbiAgICAgIGlmIChyZWNvcmQubmFtZSBpbiBhZGRlZCkge1xuICAgICAgICBkZWxldGUgYWRkZWRbcmVjb3JkLm5hbWVdO1xuICAgICAgICBkZWxldGUgb2xkVmFsdWVzW3JlY29yZC5uYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZWRbcmVjb3JkLm5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGFkZGVkKVxuICAgICAgYWRkZWRbcHJvcF0gPSBvYmplY3RbcHJvcF07XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHJlbW92ZWQpXG4gICAgICByZW1vdmVkW3Byb3BdID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNoYW5nZWQgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9sZFZhbHVlcykge1xuICAgICAgaWYgKHByb3AgaW4gYWRkZWQgfHwgcHJvcCBpbiByZW1vdmVkKVxuICAgICAgICBjb250aW51ZTtcblxuICAgICAgdmFyIG5ld1ZhbHVlID0gb2JqZWN0W3Byb3BdO1xuICAgICAgaWYgKG9sZFZhbHVlc1twcm9wXSAhPT0gbmV3VmFsdWUpXG4gICAgICAgIGNoYW5nZWRbcHJvcF0gPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgcmVtb3ZlZDogcmVtb3ZlZCxcbiAgICAgIGNoYW5nZWQ6IGNoYW5nZWRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV3U3BsaWNlKGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgICBhZGRlZENvdW50OiBhZGRlZENvdW50XG4gICAgfTtcbiAgfVxuXG4gIHZhciBFRElUX0xFQVZFID0gMDtcbiAgdmFyIEVESVRfVVBEQVRFID0gMTtcbiAgdmFyIEVESVRfQUREID0gMjtcbiAgdmFyIEVESVRfREVMRVRFID0gMztcblxuICBmdW5jdGlvbiBBcnJheVNwbGljZSgpIHt9XG5cbiAgQXJyYXlTcGxpY2UucHJvdG90eXBlID0ge1xuXG4gICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbiAgICAvLyBcImVkaXRcIiBkaXN0YW5jZS4gVGhlIG9uZSBjaGFuZ2UgaXMgdGhhdCBcInVwZGF0ZXNcIiBhcmUgdHJlYXRlZCBhcyB0d29cbiAgICAvLyBlZGl0cyAtIG5vdCBvbmUuIFdpdGggQXJyYXkgc3BsaWNlcywgYW4gdXBkYXRlIGlzIHJlYWxseSBhIGRlbGV0ZVxuICAgIC8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbiAgICAvLyBtYXhpbXVtIGFycmF5IGl0ZW1zIGluIHRoZSBvcmlnaW5hbCBhcnJheS4gRm9yIGV4YW1wbGU6XG4gICAgLy9cbiAgICAvLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbiAgICAvL1xuICAgIC8vIFdpdGggMS1lZGl0IHVwZGF0ZXMsIHRoZSBzaG9ydGVzdCBwYXRoIHdvdWxkIGJlIGp1c3QgdG8gdXBkYXRlIGFsbCBzZXZlblxuICAgIC8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbiAgICAvLyBsZWF2ZXMgdGhlIHN1YnN0cmluZyAnMTIzJyBpbnRhY3QuXG4gICAgY2FsY0VkaXREaXN0YW5jZXM6IGZ1bmN0aW9uKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gICAgICAvLyBcIkRlbGV0aW9uXCIgY29sdW1uc1xuICAgICAgdmFyIHJvd0NvdW50ID0gb2xkRW5kIC0gb2xkU3RhcnQgKyAxO1xuICAgICAgdmFyIGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gICAgICB2YXIgZGlzdGFuY2VzID0gbmV3IEFycmF5KHJvd0NvdW50KTtcblxuICAgICAgLy8gXCJBZGRpdGlvblwiIHJvd3MuIEluaXRpYWxpemUgbnVsbCBjb2x1bW4uXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgICAgZGlzdGFuY2VzW2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgICAgICAgZGlzdGFuY2VzW2ldWzBdID0gaTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSBudWxsIHJvd1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxuICAgICAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBjb2x1bW5Db3VudDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgaiAtIDFdLCBvbGRbb2xkU3RhcnQgKyBpIC0gMV0pKVxuICAgICAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbm9ydGggPSBkaXN0YW5jZXNbaSAtIDFdW2pdICsgMTtcbiAgICAgICAgICAgIHZhciB3ZXN0ID0gZGlzdGFuY2VzW2ldW2ogLSAxXSArIDE7XG4gICAgICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBub3J0aCA8IHdlc3QgPyBub3J0aCA6IHdlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXN0YW5jZXM7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgc3RhcnRzIGF0IHRoZSBmaW5hbCB3ZWlnaHQsIGFuZCB3YWxrcyBcImJhY2t3YXJkXCIgYnkgZmluZGluZ1xuICAgIC8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbiAgICAvLyBtYXRyaXguXG4gICAgc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzOiBmdW5jdGlvbihkaXN0YW5jZXMpIHtcbiAgICAgIHZhciBpID0gZGlzdGFuY2VzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgaiA9IGRpc3RhbmNlc1swXS5sZW5ndGggLSAxO1xuICAgICAgdmFyIGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gICAgICB2YXIgZWRpdHMgPSBbXTtcbiAgICAgIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICAgICAgai0tO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqID09IDApIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vcnRoV2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1baiAtIDFdO1xuICAgICAgICB2YXIgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgICAgIHZhciBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICAgICAgdmFyIG1pbjtcbiAgICAgICAgaWYgKHdlc3QgPCBub3J0aClcbiAgICAgICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG1pbiA9IG5vcnRoIDwgbm9ydGhXZXN0ID8gbm9ydGggOiBub3J0aFdlc3Q7XG5cbiAgICAgICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgICAgICBpZiAobm9ydGhXZXN0ID09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9VUERBVEUpO1xuICAgICAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaS0tO1xuICAgICAgICAgIGotLTtcbiAgICAgICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgICAgICBqLS07XG4gICAgICAgICAgY3VycmVudCA9IG5vcnRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVkaXRzLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiBlZGl0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuICAgICAqXG4gICAgICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcbiAgICAgKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuICAgICAqIHR1cGxlcyBvZlxuICAgICAqXG4gICAgICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG4gICAgICpcbiAgICAgKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcbiAgICAgKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcbiAgICAgKiBmcm9tIHxpbmRleHwsIHxhZGRlZENvdW50fCBpdGVtcyB3ZXJlIGFkZGVkLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTGFja2luZyBpbmRpdmlkdWFsIHNwbGljZSBtdXRhdGlvbiBpbmZvcm1hdGlvbiwgdGhlIG1pbmltYWwgc2V0IG9mXG4gICAgICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICAgICAqIGFycmF5LiBUaGUgYmFzaWMgYXBwcm9hY2ggaXMgdG8gY2FsY3VsYXRlIHRoZSBlZGl0IGRpc3RhbmNlIG1hdHJpeCBhbmRcbiAgICAgKiBjaG9vc2UgdGhlIHNob3J0ZXN0IHBhdGggdGhyb3VnaCBpdC5cbiAgICAgKlxuICAgICAqIENvbXBsZXhpdHk6IE8obCAqIHApXG4gICAgICogICBsOiBUaGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGFycmF5XG4gICAgICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAgICAgKi9cbiAgICBjYWxjU3BsaWNlczogZnVuY3Rpb24oY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgICAgIHZhciBwcmVmaXhDb3VudCA9IDA7XG4gICAgICB2YXIgc3VmZml4Q291bnQgPSAwO1xuXG4gICAgICB2YXIgbWluTGVuZ3RoID0gTWF0aC5taW4oY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCwgb2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgICAgaWYgKGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZFN0YXJ0ID09IDApXG4gICAgICAgIHByZWZpeENvdW50ID0gdGhpcy5zaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGgpO1xuXG4gICAgICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICAgICAgc3VmZml4Q291bnQgPSB0aGlzLnNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcblxuICAgICAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICAgICAgb2xkU3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gICAgICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuICAgICAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXG4gICAgICBpZiAoY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZEVuZCAtIG9sZFN0YXJ0ID09IDApXG4gICAgICAgIHJldHVybiBbXTtcblxuICAgICAgaWYgKGN1cnJlbnRTdGFydCA9PSBjdXJyZW50RW5kKSB7XG4gICAgICAgIHZhciBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZClcbiAgICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRTdGFydCsrXSk7XG5cbiAgICAgICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gICAgICB9IGVsc2UgaWYgKG9sZFN0YXJ0ID09IG9sZEVuZClcbiAgICAgICAgcmV0dXJuIFsgbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQpIF07XG5cbiAgICAgIHZhciBvcHMgPSB0aGlzLnNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhcbiAgICAgICAgICB0aGlzLmNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gICAgICB2YXIgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHNwbGljZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IGN1cnJlbnRTdGFydDtcbiAgICAgIHZhciBvbGRJbmRleCA9IG9sZFN0YXJ0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoKG9wc1tpXSkge1xuICAgICAgICAgIGNhc2UgRURJVF9MRUFWRTpcbiAgICAgICAgICAgIGlmIChzcGxpY2UpIHtcbiAgICAgICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgICAgICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVESVRfVVBEQVRFOlxuICAgICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICAgICAgaW5kZXgrKztcblxuICAgICAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVESVRfQUREOlxuICAgICAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNwbGljZSkge1xuICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGxpY2VzO1xuICAgIH0sXG5cbiAgICBzaGFyZWRQcmVmaXg6IGZ1bmN0aW9uKGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlYXJjaExlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIXRoaXMuZXF1YWxzKGN1cnJlbnRbaV0sIG9sZFtpXSkpXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xuICAgIH0sXG5cbiAgICBzaGFyZWRTdWZmaXg6IGZ1bmN0aW9uKGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gICAgICB2YXIgaW5kZXgxID0gY3VycmVudC5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXgyID0gb2xkLmxlbmd0aDtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB3aGlsZSAoY291bnQgPCBzZWFyY2hMZW5ndGggJiYgdGhpcy5lcXVhbHMoY3VycmVudFstLWluZGV4MV0sIG9sZFstLWluZGV4Ml0pKVxuICAgICAgICBjb3VudCsrO1xuXG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIGNhbGN1bGF0ZVNwbGljZXM6IGZ1bmN0aW9uKGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZSA9PT0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFycmF5U3BsaWNlID0gbmV3IEFycmF5U3BsaWNlKCk7XG5cbiAgZnVuY3Rpb24gY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgICByZXR1cm4gYXJyYXlTcGxpY2UuY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7XG4gICAgLy8gRGlzam9pbnRcbiAgICBpZiAoZW5kMSA8IHN0YXJ0MiB8fCBlbmQyIDwgc3RhcnQxKVxuICAgICAgcmV0dXJuIC0xO1xuXG4gICAgLy8gQWRqYWNlbnRcbiAgICBpZiAoZW5kMSA9PSBzdGFydDIgfHwgZW5kMiA9PSBzdGFydDEpXG4gICAgICByZXR1cm4gMDtcblxuICAgIC8vIE5vbi16ZXJvIGludGVyc2VjdCwgc3BhbjEgZmlyc3RcbiAgICBpZiAoc3RhcnQxIDwgc3RhcnQyKSB7XG4gICAgICBpZiAoZW5kMSA8IGVuZDIpXG4gICAgICAgIHJldHVybiBlbmQxIC0gc3RhcnQyOyAvLyBPdmVybGFwXG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlbmQyIC0gc3RhcnQyOyAvLyBDb250YWluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9uLXplcm8gaW50ZXJzZWN0LCBzcGFuMiBmaXJzdFxuICAgICAgaWYgKGVuZDIgPCBlbmQxKVxuICAgICAgICByZXR1cm4gZW5kMiAtIHN0YXJ0MTsgLy8gT3ZlcmxhcFxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZW5kMSAtIHN0YXJ0MTsgLy8gQ29udGFpbmVkXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VTcGxpY2Uoc3BsaWNlcywgaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpIHtcblxuICAgIHZhciBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQpO1xuXG4gICAgdmFyIGluc2VydGVkID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGlvbk9mZnNldCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gc3BsaWNlc1tpXTtcbiAgICAgIGN1cnJlbnQuaW5kZXggKz0gaW5zZXJ0aW9uT2Zmc2V0O1xuXG4gICAgICBpZiAoaW5zZXJ0ZWQpXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgaW50ZXJzZWN0Q291bnQgPSBpbnRlcnNlY3Qoc3BsaWNlLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5pbmRleCArIHNwbGljZS5yZW1vdmVkLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuaW5kZXggKyBjdXJyZW50LmFkZGVkQ291bnQpO1xuXG4gICAgICBpZiAoaW50ZXJzZWN0Q291bnQgPj0gMCkge1xuICAgICAgICAvLyBNZXJnZSB0aGUgdHdvIHNwbGljZXNcblxuICAgICAgICBzcGxpY2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuXG4gICAgICAgIGluc2VydGlvbk9mZnNldCAtPSBjdXJyZW50LmFkZGVkQ291bnQgLSBjdXJyZW50LnJlbW92ZWQubGVuZ3RoO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50ICs9IGN1cnJlbnQuYWRkZWRDb3VudCAtIGludGVyc2VjdENvdW50O1xuICAgICAgICB2YXIgZGVsZXRlQ291bnQgPSBzcGxpY2UucmVtb3ZlZC5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LnJlbW92ZWQubGVuZ3RoIC0gaW50ZXJzZWN0Q291bnQ7XG5cbiAgICAgICAgaWYgKCFzcGxpY2UuYWRkZWRDb3VudCAmJiAhZGVsZXRlQ291bnQpIHtcbiAgICAgICAgICAvLyBtZXJnZWQgc3BsaWNlIGlzIGEgbm9vcC4gZGlzY2FyZC5cbiAgICAgICAgICBpbnNlcnRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlbW92ZWQgPSBjdXJyZW50LnJlbW92ZWQ7XG5cbiAgICAgICAgICBpZiAoc3BsaWNlLmluZGV4IDwgY3VycmVudC5pbmRleCkge1xuICAgICAgICAgICAgLy8gc29tZSBwcmVmaXggb2Ygc3BsaWNlLnJlbW92ZWQgaXMgcHJlcGVuZGVkIHRvIGN1cnJlbnQucmVtb3ZlZC5cbiAgICAgICAgICAgIHZhciBwcmVwZW5kID0gc3BsaWNlLnJlbW92ZWQuc2xpY2UoMCwgY3VycmVudC5pbmRleCAtIHNwbGljZS5pbmRleCk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwcmVwZW5kLCByZW1vdmVkKTtcbiAgICAgICAgICAgIHJlbW92ZWQgPSBwcmVwZW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzcGxpY2UuaW5kZXggKyBzcGxpY2UucmVtb3ZlZC5sZW5ndGggPiBjdXJyZW50LmluZGV4ICsgY3VycmVudC5hZGRlZENvdW50KSB7XG4gICAgICAgICAgICAvLyBzb21lIHN1ZmZpeCBvZiBzcGxpY2UucmVtb3ZlZCBpcyBhcHBlbmRlZCB0byBjdXJyZW50LnJlbW92ZWQuXG4gICAgICAgICAgICB2YXIgYXBwZW5kID0gc3BsaWNlLnJlbW92ZWQuc2xpY2UoY3VycmVudC5pbmRleCArIGN1cnJlbnQuYWRkZWRDb3VudCAtIHNwbGljZS5pbmRleCk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZW1vdmVkLCBhcHBlbmQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNwbGljZS5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICAgICAgICBpZiAoY3VycmVudC5pbmRleCA8IHNwbGljZS5pbmRleCkge1xuICAgICAgICAgICAgc3BsaWNlLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3BsaWNlLmluZGV4IDwgY3VycmVudC5pbmRleCkge1xuICAgICAgICAvLyBJbnNlcnQgc3BsaWNlIGhlcmUuXG5cbiAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHNwbGljZXMuc3BsaWNlKGksIDAsIHNwbGljZSk7XG4gICAgICAgIGkrKztcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gc3BsaWNlLmFkZGVkQ291bnQgLSBzcGxpY2UucmVtb3ZlZC5sZW5ndGhcbiAgICAgICAgY3VycmVudC5pbmRleCArPSBvZmZzZXQ7XG4gICAgICAgIGluc2VydGlvbk9mZnNldCArPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpbnNlcnRlZClcbiAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFNwbGljZXMoYXJyYXksIGNoYW5nZVJlY29yZHMpIHtcbiAgICB2YXIgc3BsaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3JkID0gY2hhbmdlUmVjb3Jkc1tpXTtcbiAgICAgIHN3aXRjaChyZWNvcmQudHlwZSkge1xuICAgICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICAgIG1lcmdlU3BsaWNlKHNwbGljZXMsIHJlY29yZC5pbmRleCwgcmVjb3JkLnJlbW92ZWQuc2xpY2UoKSwgcmVjb3JkLmFkZGVkQ291bnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgIGlmICghaXNJbmRleChyZWNvcmQubmFtZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0b051bWJlcihyZWNvcmQubmFtZSk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIG1lcmdlU3BsaWNlKHNwbGljZXMsIGluZGV4LCBbcmVjb3JkLm9sZFZhbHVlXSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCByZWNvcmQgdHlwZTogJyArIEpTT04uc3RyaW5naWZ5KHJlY29yZCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcGxpY2VzO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdEFycmF5U3BsaWNlcyhhcnJheSwgY2hhbmdlUmVjb3Jkcykge1xuICAgIHZhciBzcGxpY2VzID0gW107XG5cbiAgICBjcmVhdGVJbml0aWFsU3BsaWNlcyhhcnJheSwgY2hhbmdlUmVjb3JkcykuZm9yRWFjaChmdW5jdGlvbihzcGxpY2UpIHtcbiAgICAgIGlmIChzcGxpY2UuYWRkZWRDb3VudCA9PSAxICYmIHNwbGljZS5yZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGlmIChzcGxpY2UucmVtb3ZlZFswXSAhPT0gYXJyYXlbc3BsaWNlLmluZGV4XSlcbiAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcblxuICAgICAgICByZXR1cm5cbiAgICAgIH07XG5cbiAgICAgIHNwbGljZXMgPSBzcGxpY2VzLmNvbmNhdChjYWxjU3BsaWNlcyhhcnJheSwgc3BsaWNlLmluZGV4LCBzcGxpY2UuaW5kZXggKyBzcGxpY2UuYWRkZWRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpY2UucmVtb3ZlZCwgMCwgc3BsaWNlLnJlbW92ZWQubGVuZ3RoKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3BsaWNlcztcbiAgfVxuXG4gLy8gRXhwb3J0IHRoZSBvYnNlcnZlLWpzIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbi8vIHRoZSBicm93c2VyLCBleHBvcnQgYXMgYSBnbG9iYWwgb2JqZWN0LlxudmFyIGV4cG9zZSA9IGdsb2JhbDtcbmlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuZXhwb3NlID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzO1xufVxuZXhwb3NlID0gZXhwb3J0cztcbn1cbmV4cG9zZS5PYnNlcnZlciA9IE9ic2VydmVyO1xuZXhwb3NlLk9ic2VydmVyLnJ1bkVPTV8gPSBydW5FT007XG5leHBvc2UuT2JzZXJ2ZXIub2JzZXJ2ZXJTZW50aW5lbF8gPSBvYnNlcnZlclNlbnRpbmVsOyAvLyBmb3IgdGVzdGluZy5cbmV4cG9zZS5PYnNlcnZlci5oYXNPYmplY3RPYnNlcnZlID0gaGFzT2JzZXJ2ZTtcbmV4cG9zZS5BcnJheU9ic2VydmVyID0gQXJyYXlPYnNlcnZlcjtcbmV4cG9zZS5BcnJheU9ic2VydmVyLmNhbGN1bGF0ZVNwbGljZXMgPSBmdW5jdGlvbihjdXJyZW50LCBwcmV2aW91cykge1xucmV0dXJuIGFycmF5U3BsaWNlLmNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpO1xufTtcbmV4cG9zZS5QbGF0Zm9ybSA9IGdsb2JhbC5QbGF0Zm9ybTtcbmV4cG9zZS5BcnJheVNwbGljZSA9IEFycmF5U3BsaWNlO1xuZXhwb3NlLk9iamVjdE9ic2VydmVyID0gT2JqZWN0T2JzZXJ2ZXI7XG5leHBvc2UuUGF0aE9ic2VydmVyID0gUGF0aE9ic2VydmVyO1xuZXhwb3NlLkNvbXBvdW5kT2JzZXJ2ZXIgPSBDb21wb3VuZE9ic2VydmVyO1xuZXhwb3NlLlBhdGggPSBQYXRoO1xuZXhwb3NlLk9ic2VydmVyVHJhbnNmb3JtID0gT2JzZXJ2ZXJUcmFuc2Zvcm07XG59KSh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlID8gZ2xvYmFsIDogdGhpcyB8fCB3aW5kb3cpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJmdW5jdGlvbiBMb2dnZXIgKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMpIHJldHVybiBuZXcgTG9nZ2VyKG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICB0aGlzLnRyYWNlID0gY29uc3RydWN0UGVyZm9ybWVyKHRoaXMsIF8uYmluZChjb25zb2xlLmRlYnVnID8gY29uc29sZS5kZWJ1ZyA6IGNvbnNvbGUubG9nLCBjb25zb2xlKSwgTG9nZ2VyLkxldmVsLnRyYWNlKTtcbiAgICB0aGlzLmRlYnVnID0gY29uc3RydWN0UGVyZm9ybWVyKHRoaXMsIF8uYmluZChjb25zb2xlLmRlYnVnID8gY29uc29sZS5kZWJ1ZyAgOiBjb25zb2xlLmxvZywgY29uc29sZSksIExvZ2dlci5MZXZlbC5kZWJ1Zyk7XG4gICAgdGhpcy5pbmZvID0gY29uc3RydWN0UGVyZm9ybWVyKHRoaXMsIF8uYmluZChjb25zb2xlLmluZm8gPyBjb25zb2xlLmluZm8gOiBjb25zb2xlLmxvZywgY29uc29sZSksIExvZ2dlci5MZXZlbC5pbmZvKTtcbiAgICB0aGlzLmxvZyA9IGNvbnN0cnVjdFBlcmZvcm1lcih0aGlzLCBfLmJpbmQoY29uc29sZS5sb2cgPyBjb25zb2xlLmxvZyA6IGNvbnNvbGUubG9nLCBjb25zb2xlKSwgTG9nZ2VyLkxldmVsLmluZm8pO1xuICAgIHRoaXMud2FybiA9IGNvbnN0cnVjdFBlcmZvcm1lcih0aGlzLCBfLmJpbmQoY29uc29sZS53YXJuID8gY29uc29sZS53YXJuIDogY29uc29sZS5sb2csIGNvbnNvbGUpLCBMb2dnZXIuTGV2ZWwud2FybmluZyk7XG4gICAgdGhpcy5lcnJvciA9IGNvbnN0cnVjdFBlcmZvcm1lcih0aGlzLCBfLmJpbmQoY29uc29sZS5lcnJvciA/IGNvbnNvbGUuZXJyb3IgOiBjb25zb2xlLmxvZywgY29uc29sZSksIExvZ2dlci5MZXZlbC5lcnJvcik7XG4gICAgdGhpcy5mYXRhbCA9IGNvbnN0cnVjdFBlcmZvcm1lcih0aGlzLCBfLmJpbmQoY29uc29sZS5lcnJvciA/IGNvbnNvbGUuZXJyb3IgOiBjb25zb2xlLmxvZywgY29uc29sZSksIExvZ2dlci5MZXZlbC5mYXRhbCk7XG5cbn1cblxudmFyIGxvZ0xldmVscyA9IHt9O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RQZXJmb3JtZXIgKGxvZ2dlciwgZiwgbGV2ZWwpIHtcbiAgICB2YXIgcGVyZm9ybWVyID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgbG9nZ2VyLnBlcmZvcm1Mb2coZiwgbGV2ZWwsIG1lc3NhZ2UsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGVyZm9ybWVyLCAnaXNFbmFibGVkJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TGV2ZWwgPSBsb2dnZXIuY3VycmVudExldmVsKCk7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWwgPj0gY3VycmVudExldmVsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBwZXJmb3JtZXIuZiA9IGY7XG4gICAgcGVyZm9ybWVyLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICBwZXJmb3JtZXIubGV2ZWwgPSBsZXZlbDtcbiAgICByZXR1cm4gcGVyZm9ybWVyO1xufVxuXG5Mb2dnZXIuTGV2ZWwgPSB7XG4gICAgdHJhY2U6IDAsXG4gICAgZGVidWc6IDEsXG4gICAgaW5mbzogMixcbiAgICB3YXJuaW5nOiAzLFxuICAgIHdhcm46IDMsXG4gICAgZXJyb3I6IDQsXG4gICAgZmF0YWw6IDVcbn07XG5cbkxvZ2dlci5MZXZlbFRleHQgPSB7fTtcbkxvZ2dlci5MZXZlbFRleHQgW0xvZ2dlci5MZXZlbC50cmFjZV0gPSAnVFJBQ0UnO1xuTG9nZ2VyLkxldmVsVGV4dCBbTG9nZ2VyLkxldmVsLmRlYnVnXSA9ICdERUJVRyc7XG5Mb2dnZXIuTGV2ZWxUZXh0IFtMb2dnZXIuTGV2ZWwuaW5mb10gPSAnSU5GTyAnO1xuTG9nZ2VyLkxldmVsVGV4dCBbTG9nZ2VyLkxldmVsLndhcm5pbmddID0gJ1dBUk4gJztcbkxvZ2dlci5MZXZlbFRleHQgW0xvZ2dlci5MZXZlbC5lcnJvcl0gPSAnRVJST1InO1xuXG5Mb2dnZXIubGV2ZWxBc1RleHQgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5MZXZlbFRleHRbbGV2ZWxdO1xufTtcblxuTG9nZ2VyLmxvZ2dlcldpdGhOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IExvZ2dlcihuYW1lKTtcbn07XG5cbkxvZ2dlci5wcm90b3R5cGUuY3VycmVudExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsb2dMZXZlbCA9IGxvZ0xldmVsc1t0aGlzLm5hbWVdO1xuICAgIHJldHVybiAgbG9nTGV2ZWwgPyBsb2dMZXZlbCA6IExvZ2dlci5MZXZlbC50cmFjZTtcbn07XG5cbkxvZ2dlci5wcm90b3R5cGUuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICBsb2dMZXZlbHNbdGhpcy5uYW1lXSA9IGxldmVsO1xufTtcblxuTG9nZ2VyLnByb3RvdHlwZS5vdmVycmlkZSA9IGZ1bmN0aW9uIChsZXZlbCwgb3ZlcnJpZGUsIG1lc3NhZ2UpIHtcbiAgICB2YXIgbGV2ZWxBc1RleHQgPSBMb2dnZXIubGV2ZWxBc1RleHQobGV2ZWwpO1xuICAgIHZhciBwZXJmb3JtZXIgPSB0aGlzW2xldmVsQXNUZXh0LnRyaW0oKS50b0xvd2VyQ2FzZSgpXTtcbiAgICB2YXIgZiA9IHBlcmZvcm1lci5mO1xuICAgIHZhciBvdGhlckFyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMywgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgdGhpcy5wZXJmb3JtTG9nKGYsIGxldmVsLCBtZXNzYWdlLCBvdGhlckFyZ3VtZW50cywgb3ZlcnJpZGUpO1xufTtcblxuTG9nZ2VyLnByb3RvdHlwZS5wZXJmb3JtTG9nID0gZnVuY3Rpb24gKGxvZ0Z1bmMsIGxldmVsLCBtZXNzYWdlLCBvdGhlckFyZ3VtZW50cywgb3ZlcnJpZGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IG92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvdmVycmlkZSA6IHRoaXMuY3VycmVudExldmVsKCk7XG4gICAgaWYgKGN1cnJlbnRMZXZlbCA8PSBsZXZlbCkge1xuICAgICAgICBsb2dGdW5jID0gXy5wYXJ0aWFsKGxvZ0Z1bmMsIExvZ2dlci5sZXZlbEFzVGV4dChsZXZlbCkgKyAnIFsnICsgc2VsZi5uYW1lICsgJ106ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPG90aGVyQXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2ldID0gb3RoZXJBcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIGxvZ0Z1bmMuYXBwbHkobG9nRnVuYywgYXJncyk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7XG4iLCJ2YXIgbG9nID0gcmVxdWlyZSgnLi9sb2cnKTtcbnZhciBMb2dnZXIgPSBsb2cubG9nZ2VyV2l0aE5hbWUoJ09wZXJhdGlvbicpO1xuXG5mdW5jdGlvbiBPcGVyYXRpb24oKSB7XG4gICAgaWYgKCF0aGlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KE9wZXJhdGlvbiwgYXJndW1lbnRzKSk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAodHlwZW9mKGFyZ3VtZW50c1swXSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMud29yayA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGlvbiA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YoYXJndW1lbnRzWzBdKSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzWzBdKSA9PT0gJ1tvYmplY3QgQXJyYXldJyB8fFxuICAgICAgICAgICAgYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLndvcmsgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgdGhpcy5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgIHRoaXMuX211c3RTdWNjZWVkID0gW107XG4gICAgdGhpcy5fb25Db21wbGV0aW9uID0gW107XG4gICAgdGhpcy5sb2dMZXZlbCA9IG51bGw7IC8vIE92ZXJyaWRlLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmYWlsZWQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICAhIXNlbGYuZXJyb3IgfHwgc2VsZi5mYWlsZWREdWVUb0RlcGVuZGVuY3k7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb21wb3NpdGUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYud29yayBpbnN0YW5jZW9mIE9wZXJhdGlvbiB8fFxuICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzZWxmLndvcmspID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdudW1PcGVyYXRpb25zUmVtYWluaW5nJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLndvcmsgaW5zdGFuY2VvZiBPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi53b3JrLmNvbXBsZXRlZCA/IDAgOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2VsZi53b3JrKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnJlZHVjZShzZWxmLndvcmssIGZ1bmN0aW9uIChtZW1vLCBvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW9wLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW8gKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjYW5SdW4nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLnJlZHVjZShzZWxmLmRlcGVuZGVuY2llcywgZnVuY3Rpb24gKG1lbW8sIGRlcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVzdFN1Y2NlZWQgPSBzZWxmLl9tdXN0U3VjY2VlZC5pbmRleE9mKGRlcCkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhblJ1biA9IG1lbW8gJiYgZGVwLmNvbXBsZXRlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11c3RTdWNjZWVkICYmIGNhblJ1bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuUnVuID0gY2FuUnVuICYmICEoZGVwLmZhaWxlZCB8fCBkZXAuY2FuY2VsbGVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuUnVuO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdmYWlsZWREdWVUb0RlcGVuZGVuY3knLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBmYWlsZWREZXBzID0gXy5yZWR1Y2Uoc2VsZi5kZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChtZW1vLCBkZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11c3RTdWNjZWVkID0gc2VsZi5fbXVzdFN1Y2NlZWQuaW5kZXhPZihkZXApID4gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWlsZWQgPSAoKGRlcC5mYWlsZWQgfHwgZGVwLmNhbmNlbGxlZCkgJiYgbXVzdFN1Y2NlZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW1vLnB1c2goZGVwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWxlZERlcHMubGVuZ3RoID8gZmFpbGVkRGVwcyA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZmFpbGVkRHVlVG9DYW5jZWxsYXRpb25PZkRlcGVuZGVuY3knLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxsZWQgPSBfLnJlZHVjZShzZWxmLmRlcGVuZGVuY2llcywgZnVuY3Rpb24gKG1lbW8sIGRlcCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVzdFN1Y2NlZWQgPSBzZWxmLl9tdXN0U3VjY2VlZC5pbmRleE9mKGRlcCkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11c3RTdWNjZWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwLmNhbmNlbGxlZCkgbWVtby5wdXNoKGRlcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxsZWQubGVuZ3RoID8gY2FuY2VsbGVkIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsb2dnaW5nT3ZlcmlkZGVuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9nTGV2ZWwgPD0gbG9nLkxldmVsLmluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG5cblxufVxuXG5PcGVyYXRpb24ucnVubmluZyA9IFtdO1xuXG5PcGVyYXRpb24ucHJvdG90eXBlLl9zdGFydFNpbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy53b3JrKGZ1bmN0aW9uIChlcnIsIHBheWxvYWQpIHtcbiAgICAgICAgc2VsZi5yZXN1bHQgPSBwYXlsb2FkO1xuICAgICAgICBzZWxmLmVycm9yID0gZXJyO1xuICAgICAgICBzZWxmLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHNlbGYucnVubmluZyA9IGZhbHNlO1xuICAgICAgICBzZWxmLl9jb21wbGV0ZSgpO1xuICAgIH0pO1xufTtcblxuT3BlcmF0aW9uLnByb3RvdHlwZS5fc3RhcnRDb21wb3NpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcGVyYXRpb25zID0gc2VsZi53b3JrIGluc3RhbmNlb2YgT3BlcmF0aW9uID8gW3NlbGYud29ya10gOiBzZWxmLndvcms7XG4gICAgXy5lYWNoKG9wZXJhdGlvbnMsIGZ1bmN0aW9uIChvcCkge1xuICAgICAgICBvcC5vbkNvbXBsZXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG51bU9wZXJhdGlvbnNSZW1haW5pbmcgPSBzZWxmLm51bU9wZXJhdGlvbnNSZW1haW5pbmc7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHNlbGYubmFtZSB8fCAnVW5uYW1lZCc7XG4gICAgICAgICAgICBMb2dnZXIuZGVidWcobmFtZSArICcgaGFzICcgKyBudW1PcGVyYXRpb25zUmVtYWluaW5nLnRvU3RyaW5nKCkgKyAnIG9wZXJhdGlvbnMgcmVtYWluaW5nJyk7XG4gICAgICAgICAgICBpZiAoIW51bU9wZXJhdGlvbnNSZW1haW5pbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gXy5wbHVjayhvcGVyYXRpb25zLCAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IF8ucGx1Y2sob3BlcmF0aW9ucywgJ3Jlc3VsdCcpO1xuICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0ID0gXy5zb21lKHJlc3VsdHMpID8gcmVzdWx0cyA6IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5lcnJvciA9IF8uc29tZShlcnJvcnMpID8gZXJyb3JzIDogbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2VsZi5fY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9wLnN0YXJ0KCk7XG4gICAgfSk7XG59O1xuXG5PcGVyYXRpb24ucHJvdG90eXBlLl9sb2dDb21wbGV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsb2dGdW5jID0gdGhpcy5fZ2V0TG9nRnVuYygpO1xuICAgIGlmIChMb2dnZXIuaW5mby5pc0VuYWJsZWQgfHwgdGhpcy5sb2dnaW5nT3ZlcmlkZGVuKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lIHx8ICdVbm5hbWVkJztcbiAgICAgICAgdmFyIGZhaWxlZERlcGVuZGVuY2llcyA9IHRoaXMuZmFpbGVkRHVlVG9EZXBlbmRlbmN5O1xuICAgICAgICBpZiAoZmFpbGVkRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICBsb2dGdW5jKCdcIicgKyBuYW1lICsgJ1wiIGZhaWxlZCBkdWUgdG8gZmFpbHVyZS9jYW5jZWxsYXRpb24gb2YgZGVwZW5kZW5jaWVzOiAnICsgXy5wbHVjayhmYWlsZWREZXBlbmRlbmNpZXMsICduYW1lJykuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mYWlsZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSB0aGlzLmVycm9yO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIG51bGwgZXJyb3JzLlxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gXy5maWx0ZXIoZXJyLCBmdW5jdGlvbiAoZSkge3JldHVybiBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyID0gW3RoaXMuZXJyb3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nRnVuYygnXCInICsgbmFtZSArICdcIiBmYWlsZWQgZHVlIHRvIGVycm9yczonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBsb2dGdW5jKCdcIicgKyBuYW1lICsgJ1wiIGhhcyBiZWVuIGNhbmNlbGxlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ0Z1bmMoJ1wiJyArIG5hbWUgKyAnXCIgaGFzIHN1Y2NlZWRlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk9wZXJhdGlvbi5wcm90b3R5cGUuX2dldExvZ0Z1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIF8uYmluZChMb2dnZXIub3ZlcnJpZGUsIExvZ2dlciwgbG9nLkxldmVsLmluZm8sIHRoaXMubG9nTGV2ZWwpO1xuICAgIH1cbiAgICByZXR1cm4gTG9nZ2VyLmluZm87XG59O1xuXG5PcGVyYXRpb24ucHJvdG90eXBlLl9sb2dTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoTG9nZ2VyLmluZm8uaXNFbmFibGVkIHx8IHRoaXMubG9nZ2luZ092ZXJpZGRlbikge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSB8fCAnVW5uYW1lZCc7XG4gICAgICAgIHZhciBsb2dGdW5jID0gdGhpcy5fZ2V0TG9nRnVuYygpO1xuICAgICAgICBsb2dGdW5jKCdcIicgKyBuYW1lICsgJ1wiIGhhcyBzdGFydGVkLicpO1xuICAgIH1cbn07XG5cblxuT3BlcmF0aW9uLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICB2YXIgaWR4ID0gT3BlcmF0aW9uLnJ1bm5pbmcuaW5kZXhPZih0aGlzKTtcbiAgICBPcGVyYXRpb24ucnVubmluZy5zcGxpY2UoaWR4LCAxKTtcbiAgICBpZiAodGhpcy5jb21wbGV0aW9uKSB7XG4gICAgICAgIF8uYmluZCh0aGlzLmNvbXBsZXRpb24sIHRoaXMpKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvZ0NvbXBsZXRpb24oKTtcbiAgICBfLmVhY2godGhpcy5fb25Db21wbGV0aW9uLCBmdW5jdGlvbiAobykge1xuICAgICAgICBfLmJpbmQobywgc2VsZikoKTtcbiAgICB9KTtcbn07XG5cbk9wZXJhdGlvbi5wcm90b3R5cGUuX19zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9sb2dTdGFydCgpO1xuICAgIGlmICh0aGlzLndvcmspIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydENvbXBvc2l0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRTaW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBPcGVyYXRpb24ucnVubmluZy5wdXNoKHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgfVxufTtcblxuT3BlcmF0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG5ldmVyU3RhcnRlZCA9ICF0aGlzLnJ1bm5pbmcgJiYgIXRoaXMuY29tcGxldGVkO1xuICAgIHZhciBuZXZlclN0YXJ0ZWRBbmRGYWlsZWQgPSBuZXZlclN0YXJ0ZWQgJiYgdGhpcy5mYWlsZWQ7XG4gICAgLy8gQSBkZXBlbmRlbmN5IGZhaWxlZCBvciB3YXMgY2FuY2VsbGVkIGJlZm9yZSB0aGlzIG9wZXJhdGlvbiBzdGFydGVkLlxuICAgIGlmIChuZXZlclN0YXJ0ZWRBbmRGYWlsZWQpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV2ZXJTdGFydGVkKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmNhblJ1bikge1xuICAgICAgICAgICAgdGhpcy5fX3N0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5kZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICBkZXAub25Db21wbGV0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FuUnVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9fc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuT3BlcmF0aW9uLnByb3RvdHlwZS5hZGREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2goYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBtdXN0U3VjY2VlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mKGxhc3RBcmcpID09ICdib29sZWFuJykge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDAsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBtdXN0U3VjY2VlZCA9IGxhc3RBcmc7XG4gICAgICAgIH1cbiAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHNlbGYuZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtdXN0U3VjY2VlZCkge1xuICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tdXN0U3VjY2VlZC5wdXNoKGFyZyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufTtcblxuT3BlcmF0aW9uLnByb3RvdHlwZS5vbkNvbXBsZXRpb24gPSBmdW5jdGlvbiAobykge1xuICAgIGlmICghdGhpcy5jb21wbGV0ZWQpIHtcbiAgICAgICAgdGhpcy5fb25Db21wbGV0aW9uLnB1c2gobyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfLmJpbmQobywgdGhpcykoKTtcbiAgICB9XG59O1xuXG5PcGVyYXRpb24ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBMb2dnZXIuZGVidWcoJ0NhbmNlbGxpbmcgJyArIHRoaXMubmFtZSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmNvbXBvc2l0ZSkge1xuICAgICAgICAgICAgXy5lYWNoKHRoaXMud29yaywgZnVuY3Rpb24gKHN1Ym9wKSB7XG4gICAgICAgICAgICAgICAgc3Vib3AuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ29tcGxldGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wZXJhdGlvbiwgJ2xvZ0xldmVsJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTG9nZ2VyLmN1cnJlbnRMZXZlbCgpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICBMb2dnZXIuc2V0TGV2ZWwodik7XG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxufSk7XG5cbm1vZHVsZS5leHBvcnRzLk9wZXJhdGlvbiA9IE9wZXJhdGlvbjtcbiIsIlxudmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nJyk7XG52YXIgTG9nZ2VyID0gbG9nLmxvZ2dlcldpdGhOYW1lKCdPcGVyYXRpb25RdWV1ZScpO1xuXG5cbmZ1bmN0aW9uIE9wZXJhdGlvblF1ZXVlKCkge1xuXG4gICAgaWYgKCF0aGlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmFwcGx5KE9wZXJhdGlvblF1ZXVlLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZihhcmd1bWVudHNbMF0pID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1heENvbmN1cnJlbnRPcGVyYXRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXhDb25jdXJyZW50T3BlcmF0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3F1ZXVlZE9wZXJhdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9ydW5uaW5nT3BlcmF0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9vblN0YXJ0ID0gW107XG4gICAgdGhpcy5fb25TdG9wID0gW107XG4gICAgdGhpcy5sb2dMZXZlbCA9IG51bGw7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ251bVJ1bm5pbmdPcGVyYXRpb25zJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9ydW5uaW5nT3BlcmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdsb2dnaW5nT3ZlcmlkZGVuJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxvZ0xldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubG9nTGV2ZWwgPD0gbG9nLkxldmVsLmluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG59XG5cbk9wZXJhdGlvblF1ZXVlLnByb3RvdHlwZS5fbmV4dE9wZXJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHdoaWxlICgoc2VsZi5fcnVubmluZ09wZXJhdGlvbnMubGVuZ3RoIDwgc2VsZi5tYXhDb25jdXJyZW50T3BlcmF0aW9ucykgJiYgc2VsZi5fcXVldWVkT3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9wID0gc2VsZi5fcXVldWVkT3BlcmF0aW9uc1swXTtcbiAgICAgICAgc2VsZi5fcXVldWVkT3BlcmF0aW9ucy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIHNlbGYuX3J1bk9wZXJhdGlvbihvcCk7XG4gICAgfVxufTtcblxuXG5PcGVyYXRpb25RdWV1ZS5wcm90b3R5cGUuX3J1bk9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlZE9wZXJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlZE9wZXJhdGlvbnNbaV0gPT0gb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZE9wZXJhdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcnVubmluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgb3AuY29tcGxldGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkeCA9IHNlbGYuX3J1bm5pbmdPcGVyYXRpb25zLmluZGV4T2Yob3ApO1xuICAgICAgICBzZWxmLl9ydW5uaW5nT3BlcmF0aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgaWYgKHNlbGYuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgIHNlbGYuX25leHRPcGVyYXRpb25zKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fbG9nU3RhdHVzKCk7XG4gICAgfTtcbiAgICBvcC5zdGFydCgpO1xuICAgIHRoaXMuX2xvZ1N0YXR1cygpO1xufTtcblxuT3BlcmF0aW9uUXVldWUucHJvdG90eXBlLl9sb2dTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxvZ0Z1bmMgPSB0aGlzLl9nZXRMb2dGdW5jKCk7XG4gICAgaWYgKExvZ2dlci5pbmZvLmlzRW5hYmxlZCB8fCB0aGlzLmxvZ2dpbmdPdmVyaWRkZW4pIHtcbiAgICAgICAgdmFyIG51bVJ1bm5pbmcgPSB0aGlzLm51bVJ1bm5pbmdPcGVyYXRpb25zO1xuICAgICAgICB2YXIgbnVtUXVldWVkID0gdGhpcy5fcXVldWVkT3BlcmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lIHx8IFwiVW5uYW1lZCBRdWV1ZVwiO1xuICAgICAgICBpZiAobnVtUnVubmluZyAmJiBudW1RdWV1ZWQpIHtcbiAgICAgICAgICAgIGxvZ0Z1bmMoJ1wiJyArIG5hbWUgKyAnXCIgbm93IGhhcyAnICsgbnVtUnVubmluZy50b1N0cmluZygpICsgJyBvcGVyYXRpb25zIHJ1bm5pbmcgYW5kICcgKyBudW1RdWV1ZWQudG9TdHJpbmcoKSArICcgb3BlcmF0aW9ucyBxdWV1ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1SdW5uaW5nKSB7XG4gICAgICAgICAgICBsb2dGdW5jKCdcIicgKyBuYW1lICsgJ1wiIG5vdyBoYXMgJyArIG51bVJ1bm5pbmcudG9TdHJpbmcoKSArICcgb3BlcmF0aW9ucyBydW5uaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobnVtUXVldWVkKSB7XG4gICAgICAgICAgICBsb2dGdW5jKCdcIicgKyBuYW1lICsgJ1wiIG5vdyBoYXMgJyArIG51bVF1ZXVlZC50b1N0cmluZygpICsgJyBvcGVyYXRpb25zIHF1ZXVlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nRnVuYygnXCInICsgbmFtZSArICdcIiBoYXMgbm8gb3BlcmF0aW9ucyBydW5uaW5nIG9yIHF1ZXVlZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuT3BlcmF0aW9uUXVldWUucHJvdG90eXBlLl9sb2dTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbG9nRnVuYyA9IHRoaXMuX2dldExvZ0Z1bmMoKTtcbiAgICBpZiAoTG9nZ2VyLmluZm8uaXNFbmFibGVkIHx8IHRoaXMubG9nZ2luZ092ZXJpZGRlbikge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMubmFtZSB8fCBcIlVubmFtZWQgUXVldWVcIjtcbiAgICAgICAgbG9nRnVuYygnXCInICsgbmFtZSArICdcIiBpcyBub3cgcnVubmluZycpO1xuICAgIH1cbn07XG5cbk9wZXJhdGlvblF1ZXVlLnByb3RvdHlwZS5fZ2V0TG9nRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5sb2dMZXZlbCkge1xuICAgICAgICByZXR1cm4gXy5iaW5kKExvZ2dlci5vdmVycmlkZSwgTG9nZ2VyLCBsb2cuTGV2ZWwuaW5mbywgdGhpcy5sb2dMZXZlbCk7XG4gICAgfVxuICAgIHJldHVybiBMb2dnZXIuaW5mbztcbn07XG5cblxuT3BlcmF0aW9uUXVldWUucHJvdG90eXBlLl9sb2dTdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsb2dGdW5jID0gdGhpcy5fZ2V0TG9nRnVuYygpO1xuICAgIGlmIChMb2dnZXIuaW5mby5pc0VuYWJsZWQgfHwgdGhpcy5sb2dnaW5nT3ZlcmlkZGVuKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lIHx8IFwiVW5uYW1lZCBRdWV1ZVwiO1xuICAgICAgICBsb2dGdW5jKCdcIicgKyBuYW1lICsgJ1wiIGlzIG5vIGxvbmdlciBydW5uaW5nJyk7XG4gICAgfVxufTtcblxuT3BlcmF0aW9uUXVldWUucHJvdG90eXBlLl9hZGRPcGVyYXRpb24gPSBmdW5jdGlvbiAob3ApIHtcbiAgICBpZiAodGhpcy5udW1SdW5uaW5nT3BlcmF0aW9ucyA8IHRoaXMubWF4Q29uY3VycmVudE9wZXJhdGlvbnMgJiYgdGhpcy5fcnVubmluZykge1xuICAgICAgICB0aGlzLl9ydW5PcGVyYXRpb24ob3ApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcXVldWVkT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICB9XG4gICAgdGhpcy5fbG9nU3RhdHVzKCk7XG59O1xuXG5PcGVyYXRpb25RdWV1ZS5wcm90b3R5cGUuYWRkT3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbk9yT3BlcmF0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wZXJhdGlvbk9yT3BlcmF0aW9ucykgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgXy5lYWNoKG9wZXJhdGlvbk9yT3BlcmF0aW9ucywgZnVuY3Rpb24gKG9wKSB7c2VsZi5fYWRkT3BlcmF0aW9uKG9wKX0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkT3BlcmF0aW9uKG9wZXJhdGlvbk9yT3BlcmF0aW9ucyk7XG4gICAgfVxufTtcblxuT3BlcmF0aW9uUXVldWUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd2FzUnVubmluZyA9IHRoaXMuX3J1bm5pbmc7XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgaWYgKCF3YXNSdW5uaW5nKSB7XG4gICAgICAgIF8uZWFjaChzZWxmLl9vblN0YXJ0LCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgXy5iaW5kKGMsIHNlbGYpKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLl9uZXh0T3BlcmF0aW9ucygpO1xuICAgICAgICBzZWxmLl9sb2dTdGFydCgpO1xuICAgIH1cbn07XG5cbk9wZXJhdGlvblF1ZXVlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGNhbmNlbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd2FzUnVubmluZyA9IHRoaXMuX3J1bm5pbmc7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIGlmICh3YXNSdW5uaW5nKSB7XG4gICAgICAgIGlmIChjYW5jZWwpIHtcbiAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gdGhpcy5fcnVubmluZ09wZXJhdGlvbnMuc2xpY2UoMCk7IC8vIENsb25lIHNvIG5vdCBmaWdodGluZyBjYWxsYmFja3MuXG4gICAgICAgICAgICBfLmVhY2gob3BlcmF0aW9ucywgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICBvLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fbG9nU3RvcCgpO1xuICAgICAgICBfLmVhY2goc2VsZi5fb25TdG9wLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgXy5iaW5kKGMsIHNlbGYpKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbk9wZXJhdGlvblF1ZXVlLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICB0aGlzLl9vblN0YXJ0LnB1c2gobyk7XG59O1xuT3BlcmF0aW9uUXVldWUucHJvdG90eXBlLm9uU3RvcCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgdGhpcy5fb25TdG9wLnB1c2gobyk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT3BlcmF0aW9uUXVldWUsICdsb2dMZXZlbCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExvZ2dlci5jdXJyZW50TGV2ZWwoKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgTG9nZ2VyLnNldExldmVsKHYpO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzLk9wZXJhdGlvblF1ZXVlID0gT3BlcmF0aW9uUXVldWU7XG4iXX0=
